import {
  require_react
} from "./chunk-QCHXOAYK.js";
import {
  __commonJS,
  __privateAdd,
  __privateGet,
  __privateSet,
  __publicField,
  __toESM
} from "./chunk-WOOG5QLI.js";

// node_modules/events/events.js
var require_events = __commonJS({
  "node_modules/events/events.js"(exports, module) {
    "use strict";
    var R = typeof Reflect === "object" ? Reflect : null;
    var ReflectApply = R && typeof R.apply === "function" ? R.apply : function ReflectApply2(target, receiver, args) {
      return Function.prototype.apply.call(target, receiver, args);
    };
    var ReflectOwnKeys;
    if (R && typeof R.ownKeys === "function") {
      ReflectOwnKeys = R.ownKeys;
    } else if (Object.getOwnPropertySymbols) {
      ReflectOwnKeys = function ReflectOwnKeys2(target) {
        return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));
      };
    } else {
      ReflectOwnKeys = function ReflectOwnKeys2(target) {
        return Object.getOwnPropertyNames(target);
      };
    }
    function ProcessEmitWarning(warning) {
      if (console && console.warn) console.warn(warning);
    }
    var NumberIsNaN = Number.isNaN || function NumberIsNaN2(value) {
      return value !== value;
    };
    function EventEmitter2() {
      EventEmitter2.init.call(this);
    }
    module.exports = EventEmitter2;
    module.exports.once = once;
    EventEmitter2.EventEmitter = EventEmitter2;
    EventEmitter2.prototype._events = void 0;
    EventEmitter2.prototype._eventsCount = 0;
    EventEmitter2.prototype._maxListeners = void 0;
    var defaultMaxListeners = 10;
    function checkListener(listener) {
      if (typeof listener !== "function") {
        throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
      }
    }
    Object.defineProperty(EventEmitter2, "defaultMaxListeners", {
      enumerable: true,
      get: function() {
        return defaultMaxListeners;
      },
      set: function(arg) {
        if (typeof arg !== "number" || arg < 0 || NumberIsNaN(arg)) {
          throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + ".");
        }
        defaultMaxListeners = arg;
      }
    });
    EventEmitter2.init = function() {
      if (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) {
        this._events = /* @__PURE__ */ Object.create(null);
        this._eventsCount = 0;
      }
      this._maxListeners = this._maxListeners || void 0;
    };
    EventEmitter2.prototype.setMaxListeners = function setMaxListeners(n) {
      if (typeof n !== "number" || n < 0 || NumberIsNaN(n)) {
        throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + ".");
      }
      this._maxListeners = n;
      return this;
    };
    function _getMaxListeners(that) {
      if (that._maxListeners === void 0)
        return EventEmitter2.defaultMaxListeners;
      return that._maxListeners;
    }
    EventEmitter2.prototype.getMaxListeners = function getMaxListeners() {
      return _getMaxListeners(this);
    };
    EventEmitter2.prototype.emit = function emit(type) {
      var args = [];
      for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);
      var doError = type === "error";
      var events2 = this._events;
      if (events2 !== void 0)
        doError = doError && events2.error === void 0;
      else if (!doError)
        return false;
      if (doError) {
        var er;
        if (args.length > 0)
          er = args[0];
        if (er instanceof Error) {
          throw er;
        }
        var err = new Error("Unhandled error." + (er ? " (" + er.message + ")" : ""));
        err.context = er;
        throw err;
      }
      var handler = events2[type];
      if (handler === void 0)
        return false;
      if (typeof handler === "function") {
        ReflectApply(handler, this, args);
      } else {
        var len = handler.length;
        var listeners = arrayClone(handler, len);
        for (var i = 0; i < len; ++i)
          ReflectApply(listeners[i], this, args);
      }
      return true;
    };
    function _addListener(target, type, listener, prepend) {
      var m;
      var events2;
      var existing;
      checkListener(listener);
      events2 = target._events;
      if (events2 === void 0) {
        events2 = target._events = /* @__PURE__ */ Object.create(null);
        target._eventsCount = 0;
      } else {
        if (events2.newListener !== void 0) {
          target.emit(
            "newListener",
            type,
            listener.listener ? listener.listener : listener
          );
          events2 = target._events;
        }
        existing = events2[type];
      }
      if (existing === void 0) {
        existing = events2[type] = listener;
        ++target._eventsCount;
      } else {
        if (typeof existing === "function") {
          existing = events2[type] = prepend ? [listener, existing] : [existing, listener];
        } else if (prepend) {
          existing.unshift(listener);
        } else {
          existing.push(listener);
        }
        m = _getMaxListeners(target);
        if (m > 0 && existing.length > m && !existing.warned) {
          existing.warned = true;
          var w = new Error("Possible EventEmitter memory leak detected. " + existing.length + " " + String(type) + " listeners added. Use emitter.setMaxListeners() to increase limit");
          w.name = "MaxListenersExceededWarning";
          w.emitter = target;
          w.type = type;
          w.count = existing.length;
          ProcessEmitWarning(w);
        }
      }
      return target;
    }
    EventEmitter2.prototype.addListener = function addListener(type, listener) {
      return _addListener(this, type, listener, false);
    };
    EventEmitter2.prototype.on = EventEmitter2.prototype.addListener;
    EventEmitter2.prototype.prependListener = function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };
    function onceWrapper() {
      if (!this.fired) {
        this.target.removeListener(this.type, this.wrapFn);
        this.fired = true;
        if (arguments.length === 0)
          return this.listener.call(this.target);
        return this.listener.apply(this.target, arguments);
      }
    }
    function _onceWrap(target, type, listener) {
      var state = { fired: false, wrapFn: void 0, target, type, listener };
      var wrapped = onceWrapper.bind(state);
      wrapped.listener = listener;
      state.wrapFn = wrapped;
      return wrapped;
    }
    EventEmitter2.prototype.once = function once2(type, listener) {
      checkListener(listener);
      this.on(type, _onceWrap(this, type, listener));
      return this;
    };
    EventEmitter2.prototype.prependOnceListener = function prependOnceListener(type, listener) {
      checkListener(listener);
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };
    EventEmitter2.prototype.removeListener = function removeListener(type, listener) {
      var list, events2, position, i, originalListener;
      checkListener(listener);
      events2 = this._events;
      if (events2 === void 0)
        return this;
      list = events2[type];
      if (list === void 0)
        return this;
      if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0)
          this._events = /* @__PURE__ */ Object.create(null);
        else {
          delete events2[type];
          if (events2.removeListener)
            this.emit("removeListener", type, list.listener || listener);
        }
      } else if (typeof list !== "function") {
        position = -1;
        for (i = list.length - 1; i >= 0; i--) {
          if (list[i] === listener || list[i].listener === listener) {
            originalListener = list[i].listener;
            position = i;
            break;
          }
        }
        if (position < 0)
          return this;
        if (position === 0)
          list.shift();
        else {
          spliceOne(list, position);
        }
        if (list.length === 1)
          events2[type] = list[0];
        if (events2.removeListener !== void 0)
          this.emit("removeListener", type, originalListener || listener);
      }
      return this;
    };
    EventEmitter2.prototype.off = EventEmitter2.prototype.removeListener;
    EventEmitter2.prototype.removeAllListeners = function removeAllListeners(type) {
      var listeners, events2, i;
      events2 = this._events;
      if (events2 === void 0)
        return this;
      if (events2.removeListener === void 0) {
        if (arguments.length === 0) {
          this._events = /* @__PURE__ */ Object.create(null);
          this._eventsCount = 0;
        } else if (events2[type] !== void 0) {
          if (--this._eventsCount === 0)
            this._events = /* @__PURE__ */ Object.create(null);
          else
            delete events2[type];
        }
        return this;
      }
      if (arguments.length === 0) {
        var keys = Object.keys(events2);
        var key;
        for (i = 0; i < keys.length; ++i) {
          key = keys[i];
          if (key === "removeListener") continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners("removeListener");
        this._events = /* @__PURE__ */ Object.create(null);
        this._eventsCount = 0;
        return this;
      }
      listeners = events2[type];
      if (typeof listeners === "function") {
        this.removeListener(type, listeners);
      } else if (listeners !== void 0) {
        for (i = listeners.length - 1; i >= 0; i--) {
          this.removeListener(type, listeners[i]);
        }
      }
      return this;
    };
    function _listeners(target, type, unwrap) {
      var events2 = target._events;
      if (events2 === void 0)
        return [];
      var evlistener = events2[type];
      if (evlistener === void 0)
        return [];
      if (typeof evlistener === "function")
        return unwrap ? [evlistener.listener || evlistener] : [evlistener];
      return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
    }
    EventEmitter2.prototype.listeners = function listeners(type) {
      return _listeners(this, type, true);
    };
    EventEmitter2.prototype.rawListeners = function rawListeners(type) {
      return _listeners(this, type, false);
    };
    EventEmitter2.listenerCount = function(emitter, type) {
      if (typeof emitter.listenerCount === "function") {
        return emitter.listenerCount(type);
      } else {
        return listenerCount.call(emitter, type);
      }
    };
    EventEmitter2.prototype.listenerCount = listenerCount;
    function listenerCount(type) {
      var events2 = this._events;
      if (events2 !== void 0) {
        var evlistener = events2[type];
        if (typeof evlistener === "function") {
          return 1;
        } else if (evlistener !== void 0) {
          return evlistener.length;
        }
      }
      return 0;
    }
    EventEmitter2.prototype.eventNames = function eventNames() {
      return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
    };
    function arrayClone(arr, n) {
      var copy = new Array(n);
      for (var i = 0; i < n; ++i)
        copy[i] = arr[i];
      return copy;
    }
    function spliceOne(list, index) {
      for (; index + 1 < list.length; index++)
        list[index] = list[index + 1];
      list.pop();
    }
    function unwrapListeners(arr) {
      var ret = new Array(arr.length);
      for (var i = 0; i < ret.length; ++i) {
        ret[i] = arr[i].listener || arr[i];
      }
      return ret;
    }
    function once(emitter, name) {
      return new Promise(function(resolve, reject) {
        function errorListener(err) {
          emitter.removeListener(name, resolver);
          reject(err);
        }
        function resolver() {
          if (typeof emitter.removeListener === "function") {
            emitter.removeListener("error", errorListener);
          }
          resolve([].slice.call(arguments));
        }
        ;
        eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });
        if (name !== "error") {
          addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });
        }
      });
    }
    function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
      if (typeof emitter.on === "function") {
        eventTargetAgnosticAddListener(emitter, "error", handler, flags);
      }
    }
    function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
      if (typeof emitter.on === "function") {
        if (flags.once) {
          emitter.once(name, listener);
        } else {
          emitter.on(name, listener);
        }
      } else if (typeof emitter.addEventListener === "function") {
        emitter.addEventListener(name, function wrapListener(arg) {
          if (flags.once) {
            emitter.removeEventListener(name, wrapListener);
          }
          listener(arg);
        });
      } else {
        throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
      }
    }
  }
});

// node_modules/@videosdk.live/js-sdk/videosdk.js
var require_videosdk = __commonJS({
  "node_modules/@videosdk.live/js-sdk/videosdk.js"(exports, module) {
    (function webpackUniversalModuleDefinition(root, factory) {
      if (typeof exports === "object" && typeof module === "object")
        module.exports = factory();
      else if (typeof define === "function" && define.amd)
        define([], factory);
      else {
        var a = factory();
        for (var i in a) (typeof exports === "object" ? exports : root)[i] = a[i];
      }
    })(self, () => {
      return (
        /******/
        (() => {
          var __webpack_modules__ = {
            /***/
            11: (
              /***/
              (__unused_webpack_module, exports2, __webpack_require__2) => {
                "use strict";
                Object.defineProperty(exports2, "__esModule", { value: true });
                exports2.Chrome74 = void 0;
                const sdpTransform = __webpack_require__2(7363);
                const Logger_1 = __webpack_require__2(2994);
                const enhancedEvents_1 = __webpack_require__2(3953);
                const ortc = __webpack_require__2(8046);
                const errors_1 = __webpack_require__2(4893);
                const scalabilityModes_1 = __webpack_require__2(3303);
                const sdpCommonUtils = __webpack_require__2(5544);
                const sdpUnifiedPlanUtils = __webpack_require__2(5938);
                const ortcUtils = __webpack_require__2(4256);
                const RemoteSdp_1 = __webpack_require__2(1305);
                const logger = new Logger_1.Logger("Chrome74");
                const NAME = "Chrome74";
                const SCTP_NUM_STREAMS = { OS: 1024, MIS: 1024 };
                class Chrome74 extends enhancedEvents_1.EnhancedEventEmitter {
                  constructor({ direction, iceParameters, iceCandidates, dtlsParameters, sctpParameters, iceServers, iceTransportPolicy, additionalSettings, getSendExtendedRtpCapabilities }) {
                    super();
                    // Closed flag.
                    __publicField(this, "_closed", false);
                    // Handler direction.
                    __publicField(this, "_direction");
                    // Remote SDP handler.
                    __publicField(this, "_remoteSdp");
                    // Callback to request sending extended RTP capabilities on demand.
                    __publicField(this, "_getSendExtendedRtpCapabilities");
                    // Initial server side DTLS role. If not 'auto', it will force the opposite
                    // value in client side.
                    __publicField(this, "_forcedLocalDtlsRole");
                    // RTCPeerConnection instance.
                    __publicField(this, "_pc");
                    // Map of RTCTransceivers indexed by MID.
                    __publicField(this, "_mapMidTransceiver", /* @__PURE__ */ new Map());
                    // Local stream for sending.
                    __publicField(this, "_sendStream", new MediaStream());
                    // Whether a DataChannel m=application section has been created.
                    __publicField(this, "_hasDataChannelMediaSection", false);
                    // Sending DataChannel id value counter. Incremented for each new DataChannel.
                    __publicField(this, "_nextSendSctpStreamId", 0);
                    // Got transport local and remote parameters.
                    __publicField(this, "_transportReady", false);
                    __publicField(this, "onIceGatheringStateChange", () => {
                      this.emit("@icegatheringstatechange", this._pc.iceGatheringState);
                    });
                    __publicField(this, "onIceCandidateError", (event) => {
                      this.emit("@icecandidateerror", event);
                    });
                    __publicField(this, "onConnectionStateChange", () => {
                      this.emit("@connectionstatechange", this._pc.connectionState);
                    });
                    __publicField(this, "onIceConnectionStateChange", () => {
                      switch (this._pc.iceConnectionState) {
                        case "checking": {
                          this.emit("@connectionstatechange", "connecting");
                          break;
                        }
                        case "connected":
                        case "completed": {
                          this.emit("@connectionstatechange", "connected");
                          break;
                        }
                        case "failed": {
                          this.emit("@connectionstatechange", "failed");
                          break;
                        }
                        case "disconnected": {
                          this.emit("@connectionstatechange", "disconnected");
                          break;
                        }
                        case "closed": {
                          this.emit("@connectionstatechange", "closed");
                          break;
                        }
                      }
                    });
                    logger.debug("constructor()");
                    this._direction = direction;
                    this._remoteSdp = new RemoteSdp_1.RemoteSdp({
                      iceParameters,
                      iceCandidates,
                      dtlsParameters,
                      sctpParameters
                    });
                    this._getSendExtendedRtpCapabilities = getSendExtendedRtpCapabilities;
                    if (dtlsParameters.role && dtlsParameters.role !== "auto") {
                      this._forcedLocalDtlsRole = dtlsParameters.role === "server" ? "client" : "server";
                    }
                    this._pc = new RTCPeerConnection({
                      iceServers: iceServers ?? [],
                      iceTransportPolicy: iceTransportPolicy ?? "all",
                      bundlePolicy: "max-bundle",
                      rtcpMuxPolicy: "require",
                      ...additionalSettings
                    });
                    this._pc.addEventListener("icegatheringstatechange", this.onIceGatheringStateChange);
                    this._pc.addEventListener("icecandidateerror", this.onIceCandidateError);
                    if (this._pc.connectionState) {
                      this._pc.addEventListener("connectionstatechange", this.onConnectionStateChange);
                    } else {
                      logger.warn("run() | pc.connectionState not supported, using pc.iceConnectionState");
                      this._pc.addEventListener("iceconnectionstatechange", this.onIceConnectionStateChange);
                    }
                  }
                  /**
                   * Creates a factory function.
                   */
                  static createFactory() {
                    return {
                      name: NAME,
                      factory: (options) => new Chrome74(options),
                      getNativeRtpCapabilities: async () => {
                        logger.debug("getNativeRtpCapabilities()");
                        let pc = new RTCPeerConnection({
                          iceServers: [],
                          iceTransportPolicy: "all",
                          bundlePolicy: "max-bundle",
                          rtcpMuxPolicy: "require"
                        });
                        try {
                          pc.addTransceiver("audio");
                          pc.addTransceiver("video");
                          const offer = await pc.createOffer();
                          try {
                            pc.close();
                          } catch (error) {
                          }
                          pc = void 0;
                          const sdpObject = sdpTransform.parse(offer.sdp);
                          const nativeRtpCapabilities = Chrome74.getLocalRtpCapabilities(sdpObject);
                          return nativeRtpCapabilities;
                        } catch (error) {
                          try {
                            pc == null ? void 0 : pc.close();
                          } catch (error2) {
                          }
                          pc = void 0;
                          throw error;
                        }
                      },
                      getNativeSctpCapabilities: async () => {
                        logger.debug("getNativeSctpCapabilities()");
                        return {
                          numStreams: SCTP_NUM_STREAMS
                        };
                      }
                    };
                  }
                  static getLocalRtpCapabilities(localSdpObject) {
                    const nativeRtpCapabilities = sdpCommonUtils.extractRtpCapabilities({
                      sdpObject: localSdpObject
                    });
                    ortc.validateAndNormalizeRtpCapabilities(nativeRtpCapabilities);
                    ortcUtils.addNackSupportForOpus(nativeRtpCapabilities);
                    return nativeRtpCapabilities;
                  }
                  get name() {
                    return NAME;
                  }
                  close() {
                    logger.debug("close()");
                    if (this._closed) {
                      return;
                    }
                    this._closed = true;
                    try {
                      this._pc.close();
                    } catch (error) {
                    }
                    this._pc.removeEventListener("icegatheringstatechange", this.onIceGatheringStateChange);
                    this._pc.removeEventListener("icecandidateerror", this.onIceCandidateError);
                    this._pc.removeEventListener("connectionstatechange", this.onConnectionStateChange);
                    this._pc.removeEventListener("iceconnectionstatechange", this.onIceConnectionStateChange);
                    this.emit("@close");
                    super.close();
                  }
                  async updateIceServers(iceServers) {
                    this.assertNotClosed();
                    logger.debug("updateIceServers()");
                    const configuration = this._pc.getConfiguration();
                    configuration.iceServers = iceServers;
                    this._pc.setConfiguration(configuration);
                  }
                  async restartIce(iceParameters) {
                    this.assertNotClosed();
                    logger.debug("restartIce()");
                    this._remoteSdp.updateIceParameters(iceParameters);
                    if (!this._transportReady) {
                      return;
                    }
                    if (this._direction === "send") {
                      const offer = await this._pc.createOffer({ iceRestart: true });
                      logger.debug("restartIce() | calling pc.setLocalDescription() [offer:%o]", offer);
                      await this._pc.setLocalDescription(offer);
                      const answer = {
                        type: "answer",
                        sdp: this._remoteSdp.getSdp()
                      };
                      logger.debug("restartIce() | calling pc.setRemoteDescription() [answer:%o]", answer);
                      await this._pc.setRemoteDescription(answer);
                    } else {
                      const offer = {
                        type: "offer",
                        sdp: this._remoteSdp.getSdp()
                      };
                      logger.debug("restartIce() | calling pc.setRemoteDescription() [offer:%o]", offer);
                      await this._pc.setRemoteDescription(offer);
                      const answer = await this._pc.createAnswer();
                      logger.debug("restartIce() | calling pc.setLocalDescription() [answer:%o]", answer);
                      await this._pc.setLocalDescription(answer);
                    }
                  }
                  async getTransportStats() {
                    this.assertNotClosed();
                    return this._pc.getStats();
                  }
                  async send({ track, encodings, codecOptions, codec }) {
                    this.assertNotClosed();
                    this.assertSendDirection();
                    logger.debug("send() [kind:%s, track.id:%s]", track.kind, track.id);
                    if (encodings && encodings.length > 1) {
                      encodings.forEach((encoding, idx) => {
                        encoding.rid = `r${idx}`;
                      });
                    }
                    const mediaSectionIdx = this._remoteSdp.getNextMediaSectionIdx();
                    const transceiver = this._pc.addTransceiver(track, {
                      direction: "sendonly",
                      streams: [this._sendStream],
                      sendEncodings: encodings
                    });
                    let offer = await this._pc.createOffer();
                    let localSdpObject = sdpTransform.parse(offer.sdp);
                    if (localSdpObject.extmapAllowMixed) {
                      this._remoteSdp.setSessionExtmapAllowMixed();
                    }
                    const nativeRtpCapabilities = Chrome74.getLocalRtpCapabilities(localSdpObject);
                    const sendExtendedRtpCapabilities = this._getSendExtendedRtpCapabilities(nativeRtpCapabilities);
                    const sendingRtpParameters = ortc.getSendingRtpParameters(track.kind, sendExtendedRtpCapabilities);
                    sendingRtpParameters.codecs = ortc.reduceCodecs(sendingRtpParameters.codecs, codec);
                    const sendingRemoteRtpParameters = ortc.getSendingRemoteRtpParameters(track.kind, sendExtendedRtpCapabilities);
                    sendingRemoteRtpParameters.codecs = ortc.reduceCodecs(sendingRemoteRtpParameters.codecs, codec);
                    if (!this._transportReady) {
                      await this.setupTransport({
                        localDtlsRole: this._forcedLocalDtlsRole ?? "client",
                        localSdpObject
                      });
                    }
                    let hackVp9Svc = false;
                    const layers = (0, scalabilityModes_1.parse)((encodings ?? [{}])[0].scalabilityMode);
                    let offerMediaObject;
                    if (encodings && encodings.length === 1 && layers.spatialLayers > 1 && sendingRtpParameters.codecs[0].mimeType.toLowerCase() === "video/vp9") {
                      logger.debug("send() | enabling legacy simulcast for VP9 SVC");
                      hackVp9Svc = true;
                      localSdpObject = sdpTransform.parse(offer.sdp);
                      offerMediaObject = localSdpObject.media[mediaSectionIdx.idx];
                      sdpUnifiedPlanUtils.addLegacySimulcast({
                        offerMediaObject,
                        numStreams: layers.spatialLayers
                      });
                      offer = {
                        type: "offer",
                        sdp: sdpTransform.write(localSdpObject)
                      };
                    }
                    logger.debug("send() | calling pc.setLocalDescription() [offer:%o]", offer);
                    await this._pc.setLocalDescription(offer);
                    const localId = transceiver.mid;
                    sendingRtpParameters.mid = localId;
                    localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
                    offerMediaObject = localSdpObject.media[mediaSectionIdx.idx];
                    sendingRtpParameters.rtcp.cname = sdpCommonUtils.getCname({
                      offerMediaObject
                    });
                    if (!encodings) {
                      sendingRtpParameters.encodings = sdpUnifiedPlanUtils.getRtpEncodings({
                        offerMediaObject
                      });
                    } else if (encodings.length === 1) {
                      let newEncodings = sdpUnifiedPlanUtils.getRtpEncodings({
                        offerMediaObject
                      });
                      Object.assign(newEncodings[0], encodings[0]);
                      if (hackVp9Svc) {
                        newEncodings = [newEncodings[0]];
                      }
                      sendingRtpParameters.encodings = newEncodings;
                    } else {
                      sendingRtpParameters.encodings = encodings;
                    }
                    if (sendingRtpParameters.encodings.length > 1 && (sendingRtpParameters.codecs[0].mimeType.toLowerCase() === "video/vp8" || sendingRtpParameters.codecs[0].mimeType.toLowerCase() === "video/h264")) {
                      for (const encoding of sendingRtpParameters.encodings) {
                        if (encoding.scalabilityMode) {
                          encoding.scalabilityMode = `L1T${layers.temporalLayers}`;
                        } else {
                          encoding.scalabilityMode = "L1T3";
                        }
                      }
                    }
                    this._remoteSdp.send({
                      offerMediaObject,
                      reuseMid: mediaSectionIdx.reuseMid,
                      offerRtpParameters: sendingRtpParameters,
                      answerRtpParameters: sendingRemoteRtpParameters,
                      codecOptions
                    });
                    const answer = {
                      type: "answer",
                      sdp: this._remoteSdp.getSdp()
                    };
                    logger.debug("send() | calling pc.setRemoteDescription() [answer:%o]", answer);
                    await this._pc.setRemoteDescription(answer);
                    this._mapMidTransceiver.set(localId, transceiver);
                    return {
                      localId,
                      rtpParameters: sendingRtpParameters,
                      rtpSender: transceiver.sender
                    };
                  }
                  async stopSending(localId) {
                    this.assertSendDirection();
                    logger.debug("stopSending() [localId:%s]", localId);
                    if (this._closed) {
                      return;
                    }
                    const transceiver = this._mapMidTransceiver.get(localId);
                    if (!transceiver) {
                      throw new Error("associated RTCRtpTransceiver not found");
                    }
                    void transceiver.sender.replaceTrack(null);
                    this._pc.removeTrack(transceiver.sender);
                    const mediaSectionClosed = this._remoteSdp.closeMediaSection(transceiver.mid);
                    if (mediaSectionClosed) {
                      try {
                        transceiver.stop();
                      } catch (error) {
                      }
                    }
                    const offer = await this._pc.createOffer();
                    logger.debug("stopSending() | calling pc.setLocalDescription() [offer:%o]", offer);
                    await this._pc.setLocalDescription(offer);
                    const answer = {
                      type: "answer",
                      sdp: this._remoteSdp.getSdp()
                    };
                    logger.debug("stopSending() | calling pc.setRemoteDescription() [answer:%o]", answer);
                    await this._pc.setRemoteDescription(answer);
                    this._mapMidTransceiver.delete(localId);
                  }
                  async pauseSending(localId) {
                    this.assertNotClosed();
                    this.assertSendDirection();
                    logger.debug("pauseSending() [localId:%s]", localId);
                    const transceiver = this._mapMidTransceiver.get(localId);
                    if (!transceiver) {
                      throw new Error("associated RTCRtpTransceiver not found");
                    }
                    transceiver.direction = "inactive";
                    this._remoteSdp.pauseMediaSection(localId);
                    const offer = await this._pc.createOffer();
                    logger.debug("pauseSending() | calling pc.setLocalDescription() [offer:%o]", offer);
                    await this._pc.setLocalDescription(offer);
                    const answer = {
                      type: "answer",
                      sdp: this._remoteSdp.getSdp()
                    };
                    logger.debug("pauseSending() | calling pc.setRemoteDescription() [answer:%o]", answer);
                    await this._pc.setRemoteDescription(answer);
                  }
                  async resumeSending(localId) {
                    this.assertNotClosed();
                    this.assertSendDirection();
                    logger.debug("resumeSending() [localId:%s]", localId);
                    const transceiver = this._mapMidTransceiver.get(localId);
                    this._remoteSdp.resumeSendingMediaSection(localId);
                    if (!transceiver) {
                      throw new Error("associated RTCRtpTransceiver not found");
                    }
                    transceiver.direction = "sendonly";
                    const offer = await this._pc.createOffer();
                    logger.debug("resumeSending() | calling pc.setLocalDescription() [offer:%o]", offer);
                    await this._pc.setLocalDescription(offer);
                    const answer = {
                      type: "answer",
                      sdp: this._remoteSdp.getSdp()
                    };
                    logger.debug("resumeSending() | calling pc.setRemoteDescription() [answer:%o]", answer);
                    await this._pc.setRemoteDescription(answer);
                  }
                  async replaceTrack(localId, track) {
                    this.assertNotClosed();
                    this.assertSendDirection();
                    if (track) {
                      logger.debug("replaceTrack() [localId:%s, track.id:%s]", localId, track.id);
                    } else {
                      logger.debug("replaceTrack() [localId:%s, no track]", localId);
                    }
                    const transceiver = this._mapMidTransceiver.get(localId);
                    if (!transceiver) {
                      throw new Error("associated RTCRtpTransceiver not found");
                    }
                    await transceiver.sender.replaceTrack(track);
                  }
                  async setMaxSpatialLayer(localId, spatialLayer) {
                    this.assertNotClosed();
                    this.assertSendDirection();
                    logger.debug("setMaxSpatialLayer() [localId:%s, spatialLayer:%s]", localId, spatialLayer);
                    const transceiver = this._mapMidTransceiver.get(localId);
                    if (!transceiver) {
                      throw new Error("associated RTCRtpTransceiver not found");
                    }
                    const parameters = transceiver.sender.getParameters();
                    parameters.encodings.forEach((encoding, idx) => {
                      if (idx <= spatialLayer) {
                        encoding.active = true;
                      } else {
                        encoding.active = false;
                      }
                    });
                    await transceiver.sender.setParameters(parameters);
                    this._remoteSdp.muxMediaSectionSimulcast(localId, parameters.encodings);
                    const offer = await this._pc.createOffer();
                    logger.debug("setMaxSpatialLayer() | calling pc.setLocalDescription() [offer:%o]", offer);
                    await this._pc.setLocalDescription(offer);
                    const answer = {
                      type: "answer",
                      sdp: this._remoteSdp.getSdp()
                    };
                    logger.debug("setMaxSpatialLayer() | calling pc.setRemoteDescription() [answer:%o]", answer);
                    await this._pc.setRemoteDescription(answer);
                  }
                  async setRtpEncodingParameters(localId, params) {
                    this.assertNotClosed();
                    this.assertSendDirection();
                    logger.debug("setRtpEncodingParameters() [localId:%s, params:%o]", localId, params);
                    const transceiver = this._mapMidTransceiver.get(localId);
                    if (!transceiver) {
                      throw new Error("associated RTCRtpTransceiver not found");
                    }
                    const parameters = transceiver.sender.getParameters();
                    parameters.encodings.forEach((encoding, idx) => {
                      parameters.encodings[idx] = { ...encoding, ...params };
                    });
                    await transceiver.sender.setParameters(parameters);
                    this._remoteSdp.muxMediaSectionSimulcast(localId, parameters.encodings);
                    const offer = await this._pc.createOffer();
                    logger.debug("setRtpEncodingParameters() | calling pc.setLocalDescription() [offer:%o]", offer);
                    await this._pc.setLocalDescription(offer);
                    const answer = {
                      type: "answer",
                      sdp: this._remoteSdp.getSdp()
                    };
                    logger.debug("setRtpEncodingParameters() | calling pc.setRemoteDescription() [answer:%o]", answer);
                    await this._pc.setRemoteDescription(answer);
                  }
                  async getSenderStats(localId) {
                    this.assertNotClosed();
                    this.assertSendDirection();
                    const transceiver = this._mapMidTransceiver.get(localId);
                    if (!transceiver) {
                      throw new Error("associated RTCRtpTransceiver not found");
                    }
                    return transceiver.sender.getStats();
                  }
                  async sendDataChannel({ ordered, maxPacketLifeTime, maxRetransmits, label, protocol }) {
                    this.assertNotClosed();
                    this.assertSendDirection();
                    const options = {
                      negotiated: true,
                      id: this._nextSendSctpStreamId,
                      ordered,
                      maxPacketLifeTime,
                      maxRetransmits,
                      protocol
                    };
                    logger.debug("sendDataChannel() [options:%o]", options);
                    const dataChannel = this._pc.createDataChannel(label, options);
                    this._nextSendSctpStreamId = ++this._nextSendSctpStreamId % SCTP_NUM_STREAMS.MIS;
                    if (!this._hasDataChannelMediaSection) {
                      const offer = await this._pc.createOffer();
                      const localSdpObject = sdpTransform.parse(offer.sdp);
                      const offerMediaObject = localSdpObject.media.find((m) => m.type === "application");
                      if (!this._transportReady) {
                        await this.setupTransport({
                          localDtlsRole: this._forcedLocalDtlsRole ?? "client",
                          localSdpObject
                        });
                      }
                      logger.debug("sendDataChannel() | calling pc.setLocalDescription() [offer:%o]", offer);
                      await this._pc.setLocalDescription(offer);
                      this._remoteSdp.sendSctpAssociation({ offerMediaObject });
                      const answer = {
                        type: "answer",
                        sdp: this._remoteSdp.getSdp()
                      };
                      logger.debug("sendDataChannel() | calling pc.setRemoteDescription() [answer:%o]", answer);
                      await this._pc.setRemoteDescription(answer);
                      this._hasDataChannelMediaSection = true;
                    }
                    const sctpStreamParameters = {
                      streamId: options.id,
                      ordered: options.ordered,
                      maxPacketLifeTime: options.maxPacketLifeTime,
                      maxRetransmits: options.maxRetransmits
                    };
                    return { dataChannel, sctpStreamParameters };
                  }
                  async receive(optionsList) {
                    this.assertNotClosed();
                    this.assertRecvDirection();
                    const results = [];
                    const mapLocalId = /* @__PURE__ */ new Map();
                    for (const options of optionsList) {
                      const { trackId, kind, rtpParameters, streamId } = options;
                      logger.debug("receive() [trackId:%s, kind:%s]", trackId, kind);
                      const localId = rtpParameters.mid ?? String(this._mapMidTransceiver.size);
                      mapLocalId.set(trackId, localId);
                      this._remoteSdp.receive({
                        mid: localId,
                        kind,
                        offerRtpParameters: rtpParameters,
                        streamId: streamId ?? rtpParameters.rtcp.cname,
                        trackId
                      });
                    }
                    const offer = {
                      type: "offer",
                      sdp: this._remoteSdp.getSdp()
                    };
                    logger.debug("receive() | calling pc.setRemoteDescription() [offer:%o]", offer);
                    await this._pc.setRemoteDescription(offer);
                    let answer = await this._pc.createAnswer();
                    const localSdpObject = sdpTransform.parse(answer.sdp);
                    for (const options of optionsList) {
                      const { trackId, rtpParameters } = options;
                      const localId = mapLocalId.get(trackId);
                      const answerMediaObject = localSdpObject.media.find((m) => String(m.mid) === localId);
                      sdpCommonUtils.applyCodecParameters({
                        offerRtpParameters: rtpParameters,
                        answerMediaObject
                      });
                    }
                    answer = {
                      type: "answer",
                      sdp: sdpTransform.write(localSdpObject)
                    };
                    if (!this._transportReady) {
                      await this.setupTransport({
                        localDtlsRole: this._forcedLocalDtlsRole ?? "client",
                        localSdpObject
                      });
                    }
                    logger.debug("receive() | calling pc.setLocalDescription() [answer:%o]", answer);
                    await this._pc.setLocalDescription(answer);
                    for (const options of optionsList) {
                      const { trackId } = options;
                      const localId = mapLocalId.get(trackId);
                      const transceiver = this._pc.getTransceivers().find((t) => t.mid === localId);
                      if (!transceiver) {
                        throw new Error("new RTCRtpTransceiver not found");
                      } else {
                        this._mapMidTransceiver.set(localId, transceiver);
                        results.push({
                          localId,
                          track: transceiver.receiver.track,
                          rtpReceiver: transceiver.receiver
                        });
                      }
                    }
                    return results;
                  }
                  async stopReceiving(localIds) {
                    this.assertRecvDirection();
                    if (this._closed) {
                      return;
                    }
                    for (const localId of localIds) {
                      logger.debug("stopReceiving() [localId:%s]", localId);
                      const transceiver = this._mapMidTransceiver.get(localId);
                      if (!transceiver) {
                        throw new Error("associated RTCRtpTransceiver not found");
                      }
                      this._remoteSdp.closeMediaSection(transceiver.mid);
                    }
                    const offer = {
                      type: "offer",
                      sdp: this._remoteSdp.getSdp()
                    };
                    logger.debug("stopReceiving() | calling pc.setRemoteDescription() [offer:%o]", offer);
                    await this._pc.setRemoteDescription(offer);
                    const answer = await this._pc.createAnswer();
                    logger.debug("stopReceiving() | calling pc.setLocalDescription() [answer:%o]", answer);
                    await this._pc.setLocalDescription(answer);
                    for (const localId of localIds) {
                      this._mapMidTransceiver.delete(localId);
                    }
                  }
                  async pauseReceiving(localIds) {
                    this.assertNotClosed();
                    this.assertRecvDirection();
                    for (const localId of localIds) {
                      logger.debug("pauseReceiving() [localId:%s]", localId);
                      const transceiver = this._mapMidTransceiver.get(localId);
                      if (!transceiver) {
                        throw new Error("associated RTCRtpTransceiver not found");
                      }
                      transceiver.direction = "inactive";
                      this._remoteSdp.pauseMediaSection(localId);
                    }
                    const offer = {
                      type: "offer",
                      sdp: this._remoteSdp.getSdp()
                    };
                    logger.debug("pauseReceiving() | calling pc.setRemoteDescription() [offer:%o]", offer);
                    await this._pc.setRemoteDescription(offer);
                    const answer = await this._pc.createAnswer();
                    logger.debug("pauseReceiving() | calling pc.setLocalDescription() [answer:%o]", answer);
                    await this._pc.setLocalDescription(answer);
                  }
                  async resumeReceiving(localIds) {
                    this.assertNotClosed();
                    this.assertRecvDirection();
                    for (const localId of localIds) {
                      logger.debug("resumeReceiving() [localId:%s]", localId);
                      const transceiver = this._mapMidTransceiver.get(localId);
                      if (!transceiver) {
                        throw new Error("associated RTCRtpTransceiver not found");
                      }
                      transceiver.direction = "recvonly";
                      this._remoteSdp.resumeReceivingMediaSection(localId);
                    }
                    const offer = {
                      type: "offer",
                      sdp: this._remoteSdp.getSdp()
                    };
                    logger.debug("resumeReceiving() | calling pc.setRemoteDescription() [offer:%o]", offer);
                    await this._pc.setRemoteDescription(offer);
                    const answer = await this._pc.createAnswer();
                    logger.debug("resumeReceiving() | calling pc.setLocalDescription() [answer:%o]", answer);
                    await this._pc.setLocalDescription(answer);
                  }
                  async getReceiverStats(localId) {
                    this.assertNotClosed();
                    this.assertRecvDirection();
                    const transceiver = this._mapMidTransceiver.get(localId);
                    if (!transceiver) {
                      throw new Error("associated RTCRtpTransceiver not found");
                    }
                    return transceiver.receiver.getStats();
                  }
                  async receiveDataChannel({ sctpStreamParameters, label, protocol }) {
                    this.assertNotClosed();
                    this.assertRecvDirection();
                    const { streamId, ordered, maxPacketLifeTime, maxRetransmits } = sctpStreamParameters;
                    const options = {
                      negotiated: true,
                      id: streamId,
                      ordered,
                      maxPacketLifeTime,
                      maxRetransmits,
                      protocol
                    };
                    logger.debug("receiveDataChannel() [options:%o]", options);
                    const dataChannel = this._pc.createDataChannel(label, options);
                    if (!this._hasDataChannelMediaSection) {
                      this._remoteSdp.receiveSctpAssociation();
                      const offer = {
                        type: "offer",
                        sdp: this._remoteSdp.getSdp()
                      };
                      logger.debug("receiveDataChannel() | calling pc.setRemoteDescription() [offer:%o]", offer);
                      await this._pc.setRemoteDescription(offer);
                      const answer = await this._pc.createAnswer();
                      if (!this._transportReady) {
                        const localSdpObject = sdpTransform.parse(answer.sdp);
                        await this.setupTransport({
                          localDtlsRole: this._forcedLocalDtlsRole ?? "client",
                          localSdpObject
                        });
                      }
                      logger.debug("receiveDataChannel() | calling pc.setRemoteDescription() [answer:%o]", answer);
                      await this._pc.setLocalDescription(answer);
                      this._hasDataChannelMediaSection = true;
                    }
                    return { dataChannel };
                  }
                  async setupTransport({ localDtlsRole, localSdpObject }) {
                    if (!localSdpObject) {
                      localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
                    }
                    const dtlsParameters = sdpCommonUtils.extractDtlsParameters({
                      sdpObject: localSdpObject
                    });
                    dtlsParameters.role = localDtlsRole;
                    this._remoteSdp.updateDtlsRole(localDtlsRole === "client" ? "server" : "client");
                    await new Promise((resolve, reject) => {
                      this.safeEmit("@connect", { dtlsParameters }, resolve, reject);
                    });
                    this._transportReady = true;
                  }
                  assertNotClosed() {
                    if (this._closed) {
                      throw new errors_1.InvalidStateError("method called in a closed handler");
                    }
                  }
                  assertSendDirection() {
                    if (this._direction !== "send") {
                      throw new Error('method can just be called for handlers with "send" direction');
                    }
                  }
                  assertRecvDirection() {
                    if (this._direction !== "recv") {
                      throw new Error('method can just be called for handlers with "recv" direction');
                    }
                  }
                }
                exports2.Chrome74 = Chrome74;
              }
            ),
            /***/
            19: (
              /***/
              function(module2, exports2, __webpack_require__2) {
                ;
                (function(root, factory, undef) {
                  if (true) {
                    module2.exports = exports2 = factory(__webpack_require__2(9021), __webpack_require__2(3009), __webpack_require__2(1025));
                  } else {
                  }
                })(this, function(CryptoJS) {
                  (function() {
                    var C = CryptoJS;
                    var C_lib = C.lib;
                    var Base = C_lib.Base;
                    var WordArray = C_lib.WordArray;
                    var C_algo = C.algo;
                    var SHA256 = C_algo.SHA256;
                    var HMAC = C_algo.HMAC;
                    var PBKDF2 = C_algo.PBKDF2 = Base.extend({
                      /**
                       * Configuration options.
                       *
                       * @property {number} keySize The key size in words to generate. Default: 4 (128 bits)
                       * @property {Hasher} hasher The hasher to use. Default: SHA256
                       * @property {number} iterations The number of iterations to perform. Default: 250000
                       */
                      cfg: Base.extend({
                        keySize: 128 / 32,
                        hasher: SHA256,
                        iterations: 25e4
                      }),
                      /**
                       * Initializes a newly created key derivation function.
                       *
                       * @param {Object} cfg (Optional) The configuration options to use for the derivation.
                       *
                       * @example
                       *
                       *     var kdf = CryptoJS.algo.PBKDF2.create();
                       *     var kdf = CryptoJS.algo.PBKDF2.create({ keySize: 8 });
                       *     var kdf = CryptoJS.algo.PBKDF2.create({ keySize: 8, iterations: 1000 });
                       */
                      init: function(cfg) {
                        this.cfg = this.cfg.extend(cfg);
                      },
                      /**
                       * Computes the Password-Based Key Derivation Function 2.
                       *
                       * @param {WordArray|string} password The password.
                       * @param {WordArray|string} salt A salt.
                       *
                       * @return {WordArray} The derived key.
                       *
                       * @example
                       *
                       *     var key = kdf.compute(password, salt);
                       */
                      compute: function(password, salt) {
                        var cfg = this.cfg;
                        var hmac = HMAC.create(cfg.hasher, password);
                        var derivedKey = WordArray.create();
                        var blockIndex = WordArray.create([1]);
                        var derivedKeyWords = derivedKey.words;
                        var blockIndexWords = blockIndex.words;
                        var keySize = cfg.keySize;
                        var iterations = cfg.iterations;
                        while (derivedKeyWords.length < keySize) {
                          var block = hmac.update(salt).finalize(blockIndex);
                          hmac.reset();
                          var blockWords = block.words;
                          var blockWordsLength = blockWords.length;
                          var intermediate = block;
                          for (var i = 1; i < iterations; i++) {
                            intermediate = hmac.finalize(intermediate);
                            hmac.reset();
                            var intermediateWords = intermediate.words;
                            for (var j = 0; j < blockWordsLength; j++) {
                              blockWords[j] ^= intermediateWords[j];
                            }
                          }
                          derivedKey.concat(block);
                          blockIndexWords[0]++;
                        }
                        derivedKey.sigBytes = keySize * 4;
                        return derivedKey;
                      }
                    });
                    C.PBKDF2 = function(password, salt, cfg) {
                      return PBKDF2.create(cfg).compute(password, salt);
                    };
                  })();
                  return CryptoJS.PBKDF2;
                });
              }
            ),
            /***/
            25: (
              /***/
              function(module2, exports2, __webpack_require__2) {
                ;
                (function(root, factory, undef) {
                  if (true) {
                    module2.exports = exports2 = factory(__webpack_require__2(9021), __webpack_require__2(7165));
                  } else {
                  }
                })(this, function(CryptoJS) {
                  (function(undefined2) {
                    var C = CryptoJS;
                    var C_lib = C.lib;
                    var CipherParams = C_lib.CipherParams;
                    var C_enc = C.enc;
                    var Hex = C_enc.Hex;
                    var C_format = C.format;
                    var HexFormatter = C_format.Hex = {
                      /**
                       * Converts the ciphertext of a cipher params object to a hexadecimally encoded string.
                       *
                       * @param {CipherParams} cipherParams The cipher params object.
                       *
                       * @return {string} The hexadecimally encoded string.
                       *
                       * @static
                       *
                       * @example
                       *
                       *     var hexString = CryptoJS.format.Hex.stringify(cipherParams);
                       */
                      stringify: function(cipherParams) {
                        return cipherParams.ciphertext.toString(Hex);
                      },
                      /**
                       * Converts a hexadecimally encoded ciphertext string to a cipher params object.
                       *
                       * @param {string} input The hexadecimally encoded string.
                       *
                       * @return {CipherParams} The cipher params object.
                       *
                       * @static
                       *
                       * @example
                       *
                       *     var cipherParams = CryptoJS.format.Hex.parse(hexString);
                       */
                      parse: function(input) {
                        var ciphertext = Hex.parse(input);
                        return CipherParams.create({ ciphertext });
                      }
                    };
                  })();
                  return CryptoJS.format.Hex;
                });
              }
            ),
            /***/
            76: (
              /***/
              (__unused_webpack_module, exports2, __webpack_require__2) => {
                "use strict";
                var __webpack_unused_export__;
                __webpack_unused_export__ = { value: true };
                __webpack_unused_export__ = __webpack_unused_export__ = __webpack_unused_export__ = __webpack_unused_export__ = __webpack_unused_export__ = exports2.s$ = __webpack_unused_export__ = __webpack_unused_export__ = exports2.pF = __webpack_unused_export__ = __webpack_unused_export__ = void 0;
                const debug_1 = __webpack_require__2(7833);
                __webpack_unused_export__ = debug_1.default;
                __webpack_require__2(8057);
                __webpack_unused_export__ = "3.15.5";
                var Device_1 = __webpack_require__2(6004);
                Object.defineProperty(exports2, "pF", { enumerable: true, get: function() {
                  return Device_1.Device;
                } });
                __webpack_unused_export__ = { enumerable: true, get: function() {
                  return Device_1.detectDevice;
                } };
                __webpack_unused_export__ = { enumerable: true, get: function() {
                  return Device_1.detectDeviceAsync;
                } };
                var scalabilityModes_1 = __webpack_require__2(3303);
                Object.defineProperty(exports2, "s$", { enumerable: true, get: function() {
                  return scalabilityModes_1.parse;
                } });
                __webpack_require__2(8046);
                __webpack_require__2(3953);
                var FakeHandler_1 = __webpack_require__2(2731);
                __webpack_unused_export__ = { enumerable: true, get: function() {
                  return FakeHandler_1.FakeHandler;
                } };
                __webpack_require__2(5248);
              }
            ),
            /***/
            296: (
              /***/
              (__unused_webpack___webpack_module__, __webpack_exports__2, __webpack_require__2) => {
                "use strict";
                __webpack_require__2.d(__webpack_exports__2, {
                  A: () => (
                    /* binding */
                    _slicedToArray
                  )
                });
                ;
                function _arrayWithHoles(r) {
                  if (Array.isArray(r)) return r;
                }
                ;
                function _iterableToArrayLimit(r, l) {
                  var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
                  if (null != t) {
                    var e, n, i, u, a = [], f = true, o = false;
                    try {
                      if (i = (t = t.call(r)).next, 0 === l) {
                        if (Object(t) !== t) return;
                        f = false;
                      } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = true) ;
                    } catch (r2) {
                      o = true, n = r2;
                    } finally {
                      try {
                        if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return;
                      } finally {
                        if (o) throw n;
                      }
                    }
                    return a;
                  }
                }
                var unsupportedIterableToArray = __webpack_require__2(7800);
                ;
                function _nonIterableRest() {
                  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
                }
                ;
                function _slicedToArray(r, e) {
                  return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || (0, unsupportedIterableToArray.A)(r, e) || _nonIterableRest();
                }
              }
            ),
            /***/
            328: (
              /***/
              (module2, __unused_webpack_exports, __webpack_require__2) => {
                __webpack_require__2(8624);
                module2.exports = self.fetch.bind(self);
              }
            ),
            /***/
            388: (
              /***/
              (__unused_webpack___webpack_module__, __webpack_exports__2, __webpack_require__2) => {
                "use strict";
                __webpack_require__2.d(__webpack_exports__2, {
                  A: () => (
                    /* binding */
                    _possibleConstructorReturn
                  )
                });
                var esm_typeof = __webpack_require__2(2284);
                ;
                function _assertThisInitialized(e) {
                  if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                  return e;
                }
                ;
                function _possibleConstructorReturn(t, e) {
                  if (e && ("object" == (0, esm_typeof.A)(e) || "function" == typeof e)) return e;
                  if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
                  return _assertThisInitialized(t);
                }
              }
            ),
            /***/
            467: (
              /***/
              (__unused_webpack___webpack_module__, __webpack_exports__2, __webpack_require__2) => {
                "use strict";
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  A: () => (
                    /* binding */
                    _asyncToGenerator2
                  )
                  /* harmony export */
                });
                function asyncGeneratorStep(n, t, e, r, o, a, c) {
                  try {
                    var i = n[a](c), u = i.value;
                  } catch (n2) {
                    return void e(n2);
                  }
                  i.done ? t(u) : Promise.resolve(u).then(r, o);
                }
                function _asyncToGenerator2(n) {
                  return function() {
                    var t = this, e = arguments;
                    return new Promise(function(r, o) {
                      var a = n.apply(t, e);
                      function _next(n2) {
                        asyncGeneratorStep(a, r, o, _next, _throw, "next", n2);
                      }
                      function _throw(n2) {
                        asyncGeneratorStep(a, r, o, _next, _throw, "throw", n2);
                      }
                      _next(void 0);
                    });
                  };
                }
              }
            ),
            /***/
            477: (
              /***/
              () => {
              }
            ),
            /***/
            482: (
              /***/
              function(module2, exports2, __webpack_require__2) {
                ;
                (function(root, factory, undef) {
                  if (true) {
                    module2.exports = exports2 = factory(__webpack_require__2(9021), __webpack_require__2(7165));
                  } else {
                  }
                })(this, function(CryptoJS) {
                  CryptoJS.pad.Iso97971 = {
                    pad: function(data, blockSize) {
                      data.concat(CryptoJS.lib.WordArray.create([2147483648], 1));
                      CryptoJS.pad.ZeroPadding.pad(data, blockSize);
                    },
                    unpad: function(data) {
                      CryptoJS.pad.ZeroPadding.unpad(data);
                      data.sigBytes--;
                    }
                  };
                  return CryptoJS.pad.Iso97971;
                });
              }
            ),
            /***/
            579: (
              /***/
              (module2, __unused_webpack_exports, __webpack_require__2) => {
                var _typeof = __webpack_require__2(3738)["default"];
                function _regeneratorValues(e) {
                  if (null != e) {
                    var t = e["function" == typeof Symbol && Symbol.iterator || "@@iterator"], r = 0;
                    if (t) return t.call(e);
                    if ("function" == typeof e.next) return e;
                    if (!isNaN(e.length)) return {
                      next: function next() {
                        return e && r >= e.length && (e = void 0), {
                          value: e && e[r++],
                          done: !e
                        };
                      }
                    };
                  }
                  throw new TypeError(_typeof(e) + " is not iterable");
                }
                module2.exports = _regeneratorValues, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
              }
            ),
            /***/
            736: (
              /***/
              (module2, __unused_webpack_exports, __webpack_require__2) => {
                function setup(env) {
                  createDebug.debug = createDebug;
                  createDebug.default = createDebug;
                  createDebug.coerce = coerce;
                  createDebug.disable = disable;
                  createDebug.enable = enable;
                  createDebug.enabled = enabled;
                  createDebug.humanize = __webpack_require__2(6585);
                  createDebug.destroy = destroy;
                  Object.keys(env).forEach((key) => {
                    createDebug[key] = env[key];
                  });
                  createDebug.names = [];
                  createDebug.skips = [];
                  createDebug.formatters = {};
                  function selectColor(namespace) {
                    let hash = 0;
                    for (let i = 0; i < namespace.length; i++) {
                      hash = (hash << 5) - hash + namespace.charCodeAt(i);
                      hash |= 0;
                    }
                    return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
                  }
                  createDebug.selectColor = selectColor;
                  function createDebug(namespace) {
                    let prevTime;
                    let enableOverride = null;
                    let namespacesCache;
                    let enabledCache;
                    function debug(...args) {
                      if (!debug.enabled) {
                        return;
                      }
                      const self2 = debug;
                      const curr = Number(/* @__PURE__ */ new Date());
                      const ms = curr - (prevTime || curr);
                      self2.diff = ms;
                      self2.prev = prevTime;
                      self2.curr = curr;
                      prevTime = curr;
                      args[0] = createDebug.coerce(args[0]);
                      if (typeof args[0] !== "string") {
                        args.unshift("%O");
                      }
                      let index = 0;
                      args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
                        if (match === "%%") {
                          return "%";
                        }
                        index++;
                        const formatter = createDebug.formatters[format];
                        if (typeof formatter === "function") {
                          const val = args[index];
                          match = formatter.call(self2, val);
                          args.splice(index, 1);
                          index--;
                        }
                        return match;
                      });
                      createDebug.formatArgs.call(self2, args);
                      const logFn = self2.log || createDebug.log;
                      logFn.apply(self2, args);
                    }
                    debug.namespace = namespace;
                    debug.useColors = createDebug.useColors();
                    debug.color = createDebug.selectColor(namespace);
                    debug.extend = extend;
                    debug.destroy = createDebug.destroy;
                    Object.defineProperty(debug, "enabled", {
                      enumerable: true,
                      configurable: false,
                      get: () => {
                        if (enableOverride !== null) {
                          return enableOverride;
                        }
                        if (namespacesCache !== createDebug.namespaces) {
                          namespacesCache = createDebug.namespaces;
                          enabledCache = createDebug.enabled(namespace);
                        }
                        return enabledCache;
                      },
                      set: (v) => {
                        enableOverride = v;
                      }
                    });
                    if (typeof createDebug.init === "function") {
                      createDebug.init(debug);
                    }
                    return debug;
                  }
                  function extend(namespace, delimiter) {
                    const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
                    newDebug.log = this.log;
                    return newDebug;
                  }
                  function enable(namespaces) {
                    createDebug.save(namespaces);
                    createDebug.namespaces = namespaces;
                    createDebug.names = [];
                    createDebug.skips = [];
                    const split = (typeof namespaces === "string" ? namespaces : "").trim().replace(/\s+/g, ",").split(",").filter(Boolean);
                    for (const ns of split) {
                      if (ns[0] === "-") {
                        createDebug.skips.push(ns.slice(1));
                      } else {
                        createDebug.names.push(ns);
                      }
                    }
                  }
                  function matchesTemplate(search, template) {
                    let searchIndex = 0;
                    let templateIndex = 0;
                    let starIndex = -1;
                    let matchIndex = 0;
                    while (searchIndex < search.length) {
                      if (templateIndex < template.length && (template[templateIndex] === search[searchIndex] || template[templateIndex] === "*")) {
                        if (template[templateIndex] === "*") {
                          starIndex = templateIndex;
                          matchIndex = searchIndex;
                          templateIndex++;
                        } else {
                          searchIndex++;
                          templateIndex++;
                        }
                      } else if (starIndex !== -1) {
                        templateIndex = starIndex + 1;
                        matchIndex++;
                        searchIndex = matchIndex;
                      } else {
                        return false;
                      }
                    }
                    while (templateIndex < template.length && template[templateIndex] === "*") {
                      templateIndex++;
                    }
                    return templateIndex === template.length;
                  }
                  function disable() {
                    const namespaces = [
                      ...createDebug.names,
                      ...createDebug.skips.map((namespace) => "-" + namespace)
                    ].join(",");
                    createDebug.enable("");
                    return namespaces;
                  }
                  function enabled(name) {
                    for (const skip of createDebug.skips) {
                      if (matchesTemplate(name, skip)) {
                        return false;
                      }
                    }
                    for (const ns of createDebug.names) {
                      if (matchesTemplate(name, ns)) {
                        return true;
                      }
                    }
                    return false;
                  }
                  function coerce(val) {
                    if (val instanceof Error) {
                      return val.stack || val.message;
                    }
                    return val;
                  }
                  function destroy() {
                    console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
                  }
                  createDebug.enable(createDebug.load());
                  return createDebug;
                }
                module2.exports = setup;
              }
            ),
            /***/
            754: (
              /***/
              function(module2, exports2, __webpack_require__2) {
                ;
                (function(root, factory) {
                  if (true) {
                    module2.exports = exports2 = factory(__webpack_require__2(9021));
                  } else {
                  }
                })(this, function(CryptoJS) {
                  (function() {
                    var C = CryptoJS;
                    var C_lib = C.lib;
                    var WordArray = C_lib.WordArray;
                    var C_enc = C.enc;
                    var Base64 = C_enc.Base64 = {
                      /**
                       * Converts a word array to a Base64 string.
                       *
                       * @param {WordArray} wordArray The word array.
                       *
                       * @return {string} The Base64 string.
                       *
                       * @static
                       *
                       * @example
                       *
                       *     var base64String = CryptoJS.enc.Base64.stringify(wordArray);
                       */
                      stringify: function(wordArray) {
                        var words = wordArray.words;
                        var sigBytes = wordArray.sigBytes;
                        var map = this._map;
                        wordArray.clamp();
                        var base64Chars = [];
                        for (var i = 0; i < sigBytes; i += 3) {
                          var byte1 = words[i >>> 2] >>> 24 - i % 4 * 8 & 255;
                          var byte2 = words[i + 1 >>> 2] >>> 24 - (i + 1) % 4 * 8 & 255;
                          var byte3 = words[i + 2 >>> 2] >>> 24 - (i + 2) % 4 * 8 & 255;
                          var triplet = byte1 << 16 | byte2 << 8 | byte3;
                          for (var j = 0; j < 4 && i + j * 0.75 < sigBytes; j++) {
                            base64Chars.push(map.charAt(triplet >>> 6 * (3 - j) & 63));
                          }
                        }
                        var paddingChar = map.charAt(64);
                        if (paddingChar) {
                          while (base64Chars.length % 4) {
                            base64Chars.push(paddingChar);
                          }
                        }
                        return base64Chars.join("");
                      },
                      /**
                       * Converts a Base64 string to a word array.
                       *
                       * @param {string} base64Str The Base64 string.
                       *
                       * @return {WordArray} The word array.
                       *
                       * @static
                       *
                       * @example
                       *
                       *     var wordArray = CryptoJS.enc.Base64.parse(base64String);
                       */
                      parse: function(base64Str) {
                        var base64StrLength = base64Str.length;
                        var map = this._map;
                        var reverseMap = this._reverseMap;
                        if (!reverseMap) {
                          reverseMap = this._reverseMap = [];
                          for (var j = 0; j < map.length; j++) {
                            reverseMap[map.charCodeAt(j)] = j;
                          }
                        }
                        var paddingChar = map.charAt(64);
                        if (paddingChar) {
                          var paddingIndex = base64Str.indexOf(paddingChar);
                          if (paddingIndex !== -1) {
                            base64StrLength = paddingIndex;
                          }
                        }
                        return parseLoop(base64Str, base64StrLength, reverseMap);
                      },
                      _map: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/="
                    };
                    function parseLoop(base64Str, base64StrLength, reverseMap) {
                      var words = [];
                      var nBytes = 0;
                      for (var i = 0; i < base64StrLength; i++) {
                        if (i % 4) {
                          var bits1 = reverseMap[base64Str.charCodeAt(i - 1)] << i % 4 * 2;
                          var bits2 = reverseMap[base64Str.charCodeAt(i)] >>> 6 - i % 4 * 2;
                          var bitsCombined = bits1 | bits2;
                          words[nBytes >>> 2] |= bitsCombined << 24 - nBytes % 4 * 8;
                          nBytes++;
                        }
                      }
                      return WordArray.create(words, nBytes);
                    }
                  })();
                  return CryptoJS.enc.Base64;
                });
              }
            ),
            /***/
            816: (
              /***/
              (__unused_webpack___webpack_module__, __webpack_exports__2, __webpack_require__2) => {
                "use strict";
                __webpack_require__2.d(__webpack_exports__2, {
                  A: () => (
                    /* binding */
                    toPropertyKey
                  )
                });
                var esm_typeof = __webpack_require__2(2284);
                ;
                function toPrimitive(t, r) {
                  if ("object" != (0, esm_typeof.A)(t) || !t) return t;
                  var e = t[Symbol.toPrimitive];
                  if (void 0 !== e) {
                    var i = e.call(t, r || "default");
                    if ("object" != (0, esm_typeof.A)(i)) return i;
                    throw new TypeError("@@toPrimitive must return a primitive value.");
                  }
                  return ("string" === r ? String : Number)(t);
                }
                ;
                function toPropertyKey(t) {
                  var i = toPrimitive(t, "string");
                  return "symbol" == (0, esm_typeof.A)(i) ? i : i + "";
                }
              }
            ),
            /***/
            867: (
              /***/
              (__unused_webpack_module, exports2, __webpack_require__2) => {
                "use strict";
                Object.defineProperty(exports2, "__esModule", { value: true });
                exports2.ReactNative106 = void 0;
                const sdpTransform = __webpack_require__2(7363);
                const enhancedEvents_1 = __webpack_require__2(3953);
                const Logger_1 = __webpack_require__2(2994);
                const ortc = __webpack_require__2(8046);
                const errors_1 = __webpack_require__2(4893);
                const scalabilityModes_1 = __webpack_require__2(3303);
                const RemoteSdp_1 = __webpack_require__2(1305);
                const sdpCommonUtils = __webpack_require__2(5544);
                const sdpUnifiedPlanUtils = __webpack_require__2(5938);
                const ortcUtils = __webpack_require__2(4256);
                const logger = new Logger_1.Logger("ReactNative106");
                const NAME = "ReactNative106";
                const SCTP_NUM_STREAMS = { OS: 1024, MIS: 1024 };
                class ReactNative106 extends enhancedEvents_1.EnhancedEventEmitter {
                  constructor({ direction, iceParameters, iceCandidates, dtlsParameters, sctpParameters, iceServers, iceTransportPolicy, additionalSettings, getSendExtendedRtpCapabilities }) {
                    super();
                    // Closed flag.
                    __publicField(this, "_closed", false);
                    // Handler direction.
                    __publicField(this, "_direction");
                    // Remote SDP handler.
                    __publicField(this, "_remoteSdp");
                    // Callback to request sending extended RTP capabilities on demand.
                    __publicField(this, "_getSendExtendedRtpCapabilities");
                    // Initial server side DTLS role. If not 'auto', it will force the opposite
                    // value in client side.
                    __publicField(this, "_forcedLocalDtlsRole");
                    // RTCPeerConnection instance.
                    __publicField(this, "_pc");
                    // Map of RTCTransceivers indexed by MID.
                    __publicField(this, "_mapMidTransceiver", /* @__PURE__ */ new Map());
                    // Local stream for sending.
                    __publicField(this, "_sendStream", new MediaStream());
                    // Whether a DataChannel m=application section has been created.
                    __publicField(this, "_hasDataChannelMediaSection", false);
                    // Sending DataChannel id value counter. Incremented for each new DataChannel.
                    __publicField(this, "_nextSendSctpStreamId", 0);
                    // Got transport local and remote parameters.
                    __publicField(this, "_transportReady", false);
                    __publicField(this, "onIceGatheringStateChange", () => {
                      this.emit("@icegatheringstatechange", this._pc.iceGatheringState);
                    });
                    __publicField(this, "onIceCandidateError", (event) => {
                      this.emit("@icecandidateerror", event);
                    });
                    __publicField(this, "onConnectionStateChange", () => {
                      this.emit("@connectionstatechange", this._pc.connectionState);
                    });
                    __publicField(this, "onIceConnectionStateChange", () => {
                      switch (this._pc.iceConnectionState) {
                        case "checking": {
                          this.emit("@connectionstatechange", "connecting");
                          break;
                        }
                        case "connected":
                        case "completed": {
                          this.emit("@connectionstatechange", "connected");
                          break;
                        }
                        case "failed": {
                          this.emit("@connectionstatechange", "failed");
                          break;
                        }
                        case "disconnected": {
                          this.emit("@connectionstatechange", "disconnected");
                          break;
                        }
                        case "closed": {
                          this.emit("@connectionstatechange", "closed");
                          break;
                        }
                      }
                    });
                    logger.debug("constructor()");
                    this._direction = direction;
                    this._remoteSdp = new RemoteSdp_1.RemoteSdp({
                      iceParameters,
                      iceCandidates,
                      dtlsParameters,
                      sctpParameters
                    });
                    this._getSendExtendedRtpCapabilities = getSendExtendedRtpCapabilities;
                    if (dtlsParameters.role && dtlsParameters.role !== "auto") {
                      this._forcedLocalDtlsRole = dtlsParameters.role === "server" ? "client" : "server";
                    }
                    this._pc = new RTCPeerConnection({
                      iceServers: iceServers ?? [],
                      iceTransportPolicy: iceTransportPolicy ?? "all",
                      bundlePolicy: "max-bundle",
                      rtcpMuxPolicy: "require",
                      ...additionalSettings
                    });
                    this._pc.addEventListener("icegatheringstatechange", this.onIceGatheringStateChange);
                    this._pc.addEventListener("icecandidateerror", this.onIceCandidateError);
                    if (this._pc.connectionState) {
                      this._pc.addEventListener("connectionstatechange", this.onConnectionStateChange);
                    } else {
                      logger.warn("run() | pc.connectionState not supported, using pc.iceConnectionState");
                      this._pc.addEventListener("iceconnectionstatechange", this.onIceConnectionStateChange);
                    }
                  }
                  /**
                   * Creates a factory function.
                   */
                  static createFactory() {
                    return {
                      name: NAME,
                      factory: (options) => new ReactNative106(options),
                      getNativeRtpCapabilities: async () => {
                        logger.debug("getNativeRtpCapabilities()");
                        let pc = new RTCPeerConnection({
                          iceServers: [],
                          iceTransportPolicy: "all",
                          bundlePolicy: "max-bundle",
                          rtcpMuxPolicy: "require"
                        });
                        try {
                          pc.addTransceiver("audio");
                          pc.addTransceiver("video");
                          const offer = await pc.createOffer();
                          try {
                            pc.close();
                          } catch (error) {
                          }
                          pc = void 0;
                          const sdpObject = sdpTransform.parse(offer.sdp);
                          const nativeRtpCapabilities = ReactNative106.getLocalRtpCapabilities(sdpObject);
                          return nativeRtpCapabilities;
                        } catch (error) {
                          try {
                            pc == null ? void 0 : pc.close();
                          } catch (error2) {
                          }
                          pc = void 0;
                          throw error;
                        }
                      },
                      getNativeSctpCapabilities: async () => {
                        logger.debug("getNativeSctpCapabilities()");
                        return {
                          numStreams: SCTP_NUM_STREAMS
                        };
                      }
                    };
                  }
                  static getLocalRtpCapabilities(localSdpObject) {
                    const nativeRtpCapabilities = sdpCommonUtils.extractRtpCapabilities({
                      sdpObject: localSdpObject
                    });
                    ortc.validateAndNormalizeRtpCapabilities(nativeRtpCapabilities);
                    ortcUtils.addNackSupportForOpus(nativeRtpCapabilities);
                    return nativeRtpCapabilities;
                  }
                  get name() {
                    return NAME;
                  }
                  close() {
                    logger.debug("close()");
                    if (this._closed) {
                      return;
                    }
                    this._closed = true;
                    this._sendStream.release(
                      /* releaseTracks */
                      false
                    );
                    try {
                      this._pc.close();
                    } catch (error) {
                    }
                    this._pc.removeEventListener("icegatheringstatechange", this.onIceGatheringStateChange);
                    this._pc.removeEventListener("icecandidateerror", this.onIceCandidateError);
                    this._pc.removeEventListener("connectionstatechange", this.onConnectionStateChange);
                    this._pc.removeEventListener("iceconnectionstatechange", this.onIceConnectionStateChange);
                    this.emit("@close");
                    super.close();
                  }
                  async updateIceServers(iceServers) {
                    this.assertNotClosed();
                    logger.debug("updateIceServers()");
                    const configuration = this._pc.getConfiguration();
                    configuration.iceServers = iceServers;
                    this._pc.setConfiguration(configuration);
                  }
                  async restartIce(iceParameters) {
                    this.assertNotClosed();
                    logger.debug("restartIce()");
                    this._remoteSdp.updateIceParameters(iceParameters);
                    if (!this._transportReady) {
                      return;
                    }
                    if (this._direction === "send") {
                      const offer = await this._pc.createOffer({ iceRestart: true });
                      logger.debug("restartIce() | calling pc.setLocalDescription() [offer:%o]", offer);
                      await this._pc.setLocalDescription(offer);
                      const answer = {
                        type: "answer",
                        sdp: this._remoteSdp.getSdp()
                      };
                      logger.debug("restartIce() | calling pc.setRemoteDescription() [answer:%o]", answer);
                      await this._pc.setRemoteDescription(answer);
                    } else {
                      const offer = {
                        type: "offer",
                        sdp: this._remoteSdp.getSdp()
                      };
                      logger.debug("restartIce() | calling pc.setRemoteDescription() [offer:%o]", offer);
                      await this._pc.setRemoteDescription(offer);
                      const answer = await this._pc.createAnswer();
                      logger.debug("restartIce() | calling pc.setLocalDescription() [answer:%o]", answer);
                      await this._pc.setLocalDescription(answer);
                    }
                  }
                  async getTransportStats() {
                    this.assertNotClosed();
                    return this._pc.getStats();
                  }
                  async send({ track, encodings, codecOptions, codec, onRtpSender }) {
                    this.assertNotClosed();
                    this.assertSendDirection();
                    logger.debug("send() [kind:%s, track.id:%s]", track.kind, track.id);
                    if (encodings && encodings.length > 1) {
                      encodings.forEach((encoding, idx) => {
                        encoding.rid = `r${idx}`;
                      });
                    }
                    const mediaSectionIdx = this._remoteSdp.getNextMediaSectionIdx();
                    const transceiver = this._pc.addTransceiver(track, {
                      direction: "sendonly",
                      streams: [this._sendStream],
                      sendEncodings: encodings
                    });
                    if (onRtpSender) {
                      onRtpSender(transceiver.sender);
                    }
                    let offer = await this._pc.createOffer();
                    let localSdpObject = sdpTransform.parse(offer.sdp);
                    if (localSdpObject.extmapAllowMixed) {
                      this._remoteSdp.setSessionExtmapAllowMixed();
                    }
                    const nativeRtpCapabilities = ReactNative106.getLocalRtpCapabilities(localSdpObject);
                    const sendExtendedRtpCapabilities = this._getSendExtendedRtpCapabilities(nativeRtpCapabilities);
                    const sendingRtpParameters = ortc.getSendingRtpParameters(track.kind, sendExtendedRtpCapabilities);
                    sendingRtpParameters.codecs = ortc.reduceCodecs(sendingRtpParameters.codecs, codec);
                    const sendingRemoteRtpParameters = ortc.getSendingRemoteRtpParameters(track.kind, sendExtendedRtpCapabilities);
                    sendingRemoteRtpParameters.codecs = ortc.reduceCodecs(sendingRemoteRtpParameters.codecs, codec);
                    if (!this._transportReady) {
                      await this.setupTransport({
                        localDtlsRole: this._forcedLocalDtlsRole ?? "client",
                        localSdpObject
                      });
                    }
                    let hackVp9Svc = false;
                    const layers = (0, scalabilityModes_1.parse)((encodings ?? [{}])[0].scalabilityMode);
                    let offerMediaObject;
                    if (encodings && encodings.length === 1 && layers.spatialLayers > 1 && sendingRtpParameters.codecs[0].mimeType.toLowerCase() === "video/vp9") {
                      logger.debug("send() | enabling legacy simulcast for VP9 SVC");
                      hackVp9Svc = true;
                      localSdpObject = sdpTransform.parse(offer.sdp);
                      offerMediaObject = localSdpObject.media[mediaSectionIdx.idx];
                      sdpUnifiedPlanUtils.addLegacySimulcast({
                        offerMediaObject,
                        numStreams: layers.spatialLayers
                      });
                      offer = {
                        type: "offer",
                        sdp: sdpTransform.write(localSdpObject)
                      };
                    }
                    logger.debug("send() | calling pc.setLocalDescription() [offer:%o]", offer);
                    await this._pc.setLocalDescription(offer);
                    let localId = transceiver.mid ?? void 0;
                    if (!localId) {
                      logger.warn("send() | missing transceiver.mid (bug in react-native-webrtc, using a workaround");
                    }
                    sendingRtpParameters.mid = localId;
                    localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
                    offerMediaObject = localSdpObject.media[mediaSectionIdx.idx];
                    sendingRtpParameters.rtcp.cname = sdpCommonUtils.getCname({
                      offerMediaObject
                    });
                    if (!encodings) {
                      sendingRtpParameters.encodings = sdpUnifiedPlanUtils.getRtpEncodings({
                        offerMediaObject
                      });
                    } else if (encodings.length === 1) {
                      let newEncodings = sdpUnifiedPlanUtils.getRtpEncodings({
                        offerMediaObject
                      });
                      Object.assign(newEncodings[0], encodings[0]);
                      if (hackVp9Svc) {
                        newEncodings = [newEncodings[0]];
                      }
                      sendingRtpParameters.encodings = newEncodings;
                    } else {
                      sendingRtpParameters.encodings = encodings;
                    }
                    if (sendingRtpParameters.encodings.length > 1 && (sendingRtpParameters.codecs[0].mimeType.toLowerCase() === "video/vp8" || sendingRtpParameters.codecs[0].mimeType.toLowerCase() === "video/h264")) {
                      for (const encoding of sendingRtpParameters.encodings) {
                        if (encoding.scalabilityMode) {
                          encoding.scalabilityMode = `L1T${layers.temporalLayers}`;
                        } else {
                          encoding.scalabilityMode = "L1T3";
                        }
                      }
                    }
                    this._remoteSdp.send({
                      offerMediaObject,
                      reuseMid: mediaSectionIdx.reuseMid,
                      offerRtpParameters: sendingRtpParameters,
                      answerRtpParameters: sendingRemoteRtpParameters,
                      codecOptions
                    });
                    const answer = {
                      type: "answer",
                      sdp: this._remoteSdp.getSdp()
                    };
                    logger.debug("send() | calling pc.setRemoteDescription() [answer:%o]", answer);
                    await this._pc.setRemoteDescription(answer);
                    if (!localId) {
                      localId = transceiver.mid;
                      sendingRtpParameters.mid = localId;
                    }
                    this._mapMidTransceiver.set(localId, transceiver);
                    return {
                      localId,
                      rtpParameters: sendingRtpParameters,
                      rtpSender: transceiver.sender
                    };
                  }
                  async stopSending(localId) {
                    this.assertSendDirection();
                    if (this._closed) {
                      return;
                    }
                    logger.debug("stopSending() [localId:%s]", localId);
                    const transceiver = this._mapMidTransceiver.get(localId);
                    if (!transceiver) {
                      throw new Error("associated RTCRtpTransceiver not found");
                    }
                    void transceiver.sender.replaceTrack(null);
                    this._pc.removeTrack(transceiver.sender);
                    const mediaSectionClosed = this._remoteSdp.closeMediaSection(transceiver.mid);
                    if (mediaSectionClosed) {
                      try {
                        transceiver.stop();
                      } catch (error) {
                      }
                    }
                    const offer = await this._pc.createOffer();
                    logger.debug("stopSending() | calling pc.setLocalDescription() [offer:%o]", offer);
                    await this._pc.setLocalDescription(offer);
                    const answer = {
                      type: "answer",
                      sdp: this._remoteSdp.getSdp()
                    };
                    logger.debug("stopSending() | calling pc.setRemoteDescription() [answer:%o]", answer);
                    await this._pc.setRemoteDescription(answer);
                    this._mapMidTransceiver.delete(localId);
                  }
                  async pauseSending(localId) {
                    this.assertNotClosed();
                    this.assertSendDirection();
                    logger.debug("pauseSending() [localId:%s]", localId);
                    const transceiver = this._mapMidTransceiver.get(localId);
                    if (!transceiver) {
                      throw new Error("associated RTCRtpTransceiver not found");
                    }
                    transceiver.direction = "inactive";
                    this._remoteSdp.pauseMediaSection(localId);
                    const offer = await this._pc.createOffer();
                    logger.debug("pauseSending() | calling pc.setLocalDescription() [offer:%o]", offer);
                    await this._pc.setLocalDescription(offer);
                    const answer = {
                      type: "answer",
                      sdp: this._remoteSdp.getSdp()
                    };
                    logger.debug("pauseSending() | calling pc.setRemoteDescription() [answer:%o]", answer);
                    await this._pc.setRemoteDescription(answer);
                  }
                  async resumeSending(localId) {
                    this.assertNotClosed();
                    this.assertSendDirection();
                    logger.debug("resumeSending() [localId:%s]", localId);
                    const transceiver = this._mapMidTransceiver.get(localId);
                    this._remoteSdp.resumeSendingMediaSection(localId);
                    if (!transceiver) {
                      throw new Error("associated RTCRtpTransceiver not found");
                    }
                    transceiver.direction = "sendonly";
                    const offer = await this._pc.createOffer();
                    logger.debug("resumeSending() | calling pc.setLocalDescription() [offer:%o]", offer);
                    await this._pc.setLocalDescription(offer);
                    const answer = {
                      type: "answer",
                      sdp: this._remoteSdp.getSdp()
                    };
                    logger.debug("resumeSending() | calling pc.setRemoteDescription() [answer:%o]", answer);
                    await this._pc.setRemoteDescription(answer);
                  }
                  async replaceTrack(localId, track) {
                    this.assertNotClosed();
                    this.assertSendDirection();
                    if (track) {
                      logger.debug("replaceTrack() [localId:%s, track.id:%s]", localId, track.id);
                    } else {
                      logger.debug("replaceTrack() [localId:%s, no track]", localId);
                    }
                    const transceiver = this._mapMidTransceiver.get(localId);
                    if (!transceiver) {
                      throw new Error("associated RTCRtpTransceiver not found");
                    }
                    await transceiver.sender.replaceTrack(track);
                  }
                  async setMaxSpatialLayer(localId, spatialLayer) {
                    this.assertNotClosed();
                    this.assertSendDirection();
                    logger.debug("setMaxSpatialLayer() [localId:%s, spatialLayer:%s]", localId, spatialLayer);
                    const transceiver = this._mapMidTransceiver.get(localId);
                    if (!transceiver) {
                      throw new Error("associated RTCRtpTransceiver not found");
                    }
                    const parameters = transceiver.sender.getParameters();
                    parameters.encodings.forEach((encoding, idx) => {
                      if (idx <= spatialLayer) {
                        encoding.active = true;
                      } else {
                        encoding.active = false;
                      }
                    });
                    await transceiver.sender.setParameters(parameters);
                    this._remoteSdp.muxMediaSectionSimulcast(localId, parameters.encodings);
                    const offer = await this._pc.createOffer();
                    logger.debug("setMaxSpatialLayer() | calling pc.setLocalDescription() [offer:%o]", offer);
                    await this._pc.setLocalDescription(offer);
                    const answer = {
                      type: "answer",
                      sdp: this._remoteSdp.getSdp()
                    };
                    logger.debug("setMaxSpatialLayer() | calling pc.setRemoteDescription() [answer:%o]", answer);
                    await this._pc.setRemoteDescription(answer);
                  }
                  async setRtpEncodingParameters(localId, params) {
                    this.assertNotClosed();
                    this.assertSendDirection();
                    logger.debug("setRtpEncodingParameters() [localId:%s, params:%o]", localId, params);
                    const transceiver = this._mapMidTransceiver.get(localId);
                    if (!transceiver) {
                      throw new Error("associated RTCRtpTransceiver not found");
                    }
                    const parameters = transceiver.sender.getParameters();
                    parameters.encodings.forEach((encoding, idx) => {
                      parameters.encodings[idx] = { ...encoding, ...params };
                    });
                    await transceiver.sender.setParameters(parameters);
                    this._remoteSdp.muxMediaSectionSimulcast(localId, parameters.encodings);
                    const offer = await this._pc.createOffer();
                    logger.debug("setRtpEncodingParameters() | calling pc.setLocalDescription() [offer:%o]", offer);
                    await this._pc.setLocalDescription(offer);
                    const answer = {
                      type: "answer",
                      sdp: this._remoteSdp.getSdp()
                    };
                    logger.debug("setRtpEncodingParameters() | calling pc.setRemoteDescription() [answer:%o]", answer);
                    await this._pc.setRemoteDescription(answer);
                  }
                  async getSenderStats(localId) {
                    this.assertNotClosed();
                    this.assertSendDirection();
                    const transceiver = this._mapMidTransceiver.get(localId);
                    if (!transceiver) {
                      throw new Error("associated RTCRtpTransceiver not found");
                    }
                    return transceiver.sender.getStats();
                  }
                  async sendDataChannel({ ordered, maxPacketLifeTime, maxRetransmits, label, protocol }) {
                    this.assertNotClosed();
                    this.assertSendDirection();
                    const options = {
                      negotiated: true,
                      id: this._nextSendSctpStreamId,
                      ordered,
                      maxPacketLifeTime,
                      maxRetransmits,
                      protocol
                    };
                    logger.debug("sendDataChannel() [options:%o]", options);
                    const dataChannel = this._pc.createDataChannel(label, options);
                    this._nextSendSctpStreamId = ++this._nextSendSctpStreamId % SCTP_NUM_STREAMS.MIS;
                    if (!this._hasDataChannelMediaSection) {
                      const offer = await this._pc.createOffer();
                      const localSdpObject = sdpTransform.parse(offer.sdp);
                      const offerMediaObject = localSdpObject.media.find((m) => m.type === "application");
                      if (!this._transportReady) {
                        await this.setupTransport({
                          localDtlsRole: this._forcedLocalDtlsRole ?? "client",
                          localSdpObject
                        });
                      }
                      logger.debug("sendDataChannel() | calling pc.setLocalDescription() [offer:%o]", offer);
                      await this._pc.setLocalDescription(offer);
                      this._remoteSdp.sendSctpAssociation({ offerMediaObject });
                      const answer = {
                        type: "answer",
                        sdp: this._remoteSdp.getSdp()
                      };
                      logger.debug("sendDataChannel() | calling pc.setRemoteDescription() [answer:%o]", answer);
                      await this._pc.setRemoteDescription(answer);
                      this._hasDataChannelMediaSection = true;
                    }
                    const sctpStreamParameters = {
                      streamId: options.id,
                      ordered: options.ordered,
                      maxPacketLifeTime: options.maxPacketLifeTime,
                      maxRetransmits: options.maxRetransmits
                    };
                    return { dataChannel, sctpStreamParameters };
                  }
                  async receive(optionsList) {
                    this.assertNotClosed();
                    this.assertRecvDirection();
                    const results = [];
                    const mapLocalId = /* @__PURE__ */ new Map();
                    for (const options of optionsList) {
                      const { trackId, kind, rtpParameters, streamId } = options;
                      logger.debug("receive() [trackId:%s, kind:%s]", trackId, kind);
                      const localId = rtpParameters.mid ?? String(this._mapMidTransceiver.size);
                      mapLocalId.set(trackId, localId);
                      this._remoteSdp.receive({
                        mid: localId,
                        kind,
                        offerRtpParameters: rtpParameters,
                        streamId: streamId ?? rtpParameters.rtcp.cname,
                        trackId
                      });
                    }
                    const offer = {
                      type: "offer",
                      sdp: this._remoteSdp.getSdp()
                    };
                    logger.debug("receive() | calling pc.setRemoteDescription() [offer:%o]", offer);
                    await this._pc.setRemoteDescription(offer);
                    for (const options of optionsList) {
                      const { trackId, onRtpReceiver } = options;
                      if (onRtpReceiver) {
                        const localId = mapLocalId.get(trackId);
                        const transceiver = this._pc.getTransceivers().find((t) => t.mid === localId);
                        if (!transceiver) {
                          throw new Error("transceiver not found");
                        }
                        onRtpReceiver(transceiver.receiver);
                      }
                    }
                    let answer = await this._pc.createAnswer();
                    const localSdpObject = sdpTransform.parse(answer.sdp);
                    for (const options of optionsList) {
                      const { trackId, rtpParameters } = options;
                      const localId = mapLocalId.get(trackId);
                      const answerMediaObject = localSdpObject.media.find((m) => String(m.mid) === localId);
                      sdpCommonUtils.applyCodecParameters({
                        offerRtpParameters: rtpParameters,
                        answerMediaObject
                      });
                    }
                    answer = {
                      type: "answer",
                      sdp: sdpTransform.write(localSdpObject)
                    };
                    if (!this._transportReady) {
                      await this.setupTransport({
                        localDtlsRole: this._forcedLocalDtlsRole ?? "client",
                        localSdpObject
                      });
                    }
                    logger.debug("receive() | calling pc.setLocalDescription() [answer:%o]", answer);
                    await this._pc.setLocalDescription(answer);
                    for (const options of optionsList) {
                      const { trackId } = options;
                      const localId = mapLocalId.get(trackId);
                      const transceiver = this._pc.getTransceivers().find((t) => t.mid === localId);
                      if (!transceiver) {
                        throw new Error("new RTCRtpTransceiver not found");
                      } else {
                        this._mapMidTransceiver.set(localId, transceiver);
                        results.push({
                          localId,
                          track: transceiver.receiver.track,
                          rtpReceiver: transceiver.receiver
                        });
                      }
                    }
                    return results;
                  }
                  async stopReceiving(localIds) {
                    this.assertRecvDirection();
                    if (this._closed) {
                      return;
                    }
                    for (const localId of localIds) {
                      logger.debug("stopReceiving() [localId:%s]", localId);
                      const transceiver = this._mapMidTransceiver.get(localId);
                      if (!transceiver) {
                        throw new Error("associated RTCRtpTransceiver not found");
                      }
                      this._remoteSdp.closeMediaSection(transceiver.mid);
                    }
                    const offer = {
                      type: "offer",
                      sdp: this._remoteSdp.getSdp()
                    };
                    logger.debug("stopReceiving() | calling pc.setRemoteDescription() [offer:%o]", offer);
                    await this._pc.setRemoteDescription(offer);
                    const answer = await this._pc.createAnswer();
                    logger.debug("stopReceiving() | calling pc.setLocalDescription() [answer:%o]", answer);
                    await this._pc.setLocalDescription(answer);
                    for (const localId of localIds) {
                      this._mapMidTransceiver.delete(localId);
                    }
                  }
                  async pauseReceiving(localIds) {
                    this.assertNotClosed();
                    this.assertRecvDirection();
                    for (const localId of localIds) {
                      logger.debug("pauseReceiving() [localId:%s]", localId);
                      const transceiver = this._mapMidTransceiver.get(localId);
                      if (!transceiver) {
                        throw new Error("associated RTCRtpTransceiver not found");
                      }
                      transceiver.direction = "inactive";
                      this._remoteSdp.pauseMediaSection(localId);
                    }
                    const offer = {
                      type: "offer",
                      sdp: this._remoteSdp.getSdp()
                    };
                    logger.debug("pauseReceiving() | calling pc.setRemoteDescription() [offer:%o]", offer);
                    await this._pc.setRemoteDescription(offer);
                    const answer = await this._pc.createAnswer();
                    logger.debug("pauseReceiving() | calling pc.setLocalDescription() [answer:%o]", answer);
                    await this._pc.setLocalDescription(answer);
                  }
                  async resumeReceiving(localIds) {
                    this.assertNotClosed();
                    this.assertRecvDirection();
                    for (const localId of localIds) {
                      logger.debug("resumeReceiving() [localId:%s]", localId);
                      const transceiver = this._mapMidTransceiver.get(localId);
                      if (!transceiver) {
                        throw new Error("associated RTCRtpTransceiver not found");
                      }
                      transceiver.direction = "recvonly";
                      this._remoteSdp.resumeReceivingMediaSection(localId);
                    }
                    const offer = {
                      type: "offer",
                      sdp: this._remoteSdp.getSdp()
                    };
                    logger.debug("resumeReceiving() | calling pc.setRemoteDescription() [offer:%o]", offer);
                    await this._pc.setRemoteDescription(offer);
                    const answer = await this._pc.createAnswer();
                    logger.debug("resumeReceiving() | calling pc.setLocalDescription() [answer:%o]", answer);
                    await this._pc.setLocalDescription(answer);
                  }
                  async getReceiverStats(localId) {
                    this.assertNotClosed();
                    this.assertRecvDirection();
                    const transceiver = this._mapMidTransceiver.get(localId);
                    if (!transceiver) {
                      throw new Error("associated RTCRtpTransceiver not found");
                    }
                    return transceiver.receiver.getStats();
                  }
                  async receiveDataChannel({ sctpStreamParameters, label, protocol }) {
                    this.assertNotClosed();
                    this.assertRecvDirection();
                    const { streamId, ordered, maxPacketLifeTime, maxRetransmits } = sctpStreamParameters;
                    const options = {
                      negotiated: true,
                      id: streamId,
                      ordered,
                      maxPacketLifeTime,
                      maxRetransmits,
                      protocol
                    };
                    logger.debug("receiveDataChannel() [options:%o]", options);
                    const dataChannel = this._pc.createDataChannel(label, options);
                    if (!this._hasDataChannelMediaSection) {
                      this._remoteSdp.receiveSctpAssociation();
                      const offer = {
                        type: "offer",
                        sdp: this._remoteSdp.getSdp()
                      };
                      logger.debug("receiveDataChannel() | calling pc.setRemoteDescription() [offer:%o]", offer);
                      await this._pc.setRemoteDescription(offer);
                      const answer = await this._pc.createAnswer();
                      if (!this._transportReady) {
                        const localSdpObject = sdpTransform.parse(answer.sdp);
                        await this.setupTransport({
                          localDtlsRole: this._forcedLocalDtlsRole ?? "client",
                          localSdpObject
                        });
                      }
                      logger.debug("receiveDataChannel() | calling pc.setRemoteDescription() [answer:%o]", answer);
                      await this._pc.setLocalDescription(answer);
                      this._hasDataChannelMediaSection = true;
                    }
                    return { dataChannel };
                  }
                  async setupTransport({ localDtlsRole, localSdpObject }) {
                    if (!localSdpObject) {
                      localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
                    }
                    const dtlsParameters = sdpCommonUtils.extractDtlsParameters({
                      sdpObject: localSdpObject
                    });
                    dtlsParameters.role = localDtlsRole;
                    this._remoteSdp.updateDtlsRole(localDtlsRole === "client" ? "server" : "client");
                    await new Promise((resolve, reject) => {
                      this.safeEmit("@connect", { dtlsParameters }, resolve, reject);
                    });
                    this._transportReady = true;
                  }
                  assertNotClosed() {
                    if (this._closed) {
                      throw new errors_1.InvalidStateError("method called in a closed handler");
                    }
                  }
                  assertSendDirection() {
                    if (this._direction !== "send") {
                      throw new Error('method can just be called for handlers with "send" direction');
                    }
                  }
                  assertRecvDirection() {
                    if (this._direction !== "recv") {
                      throw new Error('method can just be called for handlers with "recv" direction');
                    }
                  }
                }
                exports2.ReactNative106 = ReactNative106;
              }
            ),
            /***/
            878: (
              /***/
              (__unused_webpack_module, exports2) => {
                "use strict";
                Object.defineProperty(exports2, "__esModule", { value: true });
                exports2.FakeEvent = void 0;
                class FakeEvent {
                  constructor(type, options = {}) {
                    /**
                     * Constants.
                     */
                    __publicField(this, "NONE", 0);
                    __publicField(this, "CAPTURING_PHASE", 1);
                    __publicField(this, "AT_TARGET", 2);
                    __publicField(this, "BUBBLING_PHASE", 3);
                    /**
                     * Members.
                     */
                    __publicField(this, "type");
                    __publicField(this, "bubbles");
                    __publicField(this, "cancelable");
                    __publicField(this, "defaultPrevented", false);
                    __publicField(this, "composed", false);
                    __publicField(this, "currentTarget", null);
                    // Not implemented.
                    __publicField(this, "eventPhase", this.NONE);
                    __publicField(this, "isTrusted", true);
                    __publicField(this, "target", null);
                    __publicField(this, "timeStamp", 0);
                    // Deprecated.
                    __publicField(this, "cancelBubble", false);
                    __publicField(this, "returnValue", true);
                    __publicField(this, "srcElement", null);
                    this.type = type;
                    this.bubbles = options.bubbles ?? false;
                    this.cancelable = options.cancelable ?? false;
                  }
                  preventDefault() {
                    if (this.cancelable) {
                      this.defaultPrevented = true;
                    }
                  }
                  /**
                   * Not implemented.
                   */
                  stopPropagation() {
                  }
                  /**
                   * Not implemented.
                   */
                  stopImmediatePropagation() {
                  }
                  /**
                   * Not implemented.
                   */
                  composedPath() {
                    return [];
                  }
                  /**
                   * Not implemented.
                   * @deprecated
                   */
                  // eslint-disable-next-line @typescript-eslint/no-unused-vars
                  initEvent(type, bubbles, cancelable) {
                  }
                }
                exports2.FakeEvent = FakeEvent;
              }
            ),
            /***/
            887: (
              /***/
              (module2, __unused_webpack_exports, __webpack_require__2) => {
                var regenerator = __webpack_require__2(6993);
                var regeneratorAsyncIterator = __webpack_require__2(1791);
                function _regeneratorAsyncGen(r, e, t, o, n) {
                  return new regeneratorAsyncIterator(regenerator().w(r, e, t, o), n || Promise);
                }
                module2.exports = _regeneratorAsyncGen, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
              }
            ),
            /***/
            955: (
              /***/
              function(module2, exports2, __webpack_require__2) {
                ;
                (function(root, factory, undef) {
                  if (true) {
                    module2.exports = exports2 = factory(__webpack_require__2(9021), __webpack_require__2(754), __webpack_require__2(4636), __webpack_require__2(9506), __webpack_require__2(7165));
                  } else {
                  }
                })(this, function(CryptoJS) {
                  (function() {
                    var C = CryptoJS;
                    var C_lib = C.lib;
                    var BlockCipher = C_lib.BlockCipher;
                    var C_algo = C.algo;
                    var SBOX = [];
                    var INV_SBOX = [];
                    var SUB_MIX_0 = [];
                    var SUB_MIX_1 = [];
                    var SUB_MIX_2 = [];
                    var SUB_MIX_3 = [];
                    var INV_SUB_MIX_0 = [];
                    var INV_SUB_MIX_1 = [];
                    var INV_SUB_MIX_2 = [];
                    var INV_SUB_MIX_3 = [];
                    (function() {
                      var d = [];
                      for (var i = 0; i < 256; i++) {
                        if (i < 128) {
                          d[i] = i << 1;
                        } else {
                          d[i] = i << 1 ^ 283;
                        }
                      }
                      var x = 0;
                      var xi = 0;
                      for (var i = 0; i < 256; i++) {
                        var sx = xi ^ xi << 1 ^ xi << 2 ^ xi << 3 ^ xi << 4;
                        sx = sx >>> 8 ^ sx & 255 ^ 99;
                        SBOX[x] = sx;
                        INV_SBOX[sx] = x;
                        var x2 = d[x];
                        var x4 = d[x2];
                        var x8 = d[x4];
                        var t = d[sx] * 257 ^ sx * 16843008;
                        SUB_MIX_0[x] = t << 24 | t >>> 8;
                        SUB_MIX_1[x] = t << 16 | t >>> 16;
                        SUB_MIX_2[x] = t << 8 | t >>> 24;
                        SUB_MIX_3[x] = t;
                        var t = x8 * 16843009 ^ x4 * 65537 ^ x2 * 257 ^ x * 16843008;
                        INV_SUB_MIX_0[sx] = t << 24 | t >>> 8;
                        INV_SUB_MIX_1[sx] = t << 16 | t >>> 16;
                        INV_SUB_MIX_2[sx] = t << 8 | t >>> 24;
                        INV_SUB_MIX_3[sx] = t;
                        if (!x) {
                          x = xi = 1;
                        } else {
                          x = x2 ^ d[d[d[x8 ^ x2]]];
                          xi ^= d[d[xi]];
                        }
                      }
                    })();
                    var RCON = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54];
                    var AES = C_algo.AES = BlockCipher.extend({
                      _doReset: function() {
                        var t;
                        if (this._nRounds && this._keyPriorReset === this._key) {
                          return;
                        }
                        var key = this._keyPriorReset = this._key;
                        var keyWords = key.words;
                        var keySize = key.sigBytes / 4;
                        var nRounds = this._nRounds = keySize + 6;
                        var ksRows = (nRounds + 1) * 4;
                        var keySchedule = this._keySchedule = [];
                        for (var ksRow = 0; ksRow < ksRows; ksRow++) {
                          if (ksRow < keySize) {
                            keySchedule[ksRow] = keyWords[ksRow];
                          } else {
                            t = keySchedule[ksRow - 1];
                            if (!(ksRow % keySize)) {
                              t = t << 8 | t >>> 24;
                              t = SBOX[t >>> 24] << 24 | SBOX[t >>> 16 & 255] << 16 | SBOX[t >>> 8 & 255] << 8 | SBOX[t & 255];
                              t ^= RCON[ksRow / keySize | 0] << 24;
                            } else if (keySize > 6 && ksRow % keySize == 4) {
                              t = SBOX[t >>> 24] << 24 | SBOX[t >>> 16 & 255] << 16 | SBOX[t >>> 8 & 255] << 8 | SBOX[t & 255];
                            }
                            keySchedule[ksRow] = keySchedule[ksRow - keySize] ^ t;
                          }
                        }
                        var invKeySchedule = this._invKeySchedule = [];
                        for (var invKsRow = 0; invKsRow < ksRows; invKsRow++) {
                          var ksRow = ksRows - invKsRow;
                          if (invKsRow % 4) {
                            var t = keySchedule[ksRow];
                          } else {
                            var t = keySchedule[ksRow - 4];
                          }
                          if (invKsRow < 4 || ksRow <= 4) {
                            invKeySchedule[invKsRow] = t;
                          } else {
                            invKeySchedule[invKsRow] = INV_SUB_MIX_0[SBOX[t >>> 24]] ^ INV_SUB_MIX_1[SBOX[t >>> 16 & 255]] ^ INV_SUB_MIX_2[SBOX[t >>> 8 & 255]] ^ INV_SUB_MIX_3[SBOX[t & 255]];
                          }
                        }
                      },
                      encryptBlock: function(M, offset) {
                        this._doCryptBlock(M, offset, this._keySchedule, SUB_MIX_0, SUB_MIX_1, SUB_MIX_2, SUB_MIX_3, SBOX);
                      },
                      decryptBlock: function(M, offset) {
                        var t = M[offset + 1];
                        M[offset + 1] = M[offset + 3];
                        M[offset + 3] = t;
                        this._doCryptBlock(M, offset, this._invKeySchedule, INV_SUB_MIX_0, INV_SUB_MIX_1, INV_SUB_MIX_2, INV_SUB_MIX_3, INV_SBOX);
                        var t = M[offset + 1];
                        M[offset + 1] = M[offset + 3];
                        M[offset + 3] = t;
                      },
                      _doCryptBlock: function(M, offset, keySchedule, SUB_MIX_02, SUB_MIX_12, SUB_MIX_22, SUB_MIX_32, SBOX2) {
                        var nRounds = this._nRounds;
                        var s0 = M[offset] ^ keySchedule[0];
                        var s1 = M[offset + 1] ^ keySchedule[1];
                        var s2 = M[offset + 2] ^ keySchedule[2];
                        var s3 = M[offset + 3] ^ keySchedule[3];
                        var ksRow = 4;
                        for (var round = 1; round < nRounds; round++) {
                          var t0 = SUB_MIX_02[s0 >>> 24] ^ SUB_MIX_12[s1 >>> 16 & 255] ^ SUB_MIX_22[s2 >>> 8 & 255] ^ SUB_MIX_32[s3 & 255] ^ keySchedule[ksRow++];
                          var t1 = SUB_MIX_02[s1 >>> 24] ^ SUB_MIX_12[s2 >>> 16 & 255] ^ SUB_MIX_22[s3 >>> 8 & 255] ^ SUB_MIX_32[s0 & 255] ^ keySchedule[ksRow++];
                          var t2 = SUB_MIX_02[s2 >>> 24] ^ SUB_MIX_12[s3 >>> 16 & 255] ^ SUB_MIX_22[s0 >>> 8 & 255] ^ SUB_MIX_32[s1 & 255] ^ keySchedule[ksRow++];
                          var t3 = SUB_MIX_02[s3 >>> 24] ^ SUB_MIX_12[s0 >>> 16 & 255] ^ SUB_MIX_22[s1 >>> 8 & 255] ^ SUB_MIX_32[s2 & 255] ^ keySchedule[ksRow++];
                          s0 = t0;
                          s1 = t1;
                          s2 = t2;
                          s3 = t3;
                        }
                        var t0 = (SBOX2[s0 >>> 24] << 24 | SBOX2[s1 >>> 16 & 255] << 16 | SBOX2[s2 >>> 8 & 255] << 8 | SBOX2[s3 & 255]) ^ keySchedule[ksRow++];
                        var t1 = (SBOX2[s1 >>> 24] << 24 | SBOX2[s2 >>> 16 & 255] << 16 | SBOX2[s3 >>> 8 & 255] << 8 | SBOX2[s0 & 255]) ^ keySchedule[ksRow++];
                        var t2 = (SBOX2[s2 >>> 24] << 24 | SBOX2[s3 >>> 16 & 255] << 16 | SBOX2[s0 >>> 8 & 255] << 8 | SBOX2[s1 & 255]) ^ keySchedule[ksRow++];
                        var t3 = (SBOX2[s3 >>> 24] << 24 | SBOX2[s0 >>> 16 & 255] << 16 | SBOX2[s1 >>> 8 & 255] << 8 | SBOX2[s2 & 255]) ^ keySchedule[ksRow++];
                        M[offset] = t0;
                        M[offset + 1] = t1;
                        M[offset + 2] = t2;
                        M[offset + 3] = t3;
                      },
                      keySize: 256 / 32
                    });
                    C.AES = BlockCipher._createHelper(AES);
                  })();
                  return CryptoJS.AES;
                });
              }
            ),
            /***/
            1025: (
              /***/
              function(module2, exports2, __webpack_require__2) {
                ;
                (function(root, factory) {
                  if (true) {
                    module2.exports = exports2 = factory(__webpack_require__2(9021));
                  } else {
                  }
                })(this, function(CryptoJS) {
                  (function() {
                    var C = CryptoJS;
                    var C_lib = C.lib;
                    var Base = C_lib.Base;
                    var C_enc = C.enc;
                    var Utf8 = C_enc.Utf8;
                    var C_algo = C.algo;
                    var HMAC = C_algo.HMAC = Base.extend({
                      /**
                       * Initializes a newly created HMAC.
                       *
                       * @param {Hasher} hasher The hash algorithm to use.
                       * @param {WordArray|string} key The secret key.
                       *
                       * @example
                       *
                       *     var hmacHasher = CryptoJS.algo.HMAC.create(CryptoJS.algo.SHA256, key);
                       */
                      init: function(hasher, key) {
                        hasher = this._hasher = new hasher.init();
                        if (typeof key == "string") {
                          key = Utf8.parse(key);
                        }
                        var hasherBlockSize = hasher.blockSize;
                        var hasherBlockSizeBytes = hasherBlockSize * 4;
                        if (key.sigBytes > hasherBlockSizeBytes) {
                          key = hasher.finalize(key);
                        }
                        key.clamp();
                        var oKey = this._oKey = key.clone();
                        var iKey = this._iKey = key.clone();
                        var oKeyWords = oKey.words;
                        var iKeyWords = iKey.words;
                        for (var i = 0; i < hasherBlockSize; i++) {
                          oKeyWords[i] ^= 1549556828;
                          iKeyWords[i] ^= 909522486;
                        }
                        oKey.sigBytes = iKey.sigBytes = hasherBlockSizeBytes;
                        this.reset();
                      },
                      /**
                       * Resets this HMAC to its initial state.
                       *
                       * @example
                       *
                       *     hmacHasher.reset();
                       */
                      reset: function() {
                        var hasher = this._hasher;
                        hasher.reset();
                        hasher.update(this._iKey);
                      },
                      /**
                       * Updates this HMAC with a message.
                       *
                       * @param {WordArray|string} messageUpdate The message to append.
                       *
                       * @return {HMAC} This HMAC instance.
                       *
                       * @example
                       *
                       *     hmacHasher.update('message');
                       *     hmacHasher.update(wordArray);
                       */
                      update: function(messageUpdate) {
                        this._hasher.update(messageUpdate);
                        return this;
                      },
                      /**
                       * Finalizes the HMAC computation.
                       * Note that the finalize operation is effectively a destructive, read-once operation.
                       *
                       * @param {WordArray|string} messageUpdate (Optional) A final message update.
                       *
                       * @return {WordArray} The HMAC.
                       *
                       * @example
                       *
                       *     var hmac = hmacHasher.finalize();
                       *     var hmac = hmacHasher.finalize('message');
                       *     var hmac = hmacHasher.finalize(wordArray);
                       */
                      finalize: function(messageUpdate) {
                        var hasher = this._hasher;
                        var innerHash = hasher.finalize(messageUpdate);
                        hasher.reset();
                        var hmac = hasher.finalize(this._oKey.clone().concat(innerHash));
                        return hmac;
                      }
                    });
                  })();
                });
              }
            ),
            /***/
            1260: (
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                "use strict";
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  E: () => (
                    /* binding */
                    leaveReason
                  ),
                  /* harmony export */
                  t: () => (
                    /* binding */
                    LeaveReasons
                  )
                  /* harmony export */
                });
                var leaveReason = {
                  WEBSOCKET_DISCONNECTED: 1001,
                  REMOVE_PEER: 1002,
                  REMOVE_PEER_VIEWER_MODE_CHANGED: 1003,
                  REMOVE_PEER_MEDIA_RELAY_STOP: 1004,
                  SWITCH_ROOM: 1005,
                  ROOM_CLOSE: 1006,
                  UNKNOWN: 1007,
                  REMOVE_ALL: 1008,
                  MEETING_END_API: 1009,
                  REMOVE_PEER_API: 1010,
                  MANUAL_LEAVE_CALLED: 1101,
                  WEBSOCKET_CONNECTION_ATTEMPTS_EXHAUSTED: 1102,
                  JOIN_ROOM_FAILED: 1103,
                  SWITCH_ROOM_FAILED: 1104
                };
                var LeaveReasons = {
                  WEBSOCKET_DISCONNECTED: {
                    code: 1001,
                    message: "Socket disconnected"
                  },
                  REMOVE_PEER: {
                    code: 1002,
                    message: "Participant was removed from the meeting"
                  },
                  REMOVE_PEER_VIEWER_MODE_CHANGED: {
                    code: 1003,
                    message: "Participant Removed because viewer mode was changed"
                  },
                  REMOVE_PEER_MEDIA_RELAY_STOP: {
                    code: 1004,
                    message: "Participant Removed because media relay was stopped"
                  },
                  SWITCH_ROOM: {
                    code: 1005,
                    message: "Participant switched to a different room"
                  },
                  ROOM_CLOSE: {
                    code: 1006,
                    message: "The meeting has been closed"
                  },
                  UNKNOWN: {
                    code: 1007,
                    message: "Participant disconnected due to an unknown reason"
                  },
                  REMOVE_ALL: {
                    code: 1008,
                    message: "Remove All from the meeting"
                  },
                  // API
                  MEETING_END_API: {
                    code: 1009,
                    message: "Meeting Ended."
                  },
                  REMOVE_PEER_API: {
                    code: 1010,
                    message: "Participant removed from the meeting"
                  },
                  // sdk
                  MANUAL_LEAVE_CALLED: {
                    code: 1101,
                    message: "Participant manually called the leave() method to exit the meeting"
                  },
                  WEBSOCKET_CONNECTION_ATTEMPTS_EXHAUSTED: {
                    code: 1102,
                    message: "Meeting left after multiple failed websocket connection attempts."
                  },
                  JOIN_ROOM_FAILED: {
                    code: 1103,
                    message: "Meeting left due to an error while joining the room."
                  },
                  SWITCH_ROOM_FAILED: {
                    code: 1104,
                    message: "Meeting left due to an error while switching rooms."
                  }
                };
              }
            ),
            /***/
            1305: (
              /***/
              (__unused_webpack_module, exports2, __webpack_require__2) => {
                "use strict";
                Object.defineProperty(exports2, "__esModule", { value: true });
                exports2.RemoteSdp = void 0;
                const sdpTransform = __webpack_require__2(7363);
                const Logger_1 = __webpack_require__2(2994);
                const MediaSection_1 = __webpack_require__2(3471);
                const DD_CODECS = ["av1", "h264"];
                const logger = new Logger_1.Logger("RemoteSdp");
                class RemoteSdp {
                  constructor({ iceParameters, iceCandidates, dtlsParameters, sctpParameters, plainRtpParameters }) {
                    // Remote ICE parameters.
                    __publicField(this, "_iceParameters");
                    // Remote ICE candidates.
                    __publicField(this, "_iceCandidates");
                    // Remote DTLS parameters.
                    __publicField(this, "_dtlsParameters");
                    // Remote SCTP parameters.
                    __publicField(this, "_sctpParameters");
                    // Parameters for plain RTP (no SRTP nor DTLS no BUNDLE).
                    __publicField(this, "_plainRtpParameters");
                    // MediaSection instances with same order as in the SDP.
                    __publicField(this, "_mediaSections", []);
                    // MediaSection indices indexed by MID.
                    __publicField(this, "_midToIndex", /* @__PURE__ */ new Map());
                    // First MID.
                    __publicField(this, "_firstMid");
                    // SDP object.
                    __publicField(this, "_sdpObject");
                    this._iceParameters = iceParameters;
                    this._iceCandidates = iceCandidates;
                    this._dtlsParameters = dtlsParameters;
                    this._sctpParameters = sctpParameters;
                    this._plainRtpParameters = plainRtpParameters;
                    this._sdpObject = {
                      version: 0,
                      origin: {
                        address: "0.0.0.0",
                        ipVer: 4,
                        netType: "IN",
                        sessionId: "10000",
                        sessionVersion: 0,
                        username: "mediasoup-client"
                      },
                      name: "-",
                      timing: { start: 0, stop: 0 },
                      media: []
                    };
                    if (iceParameters == null ? void 0 : iceParameters.iceLite) {
                      this._sdpObject.icelite = "ice-lite";
                    }
                    if (dtlsParameters) {
                      this._sdpObject.msidSemantic = { semantic: "WMS", token: "*" };
                      const numFingerprints = this._dtlsParameters.fingerprints.length;
                      this._sdpObject.fingerprint = {
                        type: dtlsParameters.fingerprints[numFingerprints - 1].algorithm,
                        hash: dtlsParameters.fingerprints[numFingerprints - 1].value
                      };
                      this._sdpObject.groups = [{ type: "BUNDLE", mids: "" }];
                    }
                    if (plainRtpParameters) {
                      this._sdpObject.origin.address = plainRtpParameters.ip;
                      this._sdpObject.origin.ipVer = plainRtpParameters.ipVersion;
                    }
                  }
                  updateIceParameters(iceParameters) {
                    logger.debug("updateIceParameters() [iceParameters:%o]", iceParameters);
                    this._iceParameters = iceParameters;
                    this._sdpObject.icelite = iceParameters.iceLite ? "ice-lite" : void 0;
                    for (const mediaSection of this._mediaSections) {
                      mediaSection.setIceParameters(iceParameters);
                    }
                  }
                  updateDtlsRole(role) {
                    logger.debug("updateDtlsRole() [role:%s]", role);
                    this._dtlsParameters.role = role;
                    for (const mediaSection of this._mediaSections) {
                      mediaSection.setDtlsRole(role);
                    }
                  }
                  /**
                   * Set session level a=extmap-allow-mixed attibute.
                   */
                  setSessionExtmapAllowMixed() {
                    logger.debug("setSessionExtmapAllowMixed()");
                    this._sdpObject.extmapAllowMixed = "extmap-allow-mixed";
                  }
                  getNextMediaSectionIdx() {
                    for (let idx = 0; idx < this._mediaSections.length; ++idx) {
                      const mediaSection = this._mediaSections[idx];
                      if (mediaSection.closed) {
                        return { idx, reuseMid: mediaSection.mid };
                      }
                    }
                    return { idx: this._mediaSections.length };
                  }
                  send({ offerMediaObject, reuseMid, offerRtpParameters, answerRtpParameters, codecOptions }) {
                    var _a;
                    const mediaSection = new MediaSection_1.AnswerMediaSection({
                      iceParameters: this._iceParameters,
                      iceCandidates: this._iceCandidates,
                      dtlsParameters: this._dtlsParameters,
                      plainRtpParameters: this._plainRtpParameters,
                      offerMediaObject,
                      offerRtpParameters,
                      answerRtpParameters,
                      codecOptions
                    });
                    const mediaObject = mediaSection.getObject();
                    const ddCodec = mediaObject.rtp.find((rtp) => DD_CODECS.includes(rtp.codec.toLowerCase()));
                    if (!ddCodec) {
                      mediaObject.ext = (_a = mediaObject.ext) == null ? void 0 : _a.filter((extmap) => extmap.uri !== "https://aomediacodec.github.io/av1-rtp-spec/#dependency-descriptor-rtp-header-extension");
                    }
                    if (reuseMid) {
                      this._replaceMediaSection(mediaSection, reuseMid);
                    } else if (!this._midToIndex.has(mediaSection.mid)) {
                      this._addMediaSection(mediaSection);
                    } else {
                      this._replaceMediaSection(mediaSection);
                    }
                  }
                  receive({ mid, kind, offerRtpParameters, streamId, trackId }) {
                    this.setSessionExtmapAllowMixed();
                    const mediaSection = new MediaSection_1.OfferMediaSection({
                      iceParameters: this._iceParameters,
                      iceCandidates: this._iceCandidates,
                      dtlsParameters: this._dtlsParameters,
                      plainRtpParameters: this._plainRtpParameters,
                      mid,
                      kind,
                      offerRtpParameters,
                      streamId,
                      trackId
                    });
                    const oldMediaSection = this._mediaSections.find((m) => m.closed);
                    if (oldMediaSection) {
                      this._replaceMediaSection(mediaSection, oldMediaSection.mid);
                    } else {
                      this._addMediaSection(mediaSection);
                    }
                  }
                  pauseMediaSection(mid) {
                    const mediaSection = this._findMediaSection(mid);
                    mediaSection.pause();
                  }
                  resumeSendingMediaSection(mid) {
                    const mediaSection = this._findMediaSection(mid);
                    mediaSection.resume();
                  }
                  resumeReceivingMediaSection(mid) {
                    const mediaSection = this._findMediaSection(mid);
                    mediaSection.resume();
                  }
                  disableMediaSection(mid) {
                    const mediaSection = this._findMediaSection(mid);
                    mediaSection.disable();
                  }
                  /**
                   * Closes media section. Returns true if the given MID corresponds to a m
                   * section that has been indeed closed. False otherwise.
                   *
                   * NOTE: Closing the first m section is a pain since it invalidates the bundled
                   * transport, so instead closing it we just disable it.
                   */
                  closeMediaSection(mid) {
                    const mediaSection = this._findMediaSection(mid);
                    if (mid === this._firstMid) {
                      logger.debug("closeMediaSection() | cannot close first media section, disabling it instead [mid:%s]", mid);
                      this.disableMediaSection(mid);
                      return false;
                    }
                    mediaSection.close();
                    this._regenerateBundleMids();
                    return true;
                  }
                  muxMediaSectionSimulcast(mid, encodings) {
                    const mediaSection = this._findMediaSection(mid);
                    mediaSection.muxSimulcastStreams(encodings);
                    this._replaceMediaSection(mediaSection);
                  }
                  sendSctpAssociation({ offerMediaObject }) {
                    const mediaSection = new MediaSection_1.AnswerMediaSection({
                      iceParameters: this._iceParameters,
                      iceCandidates: this._iceCandidates,
                      dtlsParameters: this._dtlsParameters,
                      sctpParameters: this._sctpParameters,
                      plainRtpParameters: this._plainRtpParameters,
                      offerMediaObject
                    });
                    this._addMediaSection(mediaSection);
                  }
                  receiveSctpAssociation() {
                    const mediaSection = new MediaSection_1.OfferMediaSection({
                      iceParameters: this._iceParameters,
                      iceCandidates: this._iceCandidates,
                      dtlsParameters: this._dtlsParameters,
                      sctpParameters: this._sctpParameters,
                      plainRtpParameters: this._plainRtpParameters,
                      mid: "datachannel",
                      kind: "application"
                    });
                    this._addMediaSection(mediaSection);
                  }
                  getSdp() {
                    this._sdpObject.origin.sessionVersion++;
                    return sdpTransform.write(this._sdpObject);
                  }
                  _addMediaSection(newMediaSection) {
                    if (!this._firstMid) {
                      this._firstMid = newMediaSection.mid;
                    }
                    this._mediaSections.push(newMediaSection);
                    this._midToIndex.set(newMediaSection.mid, this._mediaSections.length - 1);
                    this._sdpObject.media.push(newMediaSection.getObject());
                    this._regenerateBundleMids();
                  }
                  _replaceMediaSection(newMediaSection, reuseMid) {
                    if (typeof reuseMid === "string") {
                      const idx = this._midToIndex.get(reuseMid);
                      if (idx === void 0) {
                        throw new Error(`no media section found for reuseMid '${reuseMid}'`);
                      }
                      const oldMediaSection = this._mediaSections[idx];
                      this._mediaSections[idx] = newMediaSection;
                      this._midToIndex.delete(oldMediaSection.mid);
                      this._midToIndex.set(newMediaSection.mid, idx);
                      this._sdpObject.media[idx] = newMediaSection.getObject();
                      this._regenerateBundleMids();
                    } else {
                      const idx = this._midToIndex.get(newMediaSection.mid);
                      if (idx === void 0) {
                        throw new Error(`no media section found with mid '${newMediaSection.mid}'`);
                      }
                      this._mediaSections[idx] = newMediaSection;
                      this._sdpObject.media[idx] = newMediaSection.getObject();
                    }
                  }
                  _findMediaSection(mid) {
                    const idx = this._midToIndex.get(mid);
                    if (idx === void 0) {
                      throw new Error(`no media section found with mid '${mid}'`);
                    }
                    return this._mediaSections[idx];
                  }
                  _regenerateBundleMids() {
                    if (!this._dtlsParameters) {
                      return;
                    }
                    this._sdpObject.groups[0].mids = this._mediaSections.filter((mediaSection) => !mediaSection.closed).map((mediaSection) => mediaSection.mid).join(" ");
                  }
                }
                exports2.RemoteSdp = RemoteSdp;
              }
            ),
            /***/
            1380: (
              /***/
              function(module2, exports2, __webpack_require__2) {
                ;
                (function(root, factory, undef) {
                  if (true) {
                    module2.exports = exports2 = factory(__webpack_require__2(9021), __webpack_require__2(3240));
                  } else {
                  }
                })(this, function(CryptoJS) {
                  (function() {
                    var C = CryptoJS;
                    var C_lib = C.lib;
                    var Hasher = C_lib.Hasher;
                    var C_x64 = C.x64;
                    var X64Word = C_x64.Word;
                    var X64WordArray = C_x64.WordArray;
                    var C_algo = C.algo;
                    function X64Word_create() {
                      return X64Word.create.apply(X64Word, arguments);
                    }
                    var K = [
                      X64Word_create(1116352408, 3609767458),
                      X64Word_create(1899447441, 602891725),
                      X64Word_create(3049323471, 3964484399),
                      X64Word_create(3921009573, 2173295548),
                      X64Word_create(961987163, 4081628472),
                      X64Word_create(1508970993, 3053834265),
                      X64Word_create(2453635748, 2937671579),
                      X64Word_create(2870763221, 3664609560),
                      X64Word_create(3624381080, 2734883394),
                      X64Word_create(310598401, 1164996542),
                      X64Word_create(607225278, 1323610764),
                      X64Word_create(1426881987, 3590304994),
                      X64Word_create(1925078388, 4068182383),
                      X64Word_create(2162078206, 991336113),
                      X64Word_create(2614888103, 633803317),
                      X64Word_create(3248222580, 3479774868),
                      X64Word_create(3835390401, 2666613458),
                      X64Word_create(4022224774, 944711139),
                      X64Word_create(264347078, 2341262773),
                      X64Word_create(604807628, 2007800933),
                      X64Word_create(770255983, 1495990901),
                      X64Word_create(1249150122, 1856431235),
                      X64Word_create(1555081692, 3175218132),
                      X64Word_create(1996064986, 2198950837),
                      X64Word_create(2554220882, 3999719339),
                      X64Word_create(2821834349, 766784016),
                      X64Word_create(2952996808, 2566594879),
                      X64Word_create(3210313671, 3203337956),
                      X64Word_create(3336571891, 1034457026),
                      X64Word_create(3584528711, 2466948901),
                      X64Word_create(113926993, 3758326383),
                      X64Word_create(338241895, 168717936),
                      X64Word_create(666307205, 1188179964),
                      X64Word_create(773529912, 1546045734),
                      X64Word_create(1294757372, 1522805485),
                      X64Word_create(1396182291, 2643833823),
                      X64Word_create(1695183700, 2343527390),
                      X64Word_create(1986661051, 1014477480),
                      X64Word_create(2177026350, 1206759142),
                      X64Word_create(2456956037, 344077627),
                      X64Word_create(2730485921, 1290863460),
                      X64Word_create(2820302411, 3158454273),
                      X64Word_create(3259730800, 3505952657),
                      X64Word_create(3345764771, 106217008),
                      X64Word_create(3516065817, 3606008344),
                      X64Word_create(3600352804, 1432725776),
                      X64Word_create(4094571909, 1467031594),
                      X64Word_create(275423344, 851169720),
                      X64Word_create(430227734, 3100823752),
                      X64Word_create(506948616, 1363258195),
                      X64Word_create(659060556, 3750685593),
                      X64Word_create(883997877, 3785050280),
                      X64Word_create(958139571, 3318307427),
                      X64Word_create(1322822218, 3812723403),
                      X64Word_create(1537002063, 2003034995),
                      X64Word_create(1747873779, 3602036899),
                      X64Word_create(1955562222, 1575990012),
                      X64Word_create(2024104815, 1125592928),
                      X64Word_create(2227730452, 2716904306),
                      X64Word_create(2361852424, 442776044),
                      X64Word_create(2428436474, 593698344),
                      X64Word_create(2756734187, 3733110249),
                      X64Word_create(3204031479, 2999351573),
                      X64Word_create(3329325298, 3815920427),
                      X64Word_create(3391569614, 3928383900),
                      X64Word_create(3515267271, 566280711),
                      X64Word_create(3940187606, 3454069534),
                      X64Word_create(4118630271, 4000239992),
                      X64Word_create(116418474, 1914138554),
                      X64Word_create(174292421, 2731055270),
                      X64Word_create(289380356, 3203993006),
                      X64Word_create(460393269, 320620315),
                      X64Word_create(685471733, 587496836),
                      X64Word_create(852142971, 1086792851),
                      X64Word_create(1017036298, 365543100),
                      X64Word_create(1126000580, 2618297676),
                      X64Word_create(1288033470, 3409855158),
                      X64Word_create(1501505948, 4234509866),
                      X64Word_create(1607167915, 987167468),
                      X64Word_create(1816402316, 1246189591)
                    ];
                    var W = [];
                    (function() {
                      for (var i = 0; i < 80; i++) {
                        W[i] = X64Word_create();
                      }
                    })();
                    var SHA512 = C_algo.SHA512 = Hasher.extend({
                      _doReset: function() {
                        this._hash = new X64WordArray.init([
                          new X64Word.init(1779033703, 4089235720),
                          new X64Word.init(3144134277, 2227873595),
                          new X64Word.init(1013904242, 4271175723),
                          new X64Word.init(2773480762, 1595750129),
                          new X64Word.init(1359893119, 2917565137),
                          new X64Word.init(2600822924, 725511199),
                          new X64Word.init(528734635, 4215389547),
                          new X64Word.init(1541459225, 327033209)
                        ]);
                      },
                      _doProcessBlock: function(M, offset) {
                        var H = this._hash.words;
                        var H0 = H[0];
                        var H1 = H[1];
                        var H2 = H[2];
                        var H3 = H[3];
                        var H4 = H[4];
                        var H5 = H[5];
                        var H6 = H[6];
                        var H7 = H[7];
                        var H0h = H0.high;
                        var H0l = H0.low;
                        var H1h = H1.high;
                        var H1l = H1.low;
                        var H2h = H2.high;
                        var H2l = H2.low;
                        var H3h = H3.high;
                        var H3l = H3.low;
                        var H4h = H4.high;
                        var H4l = H4.low;
                        var H5h = H5.high;
                        var H5l = H5.low;
                        var H6h = H6.high;
                        var H6l = H6.low;
                        var H7h = H7.high;
                        var H7l = H7.low;
                        var ah = H0h;
                        var al = H0l;
                        var bh = H1h;
                        var bl = H1l;
                        var ch = H2h;
                        var cl = H2l;
                        var dh = H3h;
                        var dl = H3l;
                        var eh = H4h;
                        var el = H4l;
                        var fh = H5h;
                        var fl = H5l;
                        var gh = H6h;
                        var gl = H6l;
                        var hh = H7h;
                        var hl = H7l;
                        for (var i = 0; i < 80; i++) {
                          var Wil;
                          var Wih;
                          var Wi = W[i];
                          if (i < 16) {
                            Wih = Wi.high = M[offset + i * 2] | 0;
                            Wil = Wi.low = M[offset + i * 2 + 1] | 0;
                          } else {
                            var gamma0x = W[i - 15];
                            var gamma0xh = gamma0x.high;
                            var gamma0xl = gamma0x.low;
                            var gamma0h = (gamma0xh >>> 1 | gamma0xl << 31) ^ (gamma0xh >>> 8 | gamma0xl << 24) ^ gamma0xh >>> 7;
                            var gamma0l = (gamma0xl >>> 1 | gamma0xh << 31) ^ (gamma0xl >>> 8 | gamma0xh << 24) ^ (gamma0xl >>> 7 | gamma0xh << 25);
                            var gamma1x = W[i - 2];
                            var gamma1xh = gamma1x.high;
                            var gamma1xl = gamma1x.low;
                            var gamma1h = (gamma1xh >>> 19 | gamma1xl << 13) ^ (gamma1xh << 3 | gamma1xl >>> 29) ^ gamma1xh >>> 6;
                            var gamma1l = (gamma1xl >>> 19 | gamma1xh << 13) ^ (gamma1xl << 3 | gamma1xh >>> 29) ^ (gamma1xl >>> 6 | gamma1xh << 26);
                            var Wi7 = W[i - 7];
                            var Wi7h = Wi7.high;
                            var Wi7l = Wi7.low;
                            var Wi16 = W[i - 16];
                            var Wi16h = Wi16.high;
                            var Wi16l = Wi16.low;
                            Wil = gamma0l + Wi7l;
                            Wih = gamma0h + Wi7h + (Wil >>> 0 < gamma0l >>> 0 ? 1 : 0);
                            Wil = Wil + gamma1l;
                            Wih = Wih + gamma1h + (Wil >>> 0 < gamma1l >>> 0 ? 1 : 0);
                            Wil = Wil + Wi16l;
                            Wih = Wih + Wi16h + (Wil >>> 0 < Wi16l >>> 0 ? 1 : 0);
                            Wi.high = Wih;
                            Wi.low = Wil;
                          }
                          var chh = eh & fh ^ ~eh & gh;
                          var chl = el & fl ^ ~el & gl;
                          var majh = ah & bh ^ ah & ch ^ bh & ch;
                          var majl = al & bl ^ al & cl ^ bl & cl;
                          var sigma0h = (ah >>> 28 | al << 4) ^ (ah << 30 | al >>> 2) ^ (ah << 25 | al >>> 7);
                          var sigma0l = (al >>> 28 | ah << 4) ^ (al << 30 | ah >>> 2) ^ (al << 25 | ah >>> 7);
                          var sigma1h = (eh >>> 14 | el << 18) ^ (eh >>> 18 | el << 14) ^ (eh << 23 | el >>> 9);
                          var sigma1l = (el >>> 14 | eh << 18) ^ (el >>> 18 | eh << 14) ^ (el << 23 | eh >>> 9);
                          var Ki = K[i];
                          var Kih = Ki.high;
                          var Kil = Ki.low;
                          var t1l = hl + sigma1l;
                          var t1h = hh + sigma1h + (t1l >>> 0 < hl >>> 0 ? 1 : 0);
                          var t1l = t1l + chl;
                          var t1h = t1h + chh + (t1l >>> 0 < chl >>> 0 ? 1 : 0);
                          var t1l = t1l + Kil;
                          var t1h = t1h + Kih + (t1l >>> 0 < Kil >>> 0 ? 1 : 0);
                          var t1l = t1l + Wil;
                          var t1h = t1h + Wih + (t1l >>> 0 < Wil >>> 0 ? 1 : 0);
                          var t2l = sigma0l + majl;
                          var t2h = sigma0h + majh + (t2l >>> 0 < sigma0l >>> 0 ? 1 : 0);
                          hh = gh;
                          hl = gl;
                          gh = fh;
                          gl = fl;
                          fh = eh;
                          fl = el;
                          el = dl + t1l | 0;
                          eh = dh + t1h + (el >>> 0 < dl >>> 0 ? 1 : 0) | 0;
                          dh = ch;
                          dl = cl;
                          ch = bh;
                          cl = bl;
                          bh = ah;
                          bl = al;
                          al = t1l + t2l | 0;
                          ah = t1h + t2h + (al >>> 0 < t1l >>> 0 ? 1 : 0) | 0;
                        }
                        H0l = H0.low = H0l + al;
                        H0.high = H0h + ah + (H0l >>> 0 < al >>> 0 ? 1 : 0);
                        H1l = H1.low = H1l + bl;
                        H1.high = H1h + bh + (H1l >>> 0 < bl >>> 0 ? 1 : 0);
                        H2l = H2.low = H2l + cl;
                        H2.high = H2h + ch + (H2l >>> 0 < cl >>> 0 ? 1 : 0);
                        H3l = H3.low = H3l + dl;
                        H3.high = H3h + dh + (H3l >>> 0 < dl >>> 0 ? 1 : 0);
                        H4l = H4.low = H4l + el;
                        H4.high = H4h + eh + (H4l >>> 0 < el >>> 0 ? 1 : 0);
                        H5l = H5.low = H5l + fl;
                        H5.high = H5h + fh + (H5l >>> 0 < fl >>> 0 ? 1 : 0);
                        H6l = H6.low = H6l + gl;
                        H6.high = H6h + gh + (H6l >>> 0 < gl >>> 0 ? 1 : 0);
                        H7l = H7.low = H7l + hl;
                        H7.high = H7h + hh + (H7l >>> 0 < hl >>> 0 ? 1 : 0);
                      },
                      _doFinalize: function() {
                        var data = this._data;
                        var dataWords = data.words;
                        var nBitsTotal = this._nDataBytes * 8;
                        var nBitsLeft = data.sigBytes * 8;
                        dataWords[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;
                        dataWords[(nBitsLeft + 128 >>> 10 << 5) + 30] = Math.floor(nBitsTotal / 4294967296);
                        dataWords[(nBitsLeft + 128 >>> 10 << 5) + 31] = nBitsTotal;
                        data.sigBytes = dataWords.length * 4;
                        this._process();
                        var hash = this._hash.toX32();
                        return hash;
                      },
                      clone: function() {
                        var clone = Hasher.clone.call(this);
                        clone._hash = this._hash.clone();
                        return clone;
                      },
                      blockSize: 1024 / 32
                    });
                    C.SHA512 = Hasher._createHelper(SHA512);
                    C.HmacSHA512 = Hasher._createHmacHelper(SHA512);
                  })();
                  return CryptoJS.SHA512;
                });
              }
            ),
            /***/
            1396: (
              /***/
              function(module2, exports2, __webpack_require__2) {
                ;
                (function(root, factory, undef) {
                  if (true) {
                    module2.exports = exports2 = factory(__webpack_require__2(9021), __webpack_require__2(3240), __webpack_require__2(6440), __webpack_require__2(5503), __webpack_require__2(754), __webpack_require__2(4725), __webpack_require__2(4636), __webpack_require__2(5471), __webpack_require__2(3009), __webpack_require__2(6308), __webpack_require__2(1380), __webpack_require__2(9557), __webpack_require__2(5953), __webpack_require__2(8056), __webpack_require__2(1025), __webpack_require__2(19), __webpack_require__2(9506), __webpack_require__2(7165), __webpack_require__2(2169), __webpack_require__2(6939), __webpack_require__2(6372), __webpack_require__2(3797), __webpack_require__2(8454), __webpack_require__2(2073), __webpack_require__2(4905), __webpack_require__2(482), __webpack_require__2(2155), __webpack_require__2(8124), __webpack_require__2(25), __webpack_require__2(955), __webpack_require__2(7628), __webpack_require__2(7193), __webpack_require__2(6298), __webpack_require__2(2696), __webpack_require__2(3128));
                  } else {
                  }
                })(this, function(CryptoJS) {
                  return CryptoJS;
                });
              }
            ),
            /***/
            1765: (
              /***/
              (__unused_webpack_module, exports2) => {
                "use strict";
                Object.defineProperty(exports2, "__esModule", { value: true });
                exports2.clone = clone;
                exports2.generateRandomNumber = generateRandomNumber;
                exports2.deepFreeze = deepFreeze;
                function clone(value) {
                  if (value === void 0) {
                    return void 0;
                  } else if (Number.isNaN(value)) {
                    return NaN;
                  } else if (typeof structuredClone === "function") {
                    return structuredClone(value);
                  } else {
                    return JSON.parse(JSON.stringify(value));
                  }
                }
                function generateRandomNumber() {
                  return Math.round(Math.random() * 1e7);
                }
                function deepFreeze(data) {
                  const propNames = Reflect.ownKeys(data);
                  for (const name of propNames) {
                    const value = data[name];
                    if (value && typeof value === "object" || typeof value === "function") {
                      deepFreeze(value);
                    }
                  }
                  return Object.freeze(data);
                }
              }
            ),
            /***/
            1791: (
              /***/
              (module2, __unused_webpack_exports, __webpack_require__2) => {
                var OverloadYield = __webpack_require__2(5172);
                var regeneratorDefine = __webpack_require__2(5546);
                function AsyncIterator(t, e) {
                  function n(r2, o, i, f) {
                    try {
                      var c = t[r2](o), u = c.value;
                      return u instanceof OverloadYield ? e.resolve(u.v).then(function(t2) {
                        n("next", t2, i, f);
                      }, function(t2) {
                        n("throw", t2, i, f);
                      }) : e.resolve(u).then(function(t2) {
                        c.value = t2, i(c);
                      }, function(t2) {
                        return n("throw", t2, i, f);
                      });
                    } catch (t2) {
                      f(t2);
                    }
                  }
                  var r;
                  this.next || (regeneratorDefine(AsyncIterator.prototype), regeneratorDefine(AsyncIterator.prototype, "function" == typeof Symbol && Symbol.asyncIterator || "@asyncIterator", function() {
                    return this;
                  })), regeneratorDefine(this, "_invoke", function(t2, o, i) {
                    function f() {
                      return new e(function(e2, r2) {
                        n(t2, i, e2, r2);
                      });
                    }
                    return r = r ? r.then(f, f) : f();
                  }, true);
                }
                module2.exports = AsyncIterator, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
              }
            ),
            /***/
            1803: (
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                "use strict";
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  ed: () => (
                    /* binding */
                    getAdaptivePrefferedLayers
                  ),
                  /* harmony export */
                  sg: () => (
                    /* binding */
                    debounce2
                  ),
                  /* harmony export */
                  v7: () => (
                    /* binding */
                    computeVideoEncodings
                  )
                  /* harmony export */
                });
                var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(4467);
                var _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(296);
                var _config__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__2(9027);
                function ownKeys(e, r) {
                  var t = Object.keys(e);
                  if (Object.getOwnPropertySymbols) {
                    var o = Object.getOwnPropertySymbols(e);
                    r && (o = o.filter(function(r2) {
                      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
                    })), t.push.apply(t, o);
                  }
                  return t;
                }
                function _objectSpread(e) {
                  for (var r = 1; r < arguments.length; r++) {
                    var t = null != arguments[r] ? arguments[r] : {};
                    r % 2 ? ownKeys(Object(t), true).forEach(function(r2) {
                      (0, _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__.A)(e, r2, t[r2]);
                    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r2) {
                      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
                    });
                  }
                  return e;
                }
                var videoPresets169 = {};
                var videoPresets43 = {};
                var screenPresets = {};
                for (var key in _config__WEBPACK_IMPORTED_MODULE_2__.$.videoProfiles) {
                  if (_config__WEBPACK_IMPORTED_MODULE_2__.$.videoProfiles[key].aspectRatio == "oneSixNine") {
                    videoPresets169[key] = _config__WEBPACK_IMPORTED_MODULE_2__.$.videoProfiles[key];
                    videoPresets169[key].encoding = {
                      maxBitrate: videoPresets169[key].bitRate,
                      maxFramerate: videoPresets169[key].frameRate
                    };
                  }
                  if (_config__WEBPACK_IMPORTED_MODULE_2__.$.videoProfiles[key].aspectRatio == "fourThree") {
                    videoPresets43[key] = _config__WEBPACK_IMPORTED_MODULE_2__.$.videoProfiles[key];
                    videoPresets43[key].encoding = {
                      maxBitrate: videoPresets43[key].bitRate,
                      maxFramerate: videoPresets43[key].frameRate
                    };
                  }
                }
                for (var key in _config__WEBPACK_IMPORTED_MODULE_2__.$.screenShareProfiles) {
                  screenPresets[key] = _config__WEBPACK_IMPORTED_MODULE_2__.$.screenShareProfiles[key];
                  screenPresets[key].encoding = {
                    maxBitrate: screenPresets[key].bitRate,
                    maxFramerate: screenPresets[key].frameRate
                  };
                }
                var presets1692 = Object.values(videoPresets169);
                var presets432 = Object.values(videoPresets43);
                var presetsScreenShare2 = Object.values(screenPresets);
                var simulcastPresetsMap169 = {
                  "default": [videoPresets169.h180p_w320p, videoPresets169.h360p_w640p],
                  1080: [
                    videoPresets169.h360p_w640p,
                    //3
                    videoPresets169.h540p_w960p
                    //2
                  ],
                  1440: [
                    videoPresets169.h360p_w640p,
                    //4
                    videoPresets169.h720p_w1280p
                    //2
                  ],
                  2160: [
                    videoPresets169.h540p_w960p,
                    //4
                    videoPresets169.h1080p_w1920p
                    //2
                  ]
                };
                var simulcastPresetsMap43 = {
                  "default": [videoPresets43.h180p_w240p, videoPresets43.h360p_w480p],
                  1080: [
                    videoPresets43.h360p_w480p,
                    //3
                    videoPresets43.h540p_w720p
                    //2
                  ],
                  1440: [
                    videoPresets43.h360p_w480p,
                    //4
                    videoPresets43.h720p_w960p
                    //2
                  ]
                };
                var computeDefaultScreenShareSimulcastPresets = function computeDefaultScreenShareSimulcastPresets2(fromPreset) {
                  var layers = [{
                    scaleResolutionDownBy: 2,
                    fps: 3
                  }];
                  return layers.map(function(t) {
                    var _fromPreset$encoding$;
                    return {
                      width: Math.floor(fromPreset.width / t.scaleResolutionDownBy),
                      height: Math.floor(fromPreset.height / t.scaleResolutionDownBy),
                      encodings: {
                        maxBitrate: Math.max(15e4, Math.floor(fromPreset.encoding.maxBitrate / (Math.pow(t.scaleResolutionDownBy, 2) * (((_fromPreset$encoding$ = fromPreset.encoding.maxFramerate) !== null && _fromPreset$encoding$ !== void 0 ? _fromPreset$encoding$ : 30) / t.fps)))),
                        maxFramerate: t.fps
                      }
                    };
                  });
                };
                var videoRids = ["q", "h", "f"];
                function computeVideoEncodings(isScreenShare, actualWidth, actualHeight, encoderConfig, options, isRNiOS) {
                  var videoEncoding = options && options.videoEncoding;
                  if (isScreenShare) {
                    videoEncoding = options && options.screenShareEncoding;
                  }
                  var useSimulcast = options === null || options === void 0 ? void 0 : options.simulcast;
                  if (!videoEncoding) {
                    videoEncoding = determineAppropriateEncoding(isScreenShare, actualWidth, actualHeight, encoderConfig);
                  }
                  if (!useSimulcast) {
                    return [videoEncoding];
                  }
                  var videoProfile = _config__WEBPACK_IMPORTED_MODULE_2__.$.videoProfiles[encoderConfig];
                  var width = actualWidth ? actualWidth : videoProfile === null || videoProfile === void 0 ? void 0 : videoProfile.width;
                  var height = actualHeight ? actualHeight : videoProfile === null || videoProfile === void 0 ? void 0 : videoProfile.height;
                  var original = {
                    width,
                    height,
                    encoding: {
                      maxBitrate: videoEncoding.maxBitrate,
                      maxFramerate: videoEncoding.maxFramerate
                    }
                  };
                  var presets = [];
                  if (isScreenShare) {
                    presets = defaultSimulcastLayers(isScreenShare, original);
                  } else {
                    presets = defaultSimulcastLayers(isScreenShare, original);
                  }
                  var midPreset;
                  var lowPreset = presets[0];
                  if (presets.length > 1) {
                    var _presets = presets;
                    var _presets2 = (0, _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_1__.A)(_presets, 2);
                    midPreset = _presets2[1];
                  }
                  var size = Math.max(width, height);
                  if (size >= 960 && midPreset) {
                    return encodingsFromPresets(width, height, [lowPreset, midPreset, original], isRNiOS);
                  }
                  if (size >= 480) {
                    return encodingsFromPresets(width, height, [lowPreset, original], isRNiOS);
                  }
                  return encodingsFromPresets(width, height, [original], isRNiOS);
                }
                function determineAppropriateEncoding(isScreenShare, width, height, encoderConfig) {
                  var videoProfile = _config__WEBPACK_IMPORTED_MODULE_2__.$.videoProfiles[encoderConfig];
                  var presets = presetsForResolution(isScreenShare, width ? width : videoProfile === null || videoProfile === void 0 ? void 0 : videoProfile.width, height ? height : videoProfile === null || videoProfile === void 0 ? void 0 : videoProfile.height, encoderConfig);
                  var encoding = presets[0].encoding;
                  var size = Math.max(width, height);
                  for (var i = 0; i < presets.length; i += 1) {
                    var preset = presets[i];
                    encoding = preset.encoding;
                    if (videoProfile) {
                      if (preset.width == videoProfile.width && preset.height == videoProfile.height && preset.encoding.maxBitrate == videoProfile.encoding.maxBitrate) {
                        break;
                      }
                    } else {
                      if (preset.width >= size) {
                        break;
                      }
                    }
                  }
                  return encoding;
                }
                function presetsForResolution(isScreenShare, width, height) {
                  if (isScreenShare) {
                    return presetsScreenShare2;
                  }
                  var aspect = width > height ? width / height : height / width;
                  if (Math.abs(aspect - 16 / 9) < Math.abs(aspect - 4 / 3)) {
                    return presets1692;
                  }
                  return presets432;
                }
                function getSimulcastPresets(height, aspectRatio) {
                  if (aspectRatio === 169) {
                    if (height >= 2160) return simulcastPresetsMap169["2160"];
                    if (height >= 1440) return simulcastPresetsMap169["1440"];
                    if (height >= 1080) return simulcastPresetsMap169["1080"];
                    return simulcastPresetsMap169["default"];
                  } else {
                    if (height >= 1440) return simulcastPresetsMap43["1440"];
                    if (height >= 1080) return simulcastPresetsMap43["1080"];
                    return simulcastPresetsMap43["default"];
                  }
                }
                function defaultSimulcastLayers(isScreenShare, original) {
                  if (isScreenShare) {
                    var defaultScreen = computeDefaultScreenShareSimulcastPresets(original);
                  }
                  var width = original.width, height = original.height;
                  var aspect = width > height ? width / height : height / width;
                  if (Math.abs(aspect - 16 / 9) < Math.abs(aspect - 4 / 3)) {
                    return getSimulcastPresets(height, 169);
                  }
                  return getSimulcastPresets(height, 43);
                }
                function encodingsFromPresets(width, height, presets, isRNiOS) {
                  var encodings = [];
                  presets.forEach(function(preset, idx) {
                    if (idx >= videoRids.length) {
                      return;
                    }
                    var maxFramerate = isRNiOS ? null : {
                      maxFramerate: preset.encoding.maxFramerate
                    };
                    var size = Math.min(width, height);
                    var rid = videoRids[idx];
                    var encoding = _objectSpread({
                      rid,
                      scaleResolutionDownBy: size / Math.min(preset.width, preset.height),
                      maxBitrate: preset.encoding.maxBitrate
                    }, maxFramerate);
                    encodings.push(encoding);
                  });
                  return encodings;
                }
                function sortPresets(presets) {
                  if (!presets) return;
                  return presets.sort(function(a, b) {
                    var aEnc = a.encoding;
                    var bEnc = b.encoding;
                    if (aEnc.maxBitrate > bEnc.maxBitrate) {
                      return 1;
                    }
                    if (aEnc.maxBitrate < bEnc.maxBitrate) return -1;
                    if (aEnc.maxBitrate === bEnc.maxBitrate && aEnc.maxFramerate && bEnc.maxFramerate) {
                      return aEnc.maxFramerate > bEnc.maxFramerate ? 1 : -1;
                    }
                    return 0;
                  });
                }
                function getResolutionScalings(encodings) {
                  var resolutionScalings = [];
                  if (!encodings || encodings.length == 0) return;
                  if (encodings.length === 1) {
                    var spatialLayers = 3;
                    for (var i = 0; i < spatialLayers; i++) {
                      resolutionScalings.push(Math.pow(2, spatialLayers - i - 1));
                    }
                    return resolutionScalings;
                  }
                  var scaleResolutionDownByDefined = false;
                  encodings.forEach(function(encoding) {
                    if (encoding.scaleResolutionDownBy !== void 0) {
                      scaleResolutionDownByDefined = true;
                      resolutionScalings.push(Math.max(1, encoding.scaleResolutionDownBy));
                    } else {
                      resolutionScalings.push(1);
                    }
                  });
                  if (!scaleResolutionDownByDefined) {
                    encodings.forEach(function(encoding, index) {
                      resolutionScalings[index] = Math.pow(2, encodings.length - index - 1);
                    });
                  }
                  return resolutionScalings;
                }
                function getAdaptivePrefferedLayers(consumer, viewportWidth, viewportHeight) {
                  if (!consumer) {
                    return {};
                  }
                  var id = consumer.id;
                  var _consumer$appData = consumer.appData, width = _consumer$appData.width, height = _consumer$appData.height, encodings = _consumer$appData.encodings;
                  try {
                    var resolutionScalings = getResolutionScalings(encodings);
                    if (!resolutionScalings) {
                      return {};
                    }
                    var resolutions = resolutionScalings.map(function(scaling) {
                      return {
                        width: width / scaling,
                        height: height / scaling
                      };
                    });
                    var sortedResolutions = resolutions.sort(function(a, b) {
                      return a.width - b.width;
                    });
                    var newPreferredSpatialLayer = sortedResolutions.findIndex(function(res) {
                      return res.width >= viewportWidth && res.height >= viewportHeight;
                    });
                    if (newPreferredSpatialLayer === -1) {
                      newPreferredSpatialLayer = sortedResolutions.length - 1;
                    }
                    var newPreferredTemporalLayer = consumer.temporalLayers ? consumer.temporalLayers : 2;
                    if (newPreferredSpatialLayer === 0 && newPreferredTemporalLayer > 0) {
                      var lowestLevelWidth = width / resolutionScalings[0];
                      var lowestLevelHeight = height / resolutionScalings[0];
                      if (viewportWidth < lowestLevelWidth * 0.5 && viewportHeight < lowestLevelHeight * 0.5) {
                        newPreferredTemporalLayer -= 1;
                      }
                      if (newPreferredTemporalLayer > 0 && viewportWidth < lowestLevelWidth * 0.25 && viewportHeight < lowestLevelHeight * 0.25) {
                        newPreferredTemporalLayer -= 1;
                      }
                    }
                    return {
                      consumerId: id,
                      newPreferredSpatialLayer: Math.max(0, newPreferredSpatialLayer),
                      newPreferredTemporalLayer: Math.max(0, newPreferredTemporalLayer)
                    };
                  } catch (error) {
                    return {};
                  }
                }
                function debounce2(func, delay) {
                  var timeout;
                  return function() {
                    var _this = this;
                    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                      args[_key] = arguments[_key];
                    }
                    clearTimeout(timeout);
                    timeout = setTimeout(function() {
                      return func.apply(_this, args);
                    }, delay);
                  };
                }
                function isVideoInView(rect) {
                  var windowHeight = window.innerHeight || document.documentElement.clientHeight;
                  var windowWidth = window.innerWidth || document.documentElement.clientWidth;
                  var verticallyInView = rect.top < windowHeight && rect.bottom > 0;
                  var horizontallyInView = rect.left < windowWidth && rect.right > 0;
                  return verticallyInView && horizontallyInView;
                }
              }
            ),
            /***/
            1806: (
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                "use strict";
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  $Q: () => (
                    /* binding */
                    E2EE_FLAG
                  ),
                  /* harmony export */
                  T4: () => (
                    /* binding */
                    KEY_PROVIDER_DEFAULTS
                  ),
                  /* harmony export */
                  Ts: () => (
                    /* binding */
                    SUPPORTED_AUDIO_MIME_TYPES
                  ),
                  /* harmony export */
                  ue: () => (
                    /* binding */
                    SUPPORTED_VIDEO_MIME_TYPES
                  )
                  /* harmony export */
                });
                var ENCRYPTION_ALGORITHM2 = "AES-GCM";
                var DECRYPTION_FAILURE_TOLERANCE = 10;
                var UNENCRYPTED_BYTES = {
                  key: 10,
                  delta: 3,
                  audio: 1,
                  // frame.type is not set on audio, so this is set manually
                  empty: 0
                };
                var IV_LENGTH = 12;
                var E2EE_FLAG = "vk_e2ee";
                var SALT = "VideoSDKEncryptionRatchetSalt";
                var KEY_PROVIDER_DEFAULTS = {
                  sharedKey: false,
                  ratchetSalt: SALT,
                  ratchetWindowSize: 0,
                  failureTolerance: DECRYPTION_FAILURE_TOLERANCE,
                  keyringSize: 16,
                  discardFrameWhenCryptorNotReady: false
                };
                var MAX_SIF_COUNT = 100;
                var MAX_SIF_DURATION = 2e3;
                var SUPPORTED_VIDEO_MIME_TYPES = ["vp8", "vp9", "h264", "av1"];
                var SUPPORTED_AUDIO_MIME_TYPES = ["opus"];
              }
            ),
            /***/
            1919: (
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                "use strict";
                __webpack_require__2.r(__webpack_exports__2);
                __webpack_require__2.d(__webpack_exports__2, {
                  "default": () => (
                    /* binding */
                    RoomClient
                  )
                });
                var socket_io_parser_build_esm_namespaceObject = {};
                __webpack_require__2.r(socket_io_parser_build_esm_namespaceObject);
                __webpack_require__2.d(socket_io_parser_build_esm_namespaceObject, {
                  Decoder: () => Decoder,
                  Encoder: () => Encoder,
                  PacketType: () => PacketType,
                  protocol: () => build_esm_protocol
                });
                var slicedToArray = __webpack_require__2(296);
                var toConsumableArray = __webpack_require__2(5458);
                var esm_typeof = __webpack_require__2(2284);
                var asyncToGenerator = __webpack_require__2(467);
                var classCallCheck = __webpack_require__2(3029);
                var createClass = __webpack_require__2(2901);
                var defineProperty = __webpack_require__2(4467);
                var regenerator = __webpack_require__2(4756);
                var regenerator_default = __webpack_require__2.n(regenerator);
                ;
                const PACKET_TYPES = /* @__PURE__ */ Object.create(null);
                PACKET_TYPES["open"] = "0";
                PACKET_TYPES["close"] = "1";
                PACKET_TYPES["ping"] = "2";
                PACKET_TYPES["pong"] = "3";
                PACKET_TYPES["message"] = "4";
                PACKET_TYPES["upgrade"] = "5";
                PACKET_TYPES["noop"] = "6";
                const PACKET_TYPES_REVERSE = /* @__PURE__ */ Object.create(null);
                Object.keys(PACKET_TYPES).forEach((key) => {
                  PACKET_TYPES_REVERSE[PACKET_TYPES[key]] = key;
                });
                const ERROR_PACKET = { type: "error", data: "parser error" };
                ;
                const withNativeBlob = typeof Blob === "function" || typeof Blob !== "undefined" && Object.prototype.toString.call(Blob) === "[object BlobConstructor]";
                const withNativeArrayBuffer = typeof ArrayBuffer === "function";
                const isView = (obj) => {
                  return typeof ArrayBuffer.isView === "function" ? ArrayBuffer.isView(obj) : obj && obj.buffer instanceof ArrayBuffer;
                };
                const encodePacket = ({ type, data }, supportsBinary, callback) => {
                  if (withNativeBlob && data instanceof Blob) {
                    if (supportsBinary) {
                      return callback(data);
                    } else {
                      return encodeBlobAsBase64(data, callback);
                    }
                  } else if (withNativeArrayBuffer && (data instanceof ArrayBuffer || isView(data))) {
                    if (supportsBinary) {
                      return callback(data);
                    } else {
                      return encodeBlobAsBase64(new Blob([data]), callback);
                    }
                  }
                  return callback(PACKET_TYPES[type] + (data || ""));
                };
                const encodeBlobAsBase64 = (data, callback) => {
                  const fileReader = new FileReader();
                  fileReader.onload = function() {
                    const content = fileReader.result.split(",")[1];
                    callback("b" + (content || ""));
                  };
                  return fileReader.readAsDataURL(data);
                };
                function toArray(data) {
                  if (data instanceof Uint8Array) {
                    return data;
                  } else if (data instanceof ArrayBuffer) {
                    return new Uint8Array(data);
                  } else {
                    return new Uint8Array(data.buffer, data.byteOffset, data.byteLength);
                  }
                }
                let TEXT_ENCODER;
                function encodePacketToBinary(packet, callback) {
                  if (withNativeBlob && packet.data instanceof Blob) {
                    return packet.data.arrayBuffer().then(toArray).then(callback);
                  } else if (withNativeArrayBuffer && (packet.data instanceof ArrayBuffer || isView(packet.data))) {
                    return callback(toArray(packet.data));
                  }
                  encodePacket(packet, false, (encoded) => {
                    if (!TEXT_ENCODER) {
                      TEXT_ENCODER = new TextEncoder();
                    }
                    callback(TEXT_ENCODER.encode(encoded));
                  });
                }
                ;
                const chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
                const lookup = typeof Uint8Array === "undefined" ? [] : new Uint8Array(256);
                for (let i = 0; i < chars.length; i++) {
                  lookup[chars.charCodeAt(i)] = i;
                }
                const encode = (arraybuffer) => {
                  let bytes = new Uint8Array(arraybuffer), i, len = bytes.length, base64 = "";
                  for (i = 0; i < len; i += 3) {
                    base64 += chars[bytes[i] >> 2];
                    base64 += chars[(bytes[i] & 3) << 4 | bytes[i + 1] >> 4];
                    base64 += chars[(bytes[i + 1] & 15) << 2 | bytes[i + 2] >> 6];
                    base64 += chars[bytes[i + 2] & 63];
                  }
                  if (len % 3 === 2) {
                    base64 = base64.substring(0, base64.length - 1) + "=";
                  } else if (len % 3 === 1) {
                    base64 = base64.substring(0, base64.length - 2) + "==";
                  }
                  return base64;
                };
                const decode = (base64) => {
                  let bufferLength = base64.length * 0.75, len = base64.length, i, p = 0, encoded1, encoded2, encoded3, encoded4;
                  if (base64[base64.length - 1] === "=") {
                    bufferLength--;
                    if (base64[base64.length - 2] === "=") {
                      bufferLength--;
                    }
                  }
                  const arraybuffer = new ArrayBuffer(bufferLength), bytes = new Uint8Array(arraybuffer);
                  for (i = 0; i < len; i += 4) {
                    encoded1 = lookup[base64.charCodeAt(i)];
                    encoded2 = lookup[base64.charCodeAt(i + 1)];
                    encoded3 = lookup[base64.charCodeAt(i + 2)];
                    encoded4 = lookup[base64.charCodeAt(i + 3)];
                    bytes[p++] = encoded1 << 2 | encoded2 >> 4;
                    bytes[p++] = (encoded2 & 15) << 4 | encoded3 >> 2;
                    bytes[p++] = (encoded3 & 3) << 6 | encoded4 & 63;
                  }
                  return arraybuffer;
                };
                ;
                const decodePacket_browser_withNativeArrayBuffer = typeof ArrayBuffer === "function";
                const decodePacket = (encodedPacket, binaryType) => {
                  if (typeof encodedPacket !== "string") {
                    return {
                      type: "message",
                      data: mapBinary(encodedPacket, binaryType)
                    };
                  }
                  const type = encodedPacket.charAt(0);
                  if (type === "b") {
                    return {
                      type: "message",
                      data: decodeBase64Packet(encodedPacket.substring(1), binaryType)
                    };
                  }
                  const packetType = PACKET_TYPES_REVERSE[type];
                  if (!packetType) {
                    return ERROR_PACKET;
                  }
                  return encodedPacket.length > 1 ? {
                    type: PACKET_TYPES_REVERSE[type],
                    data: encodedPacket.substring(1)
                  } : {
                    type: PACKET_TYPES_REVERSE[type]
                  };
                };
                const decodeBase64Packet = (data, binaryType) => {
                  if (decodePacket_browser_withNativeArrayBuffer) {
                    const decoded = decode(data);
                    return mapBinary(decoded, binaryType);
                  } else {
                    return { base64: true, data };
                  }
                };
                const mapBinary = (data, binaryType) => {
                  switch (binaryType) {
                    case "blob":
                      if (data instanceof Blob) {
                        return data;
                      } else {
                        return new Blob([data]);
                      }
                    case "arraybuffer":
                    default:
                      if (data instanceof ArrayBuffer) {
                        return data;
                      } else {
                        return data.buffer;
                      }
                  }
                };
                ;
                const SEPARATOR = String.fromCharCode(30);
                const encodePayload = (packets, callback) => {
                  const length = packets.length;
                  const encodedPackets = new Array(length);
                  let count = 0;
                  packets.forEach((packet, i) => {
                    encodePacket(packet, false, (encodedPacket) => {
                      encodedPackets[i] = encodedPacket;
                      if (++count === length) {
                        callback(encodedPackets.join(SEPARATOR));
                      }
                    });
                  });
                };
                const decodePayload = (encodedPayload, binaryType) => {
                  const encodedPackets = encodedPayload.split(SEPARATOR);
                  const packets = [];
                  for (let i = 0; i < encodedPackets.length; i++) {
                    const decodedPacket = decodePacket(encodedPackets[i], binaryType);
                    packets.push(decodedPacket);
                    if (decodedPacket.type === "error") {
                      break;
                    }
                  }
                  return packets;
                };
                function createPacketEncoderStream() {
                  return new TransformStream({
                    transform(packet, controller) {
                      encodePacketToBinary(packet, (encodedPacket) => {
                        const payloadLength = encodedPacket.length;
                        let header;
                        if (payloadLength < 126) {
                          header = new Uint8Array(1);
                          new DataView(header.buffer).setUint8(0, payloadLength);
                        } else if (payloadLength < 65536) {
                          header = new Uint8Array(3);
                          const view = new DataView(header.buffer);
                          view.setUint8(0, 126);
                          view.setUint16(1, payloadLength);
                        } else {
                          header = new Uint8Array(9);
                          const view = new DataView(header.buffer);
                          view.setUint8(0, 127);
                          view.setBigUint64(1, BigInt(payloadLength));
                        }
                        if (packet.data && typeof packet.data !== "string") {
                          header[0] |= 128;
                        }
                        controller.enqueue(header);
                        controller.enqueue(encodedPacket);
                      });
                    }
                  });
                }
                let TEXT_DECODER;
                function totalLength(chunks) {
                  return chunks.reduce((acc, chunk) => acc + chunk.length, 0);
                }
                function concatChunks(chunks, size) {
                  if (chunks[0].length === size) {
                    return chunks.shift();
                  }
                  const buffer = new Uint8Array(size);
                  let j = 0;
                  for (let i = 0; i < size; i++) {
                    buffer[i] = chunks[0][j++];
                    if (j === chunks[0].length) {
                      chunks.shift();
                      j = 0;
                    }
                  }
                  if (chunks.length && j < chunks[0].length) {
                    chunks[0] = chunks[0].slice(j);
                  }
                  return buffer;
                }
                function createPacketDecoderStream(maxPayload, binaryType) {
                  if (!TEXT_DECODER) {
                    TEXT_DECODER = new TextDecoder();
                  }
                  const chunks = [];
                  let state2 = 0;
                  let expectedLength = -1;
                  let isBinary2 = false;
                  return new TransformStream({
                    transform(chunk, controller) {
                      chunks.push(chunk);
                      while (true) {
                        if (state2 === 0) {
                          if (totalLength(chunks) < 1) {
                            break;
                          }
                          const header = concatChunks(chunks, 1);
                          isBinary2 = (header[0] & 128) === 128;
                          expectedLength = header[0] & 127;
                          if (expectedLength < 126) {
                            state2 = 3;
                          } else if (expectedLength === 126) {
                            state2 = 1;
                          } else {
                            state2 = 2;
                          }
                        } else if (state2 === 1) {
                          if (totalLength(chunks) < 2) {
                            break;
                          }
                          const headerArray = concatChunks(chunks, 2);
                          expectedLength = new DataView(headerArray.buffer, headerArray.byteOffset, headerArray.length).getUint16(0);
                          state2 = 3;
                        } else if (state2 === 2) {
                          if (totalLength(chunks) < 8) {
                            break;
                          }
                          const headerArray = concatChunks(chunks, 8);
                          const view = new DataView(headerArray.buffer, headerArray.byteOffset, headerArray.length);
                          const n = view.getUint32(0);
                          if (n > Math.pow(2, 53 - 32) - 1) {
                            controller.enqueue(ERROR_PACKET);
                            break;
                          }
                          expectedLength = n * Math.pow(2, 32) + view.getUint32(4);
                          state2 = 3;
                        } else {
                          if (totalLength(chunks) < expectedLength) {
                            break;
                          }
                          const data = concatChunks(chunks, expectedLength);
                          controller.enqueue(decodePacket(isBinary2 ? data : TEXT_DECODER.decode(data), binaryType));
                          state2 = 0;
                        }
                        if (expectedLength === 0 || expectedLength > maxPayload) {
                          controller.enqueue(ERROR_PACKET);
                          break;
                        }
                      }
                    }
                  });
                }
                const protocol = 4;
                ;
                function Emitter(obj) {
                  if (obj) return mixin(obj);
                }
                function mixin(obj) {
                  for (var key in Emitter.prototype) {
                    obj[key] = Emitter.prototype[key];
                  }
                  return obj;
                }
                Emitter.prototype.on = Emitter.prototype.addEventListener = function(event, fn) {
                  this._callbacks = this._callbacks || {};
                  (this._callbacks["$" + event] = this._callbacks["$" + event] || []).push(fn);
                  return this;
                };
                Emitter.prototype.once = function(event, fn) {
                  function on2() {
                    this.off(event, on2);
                    fn.apply(this, arguments);
                  }
                  on2.fn = fn;
                  this.on(event, on2);
                  return this;
                };
                Emitter.prototype.off = Emitter.prototype.removeListener = Emitter.prototype.removeAllListeners = Emitter.prototype.removeEventListener = function(event, fn) {
                  this._callbacks = this._callbacks || {};
                  if (0 == arguments.length) {
                    this._callbacks = {};
                    return this;
                  }
                  var callbacks = this._callbacks["$" + event];
                  if (!callbacks) return this;
                  if (1 == arguments.length) {
                    delete this._callbacks["$" + event];
                    return this;
                  }
                  var cb;
                  for (var i = 0; i < callbacks.length; i++) {
                    cb = callbacks[i];
                    if (cb === fn || cb.fn === fn) {
                      callbacks.splice(i, 1);
                      break;
                    }
                  }
                  if (callbacks.length === 0) {
                    delete this._callbacks["$" + event];
                  }
                  return this;
                };
                Emitter.prototype.emit = function(event) {
                  this._callbacks = this._callbacks || {};
                  var args = new Array(arguments.length - 1), callbacks = this._callbacks["$" + event];
                  for (var i = 1; i < arguments.length; i++) {
                    args[i - 1] = arguments[i];
                  }
                  if (callbacks) {
                    callbacks = callbacks.slice(0);
                    for (var i = 0, len = callbacks.length; i < len; ++i) {
                      callbacks[i].apply(this, args);
                    }
                  }
                  return this;
                };
                Emitter.prototype.emitReserved = Emitter.prototype.emit;
                Emitter.prototype.listeners = function(event) {
                  this._callbacks = this._callbacks || {};
                  return this._callbacks["$" + event] || [];
                };
                Emitter.prototype.hasListeners = function(event) {
                  return !!this.listeners(event).length;
                };
                ;
                const nextTick = (() => {
                  const isPromiseAvailable = typeof Promise === "function" && typeof Promise.resolve === "function";
                  if (isPromiseAvailable) {
                    return (cb) => Promise.resolve().then(cb);
                  } else {
                    return (cb, setTimeoutFn) => setTimeoutFn(cb, 0);
                  }
                })();
                const globalThisShim = (() => {
                  if (typeof self !== "undefined") {
                    return self;
                  } else if (typeof window !== "undefined") {
                    return window;
                  } else {
                    return Function("return this")();
                  }
                })();
                const defaultBinaryType = "arraybuffer";
                function createCookieJar() {
                }
                ;
                function pick(obj, ...attr) {
                  return attr.reduce((acc, k) => {
                    if (obj.hasOwnProperty(k)) {
                      acc[k] = obj[k];
                    }
                    return acc;
                  }, {});
                }
                const NATIVE_SET_TIMEOUT = globalThisShim.setTimeout;
                const NATIVE_CLEAR_TIMEOUT = globalThisShim.clearTimeout;
                function installTimerFunctions(obj, opts) {
                  if (opts.useNativeTimers) {
                    obj.setTimeoutFn = NATIVE_SET_TIMEOUT.bind(globalThisShim);
                    obj.clearTimeoutFn = NATIVE_CLEAR_TIMEOUT.bind(globalThisShim);
                  } else {
                    obj.setTimeoutFn = globalThisShim.setTimeout.bind(globalThisShim);
                    obj.clearTimeoutFn = globalThisShim.clearTimeout.bind(globalThisShim);
                  }
                }
                const BASE64_OVERHEAD = 1.33;
                function byteLength(obj) {
                  if (typeof obj === "string") {
                    return utf8Length(obj);
                  }
                  return Math.ceil((obj.byteLength || obj.size) * BASE64_OVERHEAD);
                }
                function utf8Length(str) {
                  let c = 0, length = 0;
                  for (let i = 0, l = str.length; i < l; i++) {
                    c = str.charCodeAt(i);
                    if (c < 128) {
                      length += 1;
                    } else if (c < 2048) {
                      length += 2;
                    } else if (c < 55296 || c >= 57344) {
                      length += 3;
                    } else {
                      i++;
                      length += 4;
                    }
                  }
                  return length;
                }
                function randomString() {
                  return Date.now().toString(36).substring(3) + Math.random().toString(36).substring(2, 5);
                }
                ;
                function parseqs_encode(obj) {
                  let str = "";
                  for (let i in obj) {
                    if (obj.hasOwnProperty(i)) {
                      if (str.length)
                        str += "&";
                      str += encodeURIComponent(i) + "=" + encodeURIComponent(obj[i]);
                    }
                  }
                  return str;
                }
                function parseqs_decode(qs) {
                  let qry = {};
                  let pairs = qs.split("&");
                  for (let i = 0, l = pairs.length; i < l; i++) {
                    let pair = pairs[i].split("=");
                    qry[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1]);
                  }
                  return qry;
                }
                ;
                class TransportError extends Error {
                  constructor(reason, description, context) {
                    super(reason);
                    this.description = description;
                    this.context = context;
                    this.type = "TransportError";
                  }
                }
                class Transport extends Emitter {
                  /**
                   * Transport abstract constructor.
                   *
                   * @param {Object} opts - options
                   * @protected
                   */
                  constructor(opts) {
                    super();
                    this.writable = false;
                    installTimerFunctions(this, opts);
                    this.opts = opts;
                    this.query = opts.query;
                    this.socket = opts.socket;
                    this.supportsBinary = !opts.forceBase64;
                  }
                  /**
                   * Emits an error.
                   *
                   * @param {String} reason
                   * @param description
                   * @param context - the error context
                   * @return {Transport} for chaining
                   * @protected
                   */
                  onError(reason, description, context) {
                    super.emitReserved("error", new TransportError(reason, description, context));
                    return this;
                  }
                  /**
                   * Opens the transport.
                   */
                  open() {
                    this.readyState = "opening";
                    this.doOpen();
                    return this;
                  }
                  /**
                   * Closes the transport.
                   */
                  close() {
                    if (this.readyState === "opening" || this.readyState === "open") {
                      this.doClose();
                      this.onClose();
                    }
                    return this;
                  }
                  /**
                   * Sends multiple packets.
                   *
                   * @param {Array} packets
                   */
                  send(packets) {
                    if (this.readyState === "open") {
                      this.write(packets);
                    } else {
                    }
                  }
                  /**
                   * Called upon open
                   *
                   * @protected
                   */
                  onOpen() {
                    this.readyState = "open";
                    this.writable = true;
                    super.emitReserved("open");
                  }
                  /**
                   * Called with data.
                   *
                   * @param {String} data
                   * @protected
                   */
                  onData(data) {
                    const packet = decodePacket(data, this.socket.binaryType);
                    this.onPacket(packet);
                  }
                  /**
                   * Called with a decoded packet.
                   *
                   * @protected
                   */
                  onPacket(packet) {
                    super.emitReserved("packet", packet);
                  }
                  /**
                   * Called upon close.
                   *
                   * @protected
                   */
                  onClose(details) {
                    this.readyState = "closed";
                    super.emitReserved("close", details);
                  }
                  /**
                   * Pauses the transport, in order not to lose packets during an upgrade.
                   *
                   * @param onPause
                   */
                  pause(onPause) {
                  }
                  createUri(schema, query = {}) {
                    return schema + "://" + this._hostname() + this._port() + this.opts.path + this._query(query);
                  }
                  _hostname() {
                    const hostname = this.opts.hostname;
                    return hostname.indexOf(":") === -1 ? hostname : "[" + hostname + "]";
                  }
                  _port() {
                    if (this.opts.port && (this.opts.secure && Number(this.opts.port !== 443) || !this.opts.secure && Number(this.opts.port) !== 80)) {
                      return ":" + this.opts.port;
                    } else {
                      return "";
                    }
                  }
                  _query(query) {
                    const encodedQuery = parseqs_encode(query);
                    return encodedQuery.length ? "?" + encodedQuery : "";
                  }
                }
                ;
                class polling_Polling extends Transport {
                  constructor() {
                    super(...arguments);
                    this._polling = false;
                  }
                  get name() {
                    return "polling";
                  }
                  /**
                   * Opens the socket (triggers polling). We write a PING message to determine
                   * when the transport is open.
                   *
                   * @protected
                   */
                  doOpen() {
                    this._poll();
                  }
                  /**
                   * Pauses polling.
                   *
                   * @param {Function} onPause - callback upon buffers are flushed and transport is paused
                   * @package
                   */
                  pause(onPause) {
                    this.readyState = "pausing";
                    const pause = () => {
                      this.readyState = "paused";
                      onPause();
                    };
                    if (this._polling || !this.writable) {
                      let total = 0;
                      if (this._polling) {
                        total++;
                        this.once("pollComplete", function() {
                          --total || pause();
                        });
                      }
                      if (!this.writable) {
                        total++;
                        this.once("drain", function() {
                          --total || pause();
                        });
                      }
                    } else {
                      pause();
                    }
                  }
                  /**
                   * Starts polling cycle.
                   *
                   * @private
                   */
                  _poll() {
                    this._polling = true;
                    this.doPoll();
                    this.emitReserved("poll");
                  }
                  /**
                   * Overloads onData to detect payloads.
                   *
                   * @protected
                   */
                  onData(data) {
                    const callback = (packet) => {
                      if ("opening" === this.readyState && packet.type === "open") {
                        this.onOpen();
                      }
                      if ("close" === packet.type) {
                        this.onClose({ description: "transport closed by the server" });
                        return false;
                      }
                      this.onPacket(packet);
                    };
                    decodePayload(data, this.socket.binaryType).forEach(callback);
                    if ("closed" !== this.readyState) {
                      this._polling = false;
                      this.emitReserved("pollComplete");
                      if ("open" === this.readyState) {
                        this._poll();
                      } else {
                      }
                    }
                  }
                  /**
                   * For polling, send a close packet.
                   *
                   * @protected
                   */
                  doClose() {
                    const close = () => {
                      this.write([{ type: "close" }]);
                    };
                    if ("open" === this.readyState) {
                      close();
                    } else {
                      this.once("open", close);
                    }
                  }
                  /**
                   * Writes a packets payload.
                   *
                   * @param {Array} packets - data packets
                   * @protected
                   */
                  write(packets) {
                    this.writable = false;
                    encodePayload(packets, (data) => {
                      this.doWrite(data, () => {
                        this.writable = true;
                        this.emitReserved("drain");
                      });
                    });
                  }
                  /**
                   * Generates uri for connection.
                   *
                   * @private
                   */
                  uri() {
                    const schema = this.opts.secure ? "https" : "http";
                    const query = this.query || {};
                    if (false !== this.opts.timestampRequests) {
                      query[this.opts.timestampParam] = randomString();
                    }
                    if (!this.supportsBinary && !query.sid) {
                      query.b64 = 1;
                    }
                    return this.createUri(schema, query);
                  }
                }
                ;
                let value = false;
                try {
                  value = typeof XMLHttpRequest !== "undefined" && "withCredentials" in new XMLHttpRequest();
                } catch (err) {
                }
                const hasCORS = value;
                ;
                function empty() {
                }
                class BaseXHR extends polling_Polling {
                  /**
                   * XHR Polling constructor.
                   *
                   * @param {Object} opts
                   * @package
                   */
                  constructor(opts) {
                    super(opts);
                    if (typeof location !== "undefined") {
                      const isSSL = "https:" === location.protocol;
                      let port = location.port;
                      if (!port) {
                        port = isSSL ? "443" : "80";
                      }
                      this.xd = typeof location !== "undefined" && opts.hostname !== location.hostname || port !== opts.port;
                    }
                  }
                  /**
                   * Sends data.
                   *
                   * @param {String} data to send.
                   * @param {Function} called upon flush.
                   * @private
                   */
                  doWrite(data, fn) {
                    const req = this.request({
                      method: "POST",
                      data
                    });
                    req.on("success", fn);
                    req.on("error", (xhrStatus, context) => {
                      this.onError("xhr post error", xhrStatus, context);
                    });
                  }
                  /**
                   * Starts a poll cycle.
                   *
                   * @private
                   */
                  doPoll() {
                    const req = this.request();
                    req.on("data", this.onData.bind(this));
                    req.on("error", (xhrStatus, context) => {
                      this.onError("xhr poll error", xhrStatus, context);
                    });
                    this.pollXhr = req;
                  }
                }
                class Request extends Emitter {
                  /**
                   * Request constructor
                   *
                   * @param {Object} options
                   * @package
                   */
                  constructor(createRequest, uri, opts) {
                    super();
                    this.createRequest = createRequest;
                    installTimerFunctions(this, opts);
                    this._opts = opts;
                    this._method = opts.method || "GET";
                    this._uri = uri;
                    this._data = void 0 !== opts.data ? opts.data : null;
                    this._create();
                  }
                  /**
                   * Creates the XHR object and sends the request.
                   *
                   * @private
                   */
                  _create() {
                    var _a;
                    const opts = pick(this._opts, "agent", "pfx", "key", "passphrase", "cert", "ca", "ciphers", "rejectUnauthorized", "autoUnref");
                    opts.xdomain = !!this._opts.xd;
                    const xhr = this._xhr = this.createRequest(opts);
                    try {
                      xhr.open(this._method, this._uri, true);
                      try {
                        if (this._opts.extraHeaders) {
                          xhr.setDisableHeaderCheck && xhr.setDisableHeaderCheck(true);
                          for (let i in this._opts.extraHeaders) {
                            if (this._opts.extraHeaders.hasOwnProperty(i)) {
                              xhr.setRequestHeader(i, this._opts.extraHeaders[i]);
                            }
                          }
                        }
                      } catch (e) {
                      }
                      if ("POST" === this._method) {
                        try {
                          xhr.setRequestHeader("Content-type", "text/plain;charset=UTF-8");
                        } catch (e) {
                        }
                      }
                      try {
                        xhr.setRequestHeader("Accept", "*/*");
                      } catch (e) {
                      }
                      (_a = this._opts.cookieJar) === null || _a === void 0 ? void 0 : _a.addCookies(xhr);
                      if ("withCredentials" in xhr) {
                        xhr.withCredentials = this._opts.withCredentials;
                      }
                      if (this._opts.requestTimeout) {
                        xhr.timeout = this._opts.requestTimeout;
                      }
                      xhr.onreadystatechange = () => {
                        var _a2;
                        if (xhr.readyState === 3) {
                          (_a2 = this._opts.cookieJar) === null || _a2 === void 0 ? void 0 : _a2.parseCookies(
                            // @ts-ignore
                            xhr.getResponseHeader("set-cookie")
                          );
                        }
                        if (4 !== xhr.readyState)
                          return;
                        if (200 === xhr.status || 1223 === xhr.status) {
                          this._onLoad();
                        } else {
                          this.setTimeoutFn(() => {
                            this._onError(typeof xhr.status === "number" ? xhr.status : 0);
                          }, 0);
                        }
                      };
                      xhr.send(this._data);
                    } catch (e) {
                      this.setTimeoutFn(() => {
                        this._onError(e);
                      }, 0);
                      return;
                    }
                    if (typeof document !== "undefined") {
                      this._index = Request.requestsCount++;
                      Request.requests[this._index] = this;
                    }
                  }
                  /**
                   * Called upon error.
                   *
                   * @private
                   */
                  _onError(err) {
                    this.emitReserved("error", err, this._xhr);
                    this._cleanup(true);
                  }
                  /**
                   * Cleans up house.
                   *
                   * @private
                   */
                  _cleanup(fromError) {
                    if ("undefined" === typeof this._xhr || null === this._xhr) {
                      return;
                    }
                    this._xhr.onreadystatechange = empty;
                    if (fromError) {
                      try {
                        this._xhr.abort();
                      } catch (e) {
                      }
                    }
                    if (typeof document !== "undefined") {
                      delete Request.requests[this._index];
                    }
                    this._xhr = null;
                  }
                  /**
                   * Called upon load.
                   *
                   * @private
                   */
                  _onLoad() {
                    const data = this._xhr.responseText;
                    if (data !== null) {
                      this.emitReserved("data", data);
                      this.emitReserved("success");
                      this._cleanup();
                    }
                  }
                  /**
                   * Aborts the request.
                   *
                   * @package
                   */
                  abort() {
                    this._cleanup();
                  }
                }
                Request.requestsCount = 0;
                Request.requests = {};
                if (typeof document !== "undefined") {
                  if (typeof attachEvent === "function") {
                    attachEvent("onunload", unloadHandler);
                  } else if (typeof addEventListener === "function") {
                    const terminationEvent = "onpagehide" in globalThisShim ? "pagehide" : "unload";
                    addEventListener(terminationEvent, unloadHandler, false);
                  }
                }
                function unloadHandler() {
                  for (let i in Request.requests) {
                    if (Request.requests.hasOwnProperty(i)) {
                      Request.requests[i].abort();
                    }
                  }
                }
                const hasXHR2 = function() {
                  const xhr = newRequest({
                    xdomain: false
                  });
                  return xhr && xhr.responseType !== null;
                }();
                class XHR extends BaseXHR {
                  constructor(opts) {
                    super(opts);
                    const forceBase64 = opts && opts.forceBase64;
                    this.supportsBinary = hasXHR2 && !forceBase64;
                  }
                  request(opts = {}) {
                    Object.assign(opts, { xd: this.xd }, this.opts);
                    return new Request(newRequest, this.uri(), opts);
                  }
                }
                function newRequest(opts) {
                  const xdomain = opts.xdomain;
                  try {
                    if ("undefined" !== typeof XMLHttpRequest && (!xdomain || hasCORS)) {
                      return new XMLHttpRequest();
                    }
                  } catch (e) {
                  }
                  if (!xdomain) {
                    try {
                      return new globalThisShim[["Active"].concat("Object").join("X")]("Microsoft.XMLHTTP");
                    } catch (e) {
                    }
                  }
                }
                ;
                const isReactNative = typeof navigator !== "undefined" && typeof navigator.product === "string" && navigator.product.toLowerCase() === "reactnative";
                class BaseWS extends Transport {
                  get name() {
                    return "websocket";
                  }
                  doOpen() {
                    const uri = this.uri();
                    const protocols = this.opts.protocols;
                    const opts = isReactNative ? {} : pick(this.opts, "agent", "perMessageDeflate", "pfx", "key", "passphrase", "cert", "ca", "ciphers", "rejectUnauthorized", "localAddress", "protocolVersion", "origin", "maxPayload", "family", "checkServerIdentity");
                    if (this.opts.extraHeaders) {
                      opts.headers = this.opts.extraHeaders;
                    }
                    try {
                      this.ws = this.createSocket(uri, protocols, opts);
                    } catch (err) {
                      return this.emitReserved("error", err);
                    }
                    this.ws.binaryType = this.socket.binaryType;
                    this.addEventListeners();
                  }
                  /**
                   * Adds event listeners to the socket
                   *
                   * @private
                   */
                  addEventListeners() {
                    this.ws.onopen = () => {
                      if (this.opts.autoUnref) {
                        this.ws._socket.unref();
                      }
                      this.onOpen();
                    };
                    this.ws.onclose = (closeEvent) => this.onClose({
                      description: "websocket connection closed",
                      context: closeEvent
                    });
                    this.ws.onmessage = (ev) => this.onData(ev.data);
                    this.ws.onerror = (e) => this.onError("websocket error", e);
                  }
                  write(packets) {
                    this.writable = false;
                    for (let i = 0; i < packets.length; i++) {
                      const packet = packets[i];
                      const lastPacket = i === packets.length - 1;
                      encodePacket(packet, this.supportsBinary, (data) => {
                        try {
                          this.doWrite(packet, data);
                        } catch (e) {
                        }
                        if (lastPacket) {
                          nextTick(() => {
                            this.writable = true;
                            this.emitReserved("drain");
                          }, this.setTimeoutFn);
                        }
                      });
                    }
                  }
                  doClose() {
                    if (typeof this.ws !== "undefined") {
                      this.ws.onerror = () => {
                      };
                      this.ws.close();
                      this.ws = null;
                    }
                  }
                  /**
                   * Generates uri for connection.
                   *
                   * @private
                   */
                  uri() {
                    const schema = this.opts.secure ? "wss" : "ws";
                    const query = this.query || {};
                    if (this.opts.timestampRequests) {
                      query[this.opts.timestampParam] = randomString();
                    }
                    if (!this.supportsBinary) {
                      query.b64 = 1;
                    }
                    return this.createUri(schema, query);
                  }
                }
                const WebSocketCtor = globalThisShim.WebSocket || globalThisShim.MozWebSocket;
                class WS extends BaseWS {
                  createSocket(uri, protocols, opts) {
                    return !isReactNative ? protocols ? new WebSocketCtor(uri, protocols) : new WebSocketCtor(uri) : new WebSocketCtor(uri, protocols, opts);
                  }
                  doWrite(_packet, data) {
                    this.ws.send(data);
                  }
                }
                ;
                class WT extends Transport {
                  get name() {
                    return "webtransport";
                  }
                  doOpen() {
                    try {
                      this._transport = new WebTransport(this.createUri("https"), this.opts.transportOptions[this.name]);
                    } catch (err) {
                      return this.emitReserved("error", err);
                    }
                    this._transport.closed.then(() => {
                      this.onClose();
                    }).catch((err) => {
                      this.onError("webtransport error", err);
                    });
                    this._transport.ready.then(() => {
                      this._transport.createBidirectionalStream().then((stream) => {
                        const decoderStream = createPacketDecoderStream(Number.MAX_SAFE_INTEGER, this.socket.binaryType);
                        const reader = stream.readable.pipeThrough(decoderStream).getReader();
                        const encoderStream = createPacketEncoderStream();
                        encoderStream.readable.pipeTo(stream.writable);
                        this._writer = encoderStream.writable.getWriter();
                        const read = () => {
                          reader.read().then(({ done, value: value2 }) => {
                            if (done) {
                              return;
                            }
                            this.onPacket(value2);
                            read();
                          }).catch((err) => {
                          });
                        };
                        read();
                        const packet = { type: "open" };
                        if (this.query.sid) {
                          packet.data = `{"sid":"${this.query.sid}"}`;
                        }
                        this._writer.write(packet).then(() => this.onOpen());
                      });
                    });
                  }
                  write(packets) {
                    this.writable = false;
                    for (let i = 0; i < packets.length; i++) {
                      const packet = packets[i];
                      const lastPacket = i === packets.length - 1;
                      this._writer.write(packet).then(() => {
                        if (lastPacket) {
                          nextTick(() => {
                            this.writable = true;
                            this.emitReserved("drain");
                          }, this.setTimeoutFn);
                        }
                      });
                    }
                  }
                  doClose() {
                    var _a;
                    (_a = this._transport) === null || _a === void 0 ? void 0 : _a.close();
                  }
                }
                ;
                const transports = {
                  websocket: WS,
                  webtransport: WT,
                  polling: XHR
                };
                ;
                const re = /^(?:(?![^:@\/?#]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@\/?#]*)(?::([^:@\/?#]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/;
                const parts = [
                  "source",
                  "protocol",
                  "authority",
                  "userInfo",
                  "user",
                  "password",
                  "host",
                  "port",
                  "relative",
                  "path",
                  "directory",
                  "file",
                  "query",
                  "anchor"
                ];
                function parse(str) {
                  if (str.length > 8e3) {
                    throw "URI too long";
                  }
                  const src2 = str, b = str.indexOf("["), e = str.indexOf("]");
                  if (b != -1 && e != -1) {
                    str = str.substring(0, b) + str.substring(b, e).replace(/:/g, ";") + str.substring(e, str.length);
                  }
                  let m = re.exec(str || ""), uri = {}, i = 14;
                  while (i--) {
                    uri[parts[i]] = m[i] || "";
                  }
                  if (b != -1 && e != -1) {
                    uri.source = src2;
                    uri.host = uri.host.substring(1, uri.host.length - 1).replace(/;/g, ":");
                    uri.authority = uri.authority.replace("[", "").replace("]", "").replace(/;/g, ":");
                    uri.ipv6uri = true;
                  }
                  uri.pathNames = pathNames(uri, uri["path"]);
                  uri.queryKey = queryKey(uri, uri["query"]);
                  return uri;
                }
                function pathNames(obj, path) {
                  const regx = /\/{2,9}/g, names = path.replace(regx, "/").split("/");
                  if (path.slice(0, 1) == "/" || path.length === 0) {
                    names.splice(0, 1);
                  }
                  if (path.slice(-1) == "/") {
                    names.splice(names.length - 1, 1);
                  }
                  return names;
                }
                function queryKey(uri, query) {
                  const data = {};
                  query.replace(/(?:^|&)([^&=]*)=?([^&]*)/g, function($0, $1, $2) {
                    if ($1) {
                      data[$1] = $2;
                    }
                  });
                  return data;
                }
                ;
                const withEventListeners = typeof addEventListener === "function" && typeof removeEventListener === "function";
                const OFFLINE_EVENT_LISTENERS = [];
                if (withEventListeners) {
                  addEventListener("offline", () => {
                    OFFLINE_EVENT_LISTENERS.forEach((listener) => listener());
                  }, false);
                }
                class SocketWithoutUpgrade extends Emitter {
                  /**
                   * Socket constructor.
                   *
                   * @param {String|Object} uri - uri or options
                   * @param {Object} opts - options
                   */
                  constructor(uri, opts) {
                    super();
                    this.binaryType = defaultBinaryType;
                    this.writeBuffer = [];
                    this._prevBufferLen = 0;
                    this._pingInterval = -1;
                    this._pingTimeout = -1;
                    this._maxPayload = -1;
                    this._pingTimeoutTime = Infinity;
                    if (uri && "object" === typeof uri) {
                      opts = uri;
                      uri = null;
                    }
                    if (uri) {
                      const parsedUri = parse(uri);
                      opts.hostname = parsedUri.host;
                      opts.secure = parsedUri.protocol === "https" || parsedUri.protocol === "wss";
                      opts.port = parsedUri.port;
                      if (parsedUri.query)
                        opts.query = parsedUri.query;
                    } else if (opts.host) {
                      opts.hostname = parse(opts.host).host;
                    }
                    installTimerFunctions(this, opts);
                    this.secure = null != opts.secure ? opts.secure : typeof location !== "undefined" && "https:" === location.protocol;
                    if (opts.hostname && !opts.port) {
                      opts.port = this.secure ? "443" : "80";
                    }
                    this.hostname = opts.hostname || (typeof location !== "undefined" ? location.hostname : "localhost");
                    this.port = opts.port || (typeof location !== "undefined" && location.port ? location.port : this.secure ? "443" : "80");
                    this.transports = [];
                    this._transportsByName = {};
                    opts.transports.forEach((t) => {
                      const transportName = t.prototype.name;
                      this.transports.push(transportName);
                      this._transportsByName[transportName] = t;
                    });
                    this.opts = Object.assign({
                      path: "/engine.io",
                      agent: false,
                      withCredentials: false,
                      upgrade: true,
                      timestampParam: "t",
                      rememberUpgrade: false,
                      addTrailingSlash: true,
                      rejectUnauthorized: true,
                      perMessageDeflate: {
                        threshold: 1024
                      },
                      transportOptions: {},
                      closeOnBeforeunload: false
                    }, opts);
                    this.opts.path = this.opts.path.replace(/\/$/, "") + (this.opts.addTrailingSlash ? "/" : "");
                    if (typeof this.opts.query === "string") {
                      this.opts.query = parseqs_decode(this.opts.query);
                    }
                    if (withEventListeners) {
                      if (this.opts.closeOnBeforeunload) {
                        this._beforeunloadEventListener = () => {
                          if (this.transport) {
                            this.transport.removeAllListeners();
                            this.transport.close();
                          }
                        };
                        addEventListener("beforeunload", this._beforeunloadEventListener, false);
                      }
                      if (this.hostname !== "localhost") {
                        this._offlineEventListener = () => {
                          this._onClose("transport close", {
                            description: "network connection lost"
                          });
                        };
                        OFFLINE_EVENT_LISTENERS.push(this._offlineEventListener);
                      }
                    }
                    if (this.opts.withCredentials) {
                      this._cookieJar = createCookieJar();
                    }
                    this._open();
                  }
                  /**
                   * Creates transport of the given type.
                   *
                   * @param {String} name - transport name
                   * @return {Transport}
                   * @private
                   */
                  createTransport(name) {
                    const query = Object.assign({}, this.opts.query);
                    query.EIO = protocol;
                    query.transport = name;
                    if (this.id)
                      query.sid = this.id;
                    const opts = Object.assign({}, this.opts, {
                      query,
                      socket: this,
                      hostname: this.hostname,
                      secure: this.secure,
                      port: this.port
                    }, this.opts.transportOptions[name]);
                    return new this._transportsByName[name](opts);
                  }
                  /**
                   * Initializes transport to use and starts probe.
                   *
                   * @private
                   */
                  _open() {
                    if (this.transports.length === 0) {
                      this.setTimeoutFn(() => {
                        this.emitReserved("error", "No transports available");
                      }, 0);
                      return;
                    }
                    const transportName = this.opts.rememberUpgrade && SocketWithoutUpgrade.priorWebsocketSuccess && this.transports.indexOf("websocket") !== -1 ? "websocket" : this.transports[0];
                    this.readyState = "opening";
                    const transport = this.createTransport(transportName);
                    transport.open();
                    this.setTransport(transport);
                  }
                  /**
                   * Sets the current transport. Disables the existing one (if any).
                   *
                   * @private
                   */
                  setTransport(transport) {
                    if (this.transport) {
                      this.transport.removeAllListeners();
                    }
                    this.transport = transport;
                    transport.on("drain", this._onDrain.bind(this)).on("packet", this._onPacket.bind(this)).on("error", this._onError.bind(this)).on("close", (reason) => this._onClose("transport close", reason));
                  }
                  /**
                   * Called when connection is deemed open.
                   *
                   * @private
                   */
                  onOpen() {
                    this.readyState = "open";
                    SocketWithoutUpgrade.priorWebsocketSuccess = "websocket" === this.transport.name;
                    this.emitReserved("open");
                    this.flush();
                  }
                  /**
                   * Handles a packet.
                   *
                   * @private
                   */
                  _onPacket(packet) {
                    if ("opening" === this.readyState || "open" === this.readyState || "closing" === this.readyState) {
                      this.emitReserved("packet", packet);
                      this.emitReserved("heartbeat");
                      switch (packet.type) {
                        case "open":
                          this.onHandshake(JSON.parse(packet.data));
                          break;
                        case "ping":
                          this._sendPacket("pong");
                          this.emitReserved("ping");
                          this.emitReserved("pong");
                          this._resetPingTimeout();
                          break;
                        case "error":
                          const err = new Error("server error");
                          err.code = packet.data;
                          this._onError(err);
                          break;
                        case "message":
                          this.emitReserved("data", packet.data);
                          this.emitReserved("message", packet.data);
                          break;
                      }
                    } else {
                    }
                  }
                  /**
                   * Called upon handshake completion.
                   *
                   * @param {Object} data - handshake obj
                   * @private
                   */
                  onHandshake(data) {
                    this.emitReserved("handshake", data);
                    this.id = data.sid;
                    this.transport.query.sid = data.sid;
                    this._pingInterval = data.pingInterval;
                    this._pingTimeout = data.pingTimeout;
                    this._maxPayload = data.maxPayload;
                    this.onOpen();
                    if ("closed" === this.readyState)
                      return;
                    this._resetPingTimeout();
                  }
                  /**
                   * Sets and resets ping timeout timer based on server pings.
                   *
                   * @private
                   */
                  _resetPingTimeout() {
                    this.clearTimeoutFn(this._pingTimeoutTimer);
                    const delay = this._pingInterval + this._pingTimeout;
                    this._pingTimeoutTime = Date.now() + delay;
                    this._pingTimeoutTimer = this.setTimeoutFn(() => {
                      this._onClose("ping timeout");
                    }, delay);
                    if (this.opts.autoUnref) {
                      this._pingTimeoutTimer.unref();
                    }
                  }
                  /**
                   * Called on `drain` event
                   *
                   * @private
                   */
                  _onDrain() {
                    this.writeBuffer.splice(0, this._prevBufferLen);
                    this._prevBufferLen = 0;
                    if (0 === this.writeBuffer.length) {
                      this.emitReserved("drain");
                    } else {
                      this.flush();
                    }
                  }
                  /**
                   * Flush write buffers.
                   *
                   * @private
                   */
                  flush() {
                    if ("closed" !== this.readyState && this.transport.writable && !this.upgrading && this.writeBuffer.length) {
                      const packets = this._getWritablePackets();
                      this.transport.send(packets);
                      this._prevBufferLen = packets.length;
                      this.emitReserved("flush");
                    }
                  }
                  /**
                   * Ensure the encoded size of the writeBuffer is below the maxPayload value sent by the server (only for HTTP
                   * long-polling)
                   *
                   * @private
                   */
                  _getWritablePackets() {
                    const shouldCheckPayloadSize = this._maxPayload && this.transport.name === "polling" && this.writeBuffer.length > 1;
                    if (!shouldCheckPayloadSize) {
                      return this.writeBuffer;
                    }
                    let payloadSize = 1;
                    for (let i = 0; i < this.writeBuffer.length; i++) {
                      const data = this.writeBuffer[i].data;
                      if (data) {
                        payloadSize += byteLength(data);
                      }
                      if (i > 0 && payloadSize > this._maxPayload) {
                        return this.writeBuffer.slice(0, i);
                      }
                      payloadSize += 2;
                    }
                    return this.writeBuffer;
                  }
                  /**
                   * Checks whether the heartbeat timer has expired but the socket has not yet been notified.
                   *
                   * Note: this method is private for now because it does not really fit the WebSocket API, but if we put it in the
                   * `write()` method then the message would not be buffered by the Socket.IO client.
                   *
                   * @return {boolean}
                   * @private
                   */
                  /* private */
                  _hasPingExpired() {
                    if (!this._pingTimeoutTime)
                      return true;
                    const hasExpired = Date.now() > this._pingTimeoutTime;
                    if (hasExpired) {
                      this._pingTimeoutTime = 0;
                      nextTick(() => {
                        this._onClose("ping timeout");
                      }, this.setTimeoutFn);
                    }
                    return hasExpired;
                  }
                  /**
                   * Sends a message.
                   *
                   * @param {String} msg - message.
                   * @param {Object} options.
                   * @param {Function} fn - callback function.
                   * @return {Socket} for chaining.
                   */
                  write(msg, options, fn) {
                    this._sendPacket("message", msg, options, fn);
                    return this;
                  }
                  /**
                   * Sends a message. Alias of {@link Socket#write}.
                   *
                   * @param {String} msg - message.
                   * @param {Object} options.
                   * @param {Function} fn - callback function.
                   * @return {Socket} for chaining.
                   */
                  send(msg, options, fn) {
                    this._sendPacket("message", msg, options, fn);
                    return this;
                  }
                  /**
                   * Sends a packet.
                   *
                   * @param {String} type: packet type.
                   * @param {String} data.
                   * @param {Object} options.
                   * @param {Function} fn - callback function.
                   * @private
                   */
                  _sendPacket(type, data, options, fn) {
                    if ("function" === typeof data) {
                      fn = data;
                      data = void 0;
                    }
                    if ("function" === typeof options) {
                      fn = options;
                      options = null;
                    }
                    if ("closing" === this.readyState || "closed" === this.readyState) {
                      return;
                    }
                    options = options || {};
                    options.compress = false !== options.compress;
                    const packet = {
                      type,
                      data,
                      options
                    };
                    this.emitReserved("packetCreate", packet);
                    this.writeBuffer.push(packet);
                    if (fn)
                      this.once("flush", fn);
                    this.flush();
                  }
                  /**
                   * Closes the connection.
                   */
                  close() {
                    const close = () => {
                      this._onClose("forced close");
                      this.transport.close();
                    };
                    const cleanupAndClose = () => {
                      this.off("upgrade", cleanupAndClose);
                      this.off("upgradeError", cleanupAndClose);
                      close();
                    };
                    const waitForUpgrade = () => {
                      this.once("upgrade", cleanupAndClose);
                      this.once("upgradeError", cleanupAndClose);
                    };
                    if ("opening" === this.readyState || "open" === this.readyState) {
                      this.readyState = "closing";
                      if (this.writeBuffer.length) {
                        this.once("drain", () => {
                          if (this.upgrading) {
                            waitForUpgrade();
                          } else {
                            close();
                          }
                        });
                      } else if (this.upgrading) {
                        waitForUpgrade();
                      } else {
                        close();
                      }
                    }
                    return this;
                  }
                  /**
                   * Called upon transport error
                   *
                   * @private
                   */
                  _onError(err) {
                    SocketWithoutUpgrade.priorWebsocketSuccess = false;
                    if (this.opts.tryAllTransports && this.transports.length > 1 && this.readyState === "opening") {
                      this.transports.shift();
                      return this._open();
                    }
                    this.emitReserved("error", err);
                    this._onClose("transport error", err);
                  }
                  /**
                   * Called upon transport close.
                   *
                   * @private
                   */
                  _onClose(reason, description) {
                    if ("opening" === this.readyState || "open" === this.readyState || "closing" === this.readyState) {
                      this.clearTimeoutFn(this._pingTimeoutTimer);
                      this.transport.removeAllListeners("close");
                      this.transport.close();
                      this.transport.removeAllListeners();
                      if (withEventListeners) {
                        if (this._beforeunloadEventListener) {
                          removeEventListener("beforeunload", this._beforeunloadEventListener, false);
                        }
                        if (this._offlineEventListener) {
                          const i = OFFLINE_EVENT_LISTENERS.indexOf(this._offlineEventListener);
                          if (i !== -1) {
                            OFFLINE_EVENT_LISTENERS.splice(i, 1);
                          }
                        }
                      }
                      this.readyState = "closed";
                      this.id = null;
                      this.emitReserved("close", reason, description);
                      this.writeBuffer = [];
                      this._prevBufferLen = 0;
                    }
                  }
                }
                SocketWithoutUpgrade.protocol = protocol;
                class SocketWithUpgrade extends SocketWithoutUpgrade {
                  constructor() {
                    super(...arguments);
                    this._upgrades = [];
                  }
                  onOpen() {
                    super.onOpen();
                    if ("open" === this.readyState && this.opts.upgrade) {
                      for (let i = 0; i < this._upgrades.length; i++) {
                        this._probe(this._upgrades[i]);
                      }
                    }
                  }
                  /**
                   * Probes a transport.
                   *
                   * @param {String} name - transport name
                   * @private
                   */
                  _probe(name) {
                    let transport = this.createTransport(name);
                    let failed = false;
                    SocketWithoutUpgrade.priorWebsocketSuccess = false;
                    const onTransportOpen = () => {
                      if (failed)
                        return;
                      transport.send([{ type: "ping", data: "probe" }]);
                      transport.once("packet", (msg) => {
                        if (failed)
                          return;
                        if ("pong" === msg.type && "probe" === msg.data) {
                          this.upgrading = true;
                          this.emitReserved("upgrading", transport);
                          if (!transport)
                            return;
                          SocketWithoutUpgrade.priorWebsocketSuccess = "websocket" === transport.name;
                          this.transport.pause(() => {
                            if (failed)
                              return;
                            if ("closed" === this.readyState)
                              return;
                            cleanup();
                            this.setTransport(transport);
                            transport.send([{ type: "upgrade" }]);
                            this.emitReserved("upgrade", transport);
                            transport = null;
                            this.upgrading = false;
                            this.flush();
                          });
                        } else {
                          const err = new Error("probe error");
                          err.transport = transport.name;
                          this.emitReserved("upgradeError", err);
                        }
                      });
                    };
                    function freezeTransport() {
                      if (failed)
                        return;
                      failed = true;
                      cleanup();
                      transport.close();
                      transport = null;
                    }
                    const onerror = (err) => {
                      const error = new Error("probe error: " + err);
                      error.transport = transport.name;
                      freezeTransport();
                      this.emitReserved("upgradeError", error);
                    };
                    function onTransportClose() {
                      onerror("transport closed");
                    }
                    function onclose() {
                      onerror("socket closed");
                    }
                    function onupgrade(to) {
                      if (transport && to.name !== transport.name) {
                        freezeTransport();
                      }
                    }
                    const cleanup = () => {
                      transport.removeListener("open", onTransportOpen);
                      transport.removeListener("error", onerror);
                      transport.removeListener("close", onTransportClose);
                      this.off("close", onclose);
                      this.off("upgrading", onupgrade);
                    };
                    transport.once("open", onTransportOpen);
                    transport.once("error", onerror);
                    transport.once("close", onTransportClose);
                    this.once("close", onclose);
                    this.once("upgrading", onupgrade);
                    if (this._upgrades.indexOf("webtransport") !== -1 && name !== "webtransport") {
                      this.setTimeoutFn(() => {
                        if (!failed) {
                          transport.open();
                        }
                      }, 200);
                    } else {
                      transport.open();
                    }
                  }
                  onHandshake(data) {
                    this._upgrades = this._filterUpgrades(data.upgrades);
                    super.onHandshake(data);
                  }
                  /**
                   * Filters upgrades, returning only those matching client transports.
                   *
                   * @param {Array} upgrades - server upgrades
                   * @private
                   */
                  _filterUpgrades(upgrades) {
                    const filteredUpgrades = [];
                    for (let i = 0; i < upgrades.length; i++) {
                      if (~this.transports.indexOf(upgrades[i]))
                        filteredUpgrades.push(upgrades[i]);
                    }
                    return filteredUpgrades;
                  }
                }
                class Socket extends SocketWithUpgrade {
                  constructor(uri, opts = {}) {
                    const o = typeof uri === "object" ? uri : opts;
                    if (!o.transports || o.transports && typeof o.transports[0] === "string") {
                      o.transports = (o.transports || ["polling", "websocket", "webtransport"]).map((transportName) => transports[transportName]).filter((t) => !!t);
                    }
                    super(uri, o);
                  }
                }
                ;
                class Fetch extends /* unused pure expression or super */
                null {
                  doPoll() {
                    this._fetch().then((res) => {
                      if (!res.ok) {
                        return this.onError("fetch read error", res.status, res);
                      }
                      res.text().then((data) => this.onData(data));
                    }).catch((err) => {
                      this.onError("fetch read error", err);
                    });
                  }
                  doWrite(data, callback) {
                    this._fetch(data).then((res) => {
                      if (!res.ok) {
                        return this.onError("fetch write error", res.status, res);
                      }
                      callback();
                    }).catch((err) => {
                      this.onError("fetch write error", err);
                    });
                  }
                  _fetch(data) {
                    var _a;
                    const isPost = data !== void 0;
                    const headers = new Headers(this.opts.extraHeaders);
                    if (isPost) {
                      headers.set("content-type", "text/plain;charset=UTF-8");
                    }
                    (_a = this.socket._cookieJar) === null || _a === void 0 ? void 0 : _a.appendCookies(headers);
                    return fetch(this.uri(), {
                      method: isPost ? "POST" : "GET",
                      body: isPost ? data : null,
                      headers,
                      credentials: this.opts.withCredentials ? "include" : "omit"
                    }).then((res) => {
                      var _a2;
                      (_a2 = this.socket._cookieJar) === null || _a2 === void 0 ? void 0 : _a2.parseCookies(res.headers.getSetCookie());
                      return res;
                    });
                  }
                }
                ;
                const esm_protocol = Socket.protocol;
                ;
                function url(uri, path = "", loc) {
                  let obj = uri;
                  loc = loc || typeof location !== "undefined" && location;
                  if (null == uri)
                    uri = loc.protocol + "//" + loc.host;
                  if (typeof uri === "string") {
                    if ("/" === uri.charAt(0)) {
                      if ("/" === uri.charAt(1)) {
                        uri = loc.protocol + uri;
                      } else {
                        uri = loc.host + uri;
                      }
                    }
                    if (!/^(https?|wss?):\/\//.test(uri)) {
                      if ("undefined" !== typeof loc) {
                        uri = loc.protocol + "//" + uri;
                      } else {
                        uri = "https://" + uri;
                      }
                    }
                    obj = parse(uri);
                  }
                  if (!obj.port) {
                    if (/^(http|ws)$/.test(obj.protocol)) {
                      obj.port = "80";
                    } else if (/^(http|ws)s$/.test(obj.protocol)) {
                      obj.port = "443";
                    }
                  }
                  obj.path = obj.path || "/";
                  const ipv6 = obj.host.indexOf(":") !== -1;
                  const host = ipv6 ? "[" + obj.host + "]" : obj.host;
                  obj.id = obj.protocol + "://" + host + ":" + obj.port + path;
                  obj.href = obj.protocol + "://" + host + (loc && loc.port === obj.port ? "" : ":" + obj.port);
                  return obj;
                }
                ;
                const is_binary_withNativeArrayBuffer = typeof ArrayBuffer === "function";
                const is_binary_isView = (obj) => {
                  return typeof ArrayBuffer.isView === "function" ? ArrayBuffer.isView(obj) : obj.buffer instanceof ArrayBuffer;
                };
                const is_binary_toString = Object.prototype.toString;
                const is_binary_withNativeBlob = typeof Blob === "function" || typeof Blob !== "undefined" && is_binary_toString.call(Blob) === "[object BlobConstructor]";
                const withNativeFile = typeof File === "function" || typeof File !== "undefined" && is_binary_toString.call(File) === "[object FileConstructor]";
                function isBinary(obj) {
                  return is_binary_withNativeArrayBuffer && (obj instanceof ArrayBuffer || is_binary_isView(obj)) || is_binary_withNativeBlob && obj instanceof Blob || withNativeFile && obj instanceof File;
                }
                function hasBinary(obj, toJSON) {
                  if (!obj || typeof obj !== "object") {
                    return false;
                  }
                  if (Array.isArray(obj)) {
                    for (let i = 0, l = obj.length; i < l; i++) {
                      if (hasBinary(obj[i])) {
                        return true;
                      }
                    }
                    return false;
                  }
                  if (isBinary(obj)) {
                    return true;
                  }
                  if (obj.toJSON && typeof obj.toJSON === "function" && arguments.length === 1) {
                    return hasBinary(obj.toJSON(), true);
                  }
                  for (const key in obj) {
                    if (Object.prototype.hasOwnProperty.call(obj, key) && hasBinary(obj[key])) {
                      return true;
                    }
                  }
                  return false;
                }
                ;
                function deconstructPacket(packet) {
                  const buffers = [];
                  const packetData = packet.data;
                  const pack = packet;
                  pack.data = _deconstructPacket(packetData, buffers);
                  pack.attachments = buffers.length;
                  return { packet: pack, buffers };
                }
                function _deconstructPacket(data, buffers) {
                  if (!data)
                    return data;
                  if (isBinary(data)) {
                    const placeholder = { _placeholder: true, num: buffers.length };
                    buffers.push(data);
                    return placeholder;
                  } else if (Array.isArray(data)) {
                    const newData = new Array(data.length);
                    for (let i = 0; i < data.length; i++) {
                      newData[i] = _deconstructPacket(data[i], buffers);
                    }
                    return newData;
                  } else if (typeof data === "object" && !(data instanceof Date)) {
                    const newData = {};
                    for (const key in data) {
                      if (Object.prototype.hasOwnProperty.call(data, key)) {
                        newData[key] = _deconstructPacket(data[key], buffers);
                      }
                    }
                    return newData;
                  }
                  return data;
                }
                function reconstructPacket(packet, buffers) {
                  packet.data = _reconstructPacket(packet.data, buffers);
                  delete packet.attachments;
                  return packet;
                }
                function _reconstructPacket(data, buffers) {
                  if (!data)
                    return data;
                  if (data && data._placeholder === true) {
                    const isIndexValid = typeof data.num === "number" && data.num >= 0 && data.num < buffers.length;
                    if (isIndexValid) {
                      return buffers[data.num];
                    } else {
                      throw new Error("illegal attachments");
                    }
                  } else if (Array.isArray(data)) {
                    for (let i = 0; i < data.length; i++) {
                      data[i] = _reconstructPacket(data[i], buffers);
                    }
                  } else if (typeof data === "object") {
                    for (const key in data) {
                      if (Object.prototype.hasOwnProperty.call(data, key)) {
                        data[key] = _reconstructPacket(data[key], buffers);
                      }
                    }
                  }
                  return data;
                }
                ;
                const RESERVED_EVENTS = [
                  "connect",
                  "connect_error",
                  "disconnect",
                  "disconnecting",
                  "newListener",
                  "removeListener"
                  // used by the Node.js EventEmitter
                ];
                const build_esm_protocol = 5;
                var PacketType;
                (function(PacketType2) {
                  PacketType2[PacketType2["CONNECT"] = 0] = "CONNECT";
                  PacketType2[PacketType2["DISCONNECT"] = 1] = "DISCONNECT";
                  PacketType2[PacketType2["EVENT"] = 2] = "EVENT";
                  PacketType2[PacketType2["ACK"] = 3] = "ACK";
                  PacketType2[PacketType2["CONNECT_ERROR"] = 4] = "CONNECT_ERROR";
                  PacketType2[PacketType2["BINARY_EVENT"] = 5] = "BINARY_EVENT";
                  PacketType2[PacketType2["BINARY_ACK"] = 6] = "BINARY_ACK";
                })(PacketType || (PacketType = {}));
                class Encoder {
                  /**
                   * Encoder constructor
                   *
                   * @param {function} replacer - custom replacer to pass down to JSON.parse
                   */
                  constructor(replacer) {
                    this.replacer = replacer;
                  }
                  /**
                   * Encode a packet as a single string if non-binary, or as a
                   * buffer sequence, depending on packet type.
                   *
                   * @param {Object} obj - packet object
                   */
                  encode(obj) {
                    if (obj.type === PacketType.EVENT || obj.type === PacketType.ACK) {
                      if (hasBinary(obj)) {
                        return this.encodeAsBinary({
                          type: obj.type === PacketType.EVENT ? PacketType.BINARY_EVENT : PacketType.BINARY_ACK,
                          nsp: obj.nsp,
                          data: obj.data,
                          id: obj.id
                        });
                      }
                    }
                    return [this.encodeAsString(obj)];
                  }
                  /**
                   * Encode packet as string.
                   */
                  encodeAsString(obj) {
                    let str = "" + obj.type;
                    if (obj.type === PacketType.BINARY_EVENT || obj.type === PacketType.BINARY_ACK) {
                      str += obj.attachments + "-";
                    }
                    if (obj.nsp && "/" !== obj.nsp) {
                      str += obj.nsp + ",";
                    }
                    if (null != obj.id) {
                      str += obj.id;
                    }
                    if (null != obj.data) {
                      str += JSON.stringify(obj.data, this.replacer);
                    }
                    return str;
                  }
                  /**
                   * Encode packet as 'buffer sequence' by removing blobs, and
                   * deconstructing packet into object with placeholders and
                   * a list of buffers.
                   */
                  encodeAsBinary(obj) {
                    const deconstruction = deconstructPacket(obj);
                    const pack = this.encodeAsString(deconstruction.packet);
                    const buffers = deconstruction.buffers;
                    buffers.unshift(pack);
                    return buffers;
                  }
                }
                function isObject(value2) {
                  return Object.prototype.toString.call(value2) === "[object Object]";
                }
                class Decoder extends Emitter {
                  /**
                   * Decoder constructor
                   *
                   * @param {function} reviver - custom reviver to pass down to JSON.stringify
                   */
                  constructor(reviver) {
                    super();
                    this.reviver = reviver;
                  }
                  /**
                   * Decodes an encoded packet string into packet JSON.
                   *
                   * @param {String} obj - encoded packet
                   */
                  add(obj) {
                    let packet;
                    if (typeof obj === "string") {
                      if (this.reconstructor) {
                        throw new Error("got plaintext data when reconstructing a packet");
                      }
                      packet = this.decodeString(obj);
                      const isBinaryEvent = packet.type === PacketType.BINARY_EVENT;
                      if (isBinaryEvent || packet.type === PacketType.BINARY_ACK) {
                        packet.type = isBinaryEvent ? PacketType.EVENT : PacketType.ACK;
                        this.reconstructor = new BinaryReconstructor(packet);
                        if (packet.attachments === 0) {
                          super.emitReserved("decoded", packet);
                        }
                      } else {
                        super.emitReserved("decoded", packet);
                      }
                    } else if (isBinary(obj) || obj.base64) {
                      if (!this.reconstructor) {
                        throw new Error("got binary data when not reconstructing a packet");
                      } else {
                        packet = this.reconstructor.takeBinaryData(obj);
                        if (packet) {
                          this.reconstructor = null;
                          super.emitReserved("decoded", packet);
                        }
                      }
                    } else {
                      throw new Error("Unknown type: " + obj);
                    }
                  }
                  /**
                   * Decode a packet String (JSON data)
                   *
                   * @param {String} str
                   * @return {Object} packet
                   */
                  decodeString(str) {
                    let i = 0;
                    const p = {
                      type: Number(str.charAt(0))
                    };
                    if (PacketType[p.type] === void 0) {
                      throw new Error("unknown packet type " + p.type);
                    }
                    if (p.type === PacketType.BINARY_EVENT || p.type === PacketType.BINARY_ACK) {
                      const start = i + 1;
                      while (str.charAt(++i) !== "-" && i != str.length) {
                      }
                      const buf = str.substring(start, i);
                      if (buf != Number(buf) || str.charAt(i) !== "-") {
                        throw new Error("Illegal attachments");
                      }
                      p.attachments = Number(buf);
                    }
                    if ("/" === str.charAt(i + 1)) {
                      const start = i + 1;
                      while (++i) {
                        const c = str.charAt(i);
                        if ("," === c)
                          break;
                        if (i === str.length)
                          break;
                      }
                      p.nsp = str.substring(start, i);
                    } else {
                      p.nsp = "/";
                    }
                    const next = str.charAt(i + 1);
                    if ("" !== next && Number(next) == next) {
                      const start = i + 1;
                      while (++i) {
                        const c = str.charAt(i);
                        if (null == c || Number(c) != c) {
                          --i;
                          break;
                        }
                        if (i === str.length)
                          break;
                      }
                      p.id = Number(str.substring(start, i + 1));
                    }
                    if (str.charAt(++i)) {
                      const payload = this.tryParse(str.substr(i));
                      if (Decoder.isPayloadValid(p.type, payload)) {
                        p.data = payload;
                      } else {
                        throw new Error("invalid payload");
                      }
                    }
                    return p;
                  }
                  tryParse(str) {
                    try {
                      return JSON.parse(str, this.reviver);
                    } catch (e) {
                      return false;
                    }
                  }
                  static isPayloadValid(type, payload) {
                    switch (type) {
                      case PacketType.CONNECT:
                        return isObject(payload);
                      case PacketType.DISCONNECT:
                        return payload === void 0;
                      case PacketType.CONNECT_ERROR:
                        return typeof payload === "string" || isObject(payload);
                      case PacketType.EVENT:
                      case PacketType.BINARY_EVENT:
                        return Array.isArray(payload) && (typeof payload[0] === "number" || typeof payload[0] === "string" && RESERVED_EVENTS.indexOf(payload[0]) === -1);
                      case PacketType.ACK:
                      case PacketType.BINARY_ACK:
                        return Array.isArray(payload);
                    }
                  }
                  /**
                   * Deallocates a parser's resources
                   */
                  destroy() {
                    if (this.reconstructor) {
                      this.reconstructor.finishedReconstruction();
                      this.reconstructor = null;
                    }
                  }
                }
                class BinaryReconstructor {
                  constructor(packet) {
                    this.packet = packet;
                    this.buffers = [];
                    this.reconPack = packet;
                  }
                  /**
                   * Method to be called when binary data received from connection
                   * after a BINARY_EVENT packet.
                   *
                   * @param {Buffer | ArrayBuffer} binData - the raw binary data received
                   * @return {null | Object} returns null if more binary data is expected or
                   *   a reconstructed packet object if all buffers have been received.
                   */
                  takeBinaryData(binData) {
                    this.buffers.push(binData);
                    if (this.buffers.length === this.reconPack.attachments) {
                      const packet = reconstructPacket(this.reconPack, this.buffers);
                      this.finishedReconstruction();
                      return packet;
                    }
                    return null;
                  }
                  /**
                   * Cleans up binary packet reconstruction variables.
                   */
                  finishedReconstruction() {
                    this.reconPack = null;
                    this.buffers = [];
                  }
                }
                ;
                function on(obj, ev, fn) {
                  obj.on(ev, fn);
                  return function subDestroy() {
                    obj.off(ev, fn);
                  };
                }
                ;
                const socket_RESERVED_EVENTS = Object.freeze({
                  connect: 1,
                  connect_error: 1,
                  disconnect: 1,
                  disconnecting: 1,
                  // EventEmitter reserved events: https://nodejs.org/api/events.html#events_event_newlistener
                  newListener: 1,
                  removeListener: 1
                });
                class socket_Socket extends Emitter {
                  /**
                   * `Socket` constructor.
                   */
                  constructor(io, nsp, opts) {
                    super();
                    this.connected = false;
                    this.recovered = false;
                    this.receiveBuffer = [];
                    this.sendBuffer = [];
                    this._queue = [];
                    this._queueSeq = 0;
                    this.ids = 0;
                    this.acks = {};
                    this.flags = {};
                    this.io = io;
                    this.nsp = nsp;
                    if (opts && opts.auth) {
                      this.auth = opts.auth;
                    }
                    this._opts = Object.assign({}, opts);
                    if (this.io._autoConnect)
                      this.open();
                  }
                  /**
                   * Whether the socket is currently disconnected
                   *
                   * @example
                   * const socket = io();
                   *
                   * socket.on("connect", () => {
                   *   console.log(socket.disconnected); // false
                   * });
                   *
                   * socket.on("disconnect", () => {
                   *   console.log(socket.disconnected); // true
                   * });
                   */
                  get disconnected() {
                    return !this.connected;
                  }
                  /**
                   * Subscribe to open, close and packet events
                   *
                   * @private
                   */
                  subEvents() {
                    if (this.subs)
                      return;
                    const io = this.io;
                    this.subs = [
                      on(io, "open", this.onopen.bind(this)),
                      on(io, "packet", this.onpacket.bind(this)),
                      on(io, "error", this.onerror.bind(this)),
                      on(io, "close", this.onclose.bind(this))
                    ];
                  }
                  /**
                   * Whether the Socket will try to reconnect when its Manager connects or reconnects.
                   *
                   * @example
                   * const socket = io();
                   *
                   * console.log(socket.active); // true
                   *
                   * socket.on("disconnect", (reason) => {
                   *   if (reason === "io server disconnect") {
                   *     // the disconnection was initiated by the server, you need to manually reconnect
                   *     console.log(socket.active); // false
                   *   }
                   *   // else the socket will automatically try to reconnect
                   *   console.log(socket.active); // true
                   * });
                   */
                  get active() {
                    return !!this.subs;
                  }
                  /**
                   * "Opens" the socket.
                   *
                   * @example
                   * const socket = io({
                   *   autoConnect: false
                   * });
                   *
                   * socket.connect();
                   */
                  connect() {
                    if (this.connected)
                      return this;
                    this.subEvents();
                    if (!this.io["_reconnecting"])
                      this.io.open();
                    if ("open" === this.io._readyState)
                      this.onopen();
                    return this;
                  }
                  /**
                   * Alias for {@link connect()}.
                   */
                  open() {
                    return this.connect();
                  }
                  /**
                   * Sends a `message` event.
                   *
                   * This method mimics the WebSocket.send() method.
                   *
                   * @see https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/send
                   *
                   * @example
                   * socket.send("hello");
                   *
                   * // this is equivalent to
                   * socket.emit("message", "hello");
                   *
                   * @return self
                   */
                  send(...args) {
                    args.unshift("message");
                    this.emit.apply(this, args);
                    return this;
                  }
                  /**
                   * Override `emit`.
                   * If the event is in `events`, it's emitted normally.
                   *
                   * @example
                   * socket.emit("hello", "world");
                   *
                   * // all serializable datastructures are supported (no need to call JSON.stringify)
                   * socket.emit("hello", 1, "2", { 3: ["4"], 5: Uint8Array.from([6]) });
                   *
                   * // with an acknowledgement from the server
                   * socket.emit("hello", "world", (val) => {
                   *   // ...
                   * });
                   *
                   * @return self
                   */
                  emit(ev, ...args) {
                    var _a, _b, _c;
                    if (socket_RESERVED_EVENTS.hasOwnProperty(ev)) {
                      throw new Error('"' + ev.toString() + '" is a reserved event name');
                    }
                    args.unshift(ev);
                    if (this._opts.retries && !this.flags.fromQueue && !this.flags.volatile) {
                      this._addToQueue(args);
                      return this;
                    }
                    const packet = {
                      type: PacketType.EVENT,
                      data: args
                    };
                    packet.options = {};
                    packet.options.compress = this.flags.compress !== false;
                    if ("function" === typeof args[args.length - 1]) {
                      const id = this.ids++;
                      const ack = args.pop();
                      this._registerAckCallback(id, ack);
                      packet.id = id;
                    }
                    const isTransportWritable = (_b = (_a = this.io.engine) === null || _a === void 0 ? void 0 : _a.transport) === null || _b === void 0 ? void 0 : _b.writable;
                    const isConnected = this.connected && !((_c = this.io.engine) === null || _c === void 0 ? void 0 : _c._hasPingExpired());
                    const discardPacket = this.flags.volatile && !isTransportWritable;
                    if (discardPacket) {
                    } else if (isConnected) {
                      this.notifyOutgoingListeners(packet);
                      this.packet(packet);
                    } else {
                      this.sendBuffer.push(packet);
                    }
                    this.flags = {};
                    return this;
                  }
                  /**
                   * @private
                   */
                  _registerAckCallback(id, ack) {
                    var _a;
                    const timeout = (_a = this.flags.timeout) !== null && _a !== void 0 ? _a : this._opts.ackTimeout;
                    if (timeout === void 0) {
                      this.acks[id] = ack;
                      return;
                    }
                    const timer = this.io.setTimeoutFn(() => {
                      delete this.acks[id];
                      for (let i = 0; i < this.sendBuffer.length; i++) {
                        if (this.sendBuffer[i].id === id) {
                          this.sendBuffer.splice(i, 1);
                        }
                      }
                      ack.call(this, new Error("operation has timed out"));
                    }, timeout);
                    const fn = (...args) => {
                      this.io.clearTimeoutFn(timer);
                      ack.apply(this, args);
                    };
                    fn.withError = true;
                    this.acks[id] = fn;
                  }
                  /**
                   * Emits an event and waits for an acknowledgement
                   *
                   * @example
                   * // without timeout
                   * const response = await socket.emitWithAck("hello", "world");
                   *
                   * // with a specific timeout
                   * try {
                   *   const response = await socket.timeout(1000).emitWithAck("hello", "world");
                   * } catch (err) {
                   *   // the server did not acknowledge the event in the given delay
                   * }
                   *
                   * @return a Promise that will be fulfilled when the server acknowledges the event
                   */
                  emitWithAck(ev, ...args) {
                    return new Promise((resolve, reject) => {
                      const fn = (arg1, arg2) => {
                        return arg1 ? reject(arg1) : resolve(arg2);
                      };
                      fn.withError = true;
                      args.push(fn);
                      this.emit(ev, ...args);
                    });
                  }
                  /**
                   * Add the packet to the queue.
                   * @param args
                   * @private
                   */
                  _addToQueue(args) {
                    let ack;
                    if (typeof args[args.length - 1] === "function") {
                      ack = args.pop();
                    }
                    const packet = {
                      id: this._queueSeq++,
                      tryCount: 0,
                      pending: false,
                      args,
                      flags: Object.assign({ fromQueue: true }, this.flags)
                    };
                    args.push((err, ...responseArgs) => {
                      if (packet !== this._queue[0]) {
                        return;
                      }
                      const hasError = err !== null;
                      if (hasError) {
                        if (packet.tryCount > this._opts.retries) {
                          this._queue.shift();
                          if (ack) {
                            ack(err);
                          }
                        }
                      } else {
                        this._queue.shift();
                        if (ack) {
                          ack(null, ...responseArgs);
                        }
                      }
                      packet.pending = false;
                      return this._drainQueue();
                    });
                    this._queue.push(packet);
                    this._drainQueue();
                  }
                  /**
                   * Send the first packet of the queue, and wait for an acknowledgement from the server.
                   * @param force - whether to resend a packet that has not been acknowledged yet
                   *
                   * @private
                   */
                  _drainQueue(force = false) {
                    if (!this.connected || this._queue.length === 0) {
                      return;
                    }
                    const packet = this._queue[0];
                    if (packet.pending && !force) {
                      return;
                    }
                    packet.pending = true;
                    packet.tryCount++;
                    this.flags = packet.flags;
                    this.emit.apply(this, packet.args);
                  }
                  /**
                   * Sends a packet.
                   *
                   * @param packet
                   * @private
                   */
                  packet(packet) {
                    packet.nsp = this.nsp;
                    this.io._packet(packet);
                  }
                  /**
                   * Called upon engine `open`.
                   *
                   * @private
                   */
                  onopen() {
                    if (typeof this.auth == "function") {
                      this.auth((data) => {
                        this._sendConnectPacket(data);
                      });
                    } else {
                      this._sendConnectPacket(this.auth);
                    }
                  }
                  /**
                   * Sends a CONNECT packet to initiate the Socket.IO session.
                   *
                   * @param data
                   * @private
                   */
                  _sendConnectPacket(data) {
                    this.packet({
                      type: PacketType.CONNECT,
                      data: this._pid ? Object.assign({ pid: this._pid, offset: this._lastOffset }, data) : data
                    });
                  }
                  /**
                   * Called upon engine or manager `error`.
                   *
                   * @param err
                   * @private
                   */
                  onerror(err) {
                    if (!this.connected) {
                      this.emitReserved("connect_error", err);
                    }
                  }
                  /**
                   * Called upon engine `close`.
                   *
                   * @param reason
                   * @param description
                   * @private
                   */
                  onclose(reason, description) {
                    this.connected = false;
                    delete this.id;
                    this.emitReserved("disconnect", reason, description);
                    this._clearAcks();
                  }
                  /**
                   * Clears the acknowledgement handlers upon disconnection, since the client will never receive an acknowledgement from
                   * the server.
                   *
                   * @private
                   */
                  _clearAcks() {
                    Object.keys(this.acks).forEach((id) => {
                      const isBuffered = this.sendBuffer.some((packet) => String(packet.id) === id);
                      if (!isBuffered) {
                        const ack = this.acks[id];
                        delete this.acks[id];
                        if (ack.withError) {
                          ack.call(this, new Error("socket has been disconnected"));
                        }
                      }
                    });
                  }
                  /**
                   * Called with socket packet.
                   *
                   * @param packet
                   * @private
                   */
                  onpacket(packet) {
                    const sameNamespace = packet.nsp === this.nsp;
                    if (!sameNamespace)
                      return;
                    switch (packet.type) {
                      case PacketType.CONNECT:
                        if (packet.data && packet.data.sid) {
                          this.onconnect(packet.data.sid, packet.data.pid);
                        } else {
                          this.emitReserved("connect_error", new Error("It seems you are trying to reach a Socket.IO server in v2.x with a v3.x client, but they are not compatible (more information here: https://socket.io/docs/v3/migrating-from-2-x-to-3-0/)"));
                        }
                        break;
                      case PacketType.EVENT:
                      case PacketType.BINARY_EVENT:
                        this.onevent(packet);
                        break;
                      case PacketType.ACK:
                      case PacketType.BINARY_ACK:
                        this.onack(packet);
                        break;
                      case PacketType.DISCONNECT:
                        this.ondisconnect();
                        break;
                      case PacketType.CONNECT_ERROR:
                        this.destroy();
                        const err = new Error(packet.data.message);
                        err.data = packet.data.data;
                        this.emitReserved("connect_error", err);
                        break;
                    }
                  }
                  /**
                   * Called upon a server event.
                   *
                   * @param packet
                   * @private
                   */
                  onevent(packet) {
                    const args = packet.data || [];
                    if (null != packet.id) {
                      args.push(this.ack(packet.id));
                    }
                    if (this.connected) {
                      this.emitEvent(args);
                    } else {
                      this.receiveBuffer.push(Object.freeze(args));
                    }
                  }
                  emitEvent(args) {
                    if (this._anyListeners && this._anyListeners.length) {
                      const listeners = this._anyListeners.slice();
                      for (const listener of listeners) {
                        listener.apply(this, args);
                      }
                    }
                    super.emit.apply(this, args);
                    if (this._pid && args.length && typeof args[args.length - 1] === "string") {
                      this._lastOffset = args[args.length - 1];
                    }
                  }
                  /**
                   * Produces an ack callback to emit with an event.
                   *
                   * @private
                   */
                  ack(id) {
                    const self2 = this;
                    let sent = false;
                    return function(...args) {
                      if (sent)
                        return;
                      sent = true;
                      self2.packet({
                        type: PacketType.ACK,
                        id,
                        data: args
                      });
                    };
                  }
                  /**
                   * Called upon a server acknowledgement.
                   *
                   * @param packet
                   * @private
                   */
                  onack(packet) {
                    const ack = this.acks[packet.id];
                    if (typeof ack !== "function") {
                      return;
                    }
                    delete this.acks[packet.id];
                    if (ack.withError) {
                      packet.data.unshift(null);
                    }
                    ack.apply(this, packet.data);
                  }
                  /**
                   * Called upon server connect.
                   *
                   * @private
                   */
                  onconnect(id, pid) {
                    this.id = id;
                    this.recovered = pid && this._pid === pid;
                    this._pid = pid;
                    this.connected = true;
                    this.emitBuffered();
                    this.emitReserved("connect");
                    this._drainQueue(true);
                  }
                  /**
                   * Emit buffered events (received and emitted).
                   *
                   * @private
                   */
                  emitBuffered() {
                    this.receiveBuffer.forEach((args) => this.emitEvent(args));
                    this.receiveBuffer = [];
                    this.sendBuffer.forEach((packet) => {
                      this.notifyOutgoingListeners(packet);
                      this.packet(packet);
                    });
                    this.sendBuffer = [];
                  }
                  /**
                   * Called upon server disconnect.
                   *
                   * @private
                   */
                  ondisconnect() {
                    this.destroy();
                    this.onclose("io server disconnect");
                  }
                  /**
                   * Called upon forced client/server side disconnections,
                   * this method ensures the manager stops tracking us and
                   * that reconnections don't get triggered for this.
                   *
                   * @private
                   */
                  destroy() {
                    if (this.subs) {
                      this.subs.forEach((subDestroy) => subDestroy());
                      this.subs = void 0;
                    }
                    this.io["_destroy"](this);
                  }
                  /**
                   * Disconnects the socket manually. In that case, the socket will not try to reconnect.
                   *
                   * If this is the last active Socket instance of the {@link Manager}, the low-level connection will be closed.
                   *
                   * @example
                   * const socket = io();
                   *
                   * socket.on("disconnect", (reason) => {
                   *   // console.log(reason); prints "io client disconnect"
                   * });
                   *
                   * socket.disconnect();
                   *
                   * @return self
                   */
                  disconnect() {
                    if (this.connected) {
                      this.packet({ type: PacketType.DISCONNECT });
                    }
                    this.destroy();
                    if (this.connected) {
                      this.onclose("io client disconnect");
                    }
                    return this;
                  }
                  /**
                   * Alias for {@link disconnect()}.
                   *
                   * @return self
                   */
                  close() {
                    return this.disconnect();
                  }
                  /**
                   * Sets the compress flag.
                   *
                   * @example
                   * socket.compress(false).emit("hello");
                   *
                   * @param compress - if `true`, compresses the sending data
                   * @return self
                   */
                  compress(compress) {
                    this.flags.compress = compress;
                    return this;
                  }
                  /**
                   * Sets a modifier for a subsequent event emission that the event message will be dropped when this socket is not
                   * ready to send messages.
                   *
                   * @example
                   * socket.volatile.emit("hello"); // the server may or may not receive it
                   *
                   * @returns self
                   */
                  get volatile() {
                    this.flags.volatile = true;
                    return this;
                  }
                  /**
                   * Sets a modifier for a subsequent event emission that the callback will be called with an error when the
                   * given number of milliseconds have elapsed without an acknowledgement from the server:
                   *
                   * @example
                   * socket.timeout(5000).emit("my-event", (err) => {
                   *   if (err) {
                   *     // the server did not acknowledge the event in the given delay
                   *   }
                   * });
                   *
                   * @returns self
                   */
                  timeout(timeout) {
                    this.flags.timeout = timeout;
                    return this;
                  }
                  /**
                   * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
                   * callback.
                   *
                   * @example
                   * socket.onAny((event, ...args) => {
                   *   console.log(`got ${event}`);
                   * });
                   *
                   * @param listener
                   */
                  onAny(listener) {
                    this._anyListeners = this._anyListeners || [];
                    this._anyListeners.push(listener);
                    return this;
                  }
                  /**
                   * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
                   * callback. The listener is added to the beginning of the listeners array.
                   *
                   * @example
                   * socket.prependAny((event, ...args) => {
                   *   console.log(`got event ${event}`);
                   * });
                   *
                   * @param listener
                   */
                  prependAny(listener) {
                    this._anyListeners = this._anyListeners || [];
                    this._anyListeners.unshift(listener);
                    return this;
                  }
                  /**
                   * Removes the listener that will be fired when any event is emitted.
                   *
                   * @example
                   * const catchAllListener = (event, ...args) => {
                   *   console.log(`got event ${event}`);
                   * }
                   *
                   * socket.onAny(catchAllListener);
                   *
                   * // remove a specific listener
                   * socket.offAny(catchAllListener);
                   *
                   * // or remove all listeners
                   * socket.offAny();
                   *
                   * @param listener
                   */
                  offAny(listener) {
                    if (!this._anyListeners) {
                      return this;
                    }
                    if (listener) {
                      const listeners = this._anyListeners;
                      for (let i = 0; i < listeners.length; i++) {
                        if (listener === listeners[i]) {
                          listeners.splice(i, 1);
                          return this;
                        }
                      }
                    } else {
                      this._anyListeners = [];
                    }
                    return this;
                  }
                  /**
                   * Returns an array of listeners that are listening for any event that is specified. This array can be manipulated,
                   * e.g. to remove listeners.
                   */
                  listenersAny() {
                    return this._anyListeners || [];
                  }
                  /**
                   * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
                   * callback.
                   *
                   * Note: acknowledgements sent to the server are not included.
                   *
                   * @example
                   * socket.onAnyOutgoing((event, ...args) => {
                   *   console.log(`sent event ${event}`);
                   * });
                   *
                   * @param listener
                   */
                  onAnyOutgoing(listener) {
                    this._anyOutgoingListeners = this._anyOutgoingListeners || [];
                    this._anyOutgoingListeners.push(listener);
                    return this;
                  }
                  /**
                   * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
                   * callback. The listener is added to the beginning of the listeners array.
                   *
                   * Note: acknowledgements sent to the server are not included.
                   *
                   * @example
                   * socket.prependAnyOutgoing((event, ...args) => {
                   *   console.log(`sent event ${event}`);
                   * });
                   *
                   * @param listener
                   */
                  prependAnyOutgoing(listener) {
                    this._anyOutgoingListeners = this._anyOutgoingListeners || [];
                    this._anyOutgoingListeners.unshift(listener);
                    return this;
                  }
                  /**
                   * Removes the listener that will be fired when any event is emitted.
                   *
                   * @example
                   * const catchAllListener = (event, ...args) => {
                   *   console.log(`sent event ${event}`);
                   * }
                   *
                   * socket.onAnyOutgoing(catchAllListener);
                   *
                   * // remove a specific listener
                   * socket.offAnyOutgoing(catchAllListener);
                   *
                   * // or remove all listeners
                   * socket.offAnyOutgoing();
                   *
                   * @param [listener] - the catch-all listener (optional)
                   */
                  offAnyOutgoing(listener) {
                    if (!this._anyOutgoingListeners) {
                      return this;
                    }
                    if (listener) {
                      const listeners = this._anyOutgoingListeners;
                      for (let i = 0; i < listeners.length; i++) {
                        if (listener === listeners[i]) {
                          listeners.splice(i, 1);
                          return this;
                        }
                      }
                    } else {
                      this._anyOutgoingListeners = [];
                    }
                    return this;
                  }
                  /**
                   * Returns an array of listeners that are listening for any event that is specified. This array can be manipulated,
                   * e.g. to remove listeners.
                   */
                  listenersAnyOutgoing() {
                    return this._anyOutgoingListeners || [];
                  }
                  /**
                   * Notify the listeners for each packet sent
                   *
                   * @param packet
                   *
                   * @private
                   */
                  notifyOutgoingListeners(packet) {
                    if (this._anyOutgoingListeners && this._anyOutgoingListeners.length) {
                      const listeners = this._anyOutgoingListeners.slice();
                      for (const listener of listeners) {
                        listener.apply(this, packet.data);
                      }
                    }
                  }
                }
                ;
                function Backoff(opts) {
                  opts = opts || {};
                  this.ms = opts.min || 100;
                  this.max = opts.max || 1e4;
                  this.factor = opts.factor || 2;
                  this.jitter = opts.jitter > 0 && opts.jitter <= 1 ? opts.jitter : 0;
                  this.attempts = 0;
                }
                Backoff.prototype.duration = function() {
                  var ms = this.ms * Math.pow(this.factor, this.attempts++);
                  if (this.jitter) {
                    var rand = Math.random();
                    var deviation = Math.floor(rand * this.jitter * ms);
                    ms = (Math.floor(rand * 10) & 1) == 0 ? ms - deviation : ms + deviation;
                  }
                  return Math.min(ms, this.max) | 0;
                };
                Backoff.prototype.reset = function() {
                  this.attempts = 0;
                };
                Backoff.prototype.setMin = function(min) {
                  this.ms = min;
                };
                Backoff.prototype.setMax = function(max) {
                  this.max = max;
                };
                Backoff.prototype.setJitter = function(jitter) {
                  this.jitter = jitter;
                };
                ;
                class Manager extends Emitter {
                  constructor(uri, opts) {
                    var _a;
                    super();
                    this.nsps = {};
                    this.subs = [];
                    if (uri && "object" === typeof uri) {
                      opts = uri;
                      uri = void 0;
                    }
                    opts = opts || {};
                    opts.path = opts.path || "/socket.io";
                    this.opts = opts;
                    installTimerFunctions(this, opts);
                    this.reconnection(opts.reconnection !== false);
                    this.reconnectionAttempts(opts.reconnectionAttempts || Infinity);
                    this.reconnectionDelay(opts.reconnectionDelay || 1e3);
                    this.reconnectionDelayMax(opts.reconnectionDelayMax || 5e3);
                    this.randomizationFactor((_a = opts.randomizationFactor) !== null && _a !== void 0 ? _a : 0.5);
                    this.backoff = new Backoff({
                      min: this.reconnectionDelay(),
                      max: this.reconnectionDelayMax(),
                      jitter: this.randomizationFactor()
                    });
                    this.timeout(null == opts.timeout ? 2e4 : opts.timeout);
                    this._readyState = "closed";
                    this.uri = uri;
                    const _parser = opts.parser || socket_io_parser_build_esm_namespaceObject;
                    this.encoder = new _parser.Encoder();
                    this.decoder = new _parser.Decoder();
                    this._autoConnect = opts.autoConnect !== false;
                    if (this._autoConnect)
                      this.open();
                  }
                  reconnection(v) {
                    if (!arguments.length)
                      return this._reconnection;
                    this._reconnection = !!v;
                    if (!v) {
                      this.skipReconnect = true;
                    }
                    return this;
                  }
                  reconnectionAttempts(v) {
                    if (v === void 0)
                      return this._reconnectionAttempts;
                    this._reconnectionAttempts = v;
                    return this;
                  }
                  reconnectionDelay(v) {
                    var _a;
                    if (v === void 0)
                      return this._reconnectionDelay;
                    this._reconnectionDelay = v;
                    (_a = this.backoff) === null || _a === void 0 ? void 0 : _a.setMin(v);
                    return this;
                  }
                  randomizationFactor(v) {
                    var _a;
                    if (v === void 0)
                      return this._randomizationFactor;
                    this._randomizationFactor = v;
                    (_a = this.backoff) === null || _a === void 0 ? void 0 : _a.setJitter(v);
                    return this;
                  }
                  reconnectionDelayMax(v) {
                    var _a;
                    if (v === void 0)
                      return this._reconnectionDelayMax;
                    this._reconnectionDelayMax = v;
                    (_a = this.backoff) === null || _a === void 0 ? void 0 : _a.setMax(v);
                    return this;
                  }
                  timeout(v) {
                    if (!arguments.length)
                      return this._timeout;
                    this._timeout = v;
                    return this;
                  }
                  /**
                   * Starts trying to reconnect if reconnection is enabled and we have not
                   * started reconnecting yet
                   *
                   * @private
                   */
                  maybeReconnectOnOpen() {
                    if (!this._reconnecting && this._reconnection && this.backoff.attempts === 0) {
                      this.reconnect();
                    }
                  }
                  /**
                   * Sets the current transport `socket`.
                   *
                   * @param {Function} fn - optional, callback
                   * @return self
                   * @public
                   */
                  open(fn) {
                    if (~this._readyState.indexOf("open"))
                      return this;
                    this.engine = new Socket(this.uri, this.opts);
                    const socket = this.engine;
                    const self2 = this;
                    this._readyState = "opening";
                    this.skipReconnect = false;
                    const openSubDestroy = on(socket, "open", function() {
                      self2.onopen();
                      fn && fn();
                    });
                    const onError = (err) => {
                      this.cleanup();
                      this._readyState = "closed";
                      this.emitReserved("error", err);
                      if (fn) {
                        fn(err);
                      } else {
                        this.maybeReconnectOnOpen();
                      }
                    };
                    const errorSub = on(socket, "error", onError);
                    if (false !== this._timeout) {
                      const timeout = this._timeout;
                      const timer = this.setTimeoutFn(() => {
                        openSubDestroy();
                        onError(new Error("timeout"));
                        socket.close();
                      }, timeout);
                      if (this.opts.autoUnref) {
                        timer.unref();
                      }
                      this.subs.push(() => {
                        this.clearTimeoutFn(timer);
                      });
                    }
                    this.subs.push(openSubDestroy);
                    this.subs.push(errorSub);
                    return this;
                  }
                  /**
                   * Alias for open()
                   *
                   * @return self
                   * @public
                   */
                  connect(fn) {
                    return this.open(fn);
                  }
                  /**
                   * Called upon transport open.
                   *
                   * @private
                   */
                  onopen() {
                    this.cleanup();
                    this._readyState = "open";
                    this.emitReserved("open");
                    const socket = this.engine;
                    this.subs.push(
                      on(socket, "ping", this.onping.bind(this)),
                      on(socket, "data", this.ondata.bind(this)),
                      on(socket, "error", this.onerror.bind(this)),
                      on(socket, "close", this.onclose.bind(this)),
                      // @ts-ignore
                      on(this.decoder, "decoded", this.ondecoded.bind(this))
                    );
                  }
                  /**
                   * Called upon a ping.
                   *
                   * @private
                   */
                  onping() {
                    this.emitReserved("ping");
                  }
                  /**
                   * Called with data.
                   *
                   * @private
                   */
                  ondata(data) {
                    try {
                      this.decoder.add(data);
                    } catch (e) {
                      this.onclose("parse error", e);
                    }
                  }
                  /**
                   * Called when parser fully decodes a packet.
                   *
                   * @private
                   */
                  ondecoded(packet) {
                    nextTick(() => {
                      this.emitReserved("packet", packet);
                    }, this.setTimeoutFn);
                  }
                  /**
                   * Called upon socket error.
                   *
                   * @private
                   */
                  onerror(err) {
                    this.emitReserved("error", err);
                  }
                  /**
                   * Creates a new socket for the given `nsp`.
                   *
                   * @return {Socket}
                   * @public
                   */
                  socket(nsp, opts) {
                    let socket = this.nsps[nsp];
                    if (!socket) {
                      socket = new socket_Socket(this, nsp, opts);
                      this.nsps[nsp] = socket;
                    } else if (this._autoConnect && !socket.active) {
                      socket.connect();
                    }
                    return socket;
                  }
                  /**
                   * Called upon a socket close.
                   *
                   * @param socket
                   * @private
                   */
                  _destroy(socket) {
                    const nsps = Object.keys(this.nsps);
                    for (const nsp of nsps) {
                      const socket2 = this.nsps[nsp];
                      if (socket2.active) {
                        return;
                      }
                    }
                    this._close();
                  }
                  /**
                   * Writes a packet.
                   *
                   * @param packet
                   * @private
                   */
                  _packet(packet) {
                    const encodedPackets = this.encoder.encode(packet);
                    for (let i = 0; i < encodedPackets.length; i++) {
                      this.engine.write(encodedPackets[i], packet.options);
                    }
                  }
                  /**
                   * Clean up transport subscriptions and packet buffer.
                   *
                   * @private
                   */
                  cleanup() {
                    this.subs.forEach((subDestroy) => subDestroy());
                    this.subs.length = 0;
                    this.decoder.destroy();
                  }
                  /**
                   * Close the current socket.
                   *
                   * @private
                   */
                  _close() {
                    this.skipReconnect = true;
                    this._reconnecting = false;
                    this.onclose("forced close");
                  }
                  /**
                   * Alias for close()
                   *
                   * @private
                   */
                  disconnect() {
                    return this._close();
                  }
                  /**
                   * Called when:
                   *
                   * - the low-level engine is closed
                   * - the parser encountered a badly formatted packet
                   * - all sockets are disconnected
                   *
                   * @private
                   */
                  onclose(reason, description) {
                    var _a;
                    this.cleanup();
                    (_a = this.engine) === null || _a === void 0 ? void 0 : _a.close();
                    this.backoff.reset();
                    this._readyState = "closed";
                    this.emitReserved("close", reason, description);
                    if (this._reconnection && !this.skipReconnect) {
                      this.reconnect();
                    }
                  }
                  /**
                   * Attempt a reconnection.
                   *
                   * @private
                   */
                  reconnect() {
                    if (this._reconnecting || this.skipReconnect)
                      return this;
                    const self2 = this;
                    if (this.backoff.attempts >= this._reconnectionAttempts) {
                      this.backoff.reset();
                      this.emitReserved("reconnect_failed");
                      this._reconnecting = false;
                    } else {
                      const delay = this.backoff.duration();
                      this._reconnecting = true;
                      const timer = this.setTimeoutFn(() => {
                        if (self2.skipReconnect)
                          return;
                        this.emitReserved("reconnect_attempt", self2.backoff.attempts);
                        if (self2.skipReconnect)
                          return;
                        self2.open((err) => {
                          if (err) {
                            self2._reconnecting = false;
                            self2.reconnect();
                            this.emitReserved("reconnect_error", err);
                          } else {
                            self2.onreconnect();
                          }
                        });
                      }, delay);
                      if (this.opts.autoUnref) {
                        timer.unref();
                      }
                      this.subs.push(() => {
                        this.clearTimeoutFn(timer);
                      });
                    }
                  }
                  /**
                   * Called upon successful reconnect.
                   *
                   * @private
                   */
                  onreconnect() {
                    const attempt = this.backoff.attempts;
                    this._reconnecting = false;
                    this.backoff.reset();
                    this.emitReserved("reconnect", attempt);
                  }
                }
                ;
                const cache = {};
                function esm_lookup(uri, opts) {
                  if (typeof uri === "object") {
                    opts = uri;
                    uri = void 0;
                  }
                  opts = opts || {};
                  const parsed = url(uri, opts.path || "/socket.io");
                  const source = parsed.source;
                  const id = parsed.id;
                  const path = parsed.path;
                  const sameNamespace = cache[id] && path in cache[id]["nsps"];
                  const newConnection = opts.forceNew || opts["force new connection"] || false === opts.multiplex || sameNamespace;
                  let io;
                  if (newConnection) {
                    io = new Manager(source, opts);
                  } else {
                    if (!cache[id]) {
                      cache[id] = new Manager(source, opts);
                    }
                    io = cache[id];
                  }
                  if (parsed.query && !opts.query) {
                    opts.query = parsed.queryKey;
                  }
                  return io.socket(parsed.path, opts);
                }
                Object.assign(esm_lookup, {
                  Manager,
                  Socket: socket_Socket,
                  io: esm_lookup,
                  connect: esm_lookup
                });
                var lib = __webpack_require__2(76);
                var browser = __webpack_require__2(7833);
                var browser_default = __webpack_require__2.n(browser);
                ;
                var APP_NAME = "mediasoup-demo";
                var Logger = function() {
                  function Logger2(prefix) {
                    (0, classCallCheck.A)(this, Logger2);
                    if (prefix) {
                      this._debug = browser_default()("".concat(APP_NAME, ":").concat(prefix));
                      this._warn = browser_default()("".concat(APP_NAME, ":WARN:").concat(prefix));
                      this._error = browser_default()("".concat(APP_NAME, ":ERROR:").concat(prefix));
                    } else {
                      this._debug = browser_default()(APP_NAME);
                      this._warn = browser_default()("".concat(APP_NAME, ":WARN"));
                      this._error = browser_default()("".concat(APP_NAME, ":ERROR"));
                    }
                    browser_default().disable();
                    this._debug.log = console.info.bind(console);
                    this._warn.log = console.warn.bind(console);
                    this._error.log = console.error.bind(console);
                  }
                  return (0, createClass.A)(Logger2, [{
                    key: "debug",
                    get: function get() {
                      return this._debug;
                    }
                  }, {
                    key: "warn",
                    get: function get() {
                      return this._warn;
                    }
                  }, {
                    key: "error",
                    get: function get() {
                      return this._error;
                    }
                  }]);
                }();
                ;
                function ownKeys(e, r) {
                  var t = Object.keys(e);
                  if (Object.getOwnPropertySymbols) {
                    var o = Object.getOwnPropertySymbols(e);
                    r && (o = o.filter(function(r2) {
                      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
                    })), t.push.apply(t, o);
                  }
                  return t;
                }
                function _objectSpread(e) {
                  for (var r = 1; r < arguments.length; r++) {
                    var t = null != arguments[r] ? arguments[r] : {};
                    r % 2 ? ownKeys(Object(t), true).forEach(function(r2) {
                      (0, defineProperty.A)(e, r2, t[r2]);
                    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r2) {
                      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
                    });
                  }
                  return e;
                }
                var CryptoJS = __webpack_require__2(1396);
                var KEY = CryptoJS.enc.Latin1.parse("6gf9Oz5Y(6fOWPP@3XPv0Mwp51yfJ0HiZW^0*!9NdUuZ*VdKmRC@f))&^!Iriw)q");
                var IV = CryptoJS.enc.Latin1.parse("BHrabik^$W^y*HL@A*$4YKj(");
                function getServerConfig(_x) {
                  return _getServerConfig.apply(this, arguments);
                }
                function _getServerConfig() {
                  _getServerConfig = (0, asyncToGenerator.A)(regenerator_default().mark(function _callee2(_ref) {
                    var roomId, secret, signalingBaseUrl, host, iceServers, observabilityJwt, traces, logs, metaData, signalingUrl, socketUrl, socketPath, _yield$fetch$then$cat, data, success, error, observability;
                    return regenerator_default().wrap(function(_context2) {
                      while (1) switch (_context2.prev = _context2.next) {
                        case 0:
                          roomId = _ref.roomId, secret = _ref.secret, signalingBaseUrl = _ref.signalingBaseUrl;
                          host = "call-api.videosdk.live";
                          iceServers = [];
                          observabilityJwt = null;
                          traces = {};
                          logs = {};
                          metaData = {};
                          signalingUrl = null;
                          socketUrl = null;
                          socketPath = null;
                          _context2.next = 1;
                          return fetch("https://".concat(signalingBaseUrl, "/infra/v1/meetings/init-config"), {
                            method: "POST",
                            headers: {
                              Authorization: secret,
                              "Content-Type": "application/json"
                            },
                            body: JSON.stringify({
                              roomId
                            })
                          }).then(function() {
                            var _ref2 = (0, asyncToGenerator.A)(regenerator_default().mark(function _callee(response) {
                              var res;
                              return regenerator_default().wrap(function(_context) {
                                while (1) switch (_context.prev = _context.next) {
                                  case 0:
                                    _context.next = 1;
                                    return response.json();
                                  case 1:
                                    res = _context.sent;
                                    return _context.abrupt("return", _objectSpread({
                                      success: response.status == 200
                                    }, res));
                                  case 2:
                                  case "end":
                                    return _context.stop();
                                }
                              }, _callee);
                            }));
                            return function(_x2) {
                              return _ref2.apply(this, arguments);
                            };
                          }())["catch"](function(error2) {
                            return {
                              success: false
                            };
                          });
                        case 1:
                          _yield$fetch$then$cat = _context2.sent;
                          data = _yield$fetch$then$cat.data;
                          success = _yield$fetch$then$cat.success;
                          error = _yield$fetch$then$cat.error;
                          if (success) {
                            _context2.next = 2;
                            break;
                          }
                          throw Error(error !== null && error !== void 0 ? error : "Error getting server configurations");
                        case 2:
                          if (data) {
                            host = data.baseUrl;
                            observability = data.observability;
                            iceServers = AES_DECRYPT(data.iceServers);
                            observabilityJwt = observability.jwt;
                            traces = observability.traces;
                            logs = observability.logs;
                            metaData = observability.metaData;
                            signalingUrl = data.signalingUrl;
                            socketPath = data.socketPath;
                            socketUrl = data.socketUrl;
                          }
                          return _context2.abrupt("return", {
                            baseUrl: host,
                            iceServers,
                            observabilityJwt,
                            traces,
                            logs,
                            metaData,
                            signalingUrl,
                            socketPath,
                            socketUrl
                          });
                        case 3:
                        case "end":
                          return _context2.stop();
                      }
                    }, _callee2);
                  }));
                  return _getServerConfig.apply(this, arguments);
                }
                function AES_DECRYPT(value2) {
                  try {
                    var bytes = CryptoJS.AES.decrypt(value2, KEY, {
                      iv: IV,
                      mode: CryptoJS.mode.CBC,
                      padding: CryptoJS.pad.ZeroPadding
                    });
                    var plaintext = bytes.toString(CryptoJS.enc.Utf8);
                    return JSON.parse(plaintext);
                  } catch (error) {
                    return [];
                  }
                }
                var js_cookie = __webpack_require__2(2215);
                var js_cookie_default = __webpack_require__2.n(js_cookie);
                ;
                var USER_COOKIE = "mediasoup-demo.user";
                var DEVICES_COOKIE = "mediasoup-demo.devices";
                function getUser() {
                  return jsCookie.getJSON(USER_COOKIE);
                }
                function setUser(_ref) {
                  var displayName = _ref.displayName;
                  js_cookie_default().set(USER_COOKIE, {
                    displayName
                  });
                }
                function getDevices() {
                  return js_cookie_default().getJSON(DEVICES_COOKIE);
                }
                function setDevices(_ref2) {
                  var webcamEnabled = _ref2.webcamEnabled;
                  jsCookie.set(DEVICES_COOKIE, {
                    webcamEnabled
                  });
                }
                var random_string = __webpack_require__2(2211);
                var random_string_default = __webpack_require__2.n(random_string);
                ;
                var setRoomUrl = function setRoomUrl2(url2) {
                  return {
                    type: "SET_ROOM_URL",
                    payload: {
                      url: url2
                    }
                  };
                };
                var setRoomState = function setRoomState2(state2) {
                  return {
                    type: "SET_ROOM_STATE",
                    payload: {
                      state: state2
                    }
                  };
                };
                var setRoomActiveSpeaker = function setRoomActiveSpeaker2(peerId) {
                  return {
                    type: "SET_ROOM_ACTIVE_SPEAKER",
                    payload: {
                      peerId
                    }
                  };
                };
                var setRoomStatsPeerId = function setRoomStatsPeerId2(peerId) {
                  return {
                    type: "SET_ROOM_STATS_PEER_ID",
                    payload: {
                      peerId
                    }
                  };
                };
                var setRoomFaceDetection = function setRoomFaceDetection2(flag) {
                  return {
                    type: "SET_FACE_DETECTION",
                    payload: flag
                  };
                };
                var setMe = function setMe2(_ref) {
                  var peerId = _ref.peerId, displayName = _ref.displayName, displayNameSet = _ref.displayNameSet, device = _ref.device;
                  return {
                    type: "SET_ME",
                    payload: {
                      peerId,
                      displayName,
                      displayNameSet,
                      device
                    }
                  };
                };
                var setMediaCapabilities = function setMediaCapabilities2(_ref2) {
                  var canSendMic = _ref2.canSendMic, canSendWebcam = _ref2.canSendWebcam;
                  return {
                    type: "SET_MEDIA_CAPABILITIES",
                    payload: {
                      canSendMic,
                      canSendWebcam
                    }
                  };
                };
                var setCanChangeWebcam = function setCanChangeWebcam2(flag) {
                  return {
                    type: "SET_CAN_CHANGE_WEBCAM",
                    payload: flag
                  };
                };
                var setDisplayName = function setDisplayName2(displayName) {
                  return {
                    type: "SET_DISPLAY_NAME",
                    payload: {
                      displayName
                    }
                  };
                };
                var setAudioOnlyState = function setAudioOnlyState2(enabled) {
                  return {
                    type: "SET_AUDIO_ONLY_STATE",
                    payload: {
                      enabled
                    }
                  };
                };
                var setAudioOnlyInProgress = function setAudioOnlyInProgress2(flag) {
                  return {
                    type: "SET_AUDIO_ONLY_IN_PROGRESS",
                    payload: {
                      flag
                    }
                  };
                };
                var setAudioMutedState = function setAudioMutedState2(enabled) {
                  return {
                    type: "SET_AUDIO_MUTED_STATE",
                    payload: {
                      enabled
                    }
                  };
                };
                var setRestartIceInProgress = function setRestartIceInProgress2(flag) {
                  return {
                    type: "SET_RESTART_ICE_IN_PROGRESS",
                    payload: {
                      flag
                    }
                  };
                };
                var addProducer = function addProducer2(producer) {
                  return {
                    type: "ADD_PRODUCER",
                    payload: {
                      producer
                    }
                  };
                };
                var removeProducer = function removeProducer2(producerId) {
                  return {
                    type: "REMOVE_PRODUCER",
                    payload: {
                      producerId
                    }
                  };
                };
                var setProducerPaused = function setProducerPaused2(producerId) {
                  return {
                    type: "SET_PRODUCER_PAUSED",
                    payload: {
                      producerId
                    }
                  };
                };
                var setProducerResumed = function setProducerResumed2(producerId) {
                  return {
                    type: "SET_PRODUCER_RESUMED",
                    payload: {
                      producerId
                    }
                  };
                };
                var setProducerTrack = function setProducerTrack2(producerId, track) {
                  return {
                    type: "SET_PRODUCER_TRACK",
                    payload: {
                      producerId,
                      track
                    }
                  };
                };
                var setProducerScore = function setProducerScore2(producerId, score) {
                  return {
                    type: "SET_PRODUCER_SCORE",
                    payload: {
                      producerId,
                      score
                    }
                  };
                };
                var addDataProducer = function addDataProducer2(dataProducer) {
                  return {
                    type: "ADD_DATA_PRODUCER",
                    payload: {
                      dataProducer
                    }
                  };
                };
                var removeDataProducer = function removeDataProducer2(dataProducerId) {
                  return {
                    type: "REMOVE_DATA_PRODUCER",
                    payload: {
                      dataProducerId
                    }
                  };
                };
                var setWebcamInProgress = function setWebcamInProgress2(flag) {
                  return {
                    type: "SET_WEBCAM_IN_PROGRESS",
                    payload: {
                      flag
                    }
                  };
                };
                var setShareInProgress = function setShareInProgress2(flag) {
                  return {
                    type: "SET_SHARE_IN_PROGRESS",
                    payload: {
                      flag
                    }
                  };
                };
                var addPeer = function addPeer2(peer) {
                  return {
                    type: "ADD_PEER",
                    payload: {
                      peer
                    }
                  };
                };
                var removePeer = function removePeer2(peerId, reason) {
                  return {
                    type: "REMOVE_PEER",
                    payload: {
                      peerId,
                      reason
                    }
                  };
                };
                var setPeerDisplayName = function setPeerDisplayName2(displayName, peerId) {
                  return {
                    type: "SET_PEER_DISPLAY_NAME",
                    payload: {
                      displayName,
                      peerId
                    }
                  };
                };
                var addConsumer = function addConsumer2(consumer, peerId) {
                  return {
                    type: "ADD_CONSUMER",
                    payload: {
                      consumer,
                      peerId
                    }
                  };
                };
                var removeConsumer = function removeConsumer2(consumerId, peerId) {
                  return {
                    type: "REMOVE_CONSUMER",
                    payload: {
                      consumerId,
                      peerId
                    }
                  };
                };
                var setConsumerPaused = function setConsumerPaused2(consumerId, originator) {
                  return {
                    type: "SET_CONSUMER_PAUSED",
                    payload: {
                      consumerId,
                      originator
                    }
                  };
                };
                var setConsumerResumed = function setConsumerResumed2(consumerId, originator) {
                  return {
                    type: "SET_CONSUMER_RESUMED",
                    payload: {
                      consumerId,
                      originator
                    }
                  };
                };
                var setConsumerCurrentLayers = function setConsumerCurrentLayers2(consumerId, spatialLayer, temporalLayer) {
                  return {
                    type: "SET_CONSUMER_CURRENT_LAYERS",
                    payload: {
                      consumerId,
                      spatialLayer,
                      temporalLayer
                    }
                  };
                };
                var stateActions_setConsumerPreferredLayers = function setConsumerPreferredLayers(consumerId, spatialLayer, temporalLayer) {
                  return {
                    type: "SET_CONSUMER_PREFERRED_LAYERS",
                    payload: {
                      consumerId,
                      spatialLayer,
                      temporalLayer
                    }
                  };
                };
                var stateActions_setConsumerPriority = function setConsumerPriority(consumerId, priority) {
                  return {
                    type: "SET_CONSUMER_PRIORITY",
                    payload: {
                      consumerId,
                      priority
                    }
                  };
                };
                var setConsumerTrack = function setConsumerTrack2(consumerId, track) {
                  return {
                    type: "SET_CONSUMER_TRACK",
                    payload: {
                      consumerId,
                      track
                    }
                  };
                };
                var setConsumerScore = function setConsumerScore2(consumerId, score) {
                  return {
                    type: "SET_CONSUMER_SCORE",
                    payload: {
                      consumerId,
                      score
                    }
                  };
                };
                var addDataConsumer = function addDataConsumer2(dataConsumer, peerId) {
                  return {
                    type: "ADD_DATA_CONSUMER",
                    payload: {
                      dataConsumer,
                      peerId
                    }
                  };
                };
                var removeDataConsumer = function removeDataConsumer2(dataConsumerId, peerId) {
                  return {
                    type: "REMOVE_DATA_CONSUMER",
                    payload: {
                      dataConsumerId,
                      peerId
                    }
                  };
                };
                var addNotification = function addNotification2(notification) {
                  return {
                    type: "ADD_NOTIFICATION",
                    payload: {
                      notification
                    }
                  };
                };
                var removeNotification = function removeNotification2(notificationId) {
                  return {
                    type: "REMOVE_NOTIFICATION",
                    payload: {
                      notificationId
                    }
                  };
                };
                var removeAllNotifications = function removeAllNotifications2() {
                  return {
                    type: "REMOVE_ALL_NOTIFICATIONS"
                  };
                };
                ;
                var notify = function notify2(_ref) {
                  var _ref$type = _ref.type, type = _ref$type === void 0 ? "info" : _ref$type, text = _ref.text, title = _ref.title, timeout = _ref.timeout;
                  if (!timeout) {
                    switch (type) {
                      case "info":
                        timeout = 3e3;
                        break;
                      case "error":
                        timeout = 5e3;
                        break;
                    }
                  }
                  var notification = {
                    id: random_string_default()({
                      length: 6
                    }).toLowerCase(),
                    type,
                    title,
                    text,
                    timeout
                  };
                  return function(dispatch) {
                    dispatch(addNotification(notification));
                    setTimeout(function() {
                      dispatch(removeNotification(notification.id));
                    }, timeout);
                  };
                };
                var events2 = __webpack_require__2(7007);
                var sdkCapabilities = __webpack_require__2(1803);
                var config2 = __webpack_require__2(9027);
                var errors = __webpack_require__2(7080);
                ;
                var state = {
                  CONNECTING: "CONNECTING",
                  CONNECTED: "CONNECTED",
                  RECONNECTING: "RECONNECTING",
                  FAILED: "FAILED",
                  DISCONNECTED: "DISCONNECTED"
                };
                var LeaveReason = __webpack_require__2(1260);
                var videosdk_room_stats = __webpack_require__2(5414);
                var modes = __webpack_require__2(2107);
                var hlsEvents = __webpack_require__2(5071);
                ;
                var SPAN_ID_BYTES = 8;
                var TRACE_ID_BYTES = 16;
                var SHARED_CHAR_CODES_ARRAY = Array(32);
                function getTraceId() {
                  for (var i = 0; i < TRACE_ID_BYTES * 2; i++) {
                    SHARED_CHAR_CODES_ARRAY[i] = Math.floor(Math.random() * 16) + 48;
                    if (SHARED_CHAR_CODES_ARRAY[i] >= 58) {
                      SHARED_CHAR_CODES_ARRAY[i] += 39;
                    }
                  }
                  return String.fromCharCode.apply(null, SHARED_CHAR_CODES_ARRAY.slice(0, TRACE_ID_BYTES * 2));
                }
                function getSpanId() {
                  for (var i = 0; i < SPAN_ID_BYTES * 2; i++) {
                    SHARED_CHAR_CODES_ARRAY[i] = Math.floor(Math.random() * 16) + 48;
                    if (SHARED_CHAR_CODES_ARRAY[i] >= 58) {
                      SHARED_CHAR_CODES_ARRAY[i] += 39;
                    }
                  }
                  return String.fromCharCode.apply(null, SHARED_CHAR_CODES_ARRAY.slice(0, SPAN_ID_BYTES * 2));
                }
                function getCurrentTimeInNano() {
                  var currentTimeMillis = (/* @__PURE__ */ new Date()).getTime();
                  var currentTimeNano = currentTimeMillis * 1e6;
                  var formattedTimeNano = currentTimeNano.toString().padEnd(19, "0");
                  return Number(formattedTimeNano);
                }
                function getRandomString(length) {
                  var characters = "0123456789abcdefghijklmnopqrstuvwxyz";
                  var result = "";
                  for (var i = length; i > 0; i--) {
                    result += characters[Math.floor(Math.random() * characters.length)];
                  }
                  return result;
                }
                ;
                function OTEL_ownKeys(e, r) {
                  var t = Object.keys(e);
                  if (Object.getOwnPropertySymbols) {
                    var o = Object.getOwnPropertySymbols(e);
                    r && (o = o.filter(function(r2) {
                      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
                    })), t.push.apply(t, o);
                  }
                  return t;
                }
                function OTEL_objectSpread(e) {
                  for (var r = 1; r < arguments.length; r++) {
                    var t = null != arguments[r] ? arguments[r] : {};
                    r % 2 ? OTEL_ownKeys(Object(t), true).forEach(function(r2) {
                      (0, defineProperty.A)(e, r2, t[r2]);
                    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : OTEL_ownKeys(Object(t)).forEach(function(r2) {
                      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
                    });
                  }
                  return e;
                }
                var VideoSDKTelemetery = function() {
                  function VideoSDKTelemetery2(_ref) {
                    var _this = this;
                    var roomId = _ref.roomId, peerId = _ref.peerId, sdkName = _ref.sdkName, observabilityJwt = _ref.observabilityJwt, metaData = _ref.metaData, traces = _ref.traces;
                    (0, classCallCheck.A)(this, VideoSDKTelemetery2);
                    this._traceId = getTraceId();
                    this._rootSpanId = getSpanId();
                    this._observabilityJwt = observabilityJwt;
                    this._tracesEnabled = traces.enabled;
                    this._tracesEndpoint = traces.endPoint;
                    var randomString2 = getRandomString(8);
                    this._spans = [];
                    this._traceJSON = {
                      resourceSpans: [{
                        resource: {
                          attributes: [{
                            key: "service.name",
                            value: {
                              stringValue: "videosdk-otel"
                            }
                          }, {
                            key: "telemetry.sdk.language",
                            value: {
                              stringValue: "webjs"
                            }
                          }, {
                            key: "telemetry.sdk.name",
                            value: {
                              stringValue: "opentelemetry"
                            }
                          }, {
                            key: "telemetry.sdk.version",
                            value: {
                              stringValue: "1.14.0"
                            }
                          }, {
                            key: "sdk-version",
                            value: {
                              stringValue: "0.3.12"
                            }
                          }],
                          droppedAttributesCount: 0
                        },
                        scopeSpans: [{
                          scope: {
                            name: randomString2
                          },
                          spans: []
                        }]
                      }]
                    };
                    if (this._tracesEnabled) {
                      this.addRootSpan(roomId, peerId, sdkName, metaData);
                      setInterval(function() {
                        _this.processQueue();
                      }, 4e3);
                    }
                  }
                  return (0, createClass.A)(VideoSDKTelemetery2, [{
                    key: "addRootSpan",
                    value: function addRootSpan(roomId, peerId, sdkName, metaData) {
                      var rootSpan = {
                        traceId: this._traceId,
                        spanId: this._rootSpanId,
                        name: "room_".concat(roomId, "_peer_").concat(peerId, "_sdk_").concat(sdkName),
                        kind: 1,
                        startTimeUnixNano: getCurrentTimeInNano(),
                        endTimeUnixNano: getCurrentTimeInNano(),
                        attributes: [{
                          key: "roomId",
                          value: {
                            stringValue: roomId
                          }
                        }, {
                          key: "peerId",
                          value: {
                            stringValue: peerId
                          }
                        }, {
                          key: "sdkName",
                          value: {
                            stringValue: sdkName
                          }
                        }, {
                          key: "userId",
                          value: {
                            stringValue: metaData.userId
                          }
                        }, {
                          key: "email",
                          value: {
                            stringValue: metaData.email
                          }
                        }],
                        droppedAttributesCount: 0,
                        events: [],
                        droppedEventsCount: 0,
                        status: {
                          code: 0
                        },
                        links: [],
                        droppedLinksCount: 0
                      };
                      this._spans.push(rootSpan);
                    }
                  }, {
                    key: "addSpanToTrace",
                    value: function addSpanToTrace(spanObj) {
                      this._spans.push(spanObj);
                    }
                  }, {
                    key: "trace",
                    value: function trace(_ref2) {
                      var spanName = _ref2.spanName, _ref2$attributes = _ref2.attributes, attributes = _ref2$attributes === void 0 ? {} : _ref2$attributes, _ref2$span = _ref2.span, span = _ref2$span === void 0 ? void 0 : _ref2$span;
                      if (this._tracesEnabled) {
                        var spanId = getSpanId();
                        var startTimeUnixNano = getCurrentTimeInNano();
                        var spanObj = {
                          traceId: this._traceId,
                          spanId,
                          parentSpanId: span || this._rootSpanId,
                          name: spanName,
                          kind: 1,
                          startTimeUnixNano,
                          droppedAttributesCount: 0,
                          events: [],
                          droppedEventsCount: 0,
                          links: [],
                          droppedLinksCount: 0
                        };
                        if (Object.keys(attributes).length > 0) {
                          spanObj.attributes = Object.entries(attributes).map(function(_ref3) {
                            var _ref4 = (0, slicedToArray.A)(_ref3, 2), key = _ref4[0], value2 = _ref4[1];
                            return {
                              key,
                              value: {
                                stringValue: value2
                              }
                            };
                          });
                        }
                        this.addSpanToTrace(spanObj);
                        return spanId;
                      }
                    }
                  }, {
                    key: "traceAutoComplete",
                    value: function traceAutoComplete(_ref5) {
                      var spanName = _ref5.spanName, _ref5$attributes = _ref5.attributes, attributes = _ref5$attributes === void 0 ? {} : _ref5$attributes, _ref5$status = _ref5.status, status = _ref5$status === void 0 ? 1 : _ref5$status, _ref5$span = _ref5.span, span = _ref5$span === void 0 ? void 0 : _ref5$span, _ref5$message = _ref5.message, message = _ref5$message === void 0 ? "SUCCESS" : _ref5$message;
                      if (this._tracesEnabled) {
                        var spanId = getSpanId();
                        var startTimeUnixNano = getCurrentTimeInNano();
                        var endTimeUnixNano = getCurrentTimeInNano();
                        var spanObj = {
                          traceId: this._traceId,
                          spanId,
                          parentSpanId: span || this._rootSpanId,
                          name: spanName,
                          kind: 1,
                          startTimeUnixNano,
                          endTimeUnixNano,
                          droppedAttributesCount: 0,
                          events: [],
                          droppedEventsCount: 0,
                          links: [],
                          droppedLinksCount: 0,
                          status: {
                            code: status,
                            message
                          }
                        };
                        if (Object.keys(attributes).length > 0) {
                          spanObj.attributes = Object.entries(attributes).map(function(_ref6) {
                            var _ref7 = (0, slicedToArray.A)(_ref6, 2), key = _ref7[0], value2 = _ref7[1];
                            return {
                              key,
                              value: {
                                stringValue: value2
                              }
                            };
                          });
                        }
                        this.addSpanToTrace(spanObj);
                      }
                    }
                  }, {
                    key: "completeSpan",
                    value: function completeSpan(_ref8) {
                      var span = _ref8.span, status = _ref8.status, message = _ref8.message, _ref8$attributes = _ref8.attributes, attributes = _ref8$attributes === void 0 ? {} : _ref8$attributes;
                      if (this._tracesEnabled) {
                        var endTimeUnixNano = getCurrentTimeInNano();
                        this._spans = this._spans.map(function(obj) {
                          if (obj.spanId !== span) {
                            return obj;
                          }
                          var updatedAttributes = Object.entries(attributes).map(function(_ref9) {
                            var _ref0 = (0, slicedToArray.A)(_ref9, 2), key = _ref0[0], value2 = _ref0[1];
                            return {
                              key,
                              value: {
                                stringValue: value2
                              }
                            };
                          });
                          obj.attributes = obj.attributes ? [].concat((0, toConsumableArray.A)(obj.attributes), (0, toConsumableArray.A)(updatedAttributes)) : updatedAttributes;
                          return OTEL_objectSpread(OTEL_objectSpread({}, obj), {}, {
                            status: {
                              code: status,
                              message
                            },
                            endTimeUnixNano
                          });
                        });
                      }
                    }
                  }, {
                    key: "processQueue",
                    value: function processQueue() {
                      var _this2 = this;
                      if (this._spans.length > 0) {
                        this._traceJSON.resourceSpans[0].scopeSpans[0].spans = this._spans;
                        this._spans = [];
                        var requestOptions = {
                          method: "POST",
                          headers: {
                            Authorization: this._observabilityJwt,
                            "Content-Type": "application/json"
                          },
                          body: JSON.stringify(this._traceJSON)
                        };
                        fetch(this._tracesEndpoint, requestOptions).then(function() {
                          var _ref1 = (0, asyncToGenerator.A)(regenerator_default().mark(function _callee(response) {
                            return regenerator_default().wrap(function(_context) {
                              while (1) switch (_context.prev = _context.next) {
                                case 0:
                                  _this2._traceJSON.resourceSpans[0].scopeSpans[0].spans = [];
                                  _context.next = 1;
                                  return response.text();
                                case 1:
                                  return _context.abrupt("return", _context.sent);
                                case 2:
                                case "end":
                                  return _context.stop();
                              }
                            }, _callee);
                          }));
                          return function(_x) {
                            return _ref1.apply(this, arguments);
                          };
                        }()).then(function(data) {
                        })["catch"](function(error) {
                          _this2._spans = _this2._traceJSON.resourceSpans[0].scopeSpans[0].spans;
                          console.error("There was a problem with the POST request:", error);
                        });
                      }
                    }
                  }]);
                }();
                ;
                function videosdkLogs_ownKeys(e, r) {
                  var t = Object.keys(e);
                  if (Object.getOwnPropertySymbols) {
                    var o = Object.getOwnPropertySymbols(e);
                    r && (o = o.filter(function(r2) {
                      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
                    })), t.push.apply(t, o);
                  }
                  return t;
                }
                function videosdkLogs_objectSpread(e) {
                  for (var r = 1; r < arguments.length; r++) {
                    var t = null != arguments[r] ? arguments[r] : {};
                    r % 2 ? videosdkLogs_ownKeys(Object(t), true).forEach(function(r2) {
                      (0, defineProperty.A)(e, r2, t[r2]);
                    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : videosdkLogs_ownKeys(Object(t)).forEach(function(r2) {
                      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
                    });
                  }
                  return e;
                }
                var VideoSDKLogs = function() {
                  function VideoSDKLogs2(_ref) {
                    var roomId = _ref.roomId, peerId = _ref.peerId, logs = _ref.logs, observabilityJwt = _ref.observabilityJwt, deviceInfo = _ref.deviceInfo, sessionId = _ref.sessionId, debugMode = _ref.debugMode;
                    (0, classCallCheck.A)(this, VideoSDKLogs2);
                    var browserUserAgent = deviceInfo.browserUserAgent, deviceUserAgent = deviceInfo.deviceUserAgent, platform = deviceInfo.platform;
                    this._peerId = peerId;
                    this._roomId = roomId;
                    this._logs = logs;
                    this._observabilityJwt = observabilityJwt;
                    this._deviceInfo = deviceInfo;
                    this._sessionId = sessionId;
                    this._debugMode = debugMode;
                    this.browserOrDeviceInfo = browserUserAgent ? {
                      browserName: browserUserAgent.browser.name,
                      browserVersion: browserUserAgent.browser.version,
                      osName: browserUserAgent.os.name,
                      osVersion: browserUserAgent.os.version,
                      platform
                    } : deviceUserAgent ? videosdkLogs_objectSpread({
                      platform
                    }, deviceUserAgent) : null;
                  }
                  return (0, createClass.A)(VideoSDKLogs2, [{
                    key: "pushLogs",
                    value: function() {
                      var _pushLogs = (0, asyncToGenerator.A)(regenerator_default().mark(function _callee(_ref2) {
                        var logType, logText, attributes, _ref2$dashboardLog, dashboardLog, _this$_logs, enabled, endPoint;
                        return regenerator_default().wrap(function(_context) {
                          while (1) switch (_context.prev = _context.next) {
                            case 0:
                              logType = _ref2.logType, logText = _ref2.logText, attributes = _ref2.attributes, _ref2$dashboardLog = _ref2.dashboardLog, dashboardLog = _ref2$dashboardLog === void 0 ? false : _ref2$dashboardLog;
                              _this$_logs = this._logs, enabled = _this$_logs.enabled, endPoint = _this$_logs.endPoint;
                              if (!enabled) {
                                _context.next = 2;
                                break;
                              }
                              _context.next = 1;
                              return fetch(endPoint, {
                                method: "POST",
                                headers: {
                                  Authorization: this._observabilityJwt,
                                  "Content-Type": "application/json"
                                },
                                body: JSON.stringify({
                                  logType,
                                  logText,
                                  attributes: videosdkLogs_objectSpread(videosdkLogs_objectSpread({}, attributes), {}, {
                                    roomId: this._roomId,
                                    peerId: this._peerId,
                                    SDK: "".concat(this._deviceInfo.sdkType, "-sdk"),
                                    SDK_VERSION: this._deviceInfo.sdkVersion,
                                    sessionId: this._sessionId
                                  }, this.browserOrDeviceInfo),
                                  debugMode: this._debugMode,
                                  dashboardLog
                                })
                              }).then(function(response) {
                                return response.json();
                              })["catch"](function(error) {
                                console.log("error", error);
                                return {};
                              });
                            case 1:
                              return _context.abrupt("return", _context.sent);
                            case 2:
                              return _context.abrupt("return", null);
                            case 3:
                            case "end":
                              return _context.stop();
                          }
                        }, _callee, this);
                      }));
                      function pushLogs(_x) {
                        return _pushLogs.apply(this, arguments);
                      }
                      return pushLogs;
                    }()
                  }]);
                }();
                var media = __webpack_require__2(4973);
                var possibleConstructorReturn = __webpack_require__2(388);
                var getPrototypeOf = __webpack_require__2(3954);
                var inherits = __webpack_require__2(5501);
                var setPrototypeOf = __webpack_require__2(3662);
                ;
                function _isNativeFunction(t) {
                  try {
                    return -1 !== Function.toString.call(t).indexOf("[native code]");
                  } catch (n) {
                    return "function" == typeof t;
                  }
                }
                ;
                function _isNativeReflectConstruct() {
                  try {
                    var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
                    }));
                  } catch (t2) {
                  }
                  return (_isNativeReflectConstruct = function _isNativeReflectConstruct2() {
                    return !!t;
                  })();
                }
                ;
                function _construct(t, e, r) {
                  if (_isNativeReflectConstruct()) return Reflect.construct.apply(null, arguments);
                  var o = [null];
                  o.push.apply(o, e);
                  var p = new (t.bind.apply(t, o))();
                  return r && (0, setPrototypeOf.A)(p, r.prototype), p;
                }
                ;
                function _wrapNativeSuper(t) {
                  var r = "function" == typeof Map ? /* @__PURE__ */ new Map() : void 0;
                  return _wrapNativeSuper = function _wrapNativeSuper2(t2) {
                    if (null === t2 || !_isNativeFunction(t2)) return t2;
                    if ("function" != typeof t2) throw new TypeError("Super expression must either be null or a function");
                    if (void 0 !== r) {
                      if (r.has(t2)) return r.get(t2);
                      r.set(t2, Wrapper);
                    }
                    function Wrapper() {
                      return _construct(t2, arguments, (0, getPrototypeOf.A)(this).constructor);
                    }
                    return Wrapper.prototype = Object.create(t2.prototype, {
                      constructor: {
                        value: Wrapper,
                        enumerable: false,
                        writable: true,
                        configurable: true
                      }
                    }), (0, setPrototypeOf.A)(Wrapper, t2);
                  }, _wrapNativeSuper(t);
                }
                ;
                function _callSuper(t, o, e) {
                  return o = (0, getPrototypeOf.A)(o), (0, possibleConstructorReturn.A)(t, errors_isNativeReflectConstruct() ? Reflect.construct(o, e || [], (0, getPrototypeOf.A)(t).constructor) : o.apply(t, e));
                }
                function errors_isNativeReflectConstruct() {
                  try {
                    var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
                    }));
                  } catch (t2) {
                  }
                  return (errors_isNativeReflectConstruct = function _isNativeReflectConstruct2() {
                    return !!t;
                  })();
                }
                var VideoSdkError = function(_Error) {
                  function VideoSdkError2(code, message) {
                    var _this;
                    (0, classCallCheck.A)(this, VideoSdkError2);
                    _this = _callSuper(this, VideoSdkError2, [message || "an error has occured"]);
                    (0, defineProperty.A)(_this, "code", void 0);
                    _this.name = "VideoSdkError";
                    _this.code = code;
                    return _this;
                  }
                  (0, inherits.A)(VideoSdkError2, _Error);
                  return (0, createClass.A)(VideoSdkError2);
                }(_wrapNativeSuper(Error));
                var CryptorErrorReason;
                (function(CryptorErrorReason2) {
                  CryptorErrorReason2[CryptorErrorReason2["InvalidKey"] = 0] = "InvalidKey";
                  CryptorErrorReason2[CryptorErrorReason2["MissingKey"] = 1] = "MissingKey";
                  CryptorErrorReason2[CryptorErrorReason2["InternalError"] = 2] = "InternalError";
                })(CryptorErrorReason || (CryptorErrorReason = {}));
                var DeviceUnsupportedError = function(_VideoSdkError2) {
                  function DeviceUnsupportedError2(message) {
                    var _this2;
                    (0, classCallCheck.A)(this, DeviceUnsupportedError2);
                    _this2 = _callSuper(this, DeviceUnsupportedError2, [21, message !== null && message !== void 0 ? message : "device is unsupported"]);
                    _this2.name = "DeviceUnsupportedError";
                    return _this2;
                  }
                  (0, inherits.A)(DeviceUnsupportedError2, _VideoSdkError2);
                  return (0, createClass.A)(DeviceUnsupportedError2);
                }(VideoSdkError);
                var constants = __webpack_require__2(1806);
                var e2ee_events = __webpack_require__2(6746);
                var utils = __webpack_require__2(8278);
                ;
                function normalizeKind(share, kind) {
                  return share ? kind == "audio" ? "shareAudio" : "share" : kind;
                }
                ;
                function _createForOfIteratorHelper(r, e) {
                  var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
                  if (!t) {
                    if (Array.isArray(r) || (t = _unsupportedIterableToArray2(r)) || e && r && "number" == typeof r.length) {
                      t && (r = t);
                      var _n = 0, F = function F2() {
                      };
                      return { s: F, n: function n() {
                        return _n >= r.length ? { done: true } : { done: false, value: r[_n++] };
                      }, e: function e2(r2) {
                        throw r2;
                      }, f: F };
                    }
                    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
                  }
                  var o, a = true, u = false;
                  return { s: function s() {
                    t = t.call(r);
                  }, n: function n() {
                    var r2 = t.next();
                    return a = r2.done, r2;
                  }, e: function e2(r2) {
                    u = true, o = r2;
                  }, f: function f() {
                    try {
                      a || null == t["return"] || t["return"]();
                    } finally {
                      if (u) throw o;
                    }
                  } };
                }
                function _unsupportedIterableToArray2(r, a) {
                  if (r) {
                    if ("string" == typeof r) return _arrayLikeToArray2(r, a);
                    var t = {}.toString.call(r).slice(8, -1);
                    return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray2(r, a) : void 0;
                  }
                }
                function _arrayLikeToArray2(r, a) {
                  (null == a || a > r.length) && (a = r.length);
                  for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];
                  return n;
                }
                function E2eeManager_callSuper(t, o, e) {
                  return o = (0, getPrototypeOf.A)(o), (0, possibleConstructorReturn.A)(t, E2eeManager_isNativeReflectConstruct() ? Reflect.construct(o, e || [], (0, getPrototypeOf.A)(t).constructor) : o.apply(t, e));
                }
                function E2eeManager_isNativeReflectConstruct() {
                  try {
                    var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
                    }));
                  } catch (t2) {
                  }
                  return (E2eeManager_isNativeReflectConstruct = function _isNativeReflectConstruct2() {
                    return !!t;
                  })();
                }
                var E2EEManager = function(_EventEmitter) {
                  function E2EEManager2(options) {
                    var _this;
                    (0, classCallCheck.A)(this, E2EEManager2);
                    _this = E2eeManager_callSuper(this, E2EEManager2);
                    _this.onWorkerMessage = function(ev) {
                      var _a, _b;
                      var _ev$data = ev.data, kind = _ev$data.kind, data = _ev$data.data;
                      switch (kind) {
                        case "error":
                          console.error(data.error.message);
                          _this.emit(e2ee_events.KS.EncryptionError, data.error);
                          break;
                        case "initAck":
                          if (data.enabled) {
                            _this.keyProvider.getKeys().forEach(function(keyInfo) {
                              _this.postKey(keyInfo);
                            });
                          }
                          break;
                        case "enable":
                          if (data.enabled) {
                            _this.keyProvider.getKeys().forEach(function(keyInfo) {
                              _this.postKey(keyInfo);
                            });
                          }
                          if (_this.encryptionEnabled !== data.enabled && data.participantIdentity === _this.room._peerId) {
                            _this.emit(e2ee_events.KS.ParticipantEncryptionStatusChanged, data.enabled, _this.room.localParticipant);
                            _this.encryptionEnabled = data.enabled;
                          } else if (data.participantIdentity) {
                            var participant = (_b = _this.room) === null || _b === void 0 ? void 0 : _b.getParticipantByIdentity(data.participantIdentity);
                            if (!participant) {
                              throw TypeError("couldn't set encryption status, participant not found".concat(data.participantIdentity));
                            }
                            _this.emit(e2ee_events.KS.ParticipantEncryptionStatusChanged, data.enabled, participant);
                          }
                          break;
                        case "ratchetKey":
                          _this.keyProvider.emit(e2ee_events.fo.KeyRatcheted, data.material, data.keyIndex);
                          break;
                        case "e2eeStateChange":
                          _this.emit(e2ee_events.KS.E2EEStateChange, data);
                          break;
                        default:
                          console.log("unknown message kind", ev);
                          break;
                      }
                    };
                    _this.onWorkerError = function(ev) {
                      var _ev$error;
                      console.error("Worker encountered an error:", ev);
                      console.error("Error message:", ev.message);
                      console.error("Error filename:", ev.filename);
                      console.error("Error line number:", ev.lineno);
                      console.error("Error stack:", (_ev$error = ev.error) === null || _ev$error === void 0 ? void 0 : _ev$error.stack);
                    };
                    _this.keyProvider = options.keyProvider;
                    _this.worker = options.worker;
                    _this.encryptionEnabled = false;
                    return _this;
                  }
                  (0, inherits.A)(E2EEManager2, _EventEmitter);
                  return (0, createClass.A)(E2EEManager2, [{
                    key: "setup",
                    value: function setup(room) {
                      if (!(0, utils.Ag)()) {
                        throw new DeviceUnsupportedError("tried to setup end-to-end encryption on an unsupported browser");
                      }
                      console.info("setting up e2ee");
                      if (room !== this.room) {
                        this.room = room;
                        this.setupEventListeners(room, this.keyProvider);
                        this.handleE2EEManagerEvents();
                        var msg = {
                          kind: "init",
                          data: {
                            keyProviderOptions: this.keyProvider.getOptions()
                          }
                        };
                        console.log("msg", msg);
                        if (this.worker) {
                          console.info("initializing worker", {
                            worker: this.worker
                          });
                          this.worker.onmessage = this.onWorkerMessage;
                          this.worker.onerror = this.onWorkerError;
                          this.worker.postMessage(msg);
                        }
                      }
                    }
                    /**
                     * @internal
                     */
                  }, {
                    key: "setParticipantCryptorEnabled",
                    value: function setParticipantCryptorEnabled(enabled, participantIdentity) {
                      console.debug("set e2ee to ".concat(enabled, " for participant ").concat(participantIdentity));
                      this.postEnable(enabled, participantIdentity);
                    }
                    /**
                     * @internal
                     */
                  }, {
                    key: "setSifTrailer",
                    value: function setSifTrailer(trailer) {
                      if (!trailer || trailer.length === 0) {
                        console.warn("ignoring server sent trailer as it's empty");
                      } else {
                        this.postSifTrailer(trailer);
                      }
                    }
                    // setupEngine(engine) {
                    //   engine.on(EngineEvent.RTPVideoMapUpdate, (rtpMap) => {
                    //     this.postRTPMap(rtpMap);
                    //   });
                    // }
                  }, {
                    key: "setupEventListeners",
                    value: function setupEventListeners(room, keyProvider) {
                      var _this2 = this;
                      keyProvider.on(e2ee_events.fo.SetKey, function(keyInfo) {
                        console.log("### keyInfo", keyInfo);
                        _this2.postKey(keyInfo);
                      }).on(e2ee_events.fo.RatchetRequest, function(participantId, keyIndex) {
                        return _this2.postRatchetRequest(participantId, keyIndex);
                      });
                    }
                  }, {
                    key: "postRatchetRequest",
                    value: function postRatchetRequest(participantIdentity, keyIndex) {
                      if (!this.worker) {
                        throw Error("could not ratchet key, worker is missing");
                      }
                      var msg = {
                        kind: "ratchetRequest",
                        data: {
                          participantIdentity,
                          keyIndex
                        }
                      };
                      this.worker.postMessage(msg);
                    }
                  }, {
                    key: "postKey",
                    value: function postKey(_ref) {
                      var key = _ref.key, participantIdentity = _ref.participantIdentity, keyIndex = _ref.keyIndex;
                      var _a;
                      if (!this.worker) {
                        throw Error("could not set key, worker is missing");
                      }
                      var msg = {
                        kind: "setKey",
                        data: {
                          participantIdentity,
                          isPublisher: participantIdentity === this.room._peerId,
                          key,
                          keyIndex
                        }
                      };
                      this.worker.postMessage(msg);
                    }
                  }, {
                    key: "postEnable",
                    value: function postEnable(enabled, participantIdentity) {
                      if (this.worker) {
                        var enableMsg = {
                          kind: "enable",
                          data: {
                            enabled,
                            participantIdentity
                          }
                        };
                        this.worker.postMessage(enableMsg);
                      } else {
                        throw new ReferenceError("failed to enable e2ee, worker is not ready");
                      }
                    }
                  }, {
                    key: "postRTPMap",
                    value: function postRTPMap(map) {
                      var _a;
                      if (!this.worker) {
                        throw TypeError("could not post rtp map, worker is missing");
                      }
                      if (!((_a = this.room) === null || _a === void 0 ? void 0 : _a._peerId)) {
                        throw TypeError("could not post rtp map, local participant identity is missing");
                      }
                      var msg = {
                        kind: "setRTPMap",
                        data: {
                          map,
                          participantIdentity: this.room._peerId
                        }
                      };
                      this.worker.postMessage(msg);
                    }
                  }, {
                    key: "postSifTrailer",
                    value: function postSifTrailer(trailer) {
                      if (!this.worker) {
                        throw Error("could not post SIF trailer, worker is missing");
                      }
                      var msg = {
                        kind: "setSifTrailer",
                        data: {
                          trailer
                        }
                      };
                      this.worker.postMessage(msg);
                    }
                  }, {
                    key: "setupE2EEReceiver",
                    value: function setupE2EEReceiver(consumer, peerId) {
                      var _consumer$appData;
                      this.handleReceiver(consumer, consumer.rtpReceiver, consumer.track.id, peerId, this.extractCodec(consumer.rtpParameters.codecs), normalizeKind((_consumer$appData = consumer.appData) === null || _consumer$appData === void 0 ? void 0 : _consumer$appData.share, consumer.kind));
                    }
                  }, {
                    key: "setupE2EESender",
                    value: function setupE2EESender(producer) {
                      var _producer$appData;
                      if (!producer) {
                        console.error("Producer is required to setup E2EE sender");
                        return;
                      }
                      this.handleSender(producer.rtpSender, producer.track.id, this.extractCodec(producer.rtpParameters.codecs), normalizeKind((_producer$appData = producer.appData) === null || _producer$appData === void 0 ? void 0 : _producer$appData.share, producer.kind), this.room._peerId);
                    }
                    /**
                     * Handles the given {@code RTCRtpReceiver} by creating a {@code TransformStream} which will inject
                     * a frame decoder.
                     *
                     */
                  }, {
                    key: "handleReceiver",
                    value: function() {
                      var _handleReceiver = (0, asyncToGenerator.A)(regenerator_default().mark(function _callee(consumer, receiver, trackId, participantIdentity, codec, mediaKind) {
                        var options, _consumer$appData2, _msg, writable, readable, msg;
                        return regenerator_default().wrap(function(_context) {
                          while (1) switch (_context.prev = _context.next) {
                            case 0:
                              if (this.worker) {
                                _context.next = 1;
                                break;
                              }
                              return _context.abrupt("return");
                            case 1:
                              if (!(0, utils.Wm)()) {
                                _context.next = 2;
                                break;
                              }
                              options = {
                                kind: "decode",
                                participantIdentity,
                                trackId: consumer.track.id,
                                codec
                              };
                              receiver.transform = new RTCRtpScriptTransform(this.worker, options);
                              _context.next = 5;
                              break;
                            case 2:
                              if (!(constants.$Q in receiver && codec)) {
                                _context.next = 3;
                                break;
                              }
                              _msg = {
                                kind: "updateCodec",
                                data: {
                                  trackId,
                                  codec,
                                  participantIdentity
                                }
                              };
                              this.worker.postMessage(_msg);
                              return _context.abrupt("return");
                            case 3:
                              writable = receiver.writableStream;
                              readable = receiver.readableStream;
                              if (!(!writable || !readable)) {
                                _context.next = 4;
                                break;
                              }
                              console.error("no writable or readable stream");
                              return _context.abrupt("return");
                            case 4:
                              msg = {
                                kind: "decode",
                                data: {
                                  readableStream: readable,
                                  writableStream: writable,
                                  trackId,
                                  codec,
                                  participantIdentity,
                                  mediaKind,
                                  peerId: (_consumer$appData2 = consumer.appData) === null || _consumer$appData2 === void 0 ? void 0 : _consumer$appData2.peerId
                                }
                              };
                              this.worker.postMessage(msg, [readable, writable]);
                            case 5:
                              receiver[constants.$Q] = true;
                            case 6:
                            case "end":
                              return _context.stop();
                          }
                        }, _callee, this);
                      }));
                      function handleReceiver(_x, _x2, _x3, _x4, _x5, _x6) {
                        return _handleReceiver.apply(this, arguments);
                      }
                      return handleReceiver;
                    }()
                  }, {
                    key: "handleSender",
                    value: function handleSender(sender, trackId, codec, mediaKind, peerId) {
                      var _a;
                      if (constants.$Q in sender || !this.worker) {
                        console.error("### sender already set up");
                        return;
                      }
                      if (!((_a = this.room) === null || _a === void 0 ? void 0 : _a._peerId) || this.room._peerId === "") {
                        throw TypeError("local identity needs to be known in order to set up encrypted sender");
                      }
                      if ((0, utils.Wm)()) {
                        console.info("### initialize script transform");
                        var options = {
                          kind: "encode",
                          participantIdentity: this.room._peerId,
                          trackId,
                          codec,
                          mediaKind,
                          peerId
                        };
                        sender.transform = new RTCRtpScriptTransform(this.worker, options);
                      } else {
                        try {
                          var senderStreams = sender.senderStreams;
                          if (senderStreams) {
                            var msg = {
                              kind: "encode",
                              data: {
                                readableStream: senderStreams.readable,
                                writableStream: senderStreams.writable,
                                codec,
                                trackId,
                                participantIdentity: this.room._peerId,
                                mediaKind,
                                peerId
                              }
                            };
                            this.worker.postMessage(msg, [senderStreams.readable, senderStreams.writable]);
                          } else {
                            console.error("Error no sender streams found");
                          }
                        } catch (error) {
                          console.log("Error in handle sender ", error);
                        }
                      }
                      sender[constants.$Q] = true;
                    }
                  }, {
                    key: "handleE2EEManagerEvents",
                    value: function handleE2EEManagerEvents() {
                      var _this3 = this;
                      this.on("NEW_CONSUMER", function(_ref2) {
                        var consumer = _ref2.consumer, peerId = _ref2.peerId;
                        console.log("NEW_CONSUMER", consumer);
                        _this3.setupE2EEReceiver(consumer, peerId);
                      });
                      this.on("NEW_PRODUCER", function(producer) {
                        _this3.setupE2EESender(producer);
                      });
                    }
                  }, {
                    key: "extractCodec",
                    value: function extractCodec(codecs) {
                      var codec = "";
                      var _iterator = _createForOfIteratorHelper(codecs), _step;
                      try {
                        for (_iterator.s(); !(_step = _iterator.n()).done; ) {
                          var _codec2 = _step.value;
                          var _codec = _codec2.mimeType.split("/")[1].toLowerCase();
                          if (this.kind === "audio") {
                            if (constants.Ts.includes(_codec)) {
                              _codec2 = _codec;
                              break;
                            }
                          } else {
                            if (constants.ue.includes(_codec)) {
                              _codec2 = _codec;
                              break;
                            }
                          }
                        }
                      } catch (err) {
                        _iterator.e(err);
                      } finally {
                        _iterator.f();
                      }
                      return codec;
                    }
                  }]);
                }(events2.EventEmitter);
                ;
                var WORKER_URL = "https://cdn.videosdk.live/e2ee/0.0.1/bundle.js";
                function createE2EEWorker() {
                  return _createE2EEWorker.apply(this, arguments);
                }
                function _createE2EEWorker() {
                  _createE2EEWorker = (0, asyncToGenerator.A)(regenerator_default().mark(function _callee() {
                    var response, workerCode, blob, blobUrl;
                    return regenerator_default().wrap(function(_context) {
                      while (1) switch (_context.prev = _context.next) {
                        case 0:
                          _context.next = 1;
                          return fetch(WORKER_URL);
                        case 1:
                          response = _context.sent;
                          if (response.ok) {
                            _context.next = 2;
                            break;
                          }
                          throw new Error("Failed to load worker script: ".concat(response.statusText));
                        case 2:
                          _context.next = 3;
                          return response.text();
                        case 3:
                          workerCode = _context.sent;
                          blob = new Blob([workerCode], {
                            type: "application/javascript"
                          });
                          blobUrl = URL.createObjectURL(blob);
                          return _context.abrupt("return", new Worker(blobUrl));
                        case 4:
                        case "end":
                          return _context.stop();
                      }
                    }, _callee);
                  }));
                  return _createE2EEWorker.apply(this, arguments);
                }
                var KeyProvider = __webpack_require__2(9633);
                var src = __webpack_require__2(3115);
                var reliabilityModes = __webpack_require__2(2067);
                ;
                function RoomClient_createForOfIteratorHelper(r, e) {
                  var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
                  if (!t) {
                    if (Array.isArray(r) || (t = RoomClient_unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) {
                      t && (r = t);
                      var _n = 0, F = function F2() {
                      };
                      return { s: F, n: function n() {
                        return _n >= r.length ? { done: true } : { done: false, value: r[_n++] };
                      }, e: function e2(r2) {
                        throw r2;
                      }, f: F };
                    }
                    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
                  }
                  var o, a = true, u = false;
                  return { s: function s() {
                    t = t.call(r);
                  }, n: function n() {
                    var r2 = t.next();
                    return a = r2.done, r2;
                  }, e: function e2(r2) {
                    u = true, o = r2;
                  }, f: function f() {
                    try {
                      a || null == t["return"] || t["return"]();
                    } finally {
                      if (u) throw o;
                    }
                  } };
                }
                function RoomClient_unsupportedIterableToArray(r, a) {
                  if (r) {
                    if ("string" == typeof r) return RoomClient_arrayLikeToArray(r, a);
                    var t = {}.toString.call(r).slice(8, -1);
                    return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? RoomClient_arrayLikeToArray(r, a) : void 0;
                  }
                }
                function RoomClient_arrayLikeToArray(r, a) {
                  (null == a || a > r.length) && (a = r.length);
                  for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];
                  return n;
                }
                function RoomClient_ownKeys(e, r) {
                  var t = Object.keys(e);
                  if (Object.getOwnPropertySymbols) {
                    var o = Object.getOwnPropertySymbols(e);
                    r && (o = o.filter(function(r2) {
                      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
                    })), t.push.apply(t, o);
                  }
                  return t;
                }
                function RoomClient_objectSpread(e) {
                  for (var r = 1; r < arguments.length; r++) {
                    var t = null != arguments[r] ? arguments[r] : {};
                    r % 2 ? RoomClient_ownKeys(Object(t), true).forEach(function(r2) {
                      (0, defineProperty.A)(e, r2, t[r2]);
                    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : RoomClient_ownKeys(Object(t)).forEach(function(r2) {
                      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
                    });
                  }
                  return e;
                }
                function _classPrivateMethodInitSpec(e, a) {
                  _checkPrivateRedeclaration(e, a), a.add(e);
                }
                function _checkPrivateRedeclaration(e, t) {
                  if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object");
                }
                function _assertClassBrand(e, t, n) {
                  if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n;
                  throw new TypeError("Private element is not present on this object");
                }
                var VIDEO_LAYERS = {
                  sd: {
                    low: {
                      s: 0,
                      t: 2
                    },
                    med: {
                      s: 0,
                      t: 2
                    },
                    high: {
                      s: 1,
                      t: 2
                    },
                    s0t0: {
                      s: 0,
                      t: 0
                    },
                    s0t1: {
                      s: 0,
                      t: 1
                    },
                    s0t2: {
                      s: 0,
                      t: 2
                    },
                    s1t0: {
                      s: 1,
                      t: 0
                    },
                    s1t1: {
                      s: 1,
                      t: 1
                    },
                    s1t2: {
                      s: 1,
                      t: 2
                    },
                    s2t0: {
                      s: 2,
                      t: 0
                    },
                    s2t1: {
                      s: 2,
                      t: 1
                    },
                    s2t2: {
                      s: 2,
                      t: 2
                    }
                  },
                  hd: {
                    low: {
                      s: 0,
                      t: 2
                    },
                    med: {
                      s: 1,
                      t: 2
                    },
                    high: {
                      s: 2,
                      t: 2
                    },
                    s0t0: {
                      s: 0,
                      t: 0
                    },
                    s0t1: {
                      s: 0,
                      t: 1
                    },
                    s0t2: {
                      s: 0,
                      t: 2
                    },
                    s1t0: {
                      s: 1,
                      t: 0
                    },
                    s1t1: {
                      s: 1,
                      t: 1
                    },
                    s1t2: {
                      s: 1,
                      t: 2
                    },
                    s2t0: {
                      s: 2,
                      t: 0
                    },
                    s2t1: {
                      s: 2,
                      t: 1
                    },
                    s2t2: {
                      s: 2,
                      t: 2
                    }
                  }
                };
                var VIDEO_CONSTRAINS = {
                  qvga: {
                    width: {
                      ideal: 320
                    },
                    height: {
                      ideal: 240
                    }
                  },
                  vga: {
                    width: {
                      ideal: 640
                    },
                    height: {
                      ideal: 480
                    }
                  },
                  // sd: { width: { ideal: 640 }, height: { ideal: 360 }, frameRate: { max: 24 } },
                  sd: {
                    width: {
                      ideal: 1280
                    },
                    height: {
                      ideal: 720
                    },
                    frameRate: {
                      ideal: 24
                    }
                  },
                  hd: {
                    width: {
                      ideal: 1280
                    },
                    height: {
                      ideal: 720
                    },
                    frameRate: {
                      ideal: 24
                    }
                  }
                  // hd: { width: { ideal: 960 }, height: { ideal: 540 }, frameRate: { max: 24 } },
                  // hd: { width: { ideal: 854 }, height: { ideal: 480 }, frameRate: { max: 24 } },
                  // hd: { width: { ideal: 640 }, height: { ideal: 360 }, frameRate: { max: 24 } },
                };
                var WEBCAM_SIMULCAST_ENCODINGS = {
                  sd: [{
                    scaleResolutionDownBy: 6
                  }, {
                    scaleResolutionDownBy: 4
                  }, {
                    scaleResolutionDownBy: 2
                  }],
                  // 1280x720
                  hd: [{
                    scaleResolutionDownBy: 4
                  }, {
                    scaleResolutionDownBy: 2
                  }, {
                    scaleResolutionDownBy: 1
                  }]
                };
                var WEBCAM_KSVC_ENCODINGS = [{
                  scalabilityMode: "S3T3_KEY"
                }];
                var SCREEN_SHARING_SIMULCAST_ENCODINGS = [
                  // { dtx: true, maxBitrate: 1500000 },
                  {
                    dtx: true,
                    maxFramerate: 30
                  }
                ];
                var SCREEN_SHARING_SVC_ENCODINGS = [{
                  scalabilityMode: "S3T3",
                  dtx: true
                }];
                var EXTERNAL_VIDEO_SRC = "/resources/videos/video-audio-stereo.mp4";
                var logger = new Logger("RoomClient");
                var store;
                var _RoomClient_brand = /* @__PURE__ */ new WeakSet();
                var RoomClient = function() {
                  function RoomClient2(_ref) {
                    var roomId = _ref.roomId, peerId = _ref.peerId, secret = _ref.secret, displayName = _ref.displayName, device = _ref.device, handlerName = _ref.handlerName, useSimulcast = _ref.useSimulcast, forceTcp = _ref.forceTcp, mode = _ref.mode, forceH264 = _ref.forceH264, forceVP9 = _ref.forceVP9, svc = _ref.svc, datachannel = _ref.datachannel, externalVideo = _ref.externalVideo, micEnabled = _ref.micEnabled, webcamEnabled = _ref.webcamEnabled, maxResolution = _ref.maxResolution, useSpartialLayerAnalytics = _ref.useSpartialLayerAnalytics, _deviceInfo = _ref._deviceInfo, customCameraVideoTrack = _ref.customCameraVideoTrack, customMicrophoneAudioTrack = _ref.customMicrophoneAudioTrack, autoConsume = _ref.autoConsume, preferredProtocol = _ref.preferredProtocol, signalingBaseUrl = _ref.signalingBaseUrl, metaData = _ref.metaData, translationLanguage = _ref.translationLanguage, speakingLanguage = _ref.speakingLanguage, defaultCameraIndex = _ref.defaultCameraIndex, debugMode = _ref.debugMode, _keyProvider = _ref.keyProvider, defaultCamera = _ref.defaultCamera;
                    (0, classCallCheck.A)(this, RoomClient2);
                    _classPrivateMethodInitSpec(this, _RoomClient_brand);
                    (0, defineProperty.A)(this, "e2eeManager", null);
                    logger.debug('constructor() [roomId:"%s", peerId:"%s", displayName:"%s", device:%s]', roomId, peerId, displayName, device.flag);
                    this.useSpartialLayerAnalytics = useSpartialLayerAnalytics || false;
                    this._deviceInfo = _deviceInfo;
                    this._eventEmitter = new events2.EventEmitter();
                    this._closed = false;
                    this._displayName = displayName;
                    this._device = device;
                    this._forceTcp = forceTcp;
                    this._preferredProtocol = preferredProtocol;
                    this._defaultCamera = defaultCamera;
                    var produce;
                    var consume;
                    switch (mode) {
                      case modes.nI.CONFERENCE:
                      case modes.nI.SEND_AND_RECV:
                        produce = true;
                        consume = true;
                        break;
                      case modes.nI.RECV_ONLY:
                        produce = false;
                        consume = true;
                        break;
                      default:
                        produce = false;
                        consume = false;
                    }
                    this._mode = mode;
                    this._produce = produce;
                    this._consume = consume;
                    this._forceH264 = Boolean(forceH264);
                    this._forceVP9 = Boolean(forceVP9);
                    this._micEnabled = Boolean(micEnabled);
                    this._webcamEnabled = Boolean(webcamEnabled);
                    this._externalVideo = null;
                    this._externalVideoStream = null;
                    this._nextDataChannelTestNumber = 0;
                    if (externalVideo) {
                      this._externalVideo = document.createElement("video");
                      this._externalVideo.controls = true;
                      this._externalVideo.loop = true;
                      this._externalVideo.setAttribute("playsinline", "");
                      this._externalVideo.src = externalVideo;
                      this._externalVideo.play()["catch"](function(error) {
                        return logger.warn("externalVideo.play() failed:%o", error);
                      });
                    }
                    this._handlerName = handlerName;
                    this._useSimulcast = useSimulcast;
                    this._socketUrl = "";
                    this._secret = secret;
                    this._peerId = peerId;
                    this._roomId = roomId;
                    this._baseUrl = "";
                    this._webSocket = null;
                    this._mediasoupDevice = null;
                    this._sendTransport = null;
                    this._recvTransport = null;
                    this._micProducer = null;
                    this._webcamProducer = null;
                    this._shareProducer = null;
                    this._shareAudioProducer = null;
                    this._reliableDataProducer = null;
                    this._unreliableDataProducer = null;
                    this._consumers = /* @__PURE__ */ new Map();
                    this._dataConsumers = /* @__PURE__ */ new Map();
                    this._mics = /* @__PURE__ */ new Map();
                    this._mic = {
                      device: null
                    };
                    this._webcams = /* @__PURE__ */ new Map();
                    this._webcam = {
                      device: null,
                      resolution: maxResolution || "hd"
                    };
                    this._pinnedParticipants = /* @__PURE__ */ new Map();
                    if (svc) {
                      WEBCAM_KSVC_ENCODINGS[0].scalabilityMode = "".concat(svc, "_KEY");
                      SCREEN_SHARING_SVC_ENCODINGS[0].scalabilityMode = svc;
                    }
                    this.customCameraVideoTrack = customCameraVideoTrack;
                    this.customMicrophoneAudioTrack = customMicrophoneAudioTrack;
                    this._autoConsume = autoConsume;
                    this._iceServers = [];
                    var configuration = {
                      refreshEvery: 1e3,
                      // Optional. Refresh every 5 seconds
                      startAfter: 1e3,
                      // Optional. Start collecting stats after 1 seconds
                      verbose: false
                      // Optional. Display verbose logs or not.
                    };
                    this._metrics = new videosdk_room_stats.VideoSDKMetrics(configuration);
                    this._stats = {};
                    this._latestStats = {};
                    this._isWebsocketAlive = false;
                    this._pingWebsocketInterval = null;
                    this._pingInternetInterval = null;
                    this._pingWebsocketFailedCounter = 0;
                    this._pongInternetCounter = 0;
                    this._transportState = "";
                    this._openTelemetry = null;
                    this._videosdkLogs = null;
                    this._signalingBaseUrl = signalingBaseUrl ? signalingBaseUrl : "api.videosdk.live";
                    this._metaData = RoomClient_objectSpread(RoomClient_objectSpread(RoomClient_objectSpread({}, metaData !== null && metaData !== void 0 ? metaData : {}), translationLanguage && {
                      translationLanguage
                    }), speakingLanguage && {
                      speakingLanguage
                    });
                    this._defaultCameraIndex = defaultCameraIndex;
                    this._translationLanguage = translationLanguage;
                    this._debugMode = Boolean(debugMode);
                    this._meetingConnectionState = null;
                    this._sendTransportInternal = null;
                    if (_keyProvider) {
                      if (_keyProvider instanceof KeyProvider.l) {
                        _assertClassBrand(_RoomClient_brand, this, _setupE2EE).call(this, _keyProvider);
                      } else {
                        throw new Error("keyProvider should be an instance of ExternalE2EEKeyProvider");
                      }
                    }
                  }
                  return (0, createClass.A)(RoomClient2, [{
                    key: "on",
                    value: function on2(eventType, listener) {
                      this._eventEmitter.on(eventType, listener);
                    }
                  }, {
                    key: "softClose",
                    value: function softClose() {
                      var _this$_openTelemetry;
                      var softCloseSpan = (_this$_openTelemetry = this._openTelemetry) === null || _this$_openTelemetry === void 0 ? void 0 : _this$_openTelemetry.trace({
                        name: "softClose() Start "
                      });
                      try {
                        var _this$_openTelemetry2, _this$_openTelemetry3, _this$_openTelemetry4;
                        this._eventEmitter.emit("REMOVE_PARTICIPANTS_FOR_SWITCH_MEETING");
                        var consumerCleanupSpan = (_this$_openTelemetry2 = this._openTelemetry) === null || _this$_openTelemetry2 === void 0 ? void 0 : _this$_openTelemetry2.trace({
                          name: "Consumer Cleanup",
                          parentSpan: softCloseSpan,
                          attributes: {
                            "videosdk.consumers.count": this._consumers.size || 0
                          }
                        });
                        var _iterator = RoomClient_createForOfIteratorHelper(this._consumers.values()), _step;
                        try {
                          for (_iterator.s(); !(_step = _iterator.n()).done; ) {
                            var consumer = _step.value;
                            consumer.close();
                          }
                        } catch (err) {
                          _iterator.e(err);
                        } finally {
                          _iterator.f();
                        }
                        (_this$_openTelemetry3 = this._openTelemetry) === null || _this$_openTelemetry3 === void 0 || _this$_openTelemetry3.completeSpan({
                          span: consumerCleanupSpan,
                          status: 1,
                          message: "Closed ".concat(this._consumers.size, " consumers successfully")
                        });
                        (_this$_openTelemetry4 = this._openTelemetry) === null || _this$_openTelemetry4 === void 0 || _this$_openTelemetry4.completeSpan({
                          span: softCloseSpan,
                          status: 1,
                          message: "Soft close completed successfully"
                        });
                      } catch (error) {
                        var _this$_openTelemetry5;
                        (_this$_openTelemetry5 = this._openTelemetry) === null || _this$_openTelemetry5 === void 0 || _this$_openTelemetry5.completeSpan({
                          span: softCloseSpan,
                          status: 2,
                          message: "Soft close failed: ".concat(error.message)
                        });
                        console.error(error);
                      }
                    }
                  }, {
                    key: "close",
                    value: function() {
                      var _close = (0, asyncToGenerator.A)(regenerator_default().mark(function _callee(_ref2) {
                        var _this$_openTelemetry7, _this$_openTelemetry8, _this$_openTelemetry9, _this$_videosdkLogs3, _this$_openTelemetry0;
                        var _ref2$sendLeft, sendLeft, _ref2$manualCalled, manualCalled, code, meetingLeftReason, _this$_openTelemetry6, _this$_videosdkLogs, _this$_videosdkLogs2, internalSpan;
                        return regenerator_default().wrap(function(_context) {
                          while (1) switch (_context.prev = _context.next) {
                            case 0:
                              _ref2$sendLeft = _ref2.sendLeft, sendLeft = _ref2$sendLeft === void 0 ? true : _ref2$sendLeft, _ref2$manualCalled = _ref2.manualCalled, manualCalled = _ref2$manualCalled === void 0 ? false : _ref2$manualCalled, code = _ref2.code, meetingLeftReason = _ref2.meetingLeftReason;
                              if (sendLeft) {
                                (_this$_openTelemetry6 = this._openTelemetry) === null || _this$_openTelemetry6 === void 0 || _this$_openTelemetry6.traceAutoComplete({
                                  spanName: "Meeting is in CLOSING State",
                                  status: 1
                                });
                                (_this$_videosdkLogs = this._videosdkLogs) === null || _this$_videosdkLogs === void 0 || _this$_videosdkLogs.pushLogs({
                                  logText: "Meeting is in CLOSING State",
                                  logType: "INFO"
                                });
                              }
                              if (!manualCalled) {
                                _context.next = 2;
                                break;
                              }
                              (_this$_videosdkLogs2 = this._videosdkLogs) === null || _this$_videosdkLogs2 === void 0 || _this$_videosdkLogs2.pushLogs({
                                logText: "Participant manually called the leave() method to exit the meeting",
                                logType: "INFO"
                              });
                              _context.next = 1;
                              return this._socketRequest("definePeerLeftReason", {
                                leaveReason: "MANUAL_LEAVE_CALLED"
                              });
                            case 1:
                              meetingLeftReason = LeaveReason.t["MANUAL_LEAVE_CALLED"].message;
                              code = LeaveReason.t["MANUAL_LEAVE_CALLED"].code;
                            case 2:
                              if (!this._closed) {
                                _context.next = 3;
                                break;
                              }
                              return _context.abrupt("return");
                            case 3:
                              this._closed = true;
                              if (this._pingWebsocketInterval) clearInterval(this._pingWebsocketInterval);
                              this._pingWebsocketInterval = null;
                              if (this._pingInternetInterval) clearInterval(this._pingInternetInterval);
                              this._pingInternetInterval = null;
                              if (this._sendTransportInternal) clearInterval(this._sendTransportInternal);
                              this._sendTransportInternal = null;
                              this._webSocket.close();
                              if (this._metrics.running) {
                                this._metrics.stopAllProbes();
                              }
                              logger.debug("close()");
                              internalSpan = (_this$_openTelemetry7 = this._openTelemetry) === null || _this$_openTelemetry7 === void 0 ? void 0 : _this$_openTelemetry7.trace({
                                spanName: "Closing Trasnport"
                              });
                              if (this._sendTransport) this._sendTransport.close();
                              if (this._recvTransport) this._recvTransport.close();
                              (_this$_openTelemetry8 = this._openTelemetry) === null || _this$_openTelemetry8 === void 0 || _this$_openTelemetry8.completeSpan({
                                span: internalSpan,
                                status: 1,
                                message: "Closed Trasnport"
                              });
                              store.dispatch(setRoomState("closed"));
                              if (sendLeft) this.emitMeetingStateChange(state.DISCONNECTED);
                              (_this$_openTelemetry9 = this._openTelemetry) === null || _this$_openTelemetry9 === void 0 || _this$_openTelemetry9.traceAutoComplete({
                                spanName: "Meeting is in CLOSED State",
                                status: 1
                              });
                              (_this$_videosdkLogs3 = this._videosdkLogs) === null || _this$_videosdkLogs3 === void 0 || _this$_videosdkLogs3.pushLogs({
                                logText: "Meeting is in CLOSED State",
                                logType: "INFO"
                              });
                              if (sendLeft) this._eventEmitter.emit("MEETING_LEFT", {
                                message: meetingLeftReason ? meetingLeftReason : LeaveReason.t["UNKNOWN"].message,
                                code: code ? code : LeaveReason.t["UNKNOWN"].code
                              });
                              (_this$_openTelemetry0 = this._openTelemetry) === null || _this$_openTelemetry0 === void 0 || _this$_openTelemetry0.traceAutoComplete({
                                spanName: "Emitted MEETING_LEFT Event with meeting left reason : ".concat(meetingLeftReason, " with code ").concat(code),
                                status: 1
                              });
                            case 4:
                            case "end":
                              return _context.stop();
                          }
                        }, _callee, this);
                      }));
                      function close(_x) {
                        return _close.apply(this, arguments);
                      }
                      return close;
                    }()
                  }, {
                    key: "join",
                    value: function() {
                      var _join = (0, asyncToGenerator.A)(regenerator_default().mark(function _callee10() {
                        var _this = this;
                        var _this$_openTelemetry1, _this$_openTelemetry10, _this$_videosdkLogs4, _yield$getServerConfi, baseUrl, iceServers, logs, observabilityJwt, traces, metaData, signalingUrl, socketPath, socketUrl, _this$_videosdkLogs15, _t7;
                        return regenerator_default().wrap(function(_context10) {
                          while (1) switch (_context10.prev = _context10.next) {
                            case 0:
                              _context10.prev = 0;
                              _context10.next = 1;
                              return getServerConfig({
                                roomId: this._roomId,
                                secret: this._secret,
                                signalingBaseUrl: this._signalingBaseUrl
                              });
                            case 1:
                              _yield$getServerConfi = _context10.sent;
                              baseUrl = _yield$getServerConfi.baseUrl;
                              iceServers = _yield$getServerConfi.iceServers;
                              logs = _yield$getServerConfi.logs;
                              observabilityJwt = _yield$getServerConfi.observabilityJwt;
                              traces = _yield$getServerConfi.traces;
                              metaData = _yield$getServerConfi.metaData;
                              signalingUrl = _yield$getServerConfi.signalingUrl;
                              socketPath = _yield$getServerConfi.socketPath;
                              socketUrl = _yield$getServerConfi.socketUrl;
                              this._baseUrl = baseUrl;
                              this._socketUrl = "wss://".concat(socketUrl ? socketUrl : this._baseUrl, "/?roomId=").concat(this._roomId, "&peerId=").concat(this._peerId, "&secret=").concat(this._secret, "&mode=").concat(this._mode, "&lib=socket");
                              this._iceServers = iceServers;
                              this._tracesEnabled = traces.enabled;
                              this._openTelemetry = new VideoSDKTelemetery((0, defineProperty.A)({
                                roomId: this._roomId,
                                peerId: this._peerId,
                                sdkName: "".concat(this._deviceInfo.sdkType, "-sdk"),
                                traces,
                                logs,
                                observabilityJwt,
                                metaData
                              }, "traces", traces));
                              this._joinSpan = (_this$_openTelemetry1 = this._openTelemetry) === null || _this$_openTelemetry1 === void 0 ? void 0 : _this$_openTelemetry1.trace({
                                spanName: "Join() Calling",
                                attributes: {
                                  DeviceInfo: JSON.stringify(this._deviceInfo),
                                  mode: this._mode,
                                  displayName: this._displayName,
                                  multiStream: this._useSimulcast,
                                  micEnabled: this._micEnabled,
                                  webcamEnabled: this._webcamEnabled,
                                  CustomVideoTrack: !!this.customCameraVideoTrack,
                                  CustomMicTrack: !!this.customMicrophoneAudioTrack,
                                  signalingUrl: signalingUrl ? signalingUrl : "signalingUrl not specify"
                                }
                              });
                              this._webSocket = esm_lookup(this._socketUrl, {
                                transports: ["websocket"],
                                reconnectionAttempts: 10,
                                reconnectionDelay: 5e3,
                                reconnection: true,
                                path: "".concat(socketPath !== null && socketPath !== void 0 ? socketPath : "", "/socket.io")
                              });
                              this.emitMeetingStateChange(state.CONNECTING);
                              store.dispatch(setRoomState("connecting"));
                              (_this$_openTelemetry10 = this._openTelemetry) === null || _this$_openTelemetry10 === void 0 || _this$_openTelemetry10.traceAutoComplete({
                                spanName: "Meeting is in CONNECTING State",
                                span: this._joinSpan,
                                status: 1
                              });
                              (_this$_videosdkLogs4 = this._videosdkLogs) === null || _this$_videosdkLogs4 === void 0 || _this$_videosdkLogs4.pushLogs({
                                logText: "Meeting is in CONNECTING State",
                                logType: "INFO"
                              });
                              this._webSocket.on("connect", function() {
                              });
                              this._webSocket.on("connectionSuccess", function() {
                                var _this$_openTelemetry11, _this$_videosdkLogs5;
                                _this._isWebsocketAlive = true;
                                _this._closed = false;
                                if (_this._mode === (modes.nI.RECV_ONLY || modes.nI.SIGNALLING_ONLY)) {
                                  _this.emitMeetingStateChange(state.CONNECTED);
                                }
                                (_this$_openTelemetry11 = _this._openTelemetry) === null || _this$_openTelemetry11 === void 0 || _this$_openTelemetry11.traceAutoComplete({
                                  spanName: "Meeting is in CONNECTED State",
                                  span: _this._joinSpan,
                                  status: 1
                                });
                                (_this$_videosdkLogs5 = _this._videosdkLogs) === null || _this$_videosdkLogs5 === void 0 || _this$_videosdkLogs5.pushLogs({
                                  logText: "Meeting is in CONNECTED State",
                                  logType: "INFO"
                                });
                                _this.requestEntry();
                              });
                              this._webSocket.on("disconnect", function(reason) {
                                var _this$_videosdkLogs6;
                                (_this$_videosdkLogs6 = _this._videosdkLogs) === null || _this$_videosdkLogs6 === void 0 || _this$_videosdkLogs6.pushLogs({
                                  logText: "Meeting is in Websocket Disconnect State",
                                  logType: "INFO",
                                  attributes: {
                                    reason
                                  },
                                  dashboardLog: true
                                });
                                if (reason === "transport close" || reason === "transport error") {
                                  if (_this.customMicrophoneAudioTrack) {
                                    var _this$customMicrophon;
                                    (_this$customMicrophon = _this.customMicrophoneAudioTrack) === null || _this$customMicrophon === void 0 || _this$customMicrophon.getTracks().forEach(function(track) {
                                      track.stop();
                                    });
                                    _this.customMicrophoneAudioTrack = null;
                                  }
                                  if (_this.customCameraVideoTrack) {
                                    var _this$customCameraVid;
                                    (_this$customCameraVid = _this.customCameraVideoTrack) === null || _this$customCameraVid === void 0 || _this$customCameraVid.getTracks().forEach(function(track) {
                                      track.stop();
                                    });
                                    _this.customCameraVideoTrack = null;
                                  }
                                  if (_this._sendTransport) {
                                    var _this$_sendTransport;
                                    (_this$_sendTransport = _this._sendTransport) === null || _this$_sendTransport === void 0 || _this$_sendTransport.close();
                                    _this._sendTransport = null;
                                  }
                                  if (_this._recvTransport) {
                                    var _this$_recvTransport;
                                    (_this$_recvTransport = _this._recvTransport) === null || _this$_recvTransport === void 0 || _this$_recvTransport.close();
                                    _this._recvTransport = null;
                                  }
                                }
                              });
                              this._webSocket.io.on("reconnect_failed", function() {
                                if (_this._closed) return;
                                _this.close({
                                  sendLeft: true,
                                  meetingLeftReason: LeaveReason.t["WEBSOCKET_CONNECTION_ATTEMPTS_EXHAUSTED"].message,
                                  code: LeaveReason.t["WEBSOCKET_CONNECTION_ATTEMPTS_EXHAUSTED"].code
                                });
                              });
                              this._webSocket.on("connect_error", function(error) {
                                if (_this._webSocket.active && _this._webSocket.io._reconnecting) {
                                  var _this$_openTelemetry12, _this$_videosdkLogs7, _this$customMicrophon2, _this$customCameraVid2;
                                  (_this$_openTelemetry12 = _this._openTelemetry) === null || _this$_openTelemetry12 === void 0 || _this$_openTelemetry12.traceAutoComplete({
                                    spanName: "Meeting is in RECONNECTING State",
                                    span: _this._joinSpan,
                                    status: 1
                                  });
                                  (_this$_videosdkLogs7 = _this._videosdkLogs) === null || _this$_videosdkLogs7 === void 0 || _this$_videosdkLogs7.pushLogs({
                                    logText: "Meeting is in RECONNECTING State",
                                    logType: "INFO",
                                    attributes: {
                                      error: error.message
                                    }
                                  });
                                  store.dispatch(notify({
                                    type: "error",
                                    text: "WebSocket Reconnecting"
                                  }));
                                  _this.emitMeetingStateChange(state.RECONNECTING);
                                  if (_this._sendTransport) {
                                    var _this$_sendTransport2;
                                    (_this$_sendTransport2 = _this._sendTransport) === null || _this$_sendTransport2 === void 0 || _this$_sendTransport2.close();
                                    _this._sendTransport = null;
                                  }
                                  if (_this._recvTransport) {
                                    var _this$_recvTransport2;
                                    (_this$_recvTransport2 = _this._recvTransport) === null || _this$_recvTransport2 === void 0 || _this$_recvTransport2.close();
                                    _this._recvTransport = null;
                                  }
                                  (_this$customMicrophon2 = _this.customMicrophoneAudioTrack) === null || _this$customMicrophon2 === void 0 || _this$customMicrophon2.getTracks().forEach(function(track) {
                                    track.stop();
                                  });
                                  _this.customMicrophoneAudioTrack = null;
                                  (_this$customCameraVid2 = _this.customCameraVideoTrack) === null || _this$customCameraVid2 === void 0 || _this$customCameraVid2.getTracks().forEach(function(track) {
                                    track.stop();
                                  });
                                  _this.customCameraVideoTrack = null;
                                } else {
                                  console.log("Error while trying to reconnect", error.message);
                                }
                              });
                              this._webSocket.on("close", function(data) {
                                var reason = data.reason;
                                console.log("MEETING close", reason.message);
                                if (_this._closed) return;
                                _this.close({
                                  sendLeft: true,
                                  code: reason.code,
                                  meetingLeftReason: reason.message
                                });
                              });
                              this._webSocket.on("newConsumer", function() {
                                var _ref3 = (0, asyncToGenerator.A)(regenerator_default().mark(function _callee2(request, accept) {
                                  var _this$_openTelemetry13, _this$_openTelemetry15;
                                  var newConsumerSpan, _this$_openTelemetry14, peerId, producerId, id, kind, rtpParameters, type, appData, producerPaused, span, _this$_openTelemetry16, _this$_openTelemetry17, _this$_openTelemetry18, _this$_openTelemetry19, consumer, _mediasoupClient$pars, spatialLayers, temporalLayers, action, _this$_openTelemetry20, _this$_openTelemetry21, _this$_openTelemetry22, _this$_videosdkLogs8, _t;
                                  return regenerator_default().wrap(function(_context2) {
                                    while (1) switch (_context2.prev = _context2.next) {
                                      case 0:
                                        newConsumerSpan = (_this$_openTelemetry13 = _this._openTelemetry) === null || _this$_openTelemetry13 === void 0 ? void 0 : _this$_openTelemetry13.trace({
                                          spanName: "Websocket REQ: newConsumer",
                                          attributes: {
                                            request: JSON.stringify(request)
                                          }
                                        });
                                        if (_this._consume) {
                                          _context2.next = 1;
                                          break;
                                        }
                                        accept({
                                          errorCode: 403,
                                          message: "I do not want to consume",
                                          method: "newConsumer"
                                        });
                                        (_this$_openTelemetry14 = _this._openTelemetry) === null || _this$_openTelemetry14 === void 0 || _this$_openTelemetry14.completeSpan({
                                          span: newConsumerSpan,
                                          status: 2,
                                          message: "I do not want to consume"
                                        });
                                        return _context2.abrupt("return");
                                      case 1:
                                        peerId = request.peerId, producerId = request.producerId, id = request.id, kind = request.kind, rtpParameters = request.rtpParameters, type = request.type, appData = request.appData, producerPaused = request.producerPaused;
                                        span = (_this$_openTelemetry15 = _this._openTelemetry) === null || _this$_openTelemetry15 === void 0 ? void 0 : _this$_openTelemetry15.trace({
                                          spanName: "Creating Consumer",
                                          span: newConsumerSpan
                                        });
                                        _context2.prev = 2;
                                        _context2.next = 3;
                                        return _this._recvTransport.consume({
                                          id,
                                          producerId,
                                          kind,
                                          rtpParameters,
                                          appData: RoomClient_objectSpread(RoomClient_objectSpread({}, appData), {}, {
                                            peerId
                                          }),
                                          // Trick.
                                          onRtpReceiver: function onRtpReceiver(receiver) {
                                            if (_this.e2eeManager) {
                                              var writable = receiver.writableStream;
                                              var readable = receiver.readableStream;
                                              if (!writable || !readable) {
                                                var receiverStreams = receiver.createEncodedStreams();
                                                receiver.writableStream = receiverStreams.writable;
                                                writable = receiverStreams.writable;
                                                receiver.readableStream = receiverStreams.readable;
                                                readable = receiverStreams.readable;
                                              }
                                            }
                                          }
                                        });
                                      case 3:
                                        consumer = _context2.sent;
                                        _mediasoupClient$pars = lib.s$(consumer.rtpParameters.encodings[0].scalabilityMode), spatialLayers = _mediasoupClient$pars.spatialLayers, temporalLayers = _mediasoupClient$pars.temporalLayers;
                                        consumer.spatialLayers = spatialLayers;
                                        consumer.temporalLayers = temporalLayers;
                                        consumer.currentSpatialLayers = spatialLayers - 1;
                                        consumer.currentTemporalLayers = temporalLayers - 1;
                                        _this._consumers.set(consumer.id, consumer);
                                        consumer.on("transportclose", function() {
                                          _this._consumers["delete"](consumer.id);
                                          var action2 = removeConsumer(consumer.id, peerId);
                                          store.dispatch(action2);
                                          _this._eventEmitter.emit(action2.type, action2.payload);
                                        });
                                        (_this$_openTelemetry16 = _this._openTelemetry) === null || _this$_openTelemetry16 === void 0 || _this$_openTelemetry16.completeSpan({
                                          span,
                                          status: 1,
                                          message: "Consumer Created"
                                        });
                                        span = (_this$_openTelemetry17 = _this._openTelemetry) === null || _this$_openTelemetry17 === void 0 ? void 0 : _this$_openTelemetry17.trace({
                                          spanName: "Sending Stream Enabled Event",
                                          span: newConsumerSpan
                                        });
                                        action = addConsumer({
                                          id: consumer.id,
                                          type,
                                          locallyPaused: false,
                                          remotelyPaused: producerPaused,
                                          rtpParameters: consumer.rtpParameters,
                                          spatialLayers,
                                          temporalLayers,
                                          currentSpatialLayer: spatialLayers - 1,
                                          currentTemporalLayer: temporalLayers - 1,
                                          preferredSpatialLayer: spatialLayers - 1,
                                          preferredTemporalLayer: temporalLayers - 1,
                                          priority: 1,
                                          codec: consumer.rtpParameters.codecs[0].mimeType.split("/")[1],
                                          track: consumer.track,
                                          appData,
                                          instance: consumer,
                                          rtpReceiver: consumer._rtpReceiver
                                          // DONT remove , rtpReceiver is required in the e2ee.
                                        }, peerId);
                                        store.dispatch(action);
                                        _this._eventEmitter.emit(action.type, action.payload);
                                        accept();
                                        if (consumer.kind === "video" && store.getState().me.audioOnly) _this._pauseConsumer(consumer);
                                        (_this$_openTelemetry18 = _this._openTelemetry) === null || _this$_openTelemetry18 === void 0 || _this$_openTelemetry18.completeSpan({
                                          span,
                                          status: 1,
                                          message: "Event Send Successfully"
                                        });
                                        (_this$_openTelemetry19 = _this._openTelemetry) === null || _this$_openTelemetry19 === void 0 || _this$_openTelemetry19.completeSpan({
                                          span: newConsumerSpan,
                                          status: 1,
                                          message: "New Consumer Created Successfully",
                                          attributes: {
                                            "consumer.consumerId": consumer.id
                                          }
                                        });
                                        if (consumer.kind == "video" && consumer.appData.share) {
                                          (_this$_openTelemetry20 = _this._openTelemetry) === null || _this$_openTelemetry20 === void 0 || _this$_openTelemetry20.traceAutoComplete({
                                            spanName: "Presenter Changed",
                                            span: newConsumerSpan,
                                            attributes: {
                                              "peer.id": peerId
                                            }
                                          });
                                        }
                                        if (_this.e2eeManager) {
                                          _this.e2eeManager.emit("NEW_CONSUMER", {
                                            consumer,
                                            peerId: _this._peerId
                                          });
                                        }
                                        _context2.next = 5;
                                        break;
                                      case 4:
                                        _context2.prev = 4;
                                        _t = _context2["catch"](2);
                                        (_this$_openTelemetry21 = _this._openTelemetry) === null || _this$_openTelemetry21 === void 0 || _this$_openTelemetry21.completeSpan({
                                          span,
                                          status: 2,
                                          message: "Error creating a Consumer: ".concat(_t)
                                        });
                                        (_this$_openTelemetry22 = _this._openTelemetry) === null || _this$_openTelemetry22 === void 0 || _this$_openTelemetry22.completeSpan({
                                          span: newConsumerSpan,
                                          status: 2,
                                          message: "Error creating a Consumer: ".concat(_t)
                                        });
                                        store.dispatch(notify({
                                          type: "error",
                                          text: "Error creating a Consumer: ".concat(_t)
                                        }));
                                        (_this$_videosdkLogs8 = _this._videosdkLogs) === null || _this$_videosdkLogs8 === void 0 || _this$_videosdkLogs8.pushLogs({
                                          logText: "Error creating a Consumer",
                                          logType: "ERROR",
                                          attributes: {
                                            error: _t.message
                                          }
                                        });
                                        throw _t;
                                      case 5:
                                      case "end":
                                        return _context2.stop();
                                    }
                                  }, _callee2, null, [[2, 4]]);
                                }));
                                return function(_x2, _x3) {
                                  return _ref3.apply(this, arguments);
                                };
                              }());
                              this._webSocket.on("newDataConsumer", function() {
                                var _ref4 = (0, asyncToGenerator.A)(regenerator_default().mark(function _callee3(request, accept) {
                                  var peerId, dataProducerId, id, sctpStreamParameters, label, protocol2, appData, dataConsumer, _t2;
                                  return regenerator_default().wrap(function(_context3) {
                                    while (1) switch (_context3.prev = _context3.next) {
                                      case 0:
                                        if (_this._consume) {
                                          _context3.next = 1;
                                          break;
                                        }
                                        accept({
                                          errorCode: 403,
                                          message: "I do not want to data consume",
                                          method: "newConsumer"
                                        });
                                        return _context3.abrupt("return");
                                      case 1:
                                        peerId = request.peerId, dataProducerId = request.dataProducerId, id = request.id, sctpStreamParameters = request.sctpStreamParameters, label = request.label, protocol2 = request.protocol, appData = request.appData;
                                        _context3.prev = 2;
                                        _context3.next = 3;
                                        return _this._recvTransport.consumeData({
                                          id,
                                          dataProducerId,
                                          sctpStreamParameters,
                                          label,
                                          protocol: protocol2,
                                          appData: RoomClient_objectSpread(RoomClient_objectSpread({}, appData), {}, {
                                            peerId
                                          })
                                          // Trick.
                                        });
                                      case 3:
                                        dataConsumer = _context3.sent;
                                        _this._dataConsumers.set(dataConsumer.id, dataConsumer);
                                        dataConsumer.on("transportclose", function() {
                                          _this._dataConsumers["delete"](dataConsumer.id);
                                        });
                                        dataConsumer.on("open", function() {
                                          logger.debug('DataConsumer "open" event');
                                        });
                                        dataConsumer.on("close", function() {
                                          logger.warn('DataConsumer "close" event');
                                          _this._dataConsumers["delete"](dataConsumer.id);
                                          store.dispatch(notify({
                                            type: "error",
                                            text: "DataConsumer closed"
                                          }));
                                        });
                                        dataConsumer.on("error", function(error) {
                                          logger.error('DataConsumer "error" event:%o', error);
                                          store.dispatch(notify({
                                            type: "error",
                                            text: "DataConsumer error: ".concat(error)
                                          }));
                                        });
                                        dataConsumer.on("message", function(message) {
                                          var payload;
                                          logger.debug('DataConsumer "message" event [streamId:%d]', dataConsumer.sctpStreamParameters.streamId);
                                          if (message instanceof ArrayBuffer) {
                                            var bytes = new Uint8Array(message);
                                            payload = bytes;
                                          } else {
                                            payload = message;
                                          }
                                          var _store$getState = store.getState(), peers = _store$getState.peers;
                                          var peersArray = Object.keys(peers).map(function(_peerId) {
                                            return peers[_peerId];
                                          });
                                          var sendingPeer = peersArray.find(function(peer) {
                                            return peer.dataConsumers.includes(dataConsumer.id);
                                          });
                                          switch (dataConsumer.label) {
                                            case "reliable_data_producer": {
                                              if (!sendingPeer) {
                                                logger.warn('DataConsumer "message" from unknown peer');
                                                break;
                                              }
                                              store.dispatch(notify({
                                                title: "".concat(sendingPeer.displayName, " says:"),
                                                text: message,
                                                timeout: 5e3
                                              }));
                                              _this._eventEmitter.emit("DATA", {
                                                payload,
                                                from: sendingPeer.id,
                                                timestamp: Date.now(),
                                                reliability: reliabilityModes.y.RELIABLE
                                              });
                                              break;
                                            }
                                            case "unreliable_data_producer": {
                                              if (!sendingPeer) {
                                                logger.warn('DataConsumer "message" from unknown peer');
                                                break;
                                              }
                                              store.dispatch(notify({
                                                title: "".concat(sendingPeer.displayName, " says:"),
                                                text: message,
                                                timeout: 5e3
                                              }));
                                              _this._eventEmitter.emit("DATA", {
                                                payload,
                                                from: sendingPeer.id,
                                                timestamp: Date.now(),
                                                reliability: reliabilityModes.y.UNRELIABLE
                                              });
                                              break;
                                            }
                                          }
                                        });
                                        store.dispatch(addDataConsumer({
                                          id: dataConsumer.id,
                                          sctpStreamParameters: dataConsumer.sctpStreamParameters,
                                          label: dataConsumer.label,
                                          protocol: dataConsumer.protocol
                                        }, peerId));
                                        accept();
                                        _context3.next = 5;
                                        break;
                                      case 4:
                                        _context3.prev = 4;
                                        _t2 = _context3["catch"](2);
                                        logger.error('"newDataConsumer" request failed:%o', _t2);
                                        store.dispatch(notify({
                                          type: "error",
                                          text: "Error creating a DataConsumer: ".concat(_t2)
                                        }));
                                      case 5:
                                      case "end":
                                        return _context3.stop();
                                    }
                                  }, _callee3, null, [[2, 4]]);
                                }));
                                return function(_x4, _x5) {
                                  return _ref4.apply(this, arguments);
                                };
                              }());
                              this._webSocket.on("enableMic", function() {
                                var _ref5 = (0, asyncToGenerator.A)(regenerator_default().mark(function _callee4(request, accept) {
                                  var _this$_openTelemetry23, peerId, _this$_videosdkLogs9;
                                  return regenerator_default().wrap(function(_context4) {
                                    while (1) switch (_context4.prev = _context4.next) {
                                      case 0:
                                        try {
                                          peerId = request.peerId;
                                          (_this$_openTelemetry23 = _this._openTelemetry) === null || _this$_openTelemetry23 === void 0 || _this$_openTelemetry23.traceAutoComplete({
                                            spanName: "Emitting MIC_REQUESTED & Websocket REQ: enableMic for ".concat(peerId),
                                            status: 1
                                          });
                                          _this._eventEmitter.emit("MIC_REQUESTED", {
                                            peerId
                                          });
                                          accept();
                                        } catch (error) {
                                          logger.error('"enableMic" request failed:%o', error);
                                          (_this$_videosdkLogs9 = _this._videosdkLogs) === null || _this$_videosdkLogs9 === void 0 || _this$_videosdkLogs9.pushLogs({
                                            logText: "Error enableMic request failed",
                                            logType: "ERROR",
                                            attributes: {
                                              error: error.message
                                            }
                                          });
                                          _this._emitError({
                                            code: 3027,
                                            message: error.message
                                          });
                                        }
                                      case 1:
                                      case "end":
                                        return _context4.stop();
                                    }
                                  }, _callee4);
                                }));
                                return function(_x6, _x7) {
                                  return _ref5.apply(this, arguments);
                                };
                              }());
                              this._webSocket.on("disableMic", function() {
                                var _ref6 = (0, asyncToGenerator.A)(regenerator_default().mark(function _callee5(request, accept) {
                                  var disableMicSpan, _this$_openTelemetry24, _this$_openTelemetry25, _this$_openTelemetry26, _this$_videosdkLogs0, _t3;
                                  return regenerator_default().wrap(function(_context5) {
                                    while (1) switch (_context5.prev = _context5.next) {
                                      case 0:
                                        _context5.prev = 0;
                                        disableMicSpan = (_this$_openTelemetry24 = _this._openTelemetry) === null || _this$_openTelemetry24 === void 0 ? void 0 : _this$_openTelemetry24.trace({
                                          spanName: "Websocket REQ: disableMic"
                                        });
                                        _context5.next = 1;
                                        return _this.disableMic(false, disableMicSpan);
                                      case 1:
                                        (_this$_openTelemetry25 = _this._openTelemetry) === null || _this$_openTelemetry25 === void 0 || _this$_openTelemetry25.completeSpan({
                                          span: disableMicSpan,
                                          status: 1,
                                          message: "Request Completed"
                                        });
                                        accept();
                                        _context5.next = 3;
                                        break;
                                      case 2:
                                        _context5.prev = 2;
                                        _t3 = _context5["catch"](0);
                                        (_this$_openTelemetry26 = _this._openTelemetry) === null || _this$_openTelemetry26 === void 0 || _this$_openTelemetry26.completeSpan({
                                          span: disableMicSpan,
                                          status: 2,
                                          message: "disableMic request failed ".concat(_t3)
                                        });
                                        (_this$_videosdkLogs0 = _this._videosdkLogs) === null || _this$_videosdkLogs0 === void 0 || _this$_videosdkLogs0.pushLogs({
                                          logText: "Error disableMic request failed",
                                          logType: "ERROR",
                                          attributes: {
                                            error: _t3.message
                                          }
                                        });
                                        _this._emitError({
                                          code: 3028,
                                          message: _t3.message
                                        });
                                      case 3:
                                      case "end":
                                        return _context5.stop();
                                    }
                                  }, _callee5, null, [[0, 2]]);
                                }));
                                return function(_x8, _x9) {
                                  return _ref6.apply(this, arguments);
                                };
                              }());
                              this._webSocket.on("enableWebcam", function() {
                                var _ref7 = (0, asyncToGenerator.A)(regenerator_default().mark(function _callee6(request, accept) {
                                  var _this$_openTelemetry27, peerId, _this$_videosdkLogs1;
                                  return regenerator_default().wrap(function(_context6) {
                                    while (1) switch (_context6.prev = _context6.next) {
                                      case 0:
                                        try {
                                          peerId = request.peerId;
                                          (_this$_openTelemetry27 = _this._openTelemetry) === null || _this$_openTelemetry27 === void 0 || _this$_openTelemetry27.traceAutoComplete({
                                            spanName: "Emitting WEBCAM_REQUESTED & Websocket REQ: enableWebcam for ".concat(peerId),
                                            status: 1
                                          });
                                          _this._eventEmitter.emit("WEBCAM_REQUESTED", {
                                            peerId
                                          });
                                          accept();
                                        } catch (error) {
                                          logger.error('"enableWebcam" request failed:%o', error);
                                          (_this$_videosdkLogs1 = _this._videosdkLogs) === null || _this$_videosdkLogs1 === void 0 || _this$_videosdkLogs1.pushLogs({
                                            logText: "Error enableWebcam request failed",
                                            logType: "ERROR",
                                            attributes: {
                                              error: error.message
                                            }
                                          });
                                          _this._emitError({
                                            code: 3029,
                                            message: error.message
                                          });
                                        }
                                      case 1:
                                      case "end":
                                        return _context6.stop();
                                    }
                                  }, _callee6);
                                }));
                                return function(_x0, _x1) {
                                  return _ref7.apply(this, arguments);
                                };
                              }());
                              this._webSocket.on("disableWebcam", function() {
                                var _ref8 = (0, asyncToGenerator.A)(regenerator_default().mark(function _callee7(request, accept) {
                                  var disableWebcamSpan, _this$_openTelemetry28, _this$_openTelemetry29, _this$_openTelemetry30, _this$_videosdkLogs10, _t4;
                                  return regenerator_default().wrap(function(_context7) {
                                    while (1) switch (_context7.prev = _context7.next) {
                                      case 0:
                                        _context7.prev = 0;
                                        disableWebcamSpan = (_this$_openTelemetry28 = _this._openTelemetry) === null || _this$_openTelemetry28 === void 0 ? void 0 : _this$_openTelemetry28.trace({
                                          spanName: "Websocket REQ: disableWebcam"
                                        });
                                        _context7.next = 1;
                                        return _this.disableWebcam(disableWebcamSpan);
                                      case 1:
                                        (_this$_openTelemetry29 = _this._openTelemetry) === null || _this$_openTelemetry29 === void 0 || _this$_openTelemetry29.completeSpan({
                                          span: disableWebcamSpan,
                                          status: 1,
                                          message: "Request Completed"
                                        });
                                        accept();
                                        _context7.next = 3;
                                        break;
                                      case 2:
                                        _context7.prev = 2;
                                        _t4 = _context7["catch"](0);
                                        (_this$_openTelemetry30 = _this._openTelemetry) === null || _this$_openTelemetry30 === void 0 || _this$_openTelemetry30.completeSpan({
                                          span: disableWebcamSpan,
                                          status: 2,
                                          message: "disableWebcam request failed ".concat(_t4)
                                        });
                                        (_this$_videosdkLogs10 = _this._videosdkLogs) === null || _this$_videosdkLogs10 === void 0 || _this$_videosdkLogs10.pushLogs({
                                          logText: "Error disableWebcam request failed",
                                          logType: "ERROR",
                                          attributes: {
                                            error: _t4.message
                                          }
                                        });
                                        _this._emitError({
                                          code: 3030,
                                          message: _t4.message
                                        });
                                      case 3:
                                      case "end":
                                        return _context7.stop();
                                    }
                                  }, _callee7, null, [[0, 2]]);
                                }));
                                return function(_x10, _x11) {
                                  return _ref8.apply(this, arguments);
                                };
                              }());
                              this._webSocket.on("pinStateChanged", function() {
                                var _ref9 = (0, asyncToGenerator.A)(regenerator_default().mark(function _callee8(request, accept) {
                                  var pinStateChangedSpan, _this$_openTelemetry31, _this$_openTelemetry32, peerId, _state, pinnedBy, pinPeer, _this$_openTelemetry33, _this$_videosdkLogs11, _t5;
                                  return regenerator_default().wrap(function(_context8) {
                                    while (1) switch (_context8.prev = _context8.next) {
                                      case 0:
                                        _context8.prev = 0;
                                        peerId = request.peerId, _state = request.state, pinnedBy = request.pinnedBy;
                                        pinStateChangedSpan = (_this$_openTelemetry31 = _this._openTelemetry) === null || _this$_openTelemetry31 === void 0 ? void 0 : _this$_openTelemetry31.trace({
                                          spanName: "Websocket REQ: pinStateChanged",
                                          attributes: {
                                            requestData: JSON.stringify({
                                              peerId,
                                              state: _state,
                                              pinnedBy
                                            })
                                          }
                                        });
                                        if (!_this._pinnedParticipants.has(peerId)) {
                                          _this._pinnedParticipants.set(peerId, {
                                            cam: false,
                                            share: false
                                          });
                                        }
                                        pinPeer = _this._pinnedParticipants.get(peerId);
                                        if (_state.cam != void 0) {
                                          pinPeer.cam = _state.cam;
                                        }
                                        if (_state.share != void 0) {
                                          pinPeer.share = _state.share;
                                        }
                                        _this._pinnedParticipants.set(peerId, pinPeer);
                                        _this._eventEmitter.emit("PIN_STATE_CHANGED", {
                                          peerId,
                                          state: _state,
                                          pinnedBy
                                        });
                                        if (pinPeer.share == false && pinPeer.cam == false) {
                                          _this._pinnedParticipants["delete"](peerId);
                                        }
                                        (_this$_openTelemetry32 = _this._openTelemetry) === null || _this$_openTelemetry32 === void 0 || _this$_openTelemetry32.completeSpan({
                                          span: pinStateChangedSpan,
                                          status: 1,
                                          message: "Request Completed",
                                          attributes: {
                                            _pinnedParticipants: JSON.stringify(_this._pinnedParticipants)
                                          }
                                        });
                                        accept();
                                        _context8.next = 2;
                                        break;
                                      case 1:
                                        _context8.prev = 1;
                                        _t5 = _context8["catch"](0);
                                        (_this$_openTelemetry33 = _this._openTelemetry) === null || _this$_openTelemetry33 === void 0 || _this$_openTelemetry33.completeSpan({
                                          span: pinStateChangedSpan,
                                          status: 2,
                                          message: "pinStateChanged request failed"
                                        });
                                        (_this$_videosdkLogs11 = _this._videosdkLogs) === null || _this$_videosdkLogs11 === void 0 || _this$_videosdkLogs11.pushLogs({
                                          logText: "Error pinStateChanged request failed",
                                          logType: "ERROR",
                                          attributes: {
                                            error: _t5.message
                                          }
                                        });
                                        throw _t5;
                                      case 2:
                                      case "end":
                                        return _context8.stop();
                                    }
                                  }, _callee8, null, [[0, 1]]);
                                }));
                                return function(_x12, _x13) {
                                  return _ref9.apply(this, arguments);
                                };
                              }());
                              this._webSocket.on("switchRoom", function() {
                                var _ref0 = (0, asyncToGenerator.A)(regenerator_default().mark(function _callee9(request, accept) {
                                  return regenerator_default().wrap(function(_context9) {
                                    while (1) switch (_context9.prev = _context9.next) {
                                      case 0:
                                        _this._eventEmitter.emit("SWITCH_ROOM", request);
                                        accept();
                                      case 1:
                                      case "end":
                                        return _context9.stop();
                                    }
                                  }, _callee9);
                                }));
                                return function(_x14, _x15) {
                                  return _ref0.apply(this, arguments);
                                };
                              }());
                              this._webSocket.on("statsData", function() {
                                var _ref1 = (0, asyncToGenerator.A)(regenerator_default().mark(function _callee0(request, accept) {
                                  return regenerator_default().wrap(function(_context0) {
                                    while (1) switch (_context0.prev = _context0.next) {
                                      case 0:
                                        accept({
                                          peerId: _this._peerId,
                                          statsData: _this._stats
                                        });
                                        _this._stats = {};
                                      case 1:
                                      case "end":
                                        return _context0.stop();
                                    }
                                  }, _callee0);
                                }));
                                return function(_x16, _x17) {
                                  return _ref1.apply(this, arguments);
                                };
                              }());
                              this._webSocket.on("notification", function() {
                                var _ref10 = (0, asyncToGenerator.A)(regenerator_default().mark(function _callee1(notification) {
                                  var payload, _this$_videosdkLogs12, _this$_openTelemetry34, error, peerId, kind, newState, _this$_openTelemetry35, _this$_videosdkLogs13, producerId, score, _this$_openTelemetry36, id, name, internalSpan, _this$_openTelemetry37, _this$_openTelemetry38, _this$_openTelemetry39, _id, decision, sessionId, switchingRoomId, entryResponseSpan, _this$_openTelemetry41, _this$_openTelemetry40, _this$_openTelemetry42, peer, action, _this$_openTelemetry43, _this$_videosdkLogs14, _this$_openTelemetry44, _peerId2, reason, _action, _peerId3, displayName, oldDisplayName, _this$_openTelemetry45, consumerId, consumer, _peerId4, _action2, _consumerId, _consumer, _consumerId2, _consumer2, _consumer3$appData, _consumerId3, spatialLayer, temporalLayer, _consumer3, _consumerId4, _score, dataConsumerId, dataConsumer, _peerId5, _peerId6, _action3, _this$_openTelemetry46, _this$_openTelemetry47, _this$_openTelemetry48, _this$_openTelemetry49, _this$_openTelemetry50, _this$_openTelemetry51, downstreamUrl, _state2, url2, _this$_openTelemetry52, character, _action4, _this$_openTelemetry53, _id2, _action5, _this$_openTelemetry54, currentTime, _this$_openTelemetry55, _this$_openTelemetry56, transportId, iceParameters, _internalSpan, meetingId, _meetingId, _reason, _meetingId2, _reason2, _decision, decidedBy, _meetingId3, _peerId7, _meetingId4, _displayName, _t6;
                                  return regenerator_default().wrap(function(_context1) {
                                    while (1) switch (_context1.prev = _context1.next) {
                                      case 0:
                                        payload = notification;
                                        logger.debug('proto "notification" event [method:%s, data:%o]', notification.method, payload);
                                        _t6 = notification.method;
                                        _context1.next = _t6 === "error" ? 1 : _t6 === "participantMediaStateChanged" ? 2 : _t6 === "producerScore" ? 3 : _t6 === "entryRequested" ? 4 : _t6 === "entryResponded" ? 5 : _t6 === "newPeer" ? 9 : _t6 === "peerClosed" ? 10 : _t6 === "peerDisplayNameChanged" ? 11 : _t6 === "consumerClosed" ? 12 : _t6 === "consumerPaused" ? 14 : _t6 === "consumerResumed" ? 16 : _t6 === "consumerLayersChanged" ? 18 : _t6 === "consumerScore" ? 20 : _t6 === "dataConsumerClosed" ? 21 : _t6 === "activeSpeaker" ? 23 : _t6 === "consumerResumedSubManager" ? 24 : _t6 === "consumerPausedSubManager" ? 25 : _t6 === "transcriptionStateChanged" ? 26 : _t6 === "transcriptionText" ? 27 : _t6 === "translationStateChanged" ? 28 : _t6 === "translationText" ? 29 : _t6 === "translationLanguageChanged" ? 30 : _t6 === "recordingStateChanged" ? 31 : _t6 === "recordingStarted" ? 32 : _t6 === "recordingStopped" ? 33 : _t6 === "livestreamStateChanged" ? 34 : _t6 === "livestreamStarted" ? 35 : _t6 === "livestreamStopped" ? 36 : _t6 === "hlsStateChanged" ? 37 : _t6 === "hlsPlayableStateChanged" ? 38 : _t6 === "hlsStarted" ? 39 : _t6 === "hlsStopped" ? 40 : _t6 === "whiteboardStarted" ? 41 : _t6 === "whiteboardStopped" ? 42 : _t6 === "addCharacter" ? 43 : _t6 === "removeCharacter" ? 44 : _t6 === "characterStateChanged" ? 45 : _t6 === "characterMessage" ? 46 : _t6 === "userMessage" ? 47 : _t6 === "characterData" ? 48 : _t6 === "characterError" ? 49 : _t6 === "videoStatusChanged" ? 50 : _t6 === "videoSeeked" ? 51 : _t6 === "connectionOpen" ? 52 : _t6 === "connectionClose" ? 53 : _t6 === "connectionChatMessage" ? 54 : _t6 === "connectionParticipantJoined" ? 55 : _t6 === "connectionParticipantLeft" ? 56 : _t6 === "pubsubMessage" ? 57 : _t6 === "realtimeStoreValueChanged" ? 58 : _t6 === "peerModeChanged" ? 59 : _t6 === "restartIce" ? 60 : _t6 === "mediaRelayStarted" ? 61 : _t6 === "mediaRelayStopped" ? 62 : _t6 === "mediaRelayError" ? 63 : _t6 === "mediaRelayRequestResponse" ? 64 : _t6 === "mediaRelayRequestReceived" ? 65 : 66;
                                        break;
                                      case 1:
                                        error = payload;
                                        _this._eventEmitter.emit("ERROR", error);
                                        (_this$_videosdkLogs12 = _this._videosdkLogs) === null || _this$_videosdkLogs12 === void 0 || _this$_videosdkLogs12.pushLogs({
                                          logText: "Error in Meeting Session",
                                          logType: "ERROR",
                                          attributes: {
                                            error: error.message
                                          }
                                        });
                                        (_this$_openTelemetry34 = _this._openTelemetry) === null || _this$_openTelemetry34 === void 0 || _this$_openTelemetry34.traceAutoComplete({
                                          spanName: "Emitted `ERROR` Event",
                                          attributes: {
                                            error: error.message
                                          },
                                          status: 2
                                        });
                                        return _context1.abrupt("continue", 67);
                                      case 2:
                                        try {
                                          peerId = payload.peerId, kind = payload.kind, newState = payload.newState;
                                          _this._eventEmitter.emit("PARTICIPANT_MEDIA_STATE_CHANGED", {
                                            peerId,
                                            kind,
                                            newState
                                          });
                                          if (kind == "video") {
                                            (_this$_openTelemetry35 = _this._openTelemetry) === null || _this$_openTelemetry35 === void 0 || _this$_openTelemetry35.traceAutoComplete({
                                              spanName: "".concat(peerId, " has ").concat(newState ? "enable" : "disable", " ").concat(kind),
                                              status: 1
                                            });
                                          }
                                        } catch (error2) {
                                          logger.error('"newProducer" request failed:%o', error2);
                                          (_this$_videosdkLogs13 = _this._videosdkLogs) === null || _this$_videosdkLogs13 === void 0 || _this$_videosdkLogs13.pushLogs({
                                            logText: "Error newProducer request failed",
                                            logType: "ERROR",
                                            attributes: {
                                              error: error2.message
                                            }
                                          });
                                        }
                                      case 3:
                                        producerId = payload.producerId, score = payload.score;
                                        store.dispatch(setProducerScore(producerId, score));
                                        return _context1.abrupt("continue", 67);
                                      case 4:
                                        id = payload.id, name = payload.name;
                                        internalSpan = (_this$_openTelemetry36 = _this._openTelemetry) === null || _this$_openTelemetry36 === void 0 ? void 0 : _this$_openTelemetry36.trace({
                                          spanName: "Websocket Noti: entryRequested",
                                          span: _this._joinSpan,
                                          attributes: {
                                            data: JSON.stringify({
                                              id,
                                              name
                                            })
                                          }
                                        });
                                        if (id !== _this._peerId) {
                                          _this._eventEmitter.emit("ENTRY_REQUESTED", {
                                            id,
                                            name
                                          });
                                          (_this$_openTelemetry37 = _this._openTelemetry) === null || _this$_openTelemetry37 === void 0 || _this$_openTelemetry37.completeSpan({
                                            span: internalSpan,
                                            status: 1,
                                            message: "EntryResponded Recieved"
                                          });
                                        } else {
                                          (_this$_openTelemetry38 = _this._openTelemetry) === null || _this$_openTelemetry38 === void 0 || _this$_openTelemetry38.completeSpan({
                                            span: internalSpan,
                                            status: 2,
                                            message: "Entry Request Failed"
                                          });
                                        }
                                        return _context1.abrupt("continue", 67);
                                      case 5:
                                        _id = payload.id, decision = payload.decision, sessionId = payload.sessionId, switchingRoomId = payload.switchingRoomId;
                                        entryResponseSpan = (_this$_openTelemetry39 = _this._openTelemetry) === null || _this$_openTelemetry39 === void 0 ? void 0 : _this$_openTelemetry39.trace({
                                          name: "Entry Response Handling",
                                          attributes: {
                                            "peer.id": _id,
                                            "entry.decision": decision,
                                            switching_room: !!switchingRoomId
                                          }
                                        });
                                        _this._eventEmitter.emit("ENTRY_RESPONDED", {
                                          id: _id,
                                          decision
                                        });
                                        if (!(_id === _this._peerId && decision === "allowed")) {
                                          _context1.next = 7;
                                          break;
                                        }
                                        if (!switchingRoomId) {
                                          _context1.next = 6;
                                          break;
                                        }
                                        (_this$_openTelemetry40 = _this._openTelemetry) === null || _this$_openTelemetry40 === void 0 || _this$_openTelemetry40.completeSpan({
                                          span: entryResponseSpan,
                                          status: 1,
                                          message: "Switching room initiated"
                                        });
                                        _this.softClose();
                                        _this.switchingRoom(switchingRoomId);
                                        return _context1.abrupt("continue", 67);
                                      case 6:
                                        _this._videosdkLogs = new VideoSDKLogs({
                                          roomId: _this._roomId,
                                          peerId: _this._peerId,
                                          logs,
                                          observabilityJwt,
                                          deviceInfo: _this._deviceInfo,
                                          sessionId,
                                          debugMode: _this._debugMode
                                        });
                                        _this.joinRoom();
                                        (_this$_openTelemetry41 = _this._openTelemetry) === null || _this$_openTelemetry41 === void 0 || _this$_openTelemetry41.completeSpan({
                                          span: entryResponseSpan,
                                          status: 1,
                                          message: "EntryResponded Recieved"
                                        });
                                        _context1.next = 8;
                                        break;
                                      case 7:
                                        (_this$_openTelemetry42 = _this._openTelemetry) === null || _this$_openTelemetry42 === void 0 || _this$_openTelemetry42.completeSpan({
                                          span: _this._joinSpan,
                                          status: 2,
                                          message: "Join Request Denied"
                                        });
                                      case 8:
                                        return _context1.abrupt("continue", 67);
                                      case 9:
                                        peer = payload;
                                        action = addPeer(RoomClient_objectSpread(RoomClient_objectSpread({}, peer), {}, {
                                          consumers: [],
                                          dataConsumers: []
                                        }));
                                        store.dispatch(action);
                                        _this._eventEmitter.emit(action.type, action.payload);
                                        store.dispatch(notify({
                                          text: "".concat(peer.displayName, " has joined the room")
                                        }));
                                        try {
                                          (_this$_openTelemetry43 = _this._openTelemetry) === null || _this$_openTelemetry43 === void 0 || _this$_openTelemetry43.traceAutoComplete({
                                            spanName: "Websocket Noti: newPeer ".concat(peer.displayName),
                                            attributes: {
                                              peerData: JSON.stringify(peer)
                                            }
                                          });
                                        } catch (error2) {
                                          (_this$_videosdkLogs14 = _this._videosdkLogs) === null || _this$_videosdkLogs14 === void 0 || _this$_videosdkLogs14.pushLogs({
                                            logText: "Error Websocket Noti: newPeer",
                                            logType: "ERROR",
                                            attributes: {
                                              error: error2.message
                                            }
                                          });
                                          console.error(error2);
                                        }
                                        return _context1.abrupt("continue", 67);
                                      case 10:
                                        _peerId2 = payload.peerId, reason = payload.reason;
                                        _action = removePeer(_peerId2, reason);
                                        store.dispatch(_action);
                                        _this._eventEmitter.emit(_action.type, _action.payload);
                                        (_this$_openTelemetry44 = _this._openTelemetry) === null || _this$_openTelemetry44 === void 0 || _this$_openTelemetry44.traceAutoComplete({
                                          spanName: "WebSocket Noti: Peer ".concat(_peerId2, " closed. Reason: ").concat(reason.message, " (Code: ").concat(reason.code, ")")
                                        });
                                        return _context1.abrupt("continue", 67);
                                      case 11:
                                        _peerId3 = payload.peerId, displayName = payload.displayName, oldDisplayName = payload.oldDisplayName;
                                        store.dispatch(setPeerDisplayName(displayName, _peerId3));
                                        store.dispatch(notify({
                                          text: "".concat(oldDisplayName, " is now ").concat(displayName)
                                        }));
                                        return _context1.abrupt("continue", 67);
                                      case 12:
                                        consumerId = payload.consumerId;
                                        consumer = _this._consumers.get(consumerId);
                                        if (consumer) {
                                          _context1.next = 13;
                                          break;
                                        }
                                        return _context1.abrupt("continue", 67);
                                      case 13:
                                        consumer.close();
                                        _this._consumers["delete"](consumerId);
                                        _peerId4 = consumer.appData.peerId;
                                        _action2 = removeConsumer(consumerId, _peerId4);
                                        _this._eventEmitter.emit("STREAM_STATE_CHANGED", {
                                          state: "ended",
                                          peerId: _peerId4,
                                          streamId: consumer._track.id
                                        });
                                        store.dispatch(_action2);
                                        _this._eventEmitter.emit(_action2.type, _action2.payload);
                                        (_this$_openTelemetry45 = _this._openTelemetry) === null || _this$_openTelemetry45 === void 0 || _this$_openTelemetry45.traceAutoComplete({
                                          spanName: "Websocket Noti: consumerClosed for id ".concat(consumerId),
                                          attributes: {
                                            consumerData: JSON.stringify(consumer)
                                          }
                                        });
                                        return _context1.abrupt("continue", 67);
                                      case 14:
                                        _consumerId = payload.consumerId;
                                        _consumer = _this._consumers.get(_consumerId);
                                        if (_consumer) {
                                          _context1.next = 15;
                                          break;
                                        }
                                        return _context1.abrupt("continue", 67);
                                      case 15:
                                        _consumer.pause();
                                        store.dispatch(setConsumerPaused(_consumerId, "remote"));
                                        _this._eventEmitter.emit("CONSUMER_PAUSED", {
                                          consumerId: _consumerId,
                                          peerId: _consumer.appData.peerId
                                        });
                                        return _context1.abrupt("continue", 67);
                                      case 16:
                                        _consumerId2 = payload.consumerId;
                                        _consumer2 = _this._consumers.get(_consumerId2);
                                        _this._eventEmitter.emit("STREAM_STATE_CHANGED", {
                                          state: "active",
                                          peerId: _consumer2.appData.peerId,
                                          streamId: _consumer2._track.id
                                        });
                                        if (_consumer2) {
                                          _context1.next = 17;
                                          break;
                                        }
                                        return _context1.abrupt("continue", 67);
                                      case 17:
                                        _consumer2.resume();
                                        store.dispatch(setConsumerResumed(_consumerId2, "remote"));
                                        _this._eventEmitter.emit("CONSUMER_RESUMED", {
                                          consumerId: _consumerId2,
                                          peerId: _consumer2.appData.peerId
                                        });
                                        return _context1.abrupt("continue", 67);
                                      case 18:
                                        _consumerId3 = payload.consumerId, spatialLayer = payload.spatialLayer, temporalLayer = payload.temporalLayer;
                                        _consumer3 = _this._consumers.get(_consumerId3);
                                        _consumer3.currentSpatialLayer = spatialLayer;
                                        _consumer3.currentTemporalLayer = temporalLayer;
                                        if (_consumer3) {
                                          _context1.next = 19;
                                          break;
                                        }
                                        return _context1.abrupt("continue", 67);
                                      case 19:
                                        if (((_consumer3$appData = _consumer3.appData) === null || _consumer3$appData === void 0 || (_consumer3$appData = _consumer3$appData.encodings) === null || _consumer3$appData === void 0 ? void 0 : _consumer3$appData.length) > 1) {
                                          _this._eventEmitter.emit("VIDEO_QUALITY_CHANGED", {
                                            peerId: _consumer3.appData.peerId,
                                            prevQuality: _consumer3.spatialLayers - 1 - _consumer3.currentSpatialLayer == 0 ? "HIGH" : _consumer3.spatialLayers - 1 - _consumer3.currentSpatialLayer == 1 ? "MEDIUM" : "LOW",
                                            currentQuality: _consumer3.spatialLayers - 1 - spatialLayer == 0 ? "HIGH" : _consumer3.spatialLayers - 1 - spatialLayer == 1 ? "MEDIUM" : "LOW"
                                          });
                                        } else {
                                        }
                                        _consumer3.currentSpatialLayer = spatialLayer;
                                        _consumer3.currentTemporalLayer = temporalLayer;
                                        store.dispatch(setConsumerCurrentLayers(_consumerId3, spatialLayer, temporalLayer));
                                        return _context1.abrupt("continue", 67);
                                      case 20:
                                        _consumerId4 = payload.consumerId, _score = payload.score;
                                        store.dispatch(setConsumerScore(_consumerId4, _score));
                                        return _context1.abrupt("continue", 67);
                                      case 21:
                                        dataConsumerId = payload.dataConsumerId;
                                        dataConsumer = _this._dataConsumers.get(dataConsumerId);
                                        if (dataConsumer) {
                                          _context1.next = 22;
                                          break;
                                        }
                                        return _context1.abrupt("continue", 67);
                                      case 22:
                                        dataConsumer.close();
                                        _this._dataConsumers["delete"](dataConsumerId);
                                        _peerId5 = dataConsumer.appData.peerId;
                                        store.dispatch(removeDataConsumer(dataConsumerId, _peerId5));
                                        return _context1.abrupt("continue", 67);
                                      case 23:
                                        _peerId6 = payload.peerId;
                                        _action3 = setRoomActiveSpeaker(_peerId6);
                                        store.dispatch(_action3);
                                        _this._eventEmitter.emit(_action3.type, _action3.payload);
                                        return _context1.abrupt("continue", 67);
                                      case 24:
                                        _this._eventEmitter.emit("SUB_MANAGER_RESUMED", payload);
                                        return _context1.abrupt("continue", 67);
                                      case 25:
                                        _this._eventEmitter.emit("SUB_MANAGER_PAUSED", payload);
                                        return _context1.abrupt("continue", 67);
                                      case 26:
                                        _this._eventEmitter.emit("TRANSCRIPTION_STATE_CHANGED", payload);
                                        (_this$_openTelemetry46 = _this._openTelemetry) === null || _this$_openTelemetry46 === void 0 || _this$_openTelemetry46.traceAutoComplete({
                                          spanName: "Emitted TRANSCRIPTION_STATE_CHANGED, status : ".concat(payload.status),
                                          attributes: {
                                            data: JSON.stringify(payload)
                                          },
                                          status: 1
                                        });
                                        return _context1.abrupt("continue", 67);
                                      case 27:
                                        _this._eventEmitter.emit("TRANSCRIPTION_TEXT", payload);
                                        return _context1.abrupt("continue", 67);
                                      case 28:
                                        _this._eventEmitter.emit("TRANSLATION_STATE_CHANGED", payload);
                                        (_this$_openTelemetry47 = _this._openTelemetry) === null || _this$_openTelemetry47 === void 0 || _this$_openTelemetry47.traceAutoComplete({
                                          spanName: "Emitted TRANSLATION_STATE_CHANGED, status : ".concat(payload.status),
                                          attributes: {
                                            data: JSON.stringify(payload)
                                          },
                                          status: 1
                                        });
                                        return _context1.abrupt("continue", 67);
                                      case 29:
                                        if (_this._translationLanguage == payload.language) {
                                          _this._eventEmitter.emit("TRANSLATION_TEXT", payload);
                                        }
                                        return _context1.abrupt("continue", 67);
                                      case 30:
                                        _this._eventEmitter.emit("TRANSLATION_LANGUAGE_CHANGED", payload);
                                        if (_this._peerId == payload.peerId) {
                                          _this._translationLanguage = payload.language;
                                        }
                                        return _context1.abrupt("continue", 67);
                                      case 31:
                                        _this._eventEmitter.emit("RECORDING_STATE_CHANGED", payload);
                                        (_this$_openTelemetry48 = _this._openTelemetry) === null || _this$_openTelemetry48 === void 0 || _this$_openTelemetry48.traceAutoComplete({
                                          spanName: "Emitted RECORDING_STATE_CHANGED, status : ".concat(payload.status),
                                          attributes: {
                                            data: JSON.stringify(payload)
                                          },
                                          status: 1
                                        });
                                        return _context1.abrupt("continue", 67);
                                      case 32:
                                        _this._eventEmitter.emit("RECORDING_STARTED", {});
                                        return _context1.abrupt("continue", 67);
                                      case 33:
                                        _this._eventEmitter.emit("RECORDING_STOPPED", {});
                                        return _context1.abrupt("continue", 67);
                                      case 34:
                                        _this._eventEmitter.emit("LIVESTREAM_STATE_CHANGED", payload);
                                        (_this$_openTelemetry49 = _this._openTelemetry) === null || _this$_openTelemetry49 === void 0 || _this$_openTelemetry49.traceAutoComplete({
                                          spanName: "Emitted LIVESTREAM_STATE_CHANGED, status : ".concat(payload.status),
                                          attributes: {
                                            data: JSON.stringify(payload)
                                          },
                                          status: 1
                                        });
                                        return _context1.abrupt("continue", 67);
                                      case 35:
                                        _this._eventEmitter.emit("LIVESTREAM_STARTED", {});
                                        return _context1.abrupt("continue", 67);
                                      case 36:
                                        _this._eventEmitter.emit("LIVESTREAM_STOPPED", {});
                                        return _context1.abrupt("continue", 67);
                                      case 37:
                                        _this._eventEmitter.emit("HLS_STATE_CHANGED", payload);
                                        (_this$_openTelemetry50 = _this._openTelemetry) === null || _this$_openTelemetry50 === void 0 || _this$_openTelemetry50.traceAutoComplete({
                                          spanName: "Emitted HLS_STATE_CHANGED, status : ".concat(payload.status),
                                          attributes: {
                                            data: JSON.stringify(payload)
                                          },
                                          status: 1
                                        });
                                        return _context1.abrupt("continue", 67);
                                      case 38:
                                        if (payload.isPlayable) {
                                          _this._eventEmitter.emit("HLS_STATE_CHANGED", RoomClient_objectSpread(RoomClient_objectSpread({}, payload), {}, {
                                            status: hlsEvents.V.HLS_PLAYABLE
                                          }));
                                          (_this$_openTelemetry51 = _this._openTelemetry) === null || _this$_openTelemetry51 === void 0 || _this$_openTelemetry51.traceAutoComplete({
                                            spanName: "Websocket Noti: hlsPlayableStateChanged",
                                            status: 1
                                          });
                                        }
                                        return _context1.abrupt("continue", 67);
                                      case 39:
                                        downstreamUrl = payload.downstreamUrl;
                                        _this._eventEmitter.emit("HLS_STARTED", downstreamUrl);
                                        return _context1.abrupt("continue", 67);
                                      case 40:
                                        _this._eventEmitter.emit("HLS_STOPPED", {});
                                        return _context1.abrupt("continue", 67);
                                      case 41:
                                        _state2 = payload.state, url2 = payload.url;
                                        if (_state2) {
                                          _this._eventEmitter.emit("WHITEBOARD_STARTED", {
                                            state: _state2
                                          });
                                        } else if (url2) {
                                          _this._eventEmitter.emit("WHITEBOARD_STARTED", {
                                            url: url2
                                          });
                                        }
                                        return _context1.abrupt("continue", 67);
                                      case 42:
                                        _this._eventEmitter.emit("WHITEBOARD_STOPPED", {});
                                        return _context1.abrupt("continue", 67);
                                      case 43:
                                        character = payload;
                                        _action4 = addPeer(RoomClient_objectSpread(RoomClient_objectSpread({}, character), {}, {
                                          consumers: [],
                                          dataConsumers: []
                                        }));
                                        store.dispatch(_action4);
                                        _this._eventEmitter.emit("ADD_CHARACTER", payload);
                                        (_this$_openTelemetry52 = _this._openTelemetry) === null || _this$_openTelemetry52 === void 0 || _this$_openTelemetry52.traceAutoComplete({
                                          spanName: "Emitted ADD_CHARACTER : ".concat(payload),
                                          attributes: {
                                            data: JSON.stringify(payload)
                                          },
                                          status: 1
                                        });
                                        return _context1.abrupt("continue", 67);
                                      case 44:
                                        _id2 = payload.id;
                                        _action5 = removePeer(_id2);
                                        store.dispatch(_action5);
                                        _this._eventEmitter.emit("REMOVE_CHARACTER", payload);
                                        (_this$_openTelemetry53 = _this._openTelemetry) === null || _this$_openTelemetry53 === void 0 || _this$_openTelemetry53.traceAutoComplete({
                                          spanName: "Emitted REMOVE_CHARACTER : ".concat(payload),
                                          attributes: {
                                            data: JSON.stringify(payload)
                                          },
                                          status: 1
                                        });
                                        return _context1.abrupt("continue", 67);
                                      case 45:
                                        _this._eventEmitter.emit("CHARACTER_STATE_CHANGED", payload);
                                        (_this$_openTelemetry54 = _this._openTelemetry) === null || _this$_openTelemetry54 === void 0 || _this$_openTelemetry54.traceAutoComplete({
                                          spanName: "Emitted CHARACTER_STATE_CHANGED, status : ".concat(payload.status),
                                          attributes: {
                                            data: JSON.stringify(payload)
                                          },
                                          status: 1
                                        });
                                        return _context1.abrupt("continue", 67);
                                      case 46:
                                        _this._eventEmitter.emit("CHARACTER_MESSAGE", payload);
                                        return _context1.abrupt("continue", 67);
                                      case 47:
                                        _this._eventEmitter.emit("USER_MESSAGE", payload);
                                        return _context1.abrupt("continue", 67);
                                      case 48:
                                        _this._eventEmitter.emit("CHARACTER_DATA", payload);
                                        return _context1.abrupt("continue", 67);
                                      case 49:
                                        _this._eventEmitter.emit("CHARACTER_ERROR", payload);
                                        return _context1.abrupt("continue", 67);
                                      case 50:
                                        _this._eventEmitter.emit("VIDEO_STATE_CHANGED", payload);
                                        return _context1.abrupt("continue", 67);
                                      case 51:
                                        currentTime = payload.currentTime;
                                        _this._eventEmitter.emit("VIDEO_SEEKED", {
                                          currentTime
                                        });
                                        return _context1.abrupt("continue", 67);
                                      case 52:
                                        _this._eventEmitter.emit("CONNECTION_OPEN", payload);
                                        return _context1.abrupt("continue", 67);
                                      case 53:
                                        _this._eventEmitter.emit("CONNECTION_CLOSE", payload);
                                        return _context1.abrupt("continue", 67);
                                      case 54:
                                        _this._eventEmitter.emit("CONNECTION_CHAT_MESSAGE", payload);
                                        return _context1.abrupt("continue", 67);
                                      case 55:
                                        _this._eventEmitter.emit("CONNECTION_PARTICIPANT_JOIN", payload);
                                        return _context1.abrupt("continue", 67);
                                      case 56:
                                        _this._eventEmitter.emit("CONNECTION_PARTICIPANT_LEFT", payload);
                                        return _context1.abrupt("continue", 67);
                                      case 57:
                                        _this._eventEmitter.emit("PUBSUB_MESSAGE", payload);
                                        return _context1.abrupt("continue", 67);
                                      case 58:
                                        _this._eventEmitter.emit("REALTIMESTORE_VALUE_CHANGED", payload);
                                        return _context1.abrupt("continue", 67);
                                      case 59:
                                        _this._eventEmitter.emit("PEER_MODE_CHANGED", payload);
                                        (_this$_openTelemetry55 = _this._openTelemetry) === null || _this$_openTelemetry55 === void 0 || _this$_openTelemetry55.traceAutoComplete({
                                          spanName: "Emitted PEER_MODE_CHANGED",
                                          attributes: {
                                            data: JSON.stringify(payload)
                                          },
                                          status: 1
                                        });
                                        return _context1.abrupt("continue", 67);
                                      case 60:
                                        transportId = payload.transportId, iceParameters = payload.iceParameters;
                                        _internalSpan = (_this$_openTelemetry56 = _this._openTelemetry) === null || _this$_openTelemetry56 === void 0 ? void 0 : _this$_openTelemetry56.trace({
                                          spanName: "Websocket Noti: restartIce for transportId :".concat(transportId),
                                          attributes: {
                                            iceParameters: JSON.stringify(iceParameters)
                                          }
                                        });
                                        _this.handleRemoteRestartIce({
                                          transportId,
                                          iceParameters,
                                          internalSpan: _internalSpan
                                        });
                                        return _context1.abrupt("continue", 67);
                                      case 61:
                                        meetingId = notification.meetingId;
                                        _this._eventEmitter.emit("MEDIA_RELAY_STARTED", {
                                          meetingId
                                        });
                                        return _context1.abrupt("continue", 67);
                                      case 62:
                                        _meetingId = notification.meetingId, _reason = notification.reason;
                                        _this._eventEmitter.emit("MEDIA_RELAY_STOPPED", {
                                          meetingId: _meetingId,
                                          reason: _reason
                                        });
                                        return _context1.abrupt("continue", 67);
                                      case 63:
                                        _meetingId2 = notification.meetingId, _reason2 = notification.reason;
                                        _this._eventEmitter.emit("MEDIA_RELAY_ERROR", {
                                          meetingId: _meetingId2,
                                          reason: _reason2
                                        });
                                        return _context1.abrupt("continue", 67);
                                      case 64:
                                        _decision = notification.decision, decidedBy = notification.decidedBy, _meetingId3 = notification.meetingId;
                                        _this._eventEmitter.emit("MEDIA_RELAY_REQUEST_RESPONSE", {
                                          decision: _decision,
                                          decidedBy,
                                          meetingId: _meetingId3
                                        });
                                        return _context1.abrupt("continue", 67);
                                      case 65:
                                        _peerId7 = notification.peerId, _meetingId4 = notification.meetingId, _displayName = notification.displayName;
                                        _this._eventEmitter.emit("MEDIA_RELAY_REQUEST_RECEIVED", {
                                          peerId: _peerId7,
                                          meetingId: _meetingId4,
                                          displayName: _displayName
                                        });
                                        return _context1.abrupt("continue", 67);
                                      case 66:
                                        logger.error('unknown Websocket notification.method "%s"', notification.method);
                                      case 67:
                                      case "end":
                                        return _context1.stop();
                                    }
                                  }, _callee1);
                                }));
                                return function(_x18) {
                                  return _ref10.apply(this, arguments);
                                };
                              }());
                              _context10.next = 3;
                              break;
                            case 2:
                              _context10.prev = 2;
                              _t7 = _context10["catch"](0);
                              (_this$_videosdkLogs15 = this._videosdkLogs) === null || _this$_videosdkLogs15 === void 0 || _this$_videosdkLogs15.pushLogs({
                                logText: "Error initializing the meeting :: ".concat(_t7),
                                logType: "ERROR",
                                attributes: {
                                  error: _t7
                                }
                              });
                              this.emitMeetingStateChange(state.FAILED);
                            case 3:
                            case "end":
                              return _context10.stop();
                          }
                        }, _callee10, this, [[0, 2]]);
                      }));
                      function join() {
                        return _join.apply(this, arguments);
                      }
                      return join;
                    }()
                  }, {
                    key: "requestEntry",
                    value: function() {
                      var _requestEntry = (0, asyncToGenerator.A)(regenerator_default().mark(function _callee11() {
                        var _this$_openTelemetry57, _this$_openTelemetry58;
                        var requestEntrySpan;
                        return regenerator_default().wrap(function(_context11) {
                          while (1) switch (_context11.prev = _context11.next) {
                            case 0:
                              requestEntrySpan = (_this$_openTelemetry57 = this._openTelemetry) === null || _this$_openTelemetry57 === void 0 ? void 0 : _this$_openTelemetry57.trace({
                                spanName: "Requesting Entry",
                                span: this._joinSpan
                              });
                              _context11.next = 1;
                              return this._socketRequest("requestEntry", {
                                name: this._displayName
                              });
                            case 1:
                              (_this$_openTelemetry58 = this._openTelemetry) === null || _this$_openTelemetry58 === void 0 || _this$_openTelemetry58.completeSpan({
                                span: requestEntrySpan,
                                status: 1,
                                message: "Entry Requested Successfully"
                              });
                            case 2:
                            case "end":
                              return _context11.stop();
                          }
                        }, _callee11, this);
                      }));
                      function requestEntry() {
                        return _requestEntry.apply(this, arguments);
                      }
                      return requestEntry;
                    }()
                  }, {
                    key: "respondEntry",
                    value: function() {
                      var _respondEntry = (0, asyncToGenerator.A)(regenerator_default().mark(function _callee12(peerId, decision) {
                        var _this$_openTelemetry59, _this$_openTelemetry60;
                        var respondEntrySpan;
                        return regenerator_default().wrap(function(_context12) {
                          while (1) switch (_context12.prev = _context12.next) {
                            case 0:
                              respondEntrySpan = (_this$_openTelemetry59 = this._openTelemetry) === null || _this$_openTelemetry59 === void 0 ? void 0 : _this$_openTelemetry59.trace({
                                spanName: "Responding Entry",
                                attributes: {
                                  peerId,
                                  decision
                                },
                                span: this._joinSpan
                              });
                              _context12.next = 1;
                              return this._socketRequest("respondEntry", {
                                id: peerId,
                                decision
                              });
                            case 1:
                              (_this$_openTelemetry60 = this._openTelemetry) === null || _this$_openTelemetry60 === void 0 || _this$_openTelemetry60.completeSpan({
                                message: "Entry Responded Successfully",
                                span: respondEntrySpan,
                                status: 1
                              });
                            case 2:
                            case "end":
                              return _context12.stop();
                          }
                        }, _callee12, this);
                      }));
                      function respondEntry(_x19, _x20) {
                        return _respondEntry.apply(this, arguments);
                      }
                      return respondEntry;
                    }()
                  }, {
                    key: "startTranscription",
                    value: function() {
                      var _startTranscription = (0, asyncToGenerator.A)(regenerator_default().mark(function _callee13(config3) {
                        var _this$_openTelemetry61, _this$_openTelemetry63;
                        var startTranscriptionSpan, _this$_openTelemetry62, _this$_videosdkLogs16, _t8;
                        return regenerator_default().wrap(function(_context13) {
                          while (1) switch (_context13.prev = _context13.next) {
                            case 0:
                              logger.debug("startTranscription()");
                              startTranscriptionSpan = (_this$_openTelemetry61 = this._openTelemetry) === null || _this$_openTelemetry61 === void 0 ? void 0 : _this$_openTelemetry61.trace({
                                spanName: "startTranscription() Start",
                                attributes: {
                                  config: config3 ? JSON.stringify(config3) : "config Not Specify"
                                }
                              });
                              _context13.prev = 1;
                              _context13.next = 2;
                              return this._socketRequest("startTranscription", {
                                config: config3
                              });
                            case 2:
                              _context13.next = 4;
                              break;
                            case 3:
                              _context13.prev = 3;
                              _t8 = _context13["catch"](1);
                              logger.error("startTranscription() | failed:%o", _t8);
                              (_this$_openTelemetry62 = this._openTelemetry) === null || _this$_openTelemetry62 === void 0 || _this$_openTelemetry62.completeSpan({
                                span: startTranscriptionSpan,
                                status: 2,
                                message: "startTranscription() failed"
                              });
                              (_this$_videosdkLogs16 = this._videosdkLogs) === null || _this$_videosdkLogs16 === void 0 || _this$_videosdkLogs16.pushLogs({
                                logText: "Error startTranscription() failed",
                                logType: "ERROR",
                                attributes: {
                                  error: _t8.message
                                }
                              });
                              this._emitError({
                                code: 4031,
                                message: _t8.message
                              });
                            case 4:
                              (_this$_openTelemetry63 = this._openTelemetry) === null || _this$_openTelemetry63 === void 0 || _this$_openTelemetry63.completeSpan({
                                span: startTranscriptionSpan,
                                status: 1,
                                message: "startTranscription() End"
                              });
                            case 5:
                            case "end":
                              return _context13.stop();
                          }
                        }, _callee13, this, [[1, 3]]);
                      }));
                      function startTranscription(_x21) {
                        return _startTranscription.apply(this, arguments);
                      }
                      return startTranscription;
                    }()
                  }, {
                    key: "stopTranscription",
                    value: function() {
                      var _stopTranscription = (0, asyncToGenerator.A)(regenerator_default().mark(function _callee14() {
                        var _this$_openTelemetry64, _this$_openTelemetry66;
                        var stopTranscriptionSpan, _this$_openTelemetry65, _this$_videosdkLogs17, _t9;
                        return regenerator_default().wrap(function(_context14) {
                          while (1) switch (_context14.prev = _context14.next) {
                            case 0:
                              logger.debug("stopTranscription()");
                              stopTranscriptionSpan = (_this$_openTelemetry64 = this._openTelemetry) === null || _this$_openTelemetry64 === void 0 ? void 0 : _this$_openTelemetry64.trace({
                                spanName: "stopTranscription() Start"
                              });
                              _context14.prev = 1;
                              _context14.next = 2;
                              return this._socketRequest("stopTranscription", {});
                            case 2:
                              _context14.next = 4;
                              break;
                            case 3:
                              _context14.prev = 3;
                              _t9 = _context14["catch"](1);
                              (_this$_openTelemetry65 = this._openTelemetry) === null || _this$_openTelemetry65 === void 0 || _this$_openTelemetry65.completeSpan({
                                span: stopTranscriptionSpan,
                                status: 2,
                                message: "stopTranscription() failed"
                              });
                              (_this$_videosdkLogs17 = this._videosdkLogs) === null || _this$_videosdkLogs17 === void 0 || _this$_videosdkLogs17.pushLogs({
                                logText: "Error stopTranscription() failed",
                                logType: "ERROR",
                                attributes: {
                                  error: _t9.message
                                }
                              });
                              this._emitError({
                                code: 4032,
                                message: _t9.message
                              });
                            case 4:
                              (_this$_openTelemetry66 = this._openTelemetry) === null || _this$_openTelemetry66 === void 0 || _this$_openTelemetry66.completeSpan({
                                span: stopTranscriptionSpan,
                                status: 1,
                                message: "stopTranscription() End"
                              });
                            case 5:
                            case "end":
                              return _context14.stop();
                          }
                        }, _callee14, this, [[1, 3]]);
                      }));
                      function stopTranscription() {
                        return _stopTranscription.apply(this, arguments);
                      }
                      return stopTranscription;
                    }()
                  }, {
                    key: "startTranslation",
                    value: function() {
                      var _startTranslation = (0, asyncToGenerator.A)(regenerator_default().mark(function _callee15(config3) {
                        var _this$_openTelemetry67;
                        var startTranslationSpan, _this$_openTelemetry68, _this$_openTelemetry69, _this$_videosdkLogs18, _t0;
                        return regenerator_default().wrap(function(_context15) {
                          while (1) switch (_context15.prev = _context15.next) {
                            case 0:
                              logger.debug("startTranslation() called");
                              startTranslationSpan = (_this$_openTelemetry67 = this._openTelemetry) === null || _this$_openTelemetry67 === void 0 ? void 0 : _this$_openTelemetry67.trace({
                                spanName: "startTranslation() Start",
                                attributes: {
                                  config: config3 ? JSON.stringify(config3) : "config Not Specify"
                                }
                              });
                              _context15.prev = 1;
                              _context15.next = 2;
                              return this._socketRequest("startTranslation", {
                                config: config3
                              });
                            case 2:
                              (_this$_openTelemetry68 = this._openTelemetry) === null || _this$_openTelemetry68 === void 0 || _this$_openTelemetry68.completeSpan({
                                span: startTranslationSpan,
                                status: 1,
                                message: "startTranslation() End"
                              });
                              _context15.next = 4;
                              break;
                            case 3:
                              _context15.prev = 3;
                              _t0 = _context15["catch"](1);
                              logger.error("startTranslation() | failed:%o", _t0);
                              (_this$_openTelemetry69 = this._openTelemetry) === null || _this$_openTelemetry69 === void 0 || _this$_openTelemetry69.completeSpan({
                                span: startTranslationSpan,
                                status: 2,
                                message: "startTranslation() failed"
                              });
                              (_this$_videosdkLogs18 = this._videosdkLogs) === null || _this$_videosdkLogs18 === void 0 || _this$_videosdkLogs18.pushLogs({
                                logText: "Error startTranslation() failed",
                                logType: "ERROR",
                                attributes: {
                                  error: _t0.message
                                }
                              });
                              this._emitError({
                                code: 4042,
                                message: _t0.message
                              });
                              throw _t0;
                            case 4:
                            case "end":
                              return _context15.stop();
                          }
                        }, _callee15, this, [[1, 3]]);
                      }));
                      function startTranslation(_x22) {
                        return _startTranslation.apply(this, arguments);
                      }
                      return startTranslation;
                    }()
                  }, {
                    key: "changeTranslationLanguage",
                    value: function() {
                      var _changeTranslationLanguage = (0, asyncToGenerator.A)(regenerator_default().mark(function _callee16(language) {
                        var _this$_openTelemetry70;
                        var changeTranslationLanguageSpan, _this$_openTelemetry71, _this$_openTelemetry72, _this$_videosdkLogs19, _t1;
                        return regenerator_default().wrap(function(_context16) {
                          while (1) switch (_context16.prev = _context16.next) {
                            case 0:
                              logger.debug("changeTranslationLanguage() called");
                              changeTranslationLanguageSpan = (_this$_openTelemetry70 = this._openTelemetry) === null || _this$_openTelemetry70 === void 0 ? void 0 : _this$_openTelemetry70.trace({
                                spanName: "changeTranslationLanguage() Start",
                                attributes: {
                                  language: language !== null && language !== void 0 ? language : "Language Not Specified"
                                }
                              });
                              _context16.prev = 1;
                              _context16.next = 2;
                              return this._socketRequest("changeTranslationLanguage", {
                                language
                              });
                            case 2:
                              (_this$_openTelemetry71 = this._openTelemetry) === null || _this$_openTelemetry71 === void 0 || _this$_openTelemetry71.completeSpan({
                                span: changeTranslationLanguageSpan,
                                status: 1,
                                message: "changeTranslationLanguage() End"
                              });
                              _context16.next = 4;
                              break;
                            case 3:
                              _context16.prev = 3;
                              _t1 = _context16["catch"](1);
                              logger.error("changeTranslationLanguage() | failed:%o", _t1);
                              (_this$_openTelemetry72 = this._openTelemetry) === null || _this$_openTelemetry72 === void 0 || _this$_openTelemetry72.completeSpan({
                                span: changeTranslationLanguageSpan,
                                status: 2,
                                message: "changeTranslationLanguage() failed"
                              });
                              (_this$_videosdkLogs19 = this._videosdkLogs) === null || _this$_videosdkLogs19 === void 0 || _this$_videosdkLogs19.pushLogs({
                                logText: "Error changeTranslationLanguage() failed",
                                logType: "ERROR",
                                attributes: {
                                  error: _t1.message
                                }
                              });
                              this._emitError({
                                code: 4043,
                                message: _t1.message
                              });
                              throw _t1;
                            case 4:
                            case "end":
                              return _context16.stop();
                          }
                        }, _callee16, this, [[1, 3]]);
                      }));
                      function changeTranslationLanguage(_x23) {
                        return _changeTranslationLanguage.apply(this, arguments);
                      }
                      return changeTranslationLanguage;
                    }()
                  }, {
                    key: "stopTranslation",
                    value: function() {
                      var _stopTranslation = (0, asyncToGenerator.A)(regenerator_default().mark(function _callee17() {
                        var _this$_openTelemetry73;
                        var stopTranslationSpan, _this$_openTelemetry74, _this$_openTelemetry75, _this$_videosdkLogs20, _t10;
                        return regenerator_default().wrap(function(_context17) {
                          while (1) switch (_context17.prev = _context17.next) {
                            case 0:
                              logger.debug("stopTranslation() called");
                              stopTranslationSpan = (_this$_openTelemetry73 = this._openTelemetry) === null || _this$_openTelemetry73 === void 0 ? void 0 : _this$_openTelemetry73.trace({
                                spanName: "stopTranslation() Start"
                              });
                              _context17.prev = 1;
                              _context17.next = 2;
                              return this._socketRequest("stopTranslation", {});
                            case 2:
                              (_this$_openTelemetry74 = this._openTelemetry) === null || _this$_openTelemetry74 === void 0 || _this$_openTelemetry74.completeSpan({
                                span: stopTranslationSpan,
                                status: 1,
                                message: "stopTranslation() End"
                              });
                              _context17.next = 4;
                              break;
                            case 3:
                              _context17.prev = 3;
                              _t10 = _context17["catch"](1);
                              (_this$_openTelemetry75 = this._openTelemetry) === null || _this$_openTelemetry75 === void 0 || _this$_openTelemetry75.completeSpan({
                                span: stopTranslationSpan,
                                status: 2,
                                message: "stopTranslation() failed"
                              });
                              (_this$_videosdkLogs20 = this._videosdkLogs) === null || _this$_videosdkLogs20 === void 0 || _this$_videosdkLogs20.pushLogs({
                                logText: "Error stopTranslation() failed",
                                logType: "ERROR",
                                attributes: {
                                  error: _t10.message
                                }
                              });
                              this._emitError({
                                code: 4044,
                                message: _t10.message
                              });
                              throw _t10;
                            case 4:
                            case "end":
                              return _context17.stop();
                          }
                        }, _callee17, this, [[1, 3]]);
                      }));
                      function stopTranslation() {
                        return _stopTranslation.apply(this, arguments);
                      }
                      return stopTranslation;
                    }()
                  }, {
                    key: "pauseAllConsumers",
                    value: function() {
                      var _pauseAllConsumers = (0, asyncToGenerator.A)(regenerator_default().mark(function _callee18(kind) {
                        var _this$_openTelemetry76, _this$_openTelemetry78;
                        var pauseConsumersSpan, _response$consumersWi, response, success, _response$consumersWi2, _response, _this$_openTelemetry77, _this$_videosdkLogs21, _t11;
                        return regenerator_default().wrap(function(_context18) {
                          while (1) switch (_context18.prev = _context18.next) {
                            case 0:
                              pauseConsumersSpan = (_this$_openTelemetry76 = this._openTelemetry) === null || _this$_openTelemetry76 === void 0 ? void 0 : _this$_openTelemetry76.trace({
                                spanName: "pauseAllConsumers() Start",
                                attributes: {
                                  kind: kind ? kind : "Kind not specified"
                                }
                              });
                              _context18.prev = 1;
                              _context18.next = 2;
                              return this._socketRequest("pauseAllConsumers", {
                                kind: kind === void 0 ? "all" : kind
                              });
                            case 2:
                              response = _context18.sent;
                              success = false;
                              if (!((response === null || response === void 0 || (_response$consumersWi = response.consumersWithIssues) === null || _response$consumersWi === void 0 ? void 0 : _response$consumersWi.length) > 0)) {
                                _context18.next = 4;
                                break;
                              }
                              _context18.next = 3;
                              return this._socketRequest("pauseAllConsumers", {
                                kind: kind === void 0 ? "all" : kind
                              });
                            case 3:
                              _response = _context18.sent;
                              if ((_response === null || _response === void 0 || (_response$consumersWi2 = _response.consumersWithIssues) === null || _response$consumersWi2 === void 0 ? void 0 : _response$consumersWi2.length) === 0) {
                                success = true;
                              }
                              _context18.next = 5;
                              break;
                            case 4:
                              success = true;
                            case 5:
                              if (success) {
                                this._eventEmitter.emit("ALL_CONSUMERS_PAUSED", {
                                  kind
                                });
                              }
                              _context18.next = 7;
                              break;
                            case 6:
                              _context18.prev = 6;
                              _t11 = _context18["catch"](1);
                              logger.error("pauseAllConsumers() | failed:%o", _t11);
                              (_this$_openTelemetry77 = this._openTelemetry) === null || _this$_openTelemetry77 === void 0 || _this$_openTelemetry77.completeSpan({
                                span: pauseConsumersSpan,
                                status: 2,
                                message: "pauseAllConsumers() failed"
                              });
                              (_this$_videosdkLogs21 = this._videosdkLogs) === null || _this$_videosdkLogs21 === void 0 || _this$_videosdkLogs21.pushLogs({
                                logText: "Error pauseAllConsumers() failed",
                                logType: "ERROR",
                                attributes: {
                                  error: _t11.message
                                }
                              });
                            case 7:
                              (_this$_openTelemetry78 = this._openTelemetry) === null || _this$_openTelemetry78 === void 0 || _this$_openTelemetry78.completeSpan({
                                span: pauseConsumersSpan,
                                status: 1,
                                message: "pauseAllConsumers() End"
                              });
                            case 8:
                            case "end":
                              return _context18.stop();
                          }
                        }, _callee18, this, [[1, 6]]);
                      }));
                      function pauseAllConsumers(_x24) {
                        return _pauseAllConsumers.apply(this, arguments);
                      }
                      return pauseAllConsumers;
                    }()
                  }, {
                    key: "resumeAllConsumers",
                    value: function() {
                      var _resumeAllConsumers = (0, asyncToGenerator.A)(regenerator_default().mark(function _callee19(kind) {
                        var _this$_openTelemetry79, _this$_openTelemetry81;
                        var resumeConsumersSpan, _response$consumersWi3, response, success, _response2$consumersW, _response2, _this$_openTelemetry80, _this$_videosdkLogs22, _t12;
                        return regenerator_default().wrap(function(_context19) {
                          while (1) switch (_context19.prev = _context19.next) {
                            case 0:
                              resumeConsumersSpan = (_this$_openTelemetry79 = this._openTelemetry) === null || _this$_openTelemetry79 === void 0 ? void 0 : _this$_openTelemetry79.trace({
                                spanName: "resumeAllConsumers() Start",
                                attributes: {
                                  kind: kind ? kind : "Kind not specified"
                                }
                              });
                              _context19.prev = 1;
                              _context19.next = 2;
                              return this._socketRequest("resumeAllConsumers", {
                                kind: kind === void 0 ? "all" : kind
                              });
                            case 2:
                              response = _context19.sent;
                              success = false;
                              if (!((response === null || response === void 0 || (_response$consumersWi3 = response.consumersWithIssues) === null || _response$consumersWi3 === void 0 ? void 0 : _response$consumersWi3.length) > 0)) {
                                _context19.next = 4;
                                break;
                              }
                              _context19.next = 3;
                              return this._socketRequest("resumeAllConsumers", {
                                kind: kind === void 0 ? "all" : kind
                              });
                            case 3:
                              _response2 = _context19.sent;
                              if ((_response2 === null || _response2 === void 0 || (_response2$consumersW = _response2.consumersWithIssues) === null || _response2$consumersW === void 0 ? void 0 : _response2$consumersW.length) === 0) {
                                success = true;
                              }
                              _context19.next = 5;
                              break;
                            case 4:
                              success = true;
                            case 5:
                              if (success) {
                                this._eventEmitter.emit("ALL_CONSUMERS_RESUMED", {
                                  kind
                                });
                              }
                              _context19.next = 7;
                              break;
                            case 6:
                              _context19.prev = 6;
                              _t12 = _context19["catch"](1);
                              logger.error("resumeAllConsumers() | failed:%o", _t12);
                              (_this$_openTelemetry80 = this._openTelemetry) === null || _this$_openTelemetry80 === void 0 || _this$_openTelemetry80.completeSpan({
                                span: resumeConsumersSpan,
                                status: 2,
                                message: "resumeAllConsumers() failed"
                              });
                              (_this$_videosdkLogs22 = this._videosdkLogs) === null || _this$_videosdkLogs22 === void 0 || _this$_videosdkLogs22.pushLogs({
                                logText: "Error resumeAllConsumers() failed",
                                logType: "ERROR",
                                attributes: {
                                  error: _t12.message
                                }
                              });
                            case 7:
                              (_this$_openTelemetry81 = this._openTelemetry) === null || _this$_openTelemetry81 === void 0 || _this$_openTelemetry81.completeSpan({
                                span: resumeConsumersSpan,
                                status: 1,
                                message: "resumeAllConsumers() End"
                              });
                            case 8:
                            case "end":
                              return _context19.stop();
                          }
                        }, _callee19, this, [[1, 6]]);
                      }));
                      function resumeAllConsumers(_x25) {
                        return _resumeAllConsumers.apply(this, arguments);
                      }
                      return resumeAllConsumers;
                    }()
                  }, {
                    key: "startRecording",
                    value: function() {
                      var _startRecording = (0, asyncToGenerator.A)(regenerator_default().mark(function _callee20(webhookUrl, awsDirPath, config3, transcription) {
                        var _this$_openTelemetry82, _this$_openTelemetry84;
                        var startRecordingSpan, _this$_openTelemetry83, _this$_videosdkLogs23, _t13;
                        return regenerator_default().wrap(function(_context20) {
                          while (1) switch (_context20.prev = _context20.next) {
                            case 0:
                              logger.debug("startRecording()");
                              startRecordingSpan = (_this$_openTelemetry82 = this._openTelemetry) === null || _this$_openTelemetry82 === void 0 ? void 0 : _this$_openTelemetry82.trace({
                                spanName: "startRecording() Start",
                                attributes: {
                                  webhookUrl: webhookUrl ? webhookUrl : "webhookUrl Not Specify",
                                  awsDirPath: awsDirPath ? awsDirPath : "awsDirPath Not Specify",
                                  config: config3 ? JSON.stringify(config3) : "config Not Specify",
                                  transcription: transcription ? JSON.stringify(transcription) : "transcription Not Specify"
                                }
                              });
                              _context20.prev = 1;
                              _context20.next = 2;
                              return this._socketRequest("startRecording", {
                                webhookUrl,
                                awsDirPath,
                                config: config3,
                                transcription
                              });
                            case 2:
                              _context20.next = 4;
                              break;
                            case 3:
                              _context20.prev = 3;
                              _t13 = _context20["catch"](1);
                              logger.error("startRecording() | failed:%o", _t13);
                              (_this$_openTelemetry83 = this._openTelemetry) === null || _this$_openTelemetry83 === void 0 || _this$_openTelemetry83.completeSpan({
                                span: startRecordingSpan,
                                status: 2,
                                message: "startRecording() failed"
                              });
                              (_this$_videosdkLogs23 = this._videosdkLogs) === null || _this$_videosdkLogs23 === void 0 || _this$_videosdkLogs23.pushLogs({
                                logText: "Error startRecording() failed",
                                logType: "ERROR",
                                attributes: {
                                  error: _t13.message
                                }
                              });
                              this._emitError({
                                code: 4011,
                                message: _t13.message
                              });
                            case 4:
                              (_this$_openTelemetry84 = this._openTelemetry) === null || _this$_openTelemetry84 === void 0 || _this$_openTelemetry84.completeSpan({
                                span: startRecordingSpan,
                                status: 1,
                                message: "startRecording() End"
                              });
                            case 5:
                            case "end":
                              return _context20.stop();
                          }
                        }, _callee20, this, [[1, 3]]);
                      }));
                      function startRecording(_x26, _x27, _x28, _x29) {
                        return _startRecording.apply(this, arguments);
                      }
                      return startRecording;
                    }()
                  }, {
                    key: "stopRecording",
                    value: function() {
                      var _stopRecording = (0, asyncToGenerator.A)(regenerator_default().mark(function _callee21() {
                        var _this$_openTelemetry85, _this$_openTelemetry87;
                        var stopRecordingSpan, _this$_openTelemetry86, _this$_videosdkLogs24, _t14;
                        return regenerator_default().wrap(function(_context21) {
                          while (1) switch (_context21.prev = _context21.next) {
                            case 0:
                              if (!this._closed) {
                                _context21.next = 1;
                                break;
                              }
                              return _context21.abrupt("return");
                            case 1:
                              logger.debug("stopRecording()");
                              stopRecordingSpan = (_this$_openTelemetry85 = this._openTelemetry) === null || _this$_openTelemetry85 === void 0 ? void 0 : _this$_openTelemetry85.trace({
                                spanName: "stopRecording() Start"
                              });
                              _context21.prev = 2;
                              _context21.next = 3;
                              return this._socketRequest("stopRecording", {});
                            case 3:
                              _context21.next = 5;
                              break;
                            case 4:
                              _context21.prev = 4;
                              _t14 = _context21["catch"](2);
                              (_this$_openTelemetry86 = this._openTelemetry) === null || _this$_openTelemetry86 === void 0 || _this$_openTelemetry86.completeSpan({
                                span: stopRecordingSpan,
                                status: 2,
                                message: "stopRecording() failed"
                              });
                              (_this$_videosdkLogs24 = this._videosdkLogs) === null || _this$_videosdkLogs24 === void 0 || _this$_videosdkLogs24.pushLogs({
                                logText: "Error stopRecording() failed",
                                logType: "ERROR",
                                attributes: {
                                  error: _t14.message
                                }
                              });
                              this._emitError({
                                code: 4012,
                                message: _t14.message
                              });
                            case 5:
                              (_this$_openTelemetry87 = this._openTelemetry) === null || _this$_openTelemetry87 === void 0 || _this$_openTelemetry87.completeSpan({
                                span: stopRecordingSpan,
                                status: 1,
                                message: "stopRecording() End"
                              });
                            case 6:
                            case "end":
                              return _context21.stop();
                          }
                        }, _callee21, this, [[2, 4]]);
                      }));
                      function stopRecording() {
                        return _stopRecording.apply(this, arguments);
                      }
                      return stopRecording;
                    }()
                  }, {
                    key: "startLivestream",
                    value: function() {
                      var _startLivestream = (0, asyncToGenerator.A)(regenerator_default().mark(function _callee22(outputs, config3) {
                        var _this$_openTelemetry88, _this$_openTelemetry90;
                        var startLivestreamSpan, _this$_openTelemetry89, _this$_videosdkLogs25, _t15;
                        return regenerator_default().wrap(function(_context22) {
                          while (1) switch (_context22.prev = _context22.next) {
                            case 0:
                              logger.debug("startLivestream()");
                              startLivestreamSpan = (_this$_openTelemetry88 = this._openTelemetry) === null || _this$_openTelemetry88 === void 0 ? void 0 : _this$_openTelemetry88.trace({
                                spanName: "startLivestream() Start",
                                attributes: {
                                  outputs: outputs ? JSON.stringify(outputs) : "outputs Not Specify",
                                  config: config3 ? JSON.stringify(config3) : "config Not Specify"
                                }
                              });
                              _context22.prev = 1;
                              _context22.next = 2;
                              return this._socketRequest("startLivestream", {
                                outputs,
                                config: config3
                              });
                            case 2:
                              _context22.next = 4;
                              break;
                            case 3:
                              _context22.prev = 3;
                              _t15 = _context22["catch"](1);
                              (_this$_openTelemetry89 = this._openTelemetry) === null || _this$_openTelemetry89 === void 0 || _this$_openTelemetry89.completeSpan({
                                span: startLivestreamSpan,
                                status: 1,
                                message: "startLivestream() End"
                              });
                              (_this$_videosdkLogs25 = this._videosdkLogs) === null || _this$_videosdkLogs25 === void 0 || _this$_videosdkLogs25.pushLogs({
                                logText: "Error startLivestream() failed",
                                logType: "ERROR",
                                attributes: {
                                  error: _t15.message
                                }
                              });
                              this._emitError({
                                code: 4013,
                                message: _t15.message
                              });
                            case 4:
                              (_this$_openTelemetry90 = this._openTelemetry) === null || _this$_openTelemetry90 === void 0 || _this$_openTelemetry90.completeSpan({
                                span: startLivestreamSpan,
                                status: 1,
                                message: "startLivestream() End"
                              });
                            case 5:
                            case "end":
                              return _context22.stop();
                          }
                        }, _callee22, this, [[1, 3]]);
                      }));
                      function startLivestream(_x30, _x31) {
                        return _startLivestream.apply(this, arguments);
                      }
                      return startLivestream;
                    }()
                  }, {
                    key: "stopLivestream",
                    value: function() {
                      var _stopLivestream = (0, asyncToGenerator.A)(regenerator_default().mark(function _callee23() {
                        var _this$_openTelemetry91, _this$_openTelemetry93;
                        var stopLivestreamSpan, _this$_videosdkLogs26, _this$_openTelemetry92, _t16;
                        return regenerator_default().wrap(function(_context23) {
                          while (1) switch (_context23.prev = _context23.next) {
                            case 0:
                              logger.debug("stopLivestream()");
                              stopLivestreamSpan = (_this$_openTelemetry91 = this._openTelemetry) === null || _this$_openTelemetry91 === void 0 ? void 0 : _this$_openTelemetry91.trace({
                                spanName: "stopLivestream() Start"
                              });
                              _context23.prev = 1;
                              _context23.next = 2;
                              return this._socketRequest("stopLivestream", {});
                            case 2:
                              _context23.next = 4;
                              break;
                            case 3:
                              _context23.prev = 3;
                              _t16 = _context23["catch"](1);
                              (_this$_videosdkLogs26 = this._videosdkLogs) === null || _this$_videosdkLogs26 === void 0 || _this$_videosdkLogs26.pushLogs({
                                logText: "Error stopLivestream() failed",
                                logType: "ERROR",
                                attributes: {
                                  error: _t16.message
                                }
                              });
                              (_this$_openTelemetry92 = this._openTelemetry) === null || _this$_openTelemetry92 === void 0 || _this$_openTelemetry92.completeSpan({
                                span: stopLivestreamSpan,
                                status: 2,
                                message: "Error stopLivestream() failed"
                              });
                              this._emitError({
                                code: 4014,
                                message: _t16.message
                              });
                            case 4:
                              (_this$_openTelemetry93 = this._openTelemetry) === null || _this$_openTelemetry93 === void 0 || _this$_openTelemetry93.completeSpan({
                                span: stopLivestreamSpan,
                                status: 1,
                                message: "stopLivestream() End"
                              });
                            case 5:
                            case "end":
                              return _context23.stop();
                          }
                        }, _callee23, this, [[1, 3]]);
                      }));
                      function stopLivestream() {
                        return _stopLivestream.apply(this, arguments);
                      }
                      return stopLivestream;
                    }()
                  }, {
                    key: "startHls",
                    value: function() {
                      var _startHls = (0, asyncToGenerator.A)(regenerator_default().mark(function _callee24(config3, transcription) {
                        var _this$_openTelemetry94, _this$_openTelemetry96;
                        var startHlsSpan, _this$_videosdkLogs27, _this$_openTelemetry95, _t17;
                        return regenerator_default().wrap(function(_context24) {
                          while (1) switch (_context24.prev = _context24.next) {
                            case 0:
                              config3 = config3 || {};
                              transcription = transcription || {};
                              logger.debug("startHls()");
                              startHlsSpan = (_this$_openTelemetry94 = this._openTelemetry) === null || _this$_openTelemetry94 === void 0 ? void 0 : _this$_openTelemetry94.trace({
                                spanName: "startHls() Start",
                                attributes: {
                                  config: config3 ? JSON.stringify(config3) : "config Not Specify",
                                  transcription: transcription ? JSON.stringify(transcription) : "transcription Not Specify"
                                }
                              });
                              _context24.prev = 1;
                              _context24.next = 2;
                              return this._socketRequest("startHls", {
                                config: config3,
                                transcription
                              });
                            case 2:
                              _context24.next = 4;
                              break;
                            case 3:
                              _context24.prev = 3;
                              _t17 = _context24["catch"](1);
                              (_this$_videosdkLogs27 = this._videosdkLogs) === null || _this$_videosdkLogs27 === void 0 || _this$_videosdkLogs27.pushLogs({
                                logText: "Error startHls() failed",
                                logType: "ERROR",
                                attributes: {
                                  error: _t17.message
                                }
                              });
                              (_this$_openTelemetry95 = this._openTelemetry) === null || _this$_openTelemetry95 === void 0 || _this$_openTelemetry95.completeSpan({
                                span: startHlsSpan,
                                status: 2,
                                message: "Error startHls() failed"
                              });
                              this._emitError({
                                code: 4016,
                                message: _t17.message
                              });
                              logger.error("startHls() | failed:%o", _t17);
                            case 4:
                              (_this$_openTelemetry96 = this._openTelemetry) === null || _this$_openTelemetry96 === void 0 || _this$_openTelemetry96.completeSpan({
                                span: startHlsSpan,
                                status: 1,
                                message: "startHlsSpan() End"
                              });
                            case 5:
                            case "end":
                              return _context24.stop();
                          }
                        }, _callee24, this, [[1, 3]]);
                      }));
                      function startHls(_x32, _x33) {
                        return _startHls.apply(this, arguments);
                      }
                      return startHls;
                    }()
                  }, {
                    key: "stopHls",
                    value: function() {
                      var _stopHls = (0, asyncToGenerator.A)(regenerator_default().mark(function _callee25() {
                        var _this$_openTelemetry97, _this$_openTelemetry99;
                        var stopHlsSpan, _this$_videosdkLogs28, _this$_openTelemetry98, _t18;
                        return regenerator_default().wrap(function(_context25) {
                          while (1) switch (_context25.prev = _context25.next) {
                            case 0:
                              logger.debug("stopHls()");
                              stopHlsSpan = (_this$_openTelemetry97 = this._openTelemetry) === null || _this$_openTelemetry97 === void 0 ? void 0 : _this$_openTelemetry97.trace({
                                spanName: "stopHls() Start"
                              });
                              _context25.prev = 1;
                              _context25.next = 2;
                              return this._socketRequest("stopHls", {});
                            case 2:
                              _context25.next = 4;
                              break;
                            case 3:
                              _context25.prev = 3;
                              _t18 = _context25["catch"](1);
                              (_this$_videosdkLogs28 = this._videosdkLogs) === null || _this$_videosdkLogs28 === void 0 || _this$_videosdkLogs28.pushLogs({
                                logText: "Error stopHls() failed",
                                logType: "ERROR",
                                attributes: {
                                  error: _t18.message
                                }
                              });
                              (_this$_openTelemetry98 = this._openTelemetry) === null || _this$_openTelemetry98 === void 0 || _this$_openTelemetry98.completeSpan({
                                span: stopHlsSpan,
                                status: 2,
                                message: "Error stopHls() failed"
                              });
                              this._emitError({
                                code: 4017,
                                message: _t18.message
                              });
                            case 4:
                              (_this$_openTelemetry99 = this._openTelemetry) === null || _this$_openTelemetry99 === void 0 || _this$_openTelemetry99.completeSpan({
                                span: stopHlsSpan,
                                status: 1,
                                message: "stopHls() End"
                              });
                            case 5:
                            case "end":
                              return _context25.stop();
                          }
                        }, _callee25, this, [[1, 3]]);
                      }));
                      function stopHls() {
                        return _stopHls.apply(this, arguments);
                      }
                      return stopHls;
                    }()
                  }, {
                    key: "startWhiteboard",
                    value: function() {
                      var _startWhiteboard = (0, asyncToGenerator.A)(regenerator_default().mark(function _callee26() {
                        var _this$_openTelemetry100, _this$_openTelemetry102;
                        var startWBSpan, _this$_openTelemetry101, _t19;
                        return regenerator_default().wrap(function(_context26) {
                          while (1) switch (_context26.prev = _context26.next) {
                            case 0:
                              logger.debug("startWhiteboard()");
                              startWBSpan = (_this$_openTelemetry100 = this._openTelemetry) === null || _this$_openTelemetry100 === void 0 ? void 0 : _this$_openTelemetry100.trace({
                                spanName: "startWhiteboard() Start"
                              });
                              _context26.prev = 1;
                              _context26.next = 2;
                              return this._socketRequest("startWhiteboard", {
                                version: "v2"
                              });
                            case 2:
                              _context26.next = 4;
                              break;
                            case 3:
                              _context26.prev = 3;
                              _t19 = _context26["catch"](1);
                              logger.error("startWhiteboard() | failed:%o", _t19);
                              (_this$_openTelemetry101 = this._openTelemetry) === null || _this$_openTelemetry101 === void 0 || _this$_openTelemetry101.completeSpan({
                                span: startWBSpan,
                                status: 2,
                                message: "Error startWhiteboard() failed"
                              });
                              this._emitError({
                                code: 3021,
                                message: _t19.message
                              });
                            case 4:
                              (_this$_openTelemetry102 = this._openTelemetry) === null || _this$_openTelemetry102 === void 0 || _this$_openTelemetry102.completeSpan({
                                span: startWBSpan,
                                status: 1,
                                message: "startWhiteboard() End"
                              });
                            case 5:
                            case "end":
                              return _context26.stop();
                          }
                        }, _callee26, this, [[1, 3]]);
                      }));
                      function startWhiteboard() {
                        return _startWhiteboard.apply(this, arguments);
                      }
                      return startWhiteboard;
                    }()
                  }, {
                    key: "stopWhiteboard",
                    value: function() {
                      var _stopWhiteboard = (0, asyncToGenerator.A)(regenerator_default().mark(function _callee27() {
                        var _this$_openTelemetry103, _this$_openTelemetry105;
                        var stopWBSpan, _this$_openTelemetry104, _t20;
                        return regenerator_default().wrap(function(_context27) {
                          while (1) switch (_context27.prev = _context27.next) {
                            case 0:
                              logger.debug("stopWhiteboard()");
                              stopWBSpan = (_this$_openTelemetry103 = this._openTelemetry) === null || _this$_openTelemetry103 === void 0 ? void 0 : _this$_openTelemetry103.trace({
                                spanName: "stopWhiteboard() Start"
                              });
                              _context27.prev = 1;
                              _context27.next = 2;
                              return this._socketRequest("stopWhiteboard", {});
                            case 2:
                              _context27.next = 4;
                              break;
                            case 3:
                              _context27.prev = 3;
                              _t20 = _context27["catch"](1);
                              logger.error("stopWhiteboard() | failed:%o", _t20);
                              (_this$_openTelemetry104 = this._openTelemetry) === null || _this$_openTelemetry104 === void 0 || _this$_openTelemetry104.completeSpan({
                                span: stopWBSpan,
                                status: 2,
                                message: "Error stopWhiteboard() failed"
                              });
                              this._emitError({
                                code: 3022,
                                message: _t20.message
                              });
                            case 4:
                              (_this$_openTelemetry105 = this._openTelemetry) === null || _this$_openTelemetry105 === void 0 || _this$_openTelemetry105.completeSpan({
                                span: stopWBSpan,
                                status: 1,
                                message: "stopWhiteboard() End"
                              });
                            case 5:
                            case "end":
                              return _context27.stop();
                          }
                        }, _callee27, this, [[1, 3]]);
                      }));
                      function stopWhiteboard() {
                        return _stopWhiteboard.apply(this, arguments);
                      }
                      return stopWhiteboard;
                    }()
                  }, {
                    key: "joinCharacter",
                    value: function() {
                      var _joinCharacter = (0, asyncToGenerator.A)(regenerator_default().mark(function _callee28(config3) {
                        var _this$_openTelemetry106, _this$_openTelemetry108;
                        var joinCharacterSpan, _this$_openTelemetry107, _this$_videosdkLogs29, _t21;
                        return regenerator_default().wrap(function(_context28) {
                          while (1) switch (_context28.prev = _context28.next) {
                            case 0:
                              logger.debug("joinCharacter()");
                              joinCharacterSpan = (_this$_openTelemetry106 = this._openTelemetry) === null || _this$_openTelemetry106 === void 0 ? void 0 : _this$_openTelemetry106.trace({
                                spanName: "joinCharacter() Start",
                                attributes: {
                                  config: config3 ? JSON.stringify(config3) : "config Not Specify"
                                }
                              });
                              _context28.prev = 1;
                              _context28.next = 2;
                              return this._socketRequest("joinCharacter", {
                                config: config3
                              });
                            case 2:
                              return _context28.abrupt("return", _context28.sent);
                            case 3:
                              _context28.prev = 3;
                              _t21 = _context28["catch"](1);
                              logger.error("joinCharacter() | failed:%o", _t21);
                              (_this$_openTelemetry107 = this._openTelemetry) === null || _this$_openTelemetry107 === void 0 || _this$_openTelemetry107.completeSpan({
                                span: joinCharacterSpan,
                                status: 2,
                                message: "joinCharacter() failed"
                              });
                              (_this$_videosdkLogs29 = this._videosdkLogs) === null || _this$_videosdkLogs29 === void 0 || _this$_videosdkLogs29.pushLogs({
                                logText: "Error joinCharacter() failed",
                                logType: "ERROR",
                                attributes: {
                                  error: _t21.message
                                }
                              });
                              this._emitError({
                                code: 4033,
                                message: _t21.message
                              });
                              (_this$_openTelemetry108 = this._openTelemetry) === null || _this$_openTelemetry108 === void 0 || _this$_openTelemetry108.completeSpan({
                                span: joinCharacterSpan,
                                status: 1,
                                message: "joinCharacter() End"
                              });
                              return _context28.abrupt("return", false);
                            case 4:
                            case "end":
                              return _context28.stop();
                          }
                        }, _callee28, this, [[1, 3]]);
                      }));
                      function joinCharacter(_x34) {
                        return _joinCharacter.apply(this, arguments);
                      }
                      return joinCharacter;
                    }()
                  }, {
                    key: "switchTo",
                    value: function() {
                      var _switchTo = (0, asyncToGenerator.A)(regenerator_default().mark(function _callee29(_ref11) {
                        var _this$_openTelemetry109;
                        var meetingId, participantId, token, switchToSpan, _this$_openTelemetry110, _this$_openTelemetry111, _this$_videosdkLogs30, _t22;
                        return regenerator_default().wrap(function(_context29) {
                          while (1) switch (_context29.prev = _context29.next) {
                            case 0:
                              meetingId = _ref11.meetingId, participantId = _ref11.participantId, token = _ref11.token;
                              switchToSpan = (_this$_openTelemetry109 = this._openTelemetry) === null || _this$_openTelemetry109 === void 0 ? void 0 : _this$_openTelemetry109.trace({
                                spanName: "switchTo() Start",
                                attributes: {
                                  "peer.id": participantId,
                                  meetingId
                                }
                              });
                              _context29.prev = 1;
                              _context29.next = 2;
                              return this._socketRequest("switchToMeeting", {
                                meetingId,
                                participantId,
                                secret: token || this._secret
                              });
                            case 2:
                              (_this$_openTelemetry110 = this._openTelemetry) === null || _this$_openTelemetry110 === void 0 || _this$_openTelemetry110.completeSpan({
                                span: switchToSpan,
                                status: 1,
                                message: "switchTo() Success"
                              });
                              _context29.next = 4;
                              break;
                            case 3:
                              _context29.prev = 3;
                              _t22 = _context29["catch"](1);
                              (_this$_openTelemetry111 = this._openTelemetry) === null || _this$_openTelemetry111 === void 0 || _this$_openTelemetry111.completeSpan({
                                span: switchToSpan,
                                status: 2,
                                message: "switchTo() failed"
                              });
                              (_this$_videosdkLogs30 = this._videosdkLogs) === null || _this$_videosdkLogs30 === void 0 || _this$_videosdkLogs30.pushLogs({
                                logText: "Error switchTo() failed",
                                logType: "ERROR",
                                attributes: {
                                  error: _t22.message
                                }
                              });
                            case 4:
                            case "end":
                              return _context29.stop();
                          }
                        }, _callee29, this, [[1, 3]]);
                      }));
                      function switchTo(_x35) {
                        return _switchTo.apply(this, arguments);
                      }
                      return switchTo;
                    }()
                  }, {
                    key: "removeCharacter",
                    value: function() {
                      var _removeCharacter = (0, asyncToGenerator.A)(regenerator_default().mark(function _callee30(config3) {
                        var _this$_openTelemetry112, _this$_openTelemetry114;
                        var removeCharacterSpan, _this$_openTelemetry113, _this$_videosdkLogs31, _t23;
                        return regenerator_default().wrap(function(_context30) {
                          while (1) switch (_context30.prev = _context30.next) {
                            case 0:
                              logger.debug("removeCharacter()");
                              removeCharacterSpan = (_this$_openTelemetry112 = this._openTelemetry) === null || _this$_openTelemetry112 === void 0 ? void 0 : _this$_openTelemetry112.trace({
                                spanName: "removeCharacter() Start"
                              });
                              _context30.prev = 1;
                              _context30.next = 2;
                              return this._socketRequest("leaveCharacter", {
                                config: config3
                              });
                            case 2:
                              _context30.next = 4;
                              break;
                            case 3:
                              _context30.prev = 3;
                              _t23 = _context30["catch"](1);
                              logger.error("removeCharacter() | failed:%o", _t23);
                              (_this$_openTelemetry113 = this._openTelemetry) === null || _this$_openTelemetry113 === void 0 || _this$_openTelemetry113.completeSpan({
                                span: removeCharacterSpan,
                                status: 2,
                                message: "removeCharacter() failed"
                              });
                              (_this$_videosdkLogs31 = this._videosdkLogs) === null || _this$_videosdkLogs31 === void 0 || _this$_videosdkLogs31.pushLogs({
                                logText: "Error removeCharacter() failed",
                                logType: "ERROR",
                                attributes: {
                                  error: _t23.message
                                }
                              });
                              this._emitError({
                                code: 4034,
                                message: _t23.message
                              });
                              return _context30.abrupt("return", false);
                            case 4:
                              (_this$_openTelemetry114 = this._openTelemetry) === null || _this$_openTelemetry114 === void 0 || _this$_openTelemetry114.completeSpan({
                                span: removeCharacterSpan,
                                status: 1,
                                message: "removeCharacter() End"
                              });
                              return _context30.abrupt("return", true);
                            case 5:
                            case "end":
                              return _context30.stop();
                          }
                        }, _callee30, this, [[1, 3]]);
                      }));
                      function removeCharacter(_x36) {
                        return _removeCharacter.apply(this, arguments);
                      }
                      return removeCharacter;
                    }()
                  }, {
                    key: "sendCharacterMessage",
                    value: function() {
                      var _sendCharacterMessage = (0, asyncToGenerator.A)(regenerator_default().mark(function _callee31(_ref12) {
                        var interactionId, text, _t24;
                        return regenerator_default().wrap(function(_context31) {
                          while (1) switch (_context31.prev = _context31.next) {
                            case 0:
                              interactionId = _ref12.interactionId, text = _ref12.text;
                              logger.debug("sendCharacterMessage()");
                              _context31.prev = 1;
                              _context31.next = 2;
                              return this._socketRequest("sendCharacterMessage", {
                                interactionId,
                                text
                              });
                            case 2:
                              _context31.next = 4;
                              break;
                            case 3:
                              _context31.prev = 3;
                              _t24 = _context31["catch"](1);
                              logger.error("sendCharacterMessage() | failed:%o", _t24);
                              this._emitError({
                                code: 4035,
                                message: _t24.message
                              });
                            case 4:
                            case "end":
                              return _context31.stop();
                          }
                        }, _callee31, this, [[1, 3]]);
                      }));
                      function sendCharacterMessage(_x37) {
                        return _sendCharacterMessage.apply(this, arguments);
                      }
                      return sendCharacterMessage;
                    }()
                  }, {
                    key: "interruptCharacter",
                    value: function() {
                      var _interruptCharacter = (0, asyncToGenerator.A)(regenerator_default().mark(function _callee32(_ref13) {
                        var interactionId, _t25;
                        return regenerator_default().wrap(function(_context32) {
                          while (1) switch (_context32.prev = _context32.next) {
                            case 0:
                              interactionId = _ref13.interactionId;
                              logger.debug("interruptCharacter()");
                              _context32.prev = 1;
                              _context32.next = 2;
                              return this._socketRequest("interruptCharacter", {
                                interactionId
                              });
                            case 2:
                              _context32.next = 4;
                              break;
                            case 3:
                              _context32.prev = 3;
                              _t25 = _context32["catch"](1);
                              logger.error("interruptCharacter() | failed:%o", _t25);
                              this._emitError({
                                code: 4036,
                                message: _t25.message
                              });
                            case 4:
                            case "end":
                              return _context32.stop();
                          }
                        }, _callee32, this, [[1, 3]]);
                      }));
                      function interruptCharacter(_x38) {
                        return _interruptCharacter.apply(this, arguments);
                      }
                      return interruptCharacter;
                    }()
                  }, {
                    key: "pinStateChange",
                    value: function() {
                      var _pinStateChange = (0, asyncToGenerator.A)(regenerator_default().mark(function _callee33(_ref14) {
                        var _this$_openTelemetry115;
                        var peerId, state2, _this$_videosdkLogs32, _t26;
                        return regenerator_default().wrap(function(_context33) {
                          while (1) switch (_context33.prev = _context33.next) {
                            case 0:
                              peerId = _ref14.peerId, state2 = _ref14.state;
                              (_this$_openTelemetry115 = this._openTelemetry) === null || _this$_openTelemetry115 === void 0 || _this$_openTelemetry115.traceAutoComplete({
                                spanName: "Pin state Change for ".concat(peerId),
                                attributes: {
                                  state: state2 ? JSON.stringify(state2) : null
                                },
                                status: 1
                              });
                              _context33.prev = 1;
                              _context33.next = 2;
                              return this._socketRequest("pinStateChanged", {
                                peerId,
                                state: state2
                              });
                            case 2:
                              _context33.next = 4;
                              break;
                            case 3:
                              _context33.prev = 3;
                              _t26 = _context33["catch"](1);
                              (_this$_videosdkLogs32 = this._videosdkLogs) === null || _this$_videosdkLogs32 === void 0 || _this$_videosdkLogs32.pushLogs({
                                logText: "Error pinStateChange() failed",
                                logType: "ERROR",
                                attributes: {
                                  error: _t26.message
                                }
                              });
                              logger.error("pinStateChange() | failed");
                            case 4:
                            case "end":
                              return _context33.stop();
                          }
                        }, _callee33, this, [[1, 3]]);
                      }));
                      function pinStateChange(_x39) {
                        return _pinStateChange.apply(this, arguments);
                      }
                      return pinStateChange;
                    }()
                  }, {
                    key: "startVideo",
                    value: function() {
                      var _startVideo = (0, asyncToGenerator.A)(regenerator_default().mark(function _callee34(_ref15) {
                        var _this$_videosdkLogs33;
                        var link, _this$_videosdkLogs34, _t27;
                        return regenerator_default().wrap(function(_context34) {
                          while (1) switch (_context34.prev = _context34.next) {
                            case 0:
                              link = _ref15.link;
                              logger.debug("startVideo()");
                              (_this$_videosdkLogs33 = this._videosdkLogs) === null || _this$_videosdkLogs33 === void 0 || _this$_videosdkLogs33.pushLogs({
                                logText: "startVideo() Calling",
                                logType: "INFO"
                              });
                              _context34.prev = 1;
                              _context34.next = 2;
                              return this._socketRequest("startVideo", {
                                link
                              });
                            case 2:
                              _context34.next = 4;
                              break;
                            case 3:
                              _context34.prev = 3;
                              _t27 = _context34["catch"](1);
                              (_this$_videosdkLogs34 = this._videosdkLogs) === null || _this$_videosdkLogs34 === void 0 || _this$_videosdkLogs34.pushLogs({
                                logText: "Error startVideo() failed",
                                logType: "ERROR",
                                attributes: {
                                  error: _t27.message
                                }
                              });
                              logger.error("startVideo() | failed:%o", _t27);
                              this._emitError({
                                code: 3023,
                                message: _t27.message
                              });
                            case 4:
                            case "end":
                              return _context34.stop();
                          }
                        }, _callee34, this, [[1, 3]]);
                      }));
                      function startVideo(_x40) {
                        return _startVideo.apply(this, arguments);
                      }
                      return startVideo;
                    }()
                  }, {
                    key: "stopVideo",
                    value: function() {
                      var _stopVideo = (0, asyncToGenerator.A)(regenerator_default().mark(function _callee35() {
                        var _this$_videosdkLogs35;
                        var _this$_videosdkLogs36, _t28;
                        return regenerator_default().wrap(function(_context35) {
                          while (1) switch (_context35.prev = _context35.next) {
                            case 0:
                              logger.debug("stopVideo()");
                              (_this$_videosdkLogs35 = this._videosdkLogs) === null || _this$_videosdkLogs35 === void 0 || _this$_videosdkLogs35.pushLogs({
                                logText: "stopVideo() Calling",
                                logType: "INFO"
                              });
                              _context35.prev = 1;
                              _context35.next = 2;
                              return this._socketRequest("stopVideo", {});
                            case 2:
                              _context35.next = 4;
                              break;
                            case 3:
                              _context35.prev = 3;
                              _t28 = _context35["catch"](1);
                              (_this$_videosdkLogs36 = this._videosdkLogs) === null || _this$_videosdkLogs36 === void 0 || _this$_videosdkLogs36.pushLogs({
                                logText: "Error stopVideo() failed",
                                logType: "ERROR",
                                attributes: {
                                  error: _t28.message
                                }
                              });
                              logger.error("stopVideo() | failed:%o", _t28);
                              this._emitError({
                                code: 3024,
                                message: _t28.message
                              });
                            case 4:
                            case "end":
                              return _context35.stop();
                          }
                        }, _callee35, this, [[1, 3]]);
                      }));
                      function stopVideo() {
                        return _stopVideo.apply(this, arguments);
                      }
                      return stopVideo;
                    }()
                  }, {
                    key: "pauseVideo",
                    value: function() {
                      var _pauseVideo = (0, asyncToGenerator.A)(regenerator_default().mark(function _callee36(currentTime) {
                        var _t29;
                        return regenerator_default().wrap(function(_context36) {
                          while (1) switch (_context36.prev = _context36.next) {
                            case 0:
                              logger.debug("pauseVideo()");
                              _context36.prev = 1;
                              _context36.next = 2;
                              return this._socketRequest("pauseVideo", {
                                currentTime
                              });
                            case 2:
                              _context36.next = 4;
                              break;
                            case 3:
                              _context36.prev = 3;
                              _t29 = _context36["catch"](1);
                              logger.error("pauseVideo() | failed:%o", _t29);
                              this._emitError({
                                code: 3025,
                                message: _t29.message
                              });
                            case 4:
                            case "end":
                              return _context36.stop();
                          }
                        }, _callee36, this, [[1, 3]]);
                      }));
                      function pauseVideo(_x41) {
                        return _pauseVideo.apply(this, arguments);
                      }
                      return pauseVideo;
                    }()
                  }, {
                    key: "resumeVideo",
                    value: function() {
                      var _resumeVideo = (0, asyncToGenerator.A)(regenerator_default().mark(function _callee37() {
                        var _t30;
                        return regenerator_default().wrap(function(_context37) {
                          while (1) switch (_context37.prev = _context37.next) {
                            case 0:
                              logger.debug("resumeVideo()");
                              _context37.prev = 1;
                              _context37.next = 2;
                              return this._socketRequest("resumeVideo", {});
                            case 2:
                              _context37.next = 4;
                              break;
                            case 3:
                              _context37.prev = 3;
                              _t30 = _context37["catch"](1);
                              logger.error("resumeVideo() | failed:%o", _t30);
                              this._emitError({
                                code: 3026,
                                message: _t30.message
                              });
                            case 4:
                            case "end":
                              return _context37.stop();
                          }
                        }, _callee37, this, [[1, 3]]);
                      }));
                      function resumeVideo() {
                        return _resumeVideo.apply(this, arguments);
                      }
                      return resumeVideo;
                    }()
                  }, {
                    key: "seekVideo",
                    value: function() {
                      var _seekVideo = (0, asyncToGenerator.A)(regenerator_default().mark(function _callee38(currentTime) {
                        var _t31;
                        return regenerator_default().wrap(function(_context38) {
                          while (1) switch (_context38.prev = _context38.next) {
                            case 0:
                              logger.debug("seekVideo()");
                              _context38.prev = 1;
                              _context38.next = 2;
                              return this._socketRequest("seekVideo", {
                                currentTime
                              });
                            case 2:
                              _context38.next = 4;
                              break;
                            case 3:
                              _context38.prev = 3;
                              _t31 = _context38["catch"](1);
                              logger.error("seekVideo() | failed:%o", _t31);
                              this._emitError({
                                code: 3031,
                                message: _t31.message
                              });
                            case 4:
                            case "end":
                              return _context38.stop();
                          }
                        }, _callee38, this, [[1, 3]]);
                      }));
                      function seekVideo(_x42) {
                        return _seekVideo.apply(this, arguments);
                      }
                      return seekVideo;
                    }()
                  }, {
                    key: "enablePeerMic",
                    value: function() {
                      var _enablePeerMic = (0, asyncToGenerator.A)(regenerator_default().mark(function _callee39(peerId) {
                        var _this$_openTelemetry116;
                        var _this$_videosdkLogs37, _t32;
                        return regenerator_default().wrap(function(_context39) {
                          while (1) switch (_context39.prev = _context39.next) {
                            case 0:
                              (_this$_openTelemetry116 = this._openTelemetry) === null || _this$_openTelemetry116 === void 0 || _this$_openTelemetry116.traceAutoComplete({
                                spanName: "Enabling peer ".concat(peerId, " Mic"),
                                status: 1
                              });
                              logger.debug("enablePeerMic()");
                              _context39.prev = 1;
                              _context39.next = 2;
                              return this._socketRequest("enablePeerMic", {
                                peerId
                              });
                            case 2:
                              _context39.next = 4;
                              break;
                            case 3:
                              _context39.prev = 3;
                              _t32 = _context39["catch"](1);
                              (_this$_videosdkLogs37 = this._videosdkLogs) === null || _this$_videosdkLogs37 === void 0 || _this$_videosdkLogs37.pushLogs({
                                logText: "Error enablePeerMic() failed",
                                logType: "ERROR",
                                attributes: {
                                  error: _t32.message
                                }
                              });
                              logger.error("enablePeerMic() | failed:%o", _t32);
                            case 4:
                            case "end":
                              return _context39.stop();
                          }
                        }, _callee39, this, [[1, 3]]);
                      }));
                      function enablePeerMic(_x43) {
                        return _enablePeerMic.apply(this, arguments);
                      }
                      return enablePeerMic;
                    }()
                  }, {
                    key: "requestMediaRelay",
                    value: function() {
                      var _requestMediaRelay = (0, asyncToGenerator.A)(regenerator_default().mark(function _callee40(meetingId, token, kinds) {
                        var _this$_videosdkLogs38, _t33;
                        return regenerator_default().wrap(function(_context40) {
                          while (1) switch (_context40.prev = _context40.next) {
                            case 0:
                              _context40.prev = 0;
                              _context40.next = 1;
                              return this._socketRequest("mediaRelayRequestSent", {
                                meetingId,
                                secret: token !== null && token !== void 0 ? token : this._secret,
                                kinds: kinds !== null && kinds !== void 0 ? kinds : ["audio", "video", "share", "share_audio"]
                              });
                            case 1:
                              _context40.next = 3;
                              break;
                            case 2:
                              _context40.prev = 2;
                              _t33 = _context40["catch"](0);
                              (_this$_videosdkLogs38 = this._videosdkLogs) === null || _this$_videosdkLogs38 === void 0 || _this$_videosdkLogs38.pushLogs({
                                logText: "Error relayRequest() failed",
                                logType: "ERROR",
                                attributes: {
                                  error: _t33.message
                                }
                              });
                            case 3:
                            case "end":
                              return _context40.stop();
                          }
                        }, _callee40, this, [[0, 2]]);
                      }));
                      function requestMediaRelay(_x44, _x45, _x46) {
                        return _requestMediaRelay.apply(this, arguments);
                      }
                      return requestMediaRelay;
                    }()
                  }, {
                    key: "handleRelayRequestResponse",
                    value: function() {
                      var _handleRelayRequestResponse = (0, asyncToGenerator.A)(regenerator_default().mark(function _callee41(_ref16) {
                        var decision, peerId, meetingId, _this$_videosdkLogs39, _t34;
                        return regenerator_default().wrap(function(_context41) {
                          while (1) switch (_context41.prev = _context41.next) {
                            case 0:
                              decision = _ref16.decision, peerId = _ref16.peerId, meetingId = _ref16.meetingId;
                              _context41.prev = 1;
                              _context41.next = 2;
                              return this._socketRequest("respondToMediaRelayRequest", {
                                decision,
                                decidedBy: this._peerId,
                                peerId,
                                meetingId
                              });
                            case 2:
                              _context41.next = 4;
                              break;
                            case 3:
                              _context41.prev = 3;
                              _t34 = _context41["catch"](1);
                              (_this$_videosdkLogs39 = this._videosdkLogs) === null || _this$_videosdkLogs39 === void 0 || _this$_videosdkLogs39.pushLogs({
                                logText: "Error respondToMediaRelayRequest() failed",
                                logType: "ERROR",
                                attributes: {
                                  error: _t34.message
                                }
                              });
                            case 4:
                            case "end":
                              return _context41.stop();
                          }
                        }, _callee41, this, [[1, 3]]);
                      }));
                      function handleRelayRequestResponse(_x47) {
                        return _handleRelayRequestResponse.apply(this, arguments);
                      }
                      return handleRelayRequestResponse;
                    }()
                  }, {
                    key: "stopMediaRelay",
                    value: function() {
                      var _stopMediaRelay = (0, asyncToGenerator.A)(regenerator_default().mark(function _callee42(meetingId) {
                        var _this$_videosdkLogs40, _t35;
                        return regenerator_default().wrap(function(_context42) {
                          while (1) switch (_context42.prev = _context42.next) {
                            case 0:
                              _context42.prev = 0;
                              _context42.next = 1;
                              return this._socketRequest("mediaRelayRequestStop", {
                                meetingId
                              });
                            case 1:
                              _context42.next = 3;
                              break;
                            case 2:
                              _context42.prev = 2;
                              _t35 = _context42["catch"](0);
                              (_this$_videosdkLogs40 = this._videosdkLogs) === null || _this$_videosdkLogs40 === void 0 || _this$_videosdkLogs40.pushLogs({
                                logText: "Error stopMediaRelay() failed",
                                logType: "ERROR",
                                attributes: {
                                  error: _t35.message
                                }
                              });
                            case 3:
                            case "end":
                              return _context42.stop();
                          }
                        }, _callee42, this, [[0, 2]]);
                      }));
                      function stopMediaRelay(_x48) {
                        return _stopMediaRelay.apply(this, arguments);
                      }
                      return stopMediaRelay;
                    }()
                  }, {
                    key: "enableRelayMedia",
                    value: function() {
                      var _enableRelayMedia = (0, asyncToGenerator.A)(regenerator_default().mark(function _callee43(meetingId, kind) {
                        var _this$_videosdkLogs41, _t36;
                        return regenerator_default().wrap(function(_context43) {
                          while (1) switch (_context43.prev = _context43.next) {
                            case 0:
                              _context43.prev = 0;
                              _context43.next = 1;
                              return this._socketRequest("enableRelayMedia", {
                                meetingId,
                                kind
                              });
                            case 1:
                              _context43.next = 3;
                              break;
                            case 2:
                              _context43.prev = 2;
                              _t36 = _context43["catch"](0);
                              (_this$_videosdkLogs41 = this._videosdkLogs) === null || _this$_videosdkLogs41 === void 0 || _this$_videosdkLogs41.pushLogs({
                                logText: "Error enableRelayMedia() failed",
                                logType: "ERROR",
                                attributes: {
                                  error: _t36.message
                                }
                              });
                            case 3:
                            case "end":
                              return _context43.stop();
                          }
                        }, _callee43, this, [[0, 2]]);
                      }));
                      function enableRelayMedia(_x49, _x50) {
                        return _enableRelayMedia.apply(this, arguments);
                      }
                      return enableRelayMedia;
                    }()
                  }, {
                    key: "disableRelayMedia",
                    value: function() {
                      var _disableRelayMedia = (0, asyncToGenerator.A)(regenerator_default().mark(function _callee44(meetingId, kind) {
                        var _this$_videosdkLogs42, _t37;
                        return regenerator_default().wrap(function(_context44) {
                          while (1) switch (_context44.prev = _context44.next) {
                            case 0:
                              _context44.prev = 0;
                              _context44.next = 1;
                              return this._socketRequest("disableRelayMedia", {
                                meetingId,
                                kind
                              });
                            case 1:
                              _context44.next = 3;
                              break;
                            case 2:
                              _context44.prev = 2;
                              _t37 = _context44["catch"](0);
                              (_this$_videosdkLogs42 = this._videosdkLogs) === null || _this$_videosdkLogs42 === void 0 || _this$_videosdkLogs42.pushLogs({
                                logText: "Error disableRelayMedia() failed",
                                logType: "ERROR",
                                attributes: {
                                  error: _t37.message
                                }
                              });
                            case 3:
                            case "end":
                              return _context44.stop();
                          }
                        }, _callee44, this, [[0, 2]]);
                      }));
                      function disableRelayMedia(_x51, _x52) {
                        return _disableRelayMedia.apply(this, arguments);
                      }
                      return disableRelayMedia;
                    }()
                  }, {
                    key: "enableAdaptiveSubscription",
                    value: function() {
                      var _enableAdaptiveSubscription = (0, asyncToGenerator.A)(regenerator_default().mark(function _callee45() {
                        var _this$_videosdkLogs43, _t38;
                        return regenerator_default().wrap(function(_context45) {
                          while (1) switch (_context45.prev = _context45.next) {
                            case 0:
                              _context45.prev = 0;
                              _context45.next = 1;
                              return this._socketRequest("enableAdaptiveSubscription");
                            case 1:
                              _context45.next = 3;
                              break;
                            case 2:
                              _context45.prev = 2;
                              _t38 = _context45["catch"](0);
                              (_this$_videosdkLogs43 = this._videosdkLogs) === null || _this$_videosdkLogs43 === void 0 || _this$_videosdkLogs43.pushLogs({
                                logText: "Error enableAdaptiveSubscription() failed",
                                logType: "ERROR",
                                attributes: {
                                  error: _t38.message
                                }
                              });
                            case 3:
                            case "end":
                              return _context45.stop();
                          }
                        }, _callee45, this, [[0, 2]]);
                      }));
                      function enableAdaptiveSubscription() {
                        return _enableAdaptiveSubscription.apply(this, arguments);
                      }
                      return enableAdaptiveSubscription;
                    }()
                  }, {
                    key: "disableAdaptiveSubscription",
                    value: function() {
                      var _disableAdaptiveSubscription = (0, asyncToGenerator.A)(regenerator_default().mark(function _callee46() {
                        var _this$_videosdkLogs44, _t39;
                        return regenerator_default().wrap(function(_context46) {
                          while (1) switch (_context46.prev = _context46.next) {
                            case 0:
                              _context46.prev = 0;
                              _context46.next = 1;
                              return this._socketRequest("disableAdaptiveSubscription");
                            case 1:
                              _context46.next = 3;
                              break;
                            case 2:
                              _context46.prev = 2;
                              _t39 = _context46["catch"](0);
                              (_this$_videosdkLogs44 = this._videosdkLogs) === null || _this$_videosdkLogs44 === void 0 || _this$_videosdkLogs44.pushLogs({
                                logText: "Error disableAdaptiveSubscription() failed",
                                logType: "ERROR",
                                attributes: {
                                  error: _t39.message
                                }
                              });
                            case 3:
                            case "end":
                              return _context46.stop();
                          }
                        }, _callee46, this, [[0, 2]]);
                      }));
                      function disableAdaptiveSubscription() {
                        return _disableAdaptiveSubscription.apply(this, arguments);
                      }
                      return disableAdaptiveSubscription;
                    }()
                  }, {
                    key: "disablePeerMic",
                    value: function() {
                      var _disablePeerMic = (0, asyncToGenerator.A)(regenerator_default().mark(function _callee47(peerId) {
                        var _this$_openTelemetry117;
                        var _this$_videosdkLogs45, _t40;
                        return regenerator_default().wrap(function(_context47) {
                          while (1) switch (_context47.prev = _context47.next) {
                            case 0:
                              (_this$_openTelemetry117 = this._openTelemetry) === null || _this$_openTelemetry117 === void 0 || _this$_openTelemetry117.traceAutoComplete({
                                spanName: "Disabling peer ".concat(peerId, " Mic"),
                                status: 1
                              });
                              logger.debug("disablePeerMic()");
                              _context47.prev = 1;
                              _context47.next = 2;
                              return this._socketRequest("disablePeerMic", {
                                peerId
                              });
                            case 2:
                              _context47.next = 4;
                              break;
                            case 3:
                              _context47.prev = 3;
                              _t40 = _context47["catch"](1);
                              (_this$_videosdkLogs45 = this._videosdkLogs) === null || _this$_videosdkLogs45 === void 0 || _this$_videosdkLogs45.pushLogs({
                                logText: "Error disablePeerMic() failed",
                                logType: "ERROR",
                                attributes: {
                                  error: _t40.message
                                }
                              });
                              logger.error("disablePeerMic() | failed:%o", _t40);
                            case 4:
                            case "end":
                              return _context47.stop();
                          }
                        }, _callee47, this, [[1, 3]]);
                      }));
                      function disablePeerMic(_x53) {
                        return _disablePeerMic.apply(this, arguments);
                      }
                      return disablePeerMic;
                    }()
                  }, {
                    key: "consumeWebcamStreams",
                    value: function() {
                      var _consumeWebcamStreams = (0, asyncToGenerator.A)(regenerator_default().mark(function _callee48(peerId) {
                        var _this$_videosdkLogs46;
                        var _this$_videosdkLogs47, _t41;
                        return regenerator_default().wrap(function(_context48) {
                          while (1) switch (_context48.prev = _context48.next) {
                            case 0:
                              if (!this._closed) {
                                _context48.next = 1;
                                break;
                              }
                              return _context48.abrupt("return");
                            case 1:
                              logger.debug("consumeWebcamStreams()");
                              (_this$_videosdkLogs46 = this._videosdkLogs) === null || _this$_videosdkLogs46 === void 0 || _this$_videosdkLogs46.pushLogs({
                                logText: "consumeWebcamStreams() Calling",
                                logType: "INFO",
                                attributes: {
                                  peerId
                                }
                              });
                              _context48.prev = 2;
                              _context48.next = 3;
                              return this._socketRequest("consumeVideoStreams", {
                                peerId
                              });
                            case 3:
                              _context48.next = 5;
                              break;
                            case 4:
                              _context48.prev = 4;
                              _t41 = _context48["catch"](2);
                              (_this$_videosdkLogs47 = this._videosdkLogs) === null || _this$_videosdkLogs47 === void 0 || _this$_videosdkLogs47.pushLogs({
                                logText: "Error consumeWebcamStreams() failed",
                                logType: "ERROR",
                                attributes: {
                                  error: _t41.message
                                }
                              });
                              logger.error("consumeWebcamStreams() | failed:%o", _t41);
                            case 5:
                            case "end":
                              return _context48.stop();
                          }
                        }, _callee48, this, [[2, 4]]);
                      }));
                      function consumeWebcamStreams(_x54) {
                        return _consumeWebcamStreams.apply(this, arguments);
                      }
                      return consumeWebcamStreams;
                    }()
                  }, {
                    key: "consumeMicStreams",
                    value: function() {
                      var _consumeMicStreams = (0, asyncToGenerator.A)(regenerator_default().mark(function _callee49(peerId) {
                        var _this$_videosdkLogs48;
                        var _this$_videosdkLogs49, _t42;
                        return regenerator_default().wrap(function(_context49) {
                          while (1) switch (_context49.prev = _context49.next) {
                            case 0:
                              logger.debug("consumeMicStreams()");
                              (_this$_videosdkLogs48 = this._videosdkLogs) === null || _this$_videosdkLogs48 === void 0 || _this$_videosdkLogs48.pushLogs({
                                logText: "consumeMicStreams() Calling",
                                logType: "INFO",
                                attributes: {
                                  peerId
                                }
                              });
                              _context49.prev = 1;
                              _context49.next = 2;
                              return this._socketRequest("consumeAudioStreams", {
                                peerId
                              });
                            case 2:
                              _context49.next = 4;
                              break;
                            case 3:
                              _context49.prev = 3;
                              _t42 = _context49["catch"](1);
                              (_this$_videosdkLogs49 = this._videosdkLogs) === null || _this$_videosdkLogs49 === void 0 || _this$_videosdkLogs49.pushLogs({
                                logText: "Error consumeMicStreams() failed",
                                logType: "ERROR",
                                attributes: {
                                  error: _t42.message
                                }
                              });
                              logger.error("consumeMicStreams() | failed:%o", _t42);
                            case 4:
                            case "end":
                              return _context49.stop();
                          }
                        }, _callee49, this, [[1, 3]]);
                      }));
                      function consumeMicStreams(_x55) {
                        return _consumeMicStreams.apply(this, arguments);
                      }
                      return consumeMicStreams;
                    }()
                  }, {
                    key: "stopConsumingMicStreams",
                    value: function() {
                      var _stopConsumingMicStreams = (0, asyncToGenerator.A)(regenerator_default().mark(function _callee50(peerId) {
                        var _this$_videosdkLogs50, _this$_videosdkLogs51, _t43;
                        return regenerator_default().wrap(function(_context50) {
                          while (1) switch (_context50.prev = _context50.next) {
                            case 0:
                              if (!this._closed) {
                                _context50.next = 1;
                                break;
                              }
                              return _context50.abrupt("return");
                            case 1:
                              logger.debug("stopConsumingAudioStreams()");
                              _context50.prev = 2;
                              _context50.next = 3;
                              return this._socketRequest("stopConsumingAudioStreams", {
                                peerId
                              });
                            case 3:
                              (_this$_videosdkLogs50 = this._videosdkLogs) === null || _this$_videosdkLogs50 === void 0 || _this$_videosdkLogs50.pushLogs({
                                logText: "stopConsumingAudioStreams() Calling",
                                logType: "INFO",
                                attributes: {
                                  peerId
                                }
                              });
                              _context50.next = 5;
                              break;
                            case 4:
                              _context50.prev = 4;
                              _t43 = _context50["catch"](2);
                              (_this$_videosdkLogs51 = this._videosdkLogs) === null || _this$_videosdkLogs51 === void 0 || _this$_videosdkLogs51.pushLogs({
                                logText: "Error stopConsumingMicStreams() failed",
                                logType: "ERROR",
                                attributes: {
                                  error: _t43.message
                                }
                              });
                              logger.error("stopConsumingMicStreams() | failed:%o", _t43);
                            case 5:
                            case "end":
                              return _context50.stop();
                          }
                        }, _callee50, this, [[2, 4]]);
                      }));
                      function stopConsumingMicStreams(_x56) {
                        return _stopConsumingMicStreams.apply(this, arguments);
                      }
                      return stopConsumingMicStreams;
                    }()
                  }, {
                    key: "stopConsumingWebcamStreams",
                    value: function() {
                      var _stopConsumingWebcamStreams = (0, asyncToGenerator.A)(regenerator_default().mark(function _callee51(peerId) {
                        var _this$_videosdkLogs52;
                        var _this$_videosdkLogs53, _t44;
                        return regenerator_default().wrap(function(_context51) {
                          while (1) switch (_context51.prev = _context51.next) {
                            case 0:
                              logger.debug("stopConsumingWebcamStreams()");
                              (_this$_videosdkLogs52 = this._videosdkLogs) === null || _this$_videosdkLogs52 === void 0 || _this$_videosdkLogs52.pushLogs({
                                logText: "stopConsumingWebcamStreams() Calling",
                                logType: "INFO",
                                attributes: {
                                  peerId
                                }
                              });
                              _context51.prev = 1;
                              _context51.next = 2;
                              return this._socketRequest("stopConsumingVideoStreams", {
                                peerId
                              });
                            case 2:
                              _context51.next = 4;
                              break;
                            case 3:
                              _context51.prev = 3;
                              _t44 = _context51["catch"](1);
                              (_this$_videosdkLogs53 = this._videosdkLogs) === null || _this$_videosdkLogs53 === void 0 || _this$_videosdkLogs53.pushLogs({
                                logText: "Error stopConsumingWebcamStreams() failed",
                                logType: "ERROR",
                                attributes: {
                                  error: _t44.message
                                }
                              });
                              logger.error("stopConsumingWebcamStreams() | failed:%o", _t44);
                            case 4:
                            case "end":
                              return _context51.stop();
                          }
                        }, _callee51, this, [[1, 3]]);
                      }));
                      function stopConsumingWebcamStreams(_x57) {
                        return _stopConsumingWebcamStreams.apply(this, arguments);
                      }
                      return stopConsumingWebcamStreams;
                    }()
                  }, {
                    key: "changeMode",
                    value: function() {
                      var _changeMode = (0, asyncToGenerator.A)(regenerator_default().mark(function _callee53(requestedMode) {
                        var _this$_openTelemetry118, _this2 = this;
                        var changeModeSpan, currentMode, _this$_openTelemetry119, _this$_videosdkLogs54, createTransport, _routerRtpCapabilitie, _this$_openTelemetry120, routerRtpCapabilities, transportInfo, _transportInfo, _store$getState2, me, _store$getState3, _me, _this$_videosdkLogs55, _this$_openTelemetry121, _t45;
                        return regenerator_default().wrap(function(_context53) {
                          while (1) switch (_context53.prev = _context53.next) {
                            case 0:
                              changeModeSpan = (_this$_openTelemetry118 = this._openTelemetry) === null || _this$_openTelemetry118 === void 0 ? void 0 : _this$_openTelemetry118.trace({
                                spanName: "changeMode() Calling with mode: ".concat(requestedMode)
                              });
                              currentMode = this._mode;
                              _context53.prev = 1;
                              if (!(currentMode === requestedMode)) {
                                _context53.next = 2;
                                break;
                              }
                              (_this$_openTelemetry119 = this._openTelemetry) === null || _this$_openTelemetry119 === void 0 || _this$_openTelemetry119.completeSpan({
                                span: changeModeSpan,
                                status: 2,
                                message: "changeMode() Ending"
                              });
                              (_this$_videosdkLogs54 = this._videosdkLogs) === null || _this$_videosdkLogs54 === void 0 || _this$_videosdkLogs54.pushLogs({
                                logText: "You are already in ".concat(requestedMode, " mode"),
                                logType: "INFO"
                              });
                              throw new Error("You are already in ".concat(requestedMode, " mode"));
                            case 2:
                              createTransport = function() {
                                var _ref17 = (0, asyncToGenerator.A)(regenerator_default().mark(function _callee52(producing, consuming) {
                                  return regenerator_default().wrap(function(_context52) {
                                    while (1) switch (_context52.prev = _context52.next) {
                                      case 0:
                                        _context52.next = 1;
                                        return _this2._socketRequest("createWebRtcTransport", {
                                          preferredProtocol: _this2._preferredProtocol,
                                          producing,
                                          consuming,
                                          sctpCapabilities: _this2._mediasoupDevice.sctpCapabilities
                                        });
                                      case 1:
                                        return _context52.abrupt("return", _context52.sent);
                                      case 2:
                                      case "end":
                                        return _context52.stop();
                                    }
                                  }, _callee52);
                                }));
                                return function createTransport2(_x59, _x60) {
                                  return _ref17.apply(this, arguments);
                                };
                              }();
                              if (!(0, modes.kR)(requestedMode)) {
                                _context53.next = 10;
                                break;
                              }
                              this._consume = true;
                              this._produce = true;
                              this._mode = requestedMode;
                              this._mediasoupDevice = new lib.pF({
                                handlerName: this._handlerName
                              });
                              _context53.next = 3;
                              return this._socketRequest("getRouterRtpCapabilities");
                            case 3:
                              routerRtpCapabilities = _context53.sent;
                              routerRtpCapabilities.headerExtensions = (_routerRtpCapabilitie = routerRtpCapabilities.headerExtensions) === null || _routerRtpCapabilitie === void 0 ? void 0 : _routerRtpCapabilitie.filter(function(c) {
                                return c.uri != "urn:3gpp:video-orientation";
                              });
                              _context53.next = 4;
                              return this._mediasoupDevice.load({
                                routerRtpCapabilities
                              });
                            case 4:
                              if (!this._produce) {
                                _context53.next = 6;
                                break;
                              }
                              _context53.next = 5;
                              return createTransport(true, false);
                            case 5:
                              transportInfo = _context53.sent;
                              this.createProducerTransport(transportInfo, changeModeSpan);
                            case 6:
                              if (!(currentMode !== modes.nI.RECV_ONLY && this._consume)) {
                                _context53.next = 8;
                                break;
                              }
                              _context53.next = 7;
                              return createTransport(false, true);
                            case 7:
                              _transportInfo = _context53.sent;
                              this.createConsumerTransport(_transportInfo, changeModeSpan);
                            case 8:
                              (_this$_openTelemetry120 = this._openTelemetry) === null || _this$_openTelemetry120 === void 0 || _this$_openTelemetry120.traceAutoComplete({
                                spanName: "Sending changeMode request to server",
                                span: changeModeSpan,
                                status: 1
                              });
                              _context53.next = 9;
                              return this._socketRequest("changeMode", {
                                mode: requestedMode
                              });
                            case 9:
                              if (this._produce) {
                                store.dispatch(setMediaCapabilities({
                                  canSendMic: this._mediasoupDevice.canProduce("audio"),
                                  canSendWebcam: this._mediasoupDevice.canProduce("video")
                                }));
                                if (this._micEnabled) {
                                  this.enableMic(this.customMicrophoneAudioTrack);
                                }
                                if (this._webcamEnabled) {
                                  this.enableWebcam(this.customCameraVideoTrack, changeModeSpan);
                                }
                                this.enableChatDataProducer();
                              }
                              if (window.SHOW_INFO) {
                                _store$getState2 = store.getState(), me = _store$getState2.me;
                                store.dispatch(setRoomStatsPeerId(me.id));
                              }
                              _context53.next = 17;
                              break;
                            case 10:
                              if (!((0, modes.kR)(currentMode) && requestedMode === modes.nI.RECV_ONLY)) {
                                _context53.next = 12;
                                break;
                              }
                              this._produce = false;
                              this._mode = requestedMode;
                              this._closeProducersAndTransport();
                              _context53.next = 11;
                              return this._socketRequest("changeMode", {
                                mode: requestedMode
                              });
                            case 11:
                              _context53.next = 17;
                              break;
                            case 12:
                              if (!((0, modes.wZ)(currentMode) && requestedMode === modes.nI.RECV_ONLY)) {
                                _context53.next = 15;
                                break;
                              }
                              this._consume = true;
                              this._mode = requestedMode;
                              _context53.next = 13;
                              return this._setupWebrtcTransport(changeModeSpan);
                            case 13:
                              _context53.next = 14;
                              return this._socketRequest("changeMode", {
                                mode: requestedMode
                              });
                            case 14:
                              if (window.SHOW_INFO) {
                                _store$getState3 = store.getState(), _me = _store$getState3.me;
                                store.dispatch(setRoomStatsPeerId(_me.id));
                              }
                              _context53.next = 17;
                              break;
                            case 15:
                              if (!(0, modes.wZ)(requestedMode)) {
                                _context53.next = 17;
                                break;
                              }
                              _context53.next = 16;
                              return this._socketRequest("changeMode", {
                                mode: requestedMode
                              });
                            case 16:
                              this._consume = false;
                              this._produce = false;
                              this._mode = requestedMode;
                              this._dataConsumers.clear();
                              this._closeTransports();
                            case 17:
                              _context53.next = 19;
                              break;
                            case 18:
                              _context53.prev = 18;
                              _t45 = _context53["catch"](1);
                              (_this$_videosdkLogs55 = this._videosdkLogs) === null || _this$_videosdkLogs55 === void 0 || _this$_videosdkLogs55.pushLogs({
                                logText: "Error changeMode(".concat(requestedMode, ") | failed"),
                                logType: "ERROR",
                                attributes: {
                                  error: _t45.message
                                }
                              });
                              (_this$_openTelemetry121 = this._openTelemetry) === null || _this$_openTelemetry121 === void 0 || _this$_openTelemetry121.completeSpan({
                                span: changeModeSpan,
                                status: 2,
                                message: "changeMode(".concat(requestedMode, ") | failed")
                              });
                            case 19:
                            case "end":
                              return _context53.stop();
                          }
                        }, _callee53, this, [[1, 18]]);
                      }));
                      function changeMode(_x58) {
                        return _changeMode.apply(this, arguments);
                      }
                      return changeMode;
                    }()
                    // Helper function to close producers and transport
                  }, {
                    key: "_closeProducersAndTransport",
                    value: function _closeProducersAndTransport() {
                      var _this$_sendTransport3;
                      if (this._webcamProducer) {
                        this._webcamProducer.close();
                        this._webcamProducer = null;
                      }
                      if (this._micProducer) {
                        this._micProducer.close();
                        this._micProducer = null;
                      }
                      if (this._shareProducer) {
                        this._shareProducer.close();
                        this._shareProducer = null;
                      }
                      if (this._shareAudioProducer) {
                        this._shareAudioProducer.close();
                        this._shareAudioProducer = null;
                      }
                      (_this$_sendTransport3 = this._sendTransport) === null || _this$_sendTransport3 === void 0 || _this$_sendTransport3.close();
                      this._sendTransport = null;
                    }
                    // Helper function to close transports
                  }, {
                    key: "_closeTransports",
                    value: function _closeTransports() {
                      if (this._sendTransport) {
                        var _this$_sendTransport4;
                        (_this$_sendTransport4 = this._sendTransport) === null || _this$_sendTransport4 === void 0 || _this$_sendTransport4.close();
                        this._sendTransport = null;
                      }
                      if (this._recvTransport) {
                        var _this$_recvTransport3;
                        (_this$_recvTransport3 = this._recvTransport) === null || _this$_recvTransport3 === void 0 || _this$_recvTransport3.close();
                        this._recvTransport = null;
                      }
                    }
                    // Helper function to setup WebRTC transport
                  }, {
                    key: "_setupWebrtcTransport",
                    value: function() {
                      var _setupWebrtcTransport2 = (0, asyncToGenerator.A)(regenerator_default().mark(function _callee54(changeModeSpan) {
                        var _routerRtpCapabilitie2;
                        var routerRtpCapabilities, transportInfo;
                        return regenerator_default().wrap(function(_context54) {
                          while (1) switch (_context54.prev = _context54.next) {
                            case 0:
                              this._mediasoupDevice = new lib.pF({
                                handlerName: this._handlerName
                              });
                              _context54.next = 1;
                              return this._socketRequest("getRouterRtpCapabilities");
                            case 1:
                              routerRtpCapabilities = _context54.sent;
                              routerRtpCapabilities.headerExtensions = (_routerRtpCapabilitie2 = routerRtpCapabilities.headerExtensions) === null || _routerRtpCapabilitie2 === void 0 ? void 0 : _routerRtpCapabilitie2.filter(function(c) {
                                return c.uri != "urn:3gpp:video-orientation";
                              });
                              _context54.next = 2;
                              return this._mediasoupDevice.load({
                                routerRtpCapabilities
                              });
                            case 2:
                              _context54.next = 3;
                              return this._socketRequest("createWebRtcTransport", {
                                preferredProtocol: this._preferredProtocol,
                                producing: false,
                                consuming: true,
                                sctpCapabilities: this._mediasoupDevice.sctpCapabilities
                              });
                            case 3:
                              transportInfo = _context54.sent;
                              this.createConsumerTransport(transportInfo, changeModeSpan);
                            case 4:
                            case "end":
                              return _context54.stop();
                          }
                        }, _callee54, this);
                      }));
                      function _setupWebrtcTransport(_x61) {
                        return _setupWebrtcTransport2.apply(this, arguments);
                      }
                      return _setupWebrtcTransport;
                    }()
                  }, {
                    key: "enablePeerWebcam",
                    value: function() {
                      var _enablePeerWebcam = (0, asyncToGenerator.A)(regenerator_default().mark(function _callee55(peerId) {
                        var _this$_openTelemetry122;
                        var _this$_videosdkLogs56, _t46;
                        return regenerator_default().wrap(function(_context55) {
                          while (1) switch (_context55.prev = _context55.next) {
                            case 0:
                              (_this$_openTelemetry122 = this._openTelemetry) === null || _this$_openTelemetry122 === void 0 || _this$_openTelemetry122.traceAutoComplete({
                                spanName: "Enabling peer ".concat(peerId, " Webcam"),
                                status: 1
                              });
                              logger.debug("enablePeerWebcam()");
                              _context55.prev = 1;
                              _context55.next = 2;
                              return this._socketRequest("enablePeerWebcam", {
                                peerId
                              });
                            case 2:
                              _context55.next = 4;
                              break;
                            case 3:
                              _context55.prev = 3;
                              _t46 = _context55["catch"](1);
                              (_this$_videosdkLogs56 = this._videosdkLogs) === null || _this$_videosdkLogs56 === void 0 || _this$_videosdkLogs56.pushLogs({
                                logText: "Error enablePeerWebcam | failed",
                                logType: "ERROR",
                                attributes: {
                                  error: _t46.message
                                }
                              });
                              logger.error("enablePeerWebcam() | failed:%o", _t46);
                            case 4:
                            case "end":
                              return _context55.stop();
                          }
                        }, _callee55, this, [[1, 3]]);
                      }));
                      function enablePeerWebcam(_x62) {
                        return _enablePeerWebcam.apply(this, arguments);
                      }
                      return enablePeerWebcam;
                    }()
                  }, {
                    key: "disablePeerWebcam",
                    value: function() {
                      var _disablePeerWebcam = (0, asyncToGenerator.A)(regenerator_default().mark(function _callee56(peerId) {
                        var _this$_openTelemetry123;
                        var _this$_videosdkLogs57, _t47;
                        return regenerator_default().wrap(function(_context56) {
                          while (1) switch (_context56.prev = _context56.next) {
                            case 0:
                              (_this$_openTelemetry123 = this._openTelemetry) === null || _this$_openTelemetry123 === void 0 || _this$_openTelemetry123.traceAutoComplete({
                                spanName: "Disabling peer ".concat(peerId, " Webcam"),
                                status: 1
                              });
                              logger.debug("disablePeerWebcam()");
                              _context56.prev = 1;
                              _context56.next = 2;
                              return this._socketRequest("disablePeerWebcam", {
                                peerId
                              });
                            case 2:
                              _context56.next = 4;
                              break;
                            case 3:
                              _context56.prev = 3;
                              _t47 = _context56["catch"](1);
                              (_this$_videosdkLogs57 = this._videosdkLogs) === null || _this$_videosdkLogs57 === void 0 || _this$_videosdkLogs57.pushLogs({
                                logText: "Error disablePeerWebcam | failed",
                                logType: "ERROR",
                                attributes: {
                                  error: _t47.message
                                }
                              });
                            case 4:
                            case "end":
                              return _context56.stop();
                          }
                        }, _callee56, this, [[1, 3]]);
                      }));
                      function disablePeerWebcam(_x63) {
                        return _disablePeerWebcam.apply(this, arguments);
                      }
                      return disablePeerWebcam;
                    }()
                  }, {
                    key: "getMicStats",
                    value: function getMicStats(probe) {
                      var _this3 = this;
                      if (this._micProducer) {
                        var reportCounter = 0;
                        probe.onStatsCollected = function(report) {
                          if (!_this3._stats.producerStats) {
                            _this3._stats.producerStats = {};
                          }
                          if (!_this3._stats.producerStats["audio"]) {
                            _this3._stats.producerStats["audio"] = [];
                          }
                          if (_this3._micProducer) {
                            var _this3$_micProducer;
                            _this3._latestStats[(_this3$_micProducer = _this3._micProducer) === null || _this3$_micProducer === void 0 ? void 0 : _this3$_micProducer.id] = [];
                          }
                          report["audio"].forEach(function(stat) {
                            if (_this3._micProducer) {
                              var _this3$_micProducer2;
                              _this3._latestStats[(_this3$_micProducer2 = _this3._micProducer) === null || _this3$_micProducer2 === void 0 ? void 0 : _this3$_micProducer2.id].push(stat);
                            }
                          });
                          if (reportCounter % 5 == 0 && _this3._micProducer != null) {
                            _this3._stats["producerStats"]["audio"].push(RoomClient_objectSpread({
                              timestamp: /* @__PURE__ */ new Date()
                            }, _this3._latestStats[_this3._micProducer.id] ? _this3._latestStats[_this3._micProducer.id][0] : {}));
                          }
                          reportCounter++;
                        };
                      }
                    }
                  }, {
                    key: "enableMic",
                    value: function() {
                      var _enableMic = (0, asyncToGenerator.A)(regenerator_default().mark(function _callee57() {
                        var _this$_openTelemetry124, _this4 = this, _this$_videosdkLogs65, _this$_openTelemetry136, _this$_videosdkLogs66, _this$_openTelemetry137;
                        var customAudioTrack, parentSpan, enableMicSpan2, _this$_openTelemetry125, _this$_openTelemetry127, micProducerSpan, _this$_openTelemetry126, oldProducer, _this$_openTelemetry128, action, _this$_openTelemetry129, _this$_videosdkLogs58, probe, _this$_videosdkLogs59, _this$_openTelemetry130, message, _this$_videosdkLogs60, _this$_openTelemetry131, track, internalSpan, _this$_openTelemetry140, _this$_openTelemetry141, _this$_openTelemetry142, _this$_openTelemetry143, _track, _message, _this$_videosdkLogs61, sdkError, _this$_videosdkLogs62, _sdkError, _this$_openTelemetry132, _this$_openTelemetry139, trackSpan, stream, _this$_openTelemetry133, _this$_videosdkLogs63, _this$_openTelemetry134, errorMessage, _message2, _this$_videosdkLogs64, _this$_openTelemetry135, _errorMessage, _message3, notAllowedErrorData, notReadableErrorData, _errorMessage2, _message4, err, _this$_videosdkLogs67, _this$_openTelemetry138, _err, _stream, codecOptions, audioProfile, networkPriority, encodings, appData, _this$_videosdkLogs68, _this$_openTelemetry144, _this$_openTelemetry145, _action6, _probe, _this$_videosdkLogs69, _this$_openTelemetry146, _this$_openTelemetry147, _this$_openTelemetry148, _this$_openTelemetry149, _this$_videosdkLogs70, _args57 = arguments, _t48, _t49, _t50;
                        return regenerator_default().wrap(function(_context57) {
                          while (1) switch (_context57.prev = _context57.next) {
                            case 0:
                              customAudioTrack = _args57.length > 0 && _args57[0] !== void 0 ? _args57[0] : void 0;
                              parentSpan = _args57.length > 1 && _args57[1] !== void 0 ? _args57[1] : void 0;
                              enableMicSpan2 = (_this$_openTelemetry124 = this._openTelemetry) === null || _this$_openTelemetry124 === void 0 ? void 0 : _this$_openTelemetry124.trace({
                                spanName: "enableMic() Calling ".concat(!!customAudioTrack ? "With Custom Audio Track" : "Without Custom Audio Track "),
                                attributes: {
                                  customAudioConfig: customAudioTrack ? JSON.stringify(customAudioTrack) : "Not Specify Custom Track"
                                },
                                span: parentSpan ? parentSpan : null
                              });
                              logger.debug("enableMic()");
                              this._micEnabled = true;
                              if (!this._micProducer) {
                                _context57.next = 4;
                                break;
                              }
                              micProducerSpan = (_this$_openTelemetry125 = this._openTelemetry) === null || _this$_openTelemetry125 === void 0 ? void 0 : _this$_openTelemetry125.trace({
                                spanName: "Mic Producer found",
                                span: enableMicSpan2
                              });
                              if (customAudioTrack) {
                                (_this$_openTelemetry126 = this._openTelemetry) === null || _this$_openTelemetry126 === void 0 || _this$_openTelemetry126.traceAutoComplete({
                                  spanName: "Stopping customAudioTrack",
                                  span: enableMicSpan2,
                                  status: 1
                                });
                                customAudioTrack.getTracks().forEach(function(track2) {
                                  track2.stop();
                                });
                              }
                              (_this$_openTelemetry127 = this._openTelemetry) === null || _this$_openTelemetry127 === void 0 || _this$_openTelemetry127.completeSpan({
                                span: micProducerSpan,
                                status: 1,
                                message: "Resuming Mic Producer"
                              });
                              this._micProducer.resume();
                              oldProducer = this._micProducer;
                              if (!this._sendTransport) {
                                _context57.next = 2;
                                break;
                              }
                              _context57.next = 1;
                              return this._sendTransport.produce({
                                track: this._micProducer.track,
                                encodings: this._micProducer._appData.encodings,
                                codecOptions: this._micProducer._appData.codecOptions,
                                appData: {
                                  isEncrypted: this.isE2EEEnabled
                                },
                                onRtpSender: function onRtpSender(rtpSender) {
                                  if (_this4.e2eeManager) {
                                    rtpSender.senderStreams = rtpSender.createEncodedStreams();
                                  }
                                }
                              });
                            case 1:
                              this._micProducer = _context57.sent;
                              if (this.e2eeManager) {
                                this.e2eeManager.emit("NEW_PRODUCER", this._micProducer);
                              }
                              if (this._micProducer) {
                                action = addProducer({
                                  id: this._micProducer.id,
                                  paused: this._micProducer.paused,
                                  track: this._micProducer.track,
                                  rtpParameters: this._micProducer.rtpParameters,
                                  codec: this._micProducer.rtpParameters.codecs[0].mimeType.split("/")[1],
                                  encodings: oldProducer._appData.encodings,
                                  codecOptions: oldProducer._appData.codecOptions,
                                  instance: this._micProducer,
                                  rtpSender: this._micProducer.rtpSender
                                });
                                if (this._micProducer.track.getConstraints().deviceId) {
                                  this._mic.device = this._mics.get(this._micProducer.track.getConstraints().deviceId);
                                }
                                store.dispatch(action);
                                this._eventEmitter.emit(action.type, action.payload);
                                (_this$_openTelemetry128 = this._openTelemetry) === null || _this$_openTelemetry128 === void 0 || _this$_openTelemetry128.completeSpan({
                                  span: enableMicSpan2,
                                  status: 1,
                                  message: "Enable Mic Successful"
                                });
                              } else {
                                (_this$_openTelemetry129 = this._openTelemetry) === null || _this$_openTelemetry129 === void 0 || _this$_openTelemetry129.completeSpan({
                                  span: enableMicSpan2,
                                  status: 2,
                                  message: "Error in enableMic() :: micProducer null"
                                });
                              }
                              _context57.next = 3;
                              break;
                            case 2:
                              (_this$_videosdkLogs58 = this._videosdkLogs) === null || _this$_videosdkLogs58 === void 0 || _this$_videosdkLogs58.pushLogs({
                                logText: errors.q.ERROR_ACTION_PERFORMED_BEFORE_MEETING_JOINED.message,
                                attributes: {
                                  error: "Error in enableMic() :: Transport is not setup"
                                },
                                logType: "ERROR",
                                dashboardLog: true
                              });
                              this._emitError(errors.q.ERROR_ACTION_PERFORMED_BEFORE_MEETING_JOINED);
                              return _context57.abrupt("return");
                            case 3:
                              probe = this._metrics.addNewProbe(this._micProducer, {
                                name: "mic_producer"
                              });
                              this._micProducer.observer.on("pause", function() {
                                probe === null || probe === void 0 || probe.stop();
                                _this4._latestStats[_this4._micProducer.id] = [];
                                _this4._metrics.removeExistingProbe(probe);
                              });
                              this._micProducer.observer.on("close", function() {
                                probe === null || probe === void 0 || probe.stop();
                                _this4._latestStats[_this4._micProducer.id] = [];
                                _this4._metrics.removeExistingProbe(probe);
                              });
                              this.getMicStats(probe);
                              probe.start();
                              return _context57.abrupt("return");
                            case 4:
                              if (!this._mediasoupDevice) {
                                _context57.next = 6;
                                break;
                              }
                              if (this._mediasoupDevice.canProduce("audio")) {
                                _context57.next = 5;
                                break;
                              }
                              message = this._deviceInfo.sdkType == "react-native" ? errors.q.ERROR_RN_MIC_ACCESS_UNAVAILABLE.message : errors.q.ERROR_MICROPHONE_ACCESS_UNAVAILABLE.message;
                              (_this$_videosdkLogs59 = this._videosdkLogs) === null || _this$_videosdkLogs59 === void 0 || _this$_videosdkLogs59.pushLogs({
                                logText: message,
                                attributes: {
                                  error: "Error in enableMic() :: Microphone access unavailable"
                                },
                                logType: "ERROR",
                                dashboardLog: true
                              });
                              logger.error("enableMic() | cannot produce audio");
                              (_this$_openTelemetry130 = this._openTelemetry) === null || _this$_openTelemetry130 === void 0 || _this$_openTelemetry130.completeSpan({
                                span: enableMicSpan2,
                                status: 2,
                                message: "Error in enableMic() :: ".concat(message)
                              });
                              return _context57.abrupt("return");
                            case 5:
                              _context57.next = 7;
                              break;
                            case 6:
                              (_this$_videosdkLogs60 = this._videosdkLogs) === null || _this$_videosdkLogs60 === void 0 || _this$_videosdkLogs60.pushLogs({
                                logText: "Oops! Something went wrong, and we're unable to enable the mic. Please try again.",
                                logType: "ERROR",
                                attributes: {
                                  error: "Error in enableMic(): Something went wrong."
                                },
                                dashboardLog: true
                              });
                              (_this$_openTelemetry131 = this._openTelemetry) === null || _this$_openTelemetry131 === void 0 || _this$_openTelemetry131.completeSpan({
                                span: enableMicSpan2,
                                status: 2,
                                message: "Error in enableMic() :: mediasoupDevice is undefined"
                              });
                              return _context57.abrupt("return");
                            case 7:
                              _context57.prev = 7;
                              if (this._externalVideo) {
                                _context57.next = 24;
                                break;
                              }
                              logger.debug("enableMic() | calling getUserMedia()");
                              _context57.next = 8;
                              return this._updateMics(enableMicSpan2);
                            case 8:
                              if (this._mic.device) {
                                _context57.next = 9;
                                break;
                              }
                              _message = "Whoops! No Microphone Found: We couldn't find your microphone. Is it plugged in and turned on? If so, try restarting your computer or checking your device settings. Also, ensure you're on a secure website (https://).";
                              throw new Error(_message);
                            case 9:
                              try {
                                if (customAudioTrack) {
                                  track = customAudioTrack.getAudioTracks()[0];
                                  if (track.readyState == "ended") {
                                    track = null;
                                    sdkError = errors.q.ERROR_CUSTOM_AUDIO_TRACK_ENDED;
                                    (_this$_videosdkLogs61 = this._videosdkLogs) === null || _this$_videosdkLogs61 === void 0 || _this$_videosdkLogs61.pushLogs({
                                      logText: sdkError.message,
                                      logType: "INFO",
                                      attributes: {
                                        error: "In enableMic() :: Invalid Custom Track Passed"
                                      },
                                      dashboardLog: true
                                    });
                                    this._emitError(sdkError);
                                  }
                                }
                              } catch (error) {
                                _sdkError = errors.q.ERROR_INVALID_CUSTOM_AUDIO_TRACK;
                                (_this$_videosdkLogs62 = this._videosdkLogs) === null || _this$_videosdkLogs62 === void 0 || _this$_videosdkLogs62.pushLogs({
                                  logText: _sdkError.message,
                                  logType: "INFO",
                                  attributes: {
                                    error: "In enableMic() :: Invalid Custom Track Passed"
                                  }
                                });
                                this._emitError(_sdkError);
                                console.log("Invalid Custom Audio Track Passed. Reverting to default Error: ".concat(error));
                              }
                              if (track) {
                                _context57.next = 23;
                                break;
                              }
                              trackSpan = (_this$_openTelemetry132 = this._openTelemetry) === null || _this$_openTelemetry132 === void 0 ? void 0 : _this$_openTelemetry132.trace({
                                spanName: "Creating Track",
                                span: enableMicSpan2
                              });
                              _context57.prev = 10;
                              _context57.next = 11;
                              return navigator.mediaDevices.getUserMedia({
                                audio: {
                                  // deviceId: { exact: this._mic.device.deviceId },
                                  deviceId: this._mic.device.deviceId ? {
                                    exact: this._mic.device.deviceId
                                  } : void 0,
                                  channelCount: 1,
                                  noiseSuppression: true,
                                  echoCancellation: true,
                                  googEchoCancellation: true,
                                  googEchoCancellation2: true,
                                  googAutoGainControl: true,
                                  googAutoGainControl2: true,
                                  googNoiseSuppression: true,
                                  googNoiseSuppression2: true,
                                  googHighpassFilter: true
                                }
                              });
                            case 11:
                              stream = _context57.sent;
                              _context57.next = 22;
                              break;
                            case 12:
                              _context57.prev = 12;
                              _t48 = _context57["catch"](10);
                              (_this$_openTelemetry133 = this._openTelemetry) === null || _this$_openTelemetry133 === void 0 || _this$_openTelemetry133.completeSpan({
                                message: "Error in enableMic() :: ".concat(_t48.message),
                                span: trackSpan,
                                status: 2
                              });
                              if (!(_t48.name === "SecurityError")) {
                                _context57.next = 13;
                                break;
                              }
                              errorMessage = errors.q.ERROR_RN_MIC_ACCESS_DENIED_OR_DISMISSED;
                              _message2 = errorMessage.message;
                              this._emitError(errorMessage);
                              (_this$_videosdkLogs63 = this._videosdkLogs) === null || _this$_videosdkLogs63 === void 0 || _this$_videosdkLogs63.pushLogs({
                                logText: _message2,
                                logType: "ERROR",
                                attributes: {
                                  error: "Error in enableMic() :: Microphone Permission Denied or Dismissed"
                                },
                                dashboardLog: true
                              });
                              (_this$_openTelemetry134 = this._openTelemetry) === null || _this$_openTelemetry134 === void 0 || _this$_openTelemetry134.completeSpan({
                                message: "Error in enableMic() :: occurred in creating audio track, ".concat(_message2),
                                span: enableMicSpan2,
                                status: 2
                              });
                              _context57.next = 21;
                              break;
                            case 13:
                              if (!(_t48.name === "DOMException")) {
                                _context57.next = 14;
                                break;
                              }
                              _errorMessage = errors.q.ERROR_RN_MIC_NOT_FOUND;
                              _message3 = _errorMessage.message;
                              this._emitError(_errorMessage);
                              (_this$_videosdkLogs64 = this._videosdkLogs) === null || _this$_videosdkLogs64 === void 0 || _this$_videosdkLogs64.pushLogs({
                                logText: _message3,
                                logType: "ERROR",
                                attributes: {
                                  error: "Error in enableMic() :: No Microphone Device Found"
                                },
                                dashboardLog: true
                              });
                              (_this$_openTelemetry135 = this._openTelemetry) === null || _this$_openTelemetry135 === void 0 || _this$_openTelemetry135.completeSpan({
                                message: "Error in enableMic() :: occurred in creating audio track, ".concat(_message3),
                                span: enableMicSpan2,
                                status: 2
                              });
                              _context57.next = 21;
                              break;
                            case 14:
                              if (!(_t48 instanceof DOMException)) {
                                _context57.next = 20;
                                break;
                              }
                              _t49 = _t48.name;
                              _context57.next = _t49 === "NotAllowedError" ? 15 : _t49 === "NotReadableError" ? 16 : _t49 === "NotFoundError" ? 17 : 18;
                              break;
                            case 15:
                              notAllowedErrorData = this.handleNotAllowedError(_t48, this._openTelemetry, this._videosdkLogs, enableMicSpan2, "audio");
                              this._emitError(notAllowedErrorData);
                              return _context57.abrupt("continue", 19);
                            case 16:
                              notReadableErrorData = this.handleNotReadableError(_t48, this._openTelemetry, this._videosdkLogs, enableMicSpan2, "audio");
                              this._emitError(notReadableErrorData);
                              return _context57.abrupt("continue", 19);
                            case 17:
                              _errorMessage2 = errors.q.ERROR_MICROPHONE_NOT_FOUND;
                              if (navigator && navigator.userAgent) {
                                if (navigator.userAgent.indexOf("Firefox") != -1) {
                                  _errorMessage2 = errors.q.ERROR_MICROPHONE_PERMISSION_DENIED_BY_OS;
                                }
                              }
                              _message4 = _errorMessage2.message;
                              this._emitError(_errorMessage2);
                              (_this$_videosdkLogs65 = this._videosdkLogs) === null || _this$_videosdkLogs65 === void 0 || _this$_videosdkLogs65.pushLogs({
                                logText: _message4,
                                logType: "ERROR",
                                attributes: {
                                  error: "Error in enableMic() :: No Microphone Device Found"
                                },
                                dashboardLog: true
                              });
                              (_this$_openTelemetry136 = this._openTelemetry) === null || _this$_openTelemetry136 === void 0 || _this$_openTelemetry136.completeSpan({
                                message: "Error in enableMic() :: occurred in creating audio track, ".concat(_message4),
                                span: enableMicSpan2,
                                status: 2
                              });
                              return _context57.abrupt("continue", 19);
                            case 18:
                              err = "An error occurred in creating audio track, ".concat(_t48.message);
                              (_this$_videosdkLogs66 = this._videosdkLogs) === null || _this$_videosdkLogs66 === void 0 || _this$_videosdkLogs66.pushLogs({
                                logText: _t48.message,
                                logType: "ERROR",
                                attributes: {
                                  error: "Error in enableMic() :: ".concat(err)
                                },
                                dashboardLog: true
                              });
                              (_this$_openTelemetry137 = this._openTelemetry) === null || _this$_openTelemetry137 === void 0 || _this$_openTelemetry137.completeSpan({
                                message: "Error in enableMic() :: ".concat(err),
                                span: enableMicSpan2,
                                status: 2
                              });
                              return _context57.abrupt("continue", 19);
                            case 19:
                              _context57.next = 21;
                              break;
                            case 20:
                              _err = "An error occurred in creating audio track, ".concat(_t48.message);
                              (_this$_videosdkLogs67 = this._videosdkLogs) === null || _this$_videosdkLogs67 === void 0 || _this$_videosdkLogs67.pushLogs({
                                logText: _t48.message,
                                logType: "ERROR",
                                attributes: {
                                  error: "Error in enableMic() :: ".concat(_err)
                                },
                                dashboardLog: true
                              });
                              (_this$_openTelemetry138 = this._openTelemetry) === null || _this$_openTelemetry138 === void 0 || _this$_openTelemetry138.completeSpan({
                                message: "Error in enableMic() :: ".concat(_err),
                                span: enableMicSpan2,
                                status: 2
                              });
                            case 21:
                              return _context57.abrupt("return");
                            case 22:
                              track = stream.getAudioTracks()[0];
                              (_this$_openTelemetry139 = this._openTelemetry) === null || _this$_openTelemetry139 === void 0 || _this$_openTelemetry139.completeSpan({
                                message: "Audio Track Generated",
                                span: trackSpan,
                                status: 1
                              });
                            case 23:
                              _context57.next = 26;
                              break;
                            case 24:
                              _context57.next = 25;
                              return this._getExternalVideoStream();
                            case 25:
                              _stream = _context57.sent;
                              track = _stream.getAudioTracks()[0].clone();
                            case 26:
                              internalSpan = (_this$_openTelemetry140 = this._openTelemetry) === null || _this$_openTelemetry140 === void 0 ? void 0 : _this$_openTelemetry140.trace({
                                spanName: "Generating Producer Configuration",
                                span: enableMicSpan2
                              });
                              codecOptions = {
                                opusStereo: 1,
                                opusDtx: 1
                              };
                              if (customAudioTrack) {
                                audioProfile = customAudioTrack.encoderConfig ? config2.$.audioProfiles[customAudioTrack.encoderConfig] : config2.$.audioProfiles.speech_standard;
                                codecOptions = {
                                  opusStereo: audioProfile.stereo ? 1 : 0,
                                  opusFec: audioProfile.fec ? 1 : 0,
                                  opusDtx: audioProfile.dtx ? 1 : 0,
                                  opusMaxPlaybackRate: audioProfile.maxPlaybackRate,
                                  opusPtime: audioProfile.packetTime
                                };
                              }
                              networkPriority = "high";
                              encodings = [{
                                networkPriority
                              }];
                              appData = {
                                encodings,
                                codecOptions
                              };
                              (_this$_openTelemetry141 = this._openTelemetry) === null || _this$_openTelemetry141 === void 0 || _this$_openTelemetry141.traceAutoComplete({
                                spanName: "Generated AppData",
                                span: internalSpan,
                                attributes: {
                                  appData: JSON.stringify(appData)
                                },
                                status: 1
                              });
                              (_this$_openTelemetry142 = this._openTelemetry) === null || _this$_openTelemetry142 === void 0 || _this$_openTelemetry142.completeSpan({
                                span: internalSpan,
                                status: 1,
                                message: "Producer Configuration Generated"
                              });
                              internalSpan = (_this$_openTelemetry143 = this._openTelemetry) === null || _this$_openTelemetry143 === void 0 ? void 0 : _this$_openTelemetry143.trace({
                                spanName: "Creating Mic Producer",
                                span: enableMicSpan2
                              });
                              (_track = track) === null || _track === void 0 || _track.addEventListener("ended", function() {
                                console.log("Track Ended Error");
                                try {
                                  var _this4$_videosdkLogs, _this4$_openTelemetry;
                                  var error = _this4._deviceInfo.sdkType == "react-native" ? errors.q.ERROR_RN_MIC_TRACK_ENDED : errors.q.ERROR_MICROPHONE_TRACK_ENDED;
                                  (_this4$_videosdkLogs = _this4._videosdkLogs) === null || _this4$_videosdkLogs === void 0 || _this4$_videosdkLogs.pushLogs({
                                    logText: error.message,
                                    logType: "ERROR",
                                    attributes: {
                                      error: "Error Track Ended :: ".concat(error.message)
                                    },
                                    dashboardLog: true
                                  });
                                  (_this4$_openTelemetry = _this4._openTelemetry) === null || _this4$_openTelemetry === void 0 || _this4$_openTelemetry.traceAutoComplete({
                                    spanName: "this._micProducer trackended or Microphone disconnected!",
                                    span: enableMicSpan2,
                                    message: error.message,
                                    status: 2
                                  });
                                  store.dispatch(notify({
                                    type: "error",
                                    text: "Microphone disconnected!"
                                  }));
                                  _this4.disableMic(true, enableMicSpan2)["catch"](function() {
                                  });
                                } catch (err2) {
                                  console.error(err2);
                                }
                              });
                              if (!this._sendTransport) {
                                _context57.next = 28;
                                break;
                              }
                              _context57.next = 27;
                              return this._sendTransport.produce({
                                track,
                                encodings,
                                codecOptions,
                                appData: RoomClient_objectSpread(RoomClient_objectSpread({}, appData), {}, {
                                  isEncrypted: this.isE2EEEnabled
                                }),
                                onRtpSender: function onRtpSender(rtpSender) {
                                  if (_this4.e2eeManager) {
                                    rtpSender.senderStreams = rtpSender.createEncodedStreams();
                                  }
                                }
                                // NOTE: for testing codec selection.
                                // codec : this._mediasoupDevice.rtpCapabilities.codecs
                                // 	.find((codec) => codec.mimeType.toLowerCase() === 'audio/pcma')
                              });
                            case 27:
                              this._micProducer = _context57.sent;
                              if (this.e2eeManager) {
                                this.e2eeManager.emit("NEW_PRODUCER", this._micProducer);
                              }
                              _context57.next = 29;
                              break;
                            case 28:
                              (_this$_videosdkLogs68 = this._videosdkLogs) === null || _this$_videosdkLogs68 === void 0 || _this$_videosdkLogs68.pushLogs({
                                logText: errors.q.ERROR_ACTION_PERFORMED_BEFORE_MEETING_JOINED.message,
                                attributes: {
                                  error: "Error in enableMic() :: Transport is not setup"
                                },
                                logType: "ERROR",
                                dashboardLog: true
                              });
                              this._emitError(errors.q.ERROR_ACTION_PERFORMED_BEFORE_MEETING_JOINED);
                              return _context57.abrupt("return");
                            case 29:
                              if (this._micProducer) {
                                if (track.getConstraints().deviceId) {
                                  this._mic.device = this._mics.get(track.getConstraints().deviceId);
                                }
                                _action6 = addProducer({
                                  id: this._micProducer.id,
                                  paused: this._micProducer.paused,
                                  track: this._micProducer.track,
                                  rtpParameters: this._micProducer.rtpParameters,
                                  codec: this._micProducer.rtpParameters.codecs[0].mimeType.split("/")[1],
                                  encodings,
                                  codecOptions,
                                  instance: this._micProducer,
                                  rtpSender: this._micProducer.rtpSender
                                });
                                store.dispatch(_action6);
                                this._eventEmitter.emit(_action6.type, _action6.payload);
                                _probe = this._metrics.addNewProbe(this._micProducer, {
                                  name: "mic_producer"
                                });
                                _probe.start();
                                this.getMicStats(_probe);
                                this._micProducer.on("transportclose", function() {
                                  var _this4$_micProducer;
                                  var action2 = removeProducer(_this4._micProducer.id);
                                  store.dispatch(action2);
                                  _this4._eventEmitter.emit(action2.type, action2.payload);
                                  (_this4$_micProducer = _this4._micProducer) === null || _this4$_micProducer === void 0 || _this4$_micProducer.close();
                                  _this4._micProducer = null;
                                });
                                this._micProducer.observer.on("pause", function() {
                                  _probe === null || _probe === void 0 || _probe.stop();
                                  _this4._latestStats[_this4._micProducer.id] = [];
                                  _this4._metrics.removeExistingProbe(_probe);
                                });
                                this._micProducer.observer.on("close", function() {
                                  _probe === null || _probe === void 0 || _probe.stop();
                                  _this4._latestStats[_this4._micProducer.id] = [];
                                  _this4._metrics.removeExistingProbe(_probe);
                                });
                                this._micProducer.on("trackended", function() {
                                  var _this4$_videosdkLogs2, _this4$_openTelemetry2;
                                  var error = _this4._deviceInfo.sdkType == "react-native" ? errors.q.ERROR_RN_MIC_TRACK_ENDED : errors.q.ERROR_MICROPHONE_TRACK_ENDED;
                                  (_this4$_videosdkLogs2 = _this4._videosdkLogs) === null || _this4$_videosdkLogs2 === void 0 || _this4$_videosdkLogs2.pushLogs({
                                    logText: error.message,
                                    logType: "ERROR",
                                    attributes: {
                                      error: "Error in enableMic() :: ".concat(error.message)
                                    },
                                    dashboardLog: true
                                  });
                                  (_this4$_openTelemetry2 = _this4._openTelemetry) === null || _this4$_openTelemetry2 === void 0 || _this4$_openTelemetry2.traceAutoComplete({
                                    spanName: "this._micProducer trackended or Microphone disconnected!",
                                    span: enableMicSpan2,
                                    message: error.message,
                                    status: 2
                                  });
                                  store.dispatch(notify({
                                    type: "error",
                                    text: "Microphone disconnected!"
                                  }));
                                  _this4.disableMic(true, enableMicSpan2)["catch"](function() {
                                  });
                                });
                                (_this$_openTelemetry144 = this._openTelemetry) === null || _this$_openTelemetry144 === void 0 || _this$_openTelemetry144.completeSpan({
                                  span: internalSpan,
                                  status: 1,
                                  message: "Mic Producer Created"
                                });
                                (_this$_openTelemetry145 = this._openTelemetry) === null || _this$_openTelemetry145 === void 0 || _this$_openTelemetry145.completeSpan({
                                  span: enableMicSpan2,
                                  status: 1,
                                  message: "Enable Mic Successful"
                                });
                              } else {
                                (_this$_videosdkLogs69 = this._videosdkLogs) === null || _this$_videosdkLogs69 === void 0 || _this$_videosdkLogs69.pushLogs({
                                  logText: "Oops! Something went wrong, and we're unable to enable the mic. Please try again.",
                                  logType: "ERROR",
                                  attributes: {
                                    error: "Error in enableMic(): Something went wrong."
                                  },
                                  dashboardLog: true
                                });
                                (_this$_openTelemetry146 = this._openTelemetry) === null || _this$_openTelemetry146 === void 0 || _this$_openTelemetry146.completeSpan({
                                  span: internalSpan,
                                  status: 2,
                                  message: "Error in enableMic() :: micProducer null"
                                });
                                (_this$_openTelemetry147 = this._openTelemetry) === null || _this$_openTelemetry147 === void 0 || _this$_openTelemetry147.completeSpan({
                                  span: enableMicSpan2,
                                  status: 2,
                                  message: "Error in enableMic() :: micProducer null"
                                });
                              }
                              _context57.next = 32;
                              break;
                            case 30:
                              _context57.prev = 30;
                              _t50 = _context57["catch"](7);
                              (_this$_openTelemetry148 = this._openTelemetry) === null || _this$_openTelemetry148 === void 0 || _this$_openTelemetry148.completeSpan({
                                span: internalSpan,
                                status: 2,
                                message: "Error in enableMic() :: occurred in creating mic producer, ".concat(_t50.message)
                              });
                              (_this$_openTelemetry149 = this._openTelemetry) === null || _this$_openTelemetry149 === void 0 || _this$_openTelemetry149.completeSpan({
                                span: enableMicSpan2,
                                status: 2,
                                message: "Error in enableMic :: ".concat(_t50.message)
                              });
                              (_this$_videosdkLogs70 = this._videosdkLogs) === null || _this$_videosdkLogs70 === void 0 || _this$_videosdkLogs70.pushLogs({
                                logText: _t50.message,
                                logType: "ERROR",
                                attributes: {
                                  error: "Error in enableMic() :: ".concat(_t50.message)
                                },
                                dashboardLog: true
                              });
                              logger.error("enableMic() | failed:%o", _t50);
                              store.dispatch(notify({
                                type: "error",
                                text: "Error enabling microphone: ".concat(_t50)
                              }));
                              _context57.next = 31;
                              return this._socketRequest("produceError", {
                                mediaType: "audio",
                                message: _t50.message
                              });
                            case 31:
                              if (track) track.stop();
                            case 32:
                            case "end":
                              return _context57.stop();
                          }
                        }, _callee57, this, [[7, 30], [10, 12]]);
                      }));
                      function enableMic() {
                        return _enableMic.apply(this, arguments);
                      }
                      return enableMic;
                    }()
                  }, {
                    key: "disableMic",
                    value: function() {
                      var _disableMic = (0, asyncToGenerator.A)(regenerator_default().mark(function _callee58() {
                        var _this$_openTelemetry150, _this$_openTelemetry152;
                        var closeProducer, parentSpan, disableMicSpan, _this$_openTelemetry151, _this$_videosdkLogs71, internalSpan, _this$_openTelemetry153, _this$_openTelemetry154, _this$_openTelemetry158, pauseMicSpan, _action7, _this$_openTelemetry155, _this$_openTelemetry156, _this$_openTelemetry157, _this$_videosdkLogs72, message, action, _this$_openTelemetry159, _this$_openTelemetry160, _this$_openTelemetry161, _this$_openTelemetry162, _this$_videosdkLogs73, _message5, _args58 = arguments, _t51, _t52;
                        return regenerator_default().wrap(function(_context58) {
                          while (1) switch (_context58.prev = _context58.next) {
                            case 0:
                              closeProducer = _args58.length > 0 && _args58[0] !== void 0 ? _args58[0] : false;
                              parentSpan = _args58.length > 1 && _args58[1] !== void 0 ? _args58[1] : void 0;
                              logger.debug("disableMic()");
                              disableMicSpan = (_this$_openTelemetry150 = this._openTelemetry) === null || _this$_openTelemetry150 === void 0 ? void 0 : _this$_openTelemetry150.trace({
                                spanName: "disableMic() Calling",
                                status: 1,
                                span: parentSpan ? parentSpan : null
                              });
                              if (this._micProducer) {
                                _context58.next = 1;
                                break;
                              }
                              (_this$_openTelemetry151 = this._openTelemetry) === null || _this$_openTelemetry151 === void 0 || _this$_openTelemetry151.completeSpan({
                                span: disableMicSpan,
                                status: 2,
                                message: "Error in disableMic() :: Mic Producer Not found"
                              });
                              (_this$_videosdkLogs71 = this._videosdkLogs) === null || _this$_videosdkLogs71 === void 0 || _this$_videosdkLogs71.pushLogs({
                                logText: "Attempted to call disableMic() multiple times",
                                attributes: {
                                  error: "Error in disableMic() :: Microphone is already disabled"
                                },
                                logType: "ERROR",
                                dashboardLog: true
                              });
                              return _context58.abrupt("return");
                            case 1:
                              internalSpan = (_this$_openTelemetry152 = this._openTelemetry) === null || _this$_openTelemetry152 === void 0 ? void 0 : _this$_openTelemetry152.trace({
                                spanName: "Closing Mic Producer",
                                span: disableMicSpan,
                                status: 1
                              });
                              this._micEnabled = false;
                              if (!(this._micProducer && !closeProducer)) {
                                _context58.next = 6;
                                break;
                              }
                              pauseMicSpan = (_this$_openTelemetry153 = this._openTelemetry) === null || _this$_openTelemetry153 === void 0 ? void 0 : _this$_openTelemetry153.trace({
                                spanName: "Pausing Mic Producer",
                                span: internalSpan,
                                status: 1
                              });
                              this._micProducer.pause();
                              _action7 = removeProducer(this._micProducer.id);
                              (_this$_openTelemetry154 = this._openTelemetry) === null || _this$_openTelemetry154 === void 0 || _this$_openTelemetry154.completeSpan({
                                span: pauseMicSpan,
                                status: 1,
                                message: "Pause Mic Successfully"
                              });
                              store.dispatch(_action7);
                              this._eventEmitter.emit(_action7.type, _action7.payload);
                              _context58.prev = 2;
                              _context58.next = 3;
                              return this._socketRequest("closeProducer", {
                                producerId: this._micProducer.id
                              });
                            case 3:
                              (_this$_openTelemetry155 = this._openTelemetry) === null || _this$_openTelemetry155 === void 0 || _this$_openTelemetry155.completeSpan({
                                span: internalSpan,
                                status: 1,
                                message: "Requested Server to Close Producer"
                              });
                              _context58.next = 5;
                              break;
                            case 4:
                              _context58.prev = 4;
                              _t51 = _context58["catch"](2);
                              store.dispatch(notify({
                                type: "error",
                                text: "Error closing server-side mic Producer: ".concat(_t51)
                              }));
                              message = "Error in disableMic() :: Failed to close server-side microphone producer. closeProducer status: ".concat(closeProducer);
                              (_this$_openTelemetry156 = this._openTelemetry) === null || _this$_openTelemetry156 === void 0 || _this$_openTelemetry156.completeSpan({
                                span: internalSpan,
                                status: 2,
                                message: "Error in disableMic() :: ".concat(_t51.message)
                              });
                              (_this$_openTelemetry157 = this._openTelemetry) === null || _this$_openTelemetry157 === void 0 || _this$_openTelemetry157.completeSpan({
                                span: disableMicSpan,
                                status: 2,
                                message
                              });
                              (_this$_videosdkLogs72 = this._videosdkLogs) === null || _this$_videosdkLogs72 === void 0 || _this$_videosdkLogs72.pushLogs({
                                logText: message,
                                logType: "ERROR",
                                attributes: {
                                  error: _t51.message
                                },
                                dashboardLog: true
                              });
                            case 5:
                              (_this$_openTelemetry158 = this._openTelemetry) === null || _this$_openTelemetry158 === void 0 || _this$_openTelemetry158.completeSpan({
                                span: disableMicSpan,
                                status: 1,
                                message: "Mic Disabled Successfully"
                              });
                              return _context58.abrupt("return");
                            case 6:
                              this._micProducer.close();
                              action = removeProducer(this._micProducer.id);
                              store.dispatch(action);
                              this._eventEmitter.emit(action.type, action.payload);
                              _context58.prev = 7;
                              _context58.next = 8;
                              return this._socketRequest("closeProducer", {
                                producerId: this._micProducer.id
                              });
                            case 8:
                              (_this$_openTelemetry159 = this._openTelemetry) === null || _this$_openTelemetry159 === void 0 || _this$_openTelemetry159.completeSpan({
                                span: internalSpan,
                                status: 1,
                                message: "Requested Server to Close Producer"
                              });
                              (_this$_openTelemetry160 = this._openTelemetry) === null || _this$_openTelemetry160 === void 0 || _this$_openTelemetry160.completeSpan({
                                span: disableMicSpan,
                                status: 1,
                                message: "Mic Disabled Successfully"
                              });
                              _context58.next = 10;
                              break;
                            case 9:
                              _context58.prev = 9;
                              _t52 = _context58["catch"](7);
                              store.dispatch(notify({
                                type: "error",
                                text: "Error closing server-side mic Producer: ".concat(_t52)
                              }));
                              _message5 = "Error in disableMic() :: Failed to close server-side microphone producer. closeProducer status: ".concat(closeProducer);
                              (_this$_openTelemetry161 = this._openTelemetry) === null || _this$_openTelemetry161 === void 0 || _this$_openTelemetry161.completeSpan({
                                span: internalSpan,
                                status: 2,
                                message: "Error in disableMic() :: ".concat(_t52.message)
                              });
                              (_this$_openTelemetry162 = this._openTelemetry) === null || _this$_openTelemetry162 === void 0 || _this$_openTelemetry162.completeSpan({
                                span: disableMicSpan,
                                status: 2,
                                message: _message5
                              });
                              (_this$_videosdkLogs73 = this._videosdkLogs) === null || _this$_videosdkLogs73 === void 0 || _this$_videosdkLogs73.pushLogs({
                                logText: _message5,
                                logType: "ERROR",
                                attributes: {
                                  error: _t52.message
                                },
                                dashboardLog: true
                              });
                            case 10:
                              this._micProducer = null;
                            case 11:
                            case "end":
                              return _context58.stop();
                          }
                        }, _callee58, this, [[2, 4], [7, 9]]);
                      }));
                      function disableMic() {
                        return _disableMic.apply(this, arguments);
                      }
                      return disableMic;
                    }()
                  }, {
                    key: "muteMic",
                    value: function() {
                      var _muteMic = (0, asyncToGenerator.A)(regenerator_default().mark(function _callee59() {
                        var _this$_videosdkLogs74, _t53;
                        return regenerator_default().wrap(function(_context59) {
                          while (1) switch (_context59.prev = _context59.next) {
                            case 0:
                              logger.debug("muteMic()");
                              this._micEnabled = false;
                              this._micProducer.pause();
                              _context59.prev = 1;
                              _context59.next = 2;
                              return this._socketRequest("pauseProducer", {
                                producerId: this._micProducer.id
                              });
                            case 2:
                              store.dispatch(setProducerPaused(this._micProducer.id));
                              _context59.next = 4;
                              break;
                            case 3:
                              _context59.prev = 3;
                              _t53 = _context59["catch"](1);
                              logger.error("muteMic() | failed: %o", _t53);
                              (_this$_videosdkLogs74 = this._videosdkLogs) === null || _this$_videosdkLogs74 === void 0 || _this$_videosdkLogs74.pushLogs({
                                logText: "Error pausing server-side mic Producer",
                                logType: "ERROR",
                                attributes: {
                                  error: _t53.message
                                }
                              });
                              store.dispatch(notify({
                                type: "error",
                                text: "Error pausing server-side mic Producer: ".concat(_t53)
                              }));
                            case 4:
                            case "end":
                              return _context59.stop();
                          }
                        }, _callee59, this, [[1, 3]]);
                      }));
                      function muteMic() {
                        return _muteMic.apply(this, arguments);
                      }
                      return muteMic;
                    }()
                  }, {
                    key: "unmuteMic",
                    value: function() {
                      var _unmuteMic = (0, asyncToGenerator.A)(regenerator_default().mark(function _callee60() {
                        var _this$_videosdkLogs75, _t54;
                        return regenerator_default().wrap(function(_context60) {
                          while (1) switch (_context60.prev = _context60.next) {
                            case 0:
                              logger.debug("unmuteMic()");
                              this._micEnabled = true;
                              this._micProducer.resume();
                              _context60.prev = 1;
                              _context60.next = 2;
                              return this._socketRequest("resumeProducer", {
                                producerId: this._micProducer.id
                              });
                            case 2:
                              store.dispatch(setProducerResumed(this._micProducer.id));
                              _context60.next = 4;
                              break;
                            case 3:
                              _context60.prev = 3;
                              _t54 = _context60["catch"](1);
                              logger.error("unmuteMic() | failed: %o", _t54);
                              (_this$_videosdkLogs75 = this._videosdkLogs) === null || _this$_videosdkLogs75 === void 0 || _this$_videosdkLogs75.pushLogs({
                                logText: "Error resuming server-side mic Producer",
                                logType: "ERROR",
                                attributes: {
                                  error: _t54.message
                                }
                              });
                              store.dispatch(notify({
                                type: "error",
                                text: "Error resuming server-side mic Producer: ".concat(_t54)
                              }));
                            case 4:
                            case "end":
                              return _context60.stop();
                          }
                        }, _callee60, this, [[1, 3]]);
                      }));
                      function unmuteMic() {
                        return _unmuteMic.apply(this, arguments);
                      }
                      return unmuteMic;
                    }()
                  }, {
                    key: "enableWebcam",
                    value: function() {
                      var _enableWebcam = (0, asyncToGenerator.A)(regenerator_default().mark(function _callee61() {
                        var _this$_openTelemetry163, _this$_videosdkLogs84, _this$_openTelemetry173, _this$_videosdkLogs85, _this$_openTelemetry174, _this5 = this;
                        var customVideoTrack, parentSpan, enableWebcamSpan, _this$_openTelemetry164, _this$_videosdkLogs76, _store$getState4, me, _this$_openTelemetry165, _this$_videosdkLogs77, _this$_openTelemetry166, _this$_videosdkLogs78, message, _this$_videosdkLogs79, _this$_openTelemetry167, track, device, resolution, _this$_openTelemetry176, _this$_openTelemetry177, _this$_openTelemetry178, _this$_openTelemetry179, _message6, _this$_videosdkLogs80, sdkError, _this$_videosdkLogs81, _sdkError2, _this$_openTelemetry168, trackSpan, customVideoTrackConfig, _this$_openTelemetry169, _this$_openTelemetry170, _this$_videosdkLogs82, _this$_openTelemetry171, errorMessage, _message7, _this$_videosdkLogs83, _this$_openTelemetry172, _errorMessage3, _message8, notAllowedErrorData, notReadableErrorData, _sdkError3, _errorMessage4, err, _this$_videosdkLogs86, _this$_openTelemetry175, _err2, stream, internalSpan, encodings, codec, codecOptions, _errorMessage5, _errorMessage6, constraints, isRNiOS, firstVideoCodec, appData, _track2, _track3, _this$_videosdkLogs87, _this$_videosdkLogs88, _this$_openTelemetry180, _this$_openTelemetry181, action, reportCounter, probe, _this$_videosdkLogs89, _this$_openTelemetry182, _this$_openTelemetry183, _this$_videosdkLogs90, _this$_openTelemetry184, _args61 = arguments, _t55, _t56, _t57;
                        return regenerator_default().wrap(function(_context61) {
                          while (1) switch (_context61.prev = _context61.next) {
                            case 0:
                              customVideoTrack = _args61.length > 0 && _args61[0] !== void 0 ? _args61[0] : void 0;
                              parentSpan = _args61.length > 1 && _args61[1] !== void 0 ? _args61[1] : void 0;
                              enableWebcamSpan = (_this$_openTelemetry163 = this._openTelemetry) === null || _this$_openTelemetry163 === void 0 ? void 0 : _this$_openTelemetry163.trace({
                                spanName: "enableWebcam() Calling ".concat(!!customVideoTrack ? "With Custom Video Track" : "Without Custom Video Track "),
                                attributes: {
                                  customVideoConfig: customVideoTrack ? JSON.stringify(customVideoTrack) : "Not Specify Custom Track"
                                },
                                span: parentSpan ? parentSpan : null
                              });
                              logger.debug("enableWebcam()");
                              this._webcamEnabled = true;
                              if (!this._webcamProducer) {
                                _context61.next = 1;
                                break;
                              }
                              (_this$_openTelemetry164 = this._openTelemetry) === null || _this$_openTelemetry164 === void 0 || _this$_openTelemetry164.completeSpan({
                                span: enableWebcamSpan,
                                status: 2,
                                message: "Error in enableWebcam() :: Webcam Producer found"
                              });
                              (_this$_videosdkLogs76 = this._videosdkLogs) === null || _this$_videosdkLogs76 === void 0 || _this$_videosdkLogs76.pushLogs({
                                logText: "Attempted to call enableWebcam() multiple times",
                                attributes: {
                                  error: "Error in enableWebcam() :: Webcam is already enabled"
                                },
                                logType: "ERROR",
                                dashboardLog: true
                              });
                              return _context61.abrupt("return");
                            case 1:
                              _store$getState4 = store.getState(), me = _store$getState4.me;
                              if (!me.webcamInProgress) {
                                _context61.next = 2;
                                break;
                              }
                              (_this$_openTelemetry165 = this._openTelemetry) === null || _this$_openTelemetry165 === void 0 || _this$_openTelemetry165.completeSpan({
                                span: enableWebcamSpan,
                                status: 2,
                                message: "Error in enableWebcam(): Webcam enabling process is already in progress."
                              });
                              (_this$_videosdkLogs77 = this._videosdkLogs) === null || _this$_videosdkLogs77 === void 0 || _this$_videosdkLogs77.pushLogs({
                                logText: "Attempted to call enableWebcam() multiple times",
                                attributes: {
                                  error: "Error in enableWebcam(): Webcam enabling process is already in progress."
                                },
                                logType: "ERROR",
                                dashboardLog: true
                              });
                              return _context61.abrupt("return");
                            case 2:
                              if (!this._mediasoupDevice) {
                                _context61.next = 4;
                                break;
                              }
                              if (this._mediasoupDevice.canProduce("video")) {
                                _context61.next = 3;
                                break;
                              }
                              message = this._deviceInfo.sdkType == "react-native" ? errors.q.ERROR_RN_CAMERA_ACCESS_UNAVAILABLE.message : errors.q.ERROR_CAMERA_ACCESS_UNAVAILABLE.message;
                              (_this$_openTelemetry166 = this._openTelemetry) === null || _this$_openTelemetry166 === void 0 || _this$_openTelemetry166.completeSpan({
                                span: enableWebcamSpan,
                                status: 2,
                                message: "Error in enableWebcam() :: ".concat(message)
                              });
                              (_this$_videosdkLogs78 = this._videosdkLogs) === null || _this$_videosdkLogs78 === void 0 || _this$_videosdkLogs78.pushLogs({
                                logText: message,
                                attributes: {
                                  error: "Error in enableWebcam() :: Camera access unavailable"
                                },
                                logType: "ERROR",
                                dashboardLog: true
                              });
                              logger.error("enableWebcam() | cannot produce video");
                              return _context61.abrupt("return");
                            case 3:
                              _context61.next = 5;
                              break;
                            case 4:
                              (_this$_videosdkLogs79 = this._videosdkLogs) === null || _this$_videosdkLogs79 === void 0 || _this$_videosdkLogs79.pushLogs({
                                logText: "Oops! Something went wrong, and we're unable to enable the webcam. Please try again.",
                                logType: "ERROR",
                                attributes: {
                                  error: "Error in enableWebcam(): Something went wrong."
                                }
                              });
                              (_this$_openTelemetry167 = this._openTelemetry) === null || _this$_openTelemetry167 === void 0 || _this$_openTelemetry167.completeSpan({
                                span: enableWebcamSpan,
                                status: 2,
                                message: "Error in enableWebcam() :: mediasoupDevice is undefined"
                              });
                              return _context61.abrupt("return");
                            case 5:
                              store.dispatch(setWebcamInProgress(true));
                              resolution = this._webcam.resolution;
                              _context61.prev = 6;
                              if (this._externalVideo) {
                                _context61.next = 25;
                                break;
                              }
                              _context61.next = 7;
                              return this._updateWebcams(enableWebcamSpan);
                            case 7:
                              device = this._webcam.device;
                              if (device) {
                                _context61.next = 8;
                                break;
                              }
                              _message6 = "Whoops! No Webcam Found: We couldn't find your camera. Is it plugged in and turned on? If so, try restarting your computer or checking your device settings. If you need help, check out troubleshooter at https://test.8x8.vc/. Also, ensure you're on a secure website (https://).";
                              throw new Error(_message6);
                            case 8:
                              logger.debug("enableWebcam() | calling getUserMedia()");
                              try {
                                if (customVideoTrack) {
                                  track = customVideoTrack.getVideoTracks()[0];
                                  if (track.readyState == "ended") {
                                    track = null;
                                    sdkError = errors.q.ERROR_CUSTOM_VIDEO_TRACK_ENDED;
                                    (_this$_videosdkLogs80 = this._videosdkLogs) === null || _this$_videosdkLogs80 === void 0 || _this$_videosdkLogs80.pushLogs({
                                      logText: sdkError.message,
                                      logType: "INFO",
                                      attributes: {
                                        error: "In enableWebcam() :: Invalid Custom Track Passed"
                                      },
                                      dashboardLog: true
                                    });
                                    this._emitError(sdkError);
                                  }
                                }
                              } catch (error) {
                                _sdkError2 = errors.q.ERROR_INVALID_CUSTOM_VIDEO_TRACK;
                                (_this$_videosdkLogs81 = this._videosdkLogs) === null || _this$_videosdkLogs81 === void 0 || _this$_videosdkLogs81.pushLogs({
                                  logText: _sdkError2.message,
                                  logType: "INFO",
                                  attributes: {
                                    error: "In enableWebcam() :: Invalid Custom Track Passed"
                                  }
                                });
                                this._emitError(_sdkError2);
                                console.log("Invalid Custom Video Track Passed. Reverting to default Error: ".concat(error));
                              }
                              if (track) {
                                _context61.next = 24;
                                break;
                              }
                              trackSpan = (_this$_openTelemetry168 = this._openTelemetry) === null || _this$_openTelemetry168 === void 0 ? void 0 : _this$_openTelemetry168.trace({
                                spanName: "Creating Track",
                                span: enableWebcamSpan
                              });
                              customVideoTrackConfig = null;
                              _context61.prev = 9;
                              if (!(this._webcam.resolution == "hd")) {
                                _context61.next = 11;
                                break;
                              }
                              _context61.next = 10;
                              return src.VideoSDK.createCameraVideoTrack({
                                cameraId: device.deviceId,
                                encoderConfig: "h720p_w1280p",
                                multiStream: this._useSimulcast,
                                facingMode: device.facing
                              });
                            case 10:
                              customVideoTrack = _context61.sent;
                              customVideoTrackConfig = JSON.stringify({
                                encoderConfig: "h720p_w1280p",
                                multiStream: this._useSimulcast
                              });
                              _context61.next = 13;
                              break;
                            case 11:
                              _context61.next = 12;
                              return src.VideoSDK.createCameraVideoTrack({
                                cameraId: device.deviceId,
                                encoderConfig: "h540p_w960p",
                                multiStream: this._useSimulcast,
                                facingMode: device.facing
                              });
                            case 12:
                              customVideoTrack = _context61.sent;
                              customVideoTrackConfig = JSON.stringify({
                                encoderConfig: "h540p_w960p",
                                multiStream: this._useSimulcast
                              });
                            case 13:
                              track = customVideoTrack.getVideoTracks()[0];
                              (_this$_openTelemetry169 = this._openTelemetry) === null || _this$_openTelemetry169 === void 0 || _this$_openTelemetry169.completeSpan({
                                message: "Video Track Generated",
                                span: trackSpan,
                                attributes: {
                                  customVideoTrackConfig
                                },
                                status: 1
                              });
                              _context61.next = 24;
                              break;
                            case 14:
                              _context61.prev = 14;
                              _t55 = _context61["catch"](9);
                              (_this$_openTelemetry170 = this._openTelemetry) === null || _this$_openTelemetry170 === void 0 || _this$_openTelemetry170.completeSpan({
                                message: "Error in enableWebcam() :: ".concat(_t55.message),
                                span: trackSpan,
                                status: 2
                              });
                              if (!(_t55.name === "SecurityError")) {
                                _context61.next = 15;
                                break;
                              }
                              errorMessage = errors.q.ERROR_RN_CAMERA_ACCESS_DENIED_OR_DISMISSED;
                              _message7 = errorMessage.message;
                              this._emitError(errorMessage);
                              (_this$_videosdkLogs82 = this._videosdkLogs) === null || _this$_videosdkLogs82 === void 0 || _this$_videosdkLogs82.pushLogs({
                                logText: _message7,
                                logType: "ERROR",
                                attributes: {
                                  error: "Error in enableWebcam() :: Camera Permission Denied or Dismissed"
                                },
                                dashboardLog: true
                              });
                              (_this$_openTelemetry171 = this._openTelemetry) === null || _this$_openTelemetry171 === void 0 || _this$_openTelemetry171.completeSpan({
                                message: "Error in enableWebcam() :: occurred in creating video track, ".concat(_message7),
                                span: enableMicSpan,
                                status: 2
                              });
                              _context61.next = 23;
                              break;
                            case 15:
                              if (!(_t55.name === "DOMException")) {
                                _context61.next = 16;
                                break;
                              }
                              _errorMessage3 = errors.q.ERROR_RN_CAMERA_NOT_FOUND;
                              _message8 = _errorMessage3.message;
                              this._emitError(_errorMessage3);
                              (_this$_videosdkLogs83 = this._videosdkLogs) === null || _this$_videosdkLogs83 === void 0 || _this$_videosdkLogs83.pushLogs({
                                logText: _message8,
                                logType: "ERROR",
                                attributes: {
                                  error: "Error in enableWebcam() :: No Camra Device Found"
                                },
                                dashboardLog: true
                              });
                              (_this$_openTelemetry172 = this._openTelemetry) === null || _this$_openTelemetry172 === void 0 || _this$_openTelemetry172.completeSpan({
                                message: "Error in enableWebcam() :: occurred in creating video track, ".concat(_message8),
                                span: enableMicSpan,
                                status: 2
                              });
                              _context61.next = 23;
                              break;
                            case 16:
                              if (!(_t55 instanceof DOMException)) {
                                _context61.next = 22;
                                break;
                              }
                              _t56 = _t55.name;
                              _context61.next = _t56 === "NotAllowedError" ? 17 : _t56 === "NotReadableError" ? 18 : _t56 === "NotFoundError" ? 19 : 20;
                              break;
                            case 17:
                              notAllowedErrorData = this.handleNotAllowedError(_t55, this._openTelemetry, this._videosdkLogs, enableWebcamSpan, "video");
                              this._emitError(notAllowedErrorData);
                              return _context61.abrupt("continue", 21);
                            case 18:
                              notReadableErrorData = this.handleNotReadableError(_t55, this._openTelemetry, this._videosdkLogs, enableWebcamSpan, "video");
                              this._emitError(notReadableErrorData);
                              return _context61.abrupt("continue", 21);
                            case 19:
                              _sdkError3 = errors.q.ERROR_CAMERA_NOT_FOUND;
                              if (navigator && navigator.userAgent) {
                                if (navigator.userAgent.indexOf("Firefox") != -1) {
                                  _sdkError3 = errors.q.ERROR_CAMERA_PERMISSION_DENIED_BY_OS;
                                }
                              }
                              _errorMessage4 = _sdkError3.message;
                              this._emitError(_sdkError3);
                              (_this$_videosdkLogs84 = this._videosdkLogs) === null || _this$_videosdkLogs84 === void 0 || _this$_videosdkLogs84.pushLogs({
                                logText: _errorMessage4,
                                logType: "ERROR",
                                attributes: {
                                  error: "Error in enableWebcam() :: No Webcam Device Found"
                                },
                                dashboardLog: true
                              });
                              (_this$_openTelemetry173 = this._openTelemetry) === null || _this$_openTelemetry173 === void 0 || _this$_openTelemetry173.completeSpan({
                                message: "Error in enableWebcam() :: occurred in creating video track, ".concat(_errorMessage4),
                                span: enableWebcamSpan,
                                status: 2
                              });
                              return _context61.abrupt("continue", 21);
                            case 20:
                              err = "An error occurred in creating video track, ".concat(_t55.message);
                              (_this$_videosdkLogs85 = this._videosdkLogs) === null || _this$_videosdkLogs85 === void 0 || _this$_videosdkLogs85.pushLogs({
                                logText: _t55.message,
                                logType: "ERROR",
                                attributes: {
                                  error: "Error in enableWebcam() :: ".concat(err)
                                },
                                dashboardLog: true
                              });
                              (_this$_openTelemetry174 = this._openTelemetry) === null || _this$_openTelemetry174 === void 0 || _this$_openTelemetry174.completeSpan({
                                message: "Error in enableWebcam() :: ".concat(err),
                                span: enableWebcamSpan,
                                status: 2
                              });
                              return _context61.abrupt("continue", 21);
                            case 21:
                              _context61.next = 23;
                              break;
                            case 22:
                              _err2 = "An error occurred in creating video track, ".concat(_t55.message);
                              (_this$_videosdkLogs86 = this._videosdkLogs) === null || _this$_videosdkLogs86 === void 0 || _this$_videosdkLogs86.pushLogs({
                                logText: _t55.message,
                                logType: "ERROR",
                                attributes: {
                                  error: "Error in enableWebcam() :: ".concat(_err2)
                                },
                                dashboardLog: true
                              });
                              (_this$_openTelemetry175 = this._openTelemetry) === null || _this$_openTelemetry175 === void 0 || _this$_openTelemetry175.completeSpan({
                                message: "Error in enableWebcam() :: ".concat(_err2),
                                span: enableWebcamSpan,
                                status: 2
                              });
                            case 23:
                              return _context61.abrupt("return");
                            case 24:
                              _context61.next = 27;
                              break;
                            case 25:
                              device = {
                                label: "external video"
                              };
                              _context61.next = 26;
                              return this._getExternalVideoStream();
                            case 26:
                              stream = _context61.sent;
                              track = stream.getVideoTracks()[0].clone();
                            case 27:
                              internalSpan = (_this$_openTelemetry176 = this._openTelemetry) === null || _this$_openTelemetry176 === void 0 ? void 0 : _this$_openTelemetry176.trace({
                                spanName: "Generating Producer Configuration",
                                span: enableWebcamSpan
                              });
                              codecOptions = {
                                videoGoogleStartBitrate: 1e3
                              };
                              if (!this._forceH264) {
                                _context61.next = 29;
                                break;
                              }
                              codec = this._mediasoupDevice.rtpCapabilities.codecs.find(function(c) {
                                return c.mimeType.toLowerCase() === "video/h264";
                              });
                              if (codec) {
                                _context61.next = 28;
                                break;
                              }
                              _errorMessage5 = "The desired H.264 codec and configuration are not supported";
                              throw new Error(_errorMessage5);
                            case 28:
                              _context61.next = 30;
                              break;
                            case 29:
                              if (!this._forceVP9) {
                                _context61.next = 30;
                                break;
                              }
                              codec = this._mediasoupDevice.rtpCapabilities.codecs.find(function(c) {
                                return c.mimeType.toLowerCase() === "video/vp9";
                              });
                              if (codec) {
                                _context61.next = 30;
                                break;
                              }
                              _errorMessage6 = "The desired VP9 codec and configuration are not supported";
                              throw new Error(_errorMessage6);
                            case 30:
                              if (track) {
                                constraints = track.getConstraints();
                                isRNiOS = this._deviceInfo.sdkType == "react-native" && this._deviceInfo.platform == "ios";
                                encodings = (0, sdkCapabilities.v7)(false, constraints.width, constraints.height, customVideoTrack.encoderConfig, {
                                  simulcast: customVideoTrack.multiStream
                                }, isRNiOS);
                              } else {
                                if (this._useSimulcast) {
                                  firstVideoCodec = this._mediasoupDevice.rtpCapabilities.codecs.find(function(c) {
                                    return c.kind === "video";
                                  });
                                  if (this._forceVP9 && codec || firstVideoCodec.mimeType.toLowerCase() === "video/vp9") {
                                    encodings = WEBCAM_KSVC_ENCODINGS;
                                  } else {
                                    encodings = WEBCAM_SIMULCAST_ENCODINGS[this._webcam.resolution];
                                  }
                                }
                              }
                              appData = {};
                              try {
                                appData = {
                                  encodings,
                                  width: customVideoTrack ? (_track2 = track) === null || _track2 === void 0 ? void 0 : _track2.getConstraints().width : VIDEO_CONSTRAINS[resolution].width.ideal,
                                  height: customVideoTrack ? (_track3 = track) === null || _track3 === void 0 ? void 0 : _track3.getConstraints().height : VIDEO_CONSTRAINS[resolution].height.ideal
                                };
                              } catch (error) {
                                (_this$_videosdkLogs87 = this._videosdkLogs) === null || _this$_videosdkLogs87 === void 0 || _this$_videosdkLogs87.pushLogs({
                                  logText: error.message,
                                  logType: "INFO",
                                  attributes: {
                                    error: "In enableWebcam() :: ".concat(error.message)
                                  },
                                  dashboardLog: true
                                });
                                console.log(error);
                              }
                              (_this$_openTelemetry177 = this._openTelemetry) === null || _this$_openTelemetry177 === void 0 || _this$_openTelemetry177.traceAutoComplete({
                                spanName: "Track Generated with height ".concat(appData.height, " and width ").concat(appData.width, " with multiStream ").concat(this._useSimulcast),
                                attributes: {
                                  appData: JSON.stringify(appData)
                                },
                                span: enableWebcamSpan,
                                status: 1
                              });
                              (_this$_openTelemetry178 = this._openTelemetry) === null || _this$_openTelemetry178 === void 0 || _this$_openTelemetry178.completeSpan({
                                span: internalSpan,
                                status: 1,
                                message: "Producer Configuration Generated"
                              });
                              internalSpan = (_this$_openTelemetry179 = this._openTelemetry) === null || _this$_openTelemetry179 === void 0 ? void 0 : _this$_openTelemetry179.trace({
                                spanName: "Creating Webcam Producer",
                                span: enableWebcamSpan
                              });
                              if (!this._sendTransport) {
                                _context61.next = 32;
                                break;
                              }
                              _context61.next = 31;
                              return this._sendTransport.produce({
                                track,
                                encodings,
                                codecOptions,
                                codec,
                                appData: RoomClient_objectSpread(RoomClient_objectSpread({}, appData), {}, {
                                  isEncrypted: this.isE2EEEnabled
                                }),
                                onRtpSender: function onRtpSender(rtpSender) {
                                  if (_this5.e2eeManager) {
                                    rtpSender.senderStreams = rtpSender.createEncodedStreams();
                                  }
                                }
                              });
                            case 31:
                              this._webcamProducer = _context61.sent;
                              if (this.e2eeManager) {
                                this.e2eeManager.emit("NEW_PRODUCER", this._webcamProducer);
                              }
                              _context61.next = 33;
                              break;
                            case 32:
                              (_this$_videosdkLogs88 = this._videosdkLogs) === null || _this$_videosdkLogs88 === void 0 || _this$_videosdkLogs88.pushLogs({
                                logText: errors.q.ERROR_ACTION_PERFORMED_BEFORE_MEETING_JOINED.message,
                                attributes: {
                                  error: "Error in enableWebcam() :: Transport is not setup"
                                },
                                logType: "ERROR",
                                dashboardLog: true
                              });
                              this._emitError(errors.q.ERROR_ACTION_PERFORMED_BEFORE_MEETING_JOINED);
                              return _context61.abrupt("return");
                            case 33:
                              if (track.getSettings().deviceId) {
                                this._webcam.device = this._webcams.get(track.getSettings().deviceId);
                              }
                              if (this._webcamProducer) {
                                action = addProducer({
                                  id: this._webcamProducer.id,
                                  deviceLabel: device.label,
                                  type: this._getWebcamType(device),
                                  paused: this._webcamProducer.paused,
                                  track: this._webcamProducer.track,
                                  rtpParameters: this._webcamProducer.rtpParameters,
                                  codec: this._webcamProducer.rtpParameters.codecs[0].mimeType.split("/")[1],
                                  instance: this._webcamProducer,
                                  rtpSender: this._webcamProducer.rtpSender
                                });
                                store.dispatch(action);
                                this._eventEmitter.emit(action.type, action.payload);
                                reportCounter = 0;
                                probe = this._metrics.addNewProbe(this._webcamProducer, "producer");
                                probe.onStatsCollected = function(report) {
                                  try {
                                    if (!_this5._stats.producerStats) {
                                      _this5._stats.producerStats = {};
                                    }
                                    if (!_this5._stats.producerStats["video"]) {
                                      _this5._stats.producerStats["video"] = [];
                                    }
                                    if (_this5._webcamProducer) {
                                      var _this5$_webcamProduce;
                                      _this5._latestStats[(_this5$_webcamProduce = _this5._webcamProducer) === null || _this5$_webcamProduce === void 0 ? void 0 : _this5$_webcamProduce.id] = [];
                                    }
                                    report["video"].forEach(function(stat) {
                                      var _this5$_webcamProduce2;
                                      _this5._latestStats[(_this5$_webcamProduce2 = _this5._webcamProducer) === null || _this5$_webcamProduce2 === void 0 ? void 0 : _this5$_webcamProduce2.id].push(stat);
                                    });
                                    if (reportCounter % 5 == 0 && _this5._webcamProducer != null) {
                                      _this5._stats["producerStats"]["video"].push({
                                        timestamp: /* @__PURE__ */ new Date(),
                                        stats: _this5._latestStats[_this5._webcamProducer.id]
                                      });
                                    }
                                    reportCounter++;
                                  } catch (error) {
                                    var _this5$_videosdkLogs;
                                    (_this5$_videosdkLogs = _this5._videosdkLogs) === null || _this5$_videosdkLogs === void 0 || _this5$_videosdkLogs.pushLogs({
                                      logText: "Error PRODUCER Stats ERROR",
                                      logType: "ERROR",
                                      attributes: {
                                        error: error.message
                                      }
                                    });
                                  }
                                };
                                probe.start();
                                this._webcamProducer.observer.on("close", function() {
                                  probe.stop();
                                  _this5._metrics.removeExistingProbe(probe);
                                });
                                this._webcamProducer.on("transportclose", function() {
                                  var _this5$_webcamProduce3;
                                  var action2 = removeProducer(_this5._webcamProducer.id);
                                  store.dispatch(action2);
                                  _this5._eventEmitter.emit(action2.type, action2.payload);
                                  (_this5$_webcamProduce3 = _this5._webcamProducer) === null || _this5$_webcamProduce3 === void 0 || _this5$_webcamProduce3.close();
                                  _this5._webcamProducer = null;
                                });
                                this._webcamProducer.on("trackended", function() {
                                  var _this5$_videosdkLogs2, _this5$_openTelemetry;
                                  var error = _this5._deviceInfo.sdkType == "react-native" ? errors.q.ERROR_RN_CAMERA_TRACK_ENDED : errors.q.ERROR_WEBCAM_TRACK_ENDED;
                                  (_this5$_videosdkLogs2 = _this5._videosdkLogs) === null || _this5$_videosdkLogs2 === void 0 || _this5$_videosdkLogs2.pushLogs({
                                    logText: error.message,
                                    logType: "ERROR",
                                    attributes: {
                                      error: "Error in enableWebcam() :: ".concat(error.message)
                                    },
                                    dashboardLog: true
                                  });
                                  (_this5$_openTelemetry = _this5._openTelemetry) === null || _this5$_openTelemetry === void 0 || _this5$_openTelemetry.traceAutoComplete({
                                    spanName: "this._webcamProducer trackended or Webcam disconnected!",
                                    span: enableWebcamSpan,
                                    message: error.message,
                                    status: 2
                                  });
                                  store.dispatch(notify({
                                    type: "error",
                                    text: "Webcam disconnected!"
                                  }));
                                  _this5.disableWebcam(enableWebcamSpan)["catch"](function() {
                                  });
                                });
                                (_this$_openTelemetry180 = this._openTelemetry) === null || _this$_openTelemetry180 === void 0 || _this$_openTelemetry180.completeSpan({
                                  span: internalSpan,
                                  status: 1,
                                  message: "Webcam Producer Created"
                                });
                                (_this$_openTelemetry181 = this._openTelemetry) === null || _this$_openTelemetry181 === void 0 || _this$_openTelemetry181.completeSpan({
                                  span: enableWebcamSpan,
                                  status: 1,
                                  message: "Enable Webcam Successful"
                                });
                              } else {
                                (_this$_videosdkLogs89 = this._videosdkLogs) === null || _this$_videosdkLogs89 === void 0 || _this$_videosdkLogs89.pushLogs({
                                  logText: "Oops! Something went wrong, and we're unable to enable the webcam. Please try again.",
                                  logType: "ERROR",
                                  attributes: {
                                    error: "Error in enableWebcam(): Something went wrong."
                                  },
                                  dashboardLog: true
                                });
                                (_this$_openTelemetry182 = this._openTelemetry) === null || _this$_openTelemetry182 === void 0 || _this$_openTelemetry182.completeSpan({
                                  span: internalSpan,
                                  status: 2,
                                  message: "Error in enableWebcam() :: webcamProducer null"
                                });
                                (_this$_openTelemetry183 = this._openTelemetry) === null || _this$_openTelemetry183 === void 0 || _this$_openTelemetry183.completeSpan({
                                  span: enableWebcamSpan,
                                  status: 2,
                                  message: "Error in enableWebcam() :: webcamProducer null"
                                });
                              }
                              _context61.next = 36;
                              break;
                            case 34:
                              _context61.prev = 34;
                              _t57 = _context61["catch"](6);
                              (_this$_videosdkLogs90 = this._videosdkLogs) === null || _this$_videosdkLogs90 === void 0 || _this$_videosdkLogs90.pushLogs({
                                logText: _t57.message,
                                logType: "ERROR",
                                attributes: {
                                  error: "Error in enableWebcam() :: ".concat(_t57.message)
                                },
                                dashboardLog: true
                              });
                              (_this$_openTelemetry184 = this._openTelemetry) === null || _this$_openTelemetry184 === void 0 || _this$_openTelemetry184.completeSpan({
                                span: enableWebcamSpan,
                                status: 2,
                                message: "Error in enableWebcam() :: ".concat(_t57.message)
                              });
                              store.dispatch(notify({
                                type: "error",
                                text: "Error enabling webcam: ".concat(_t57)
                              }));
                              _context61.next = 35;
                              return this._socketRequest("produceError", {
                                mediaType: "video",
                                message: _t57.message
                              });
                            case 35:
                              if (track) track.stop();
                            case 36:
                              store.dispatch(setWebcamInProgress(false));
                            case 37:
                            case "end":
                              return _context61.stop();
                          }
                        }, _callee61, this, [[6, 34], [9, 14]]);
                      }));
                      function enableWebcam() {
                        return _enableWebcam.apply(this, arguments);
                      }
                      return enableWebcam;
                    }()
                  }, {
                    key: "handleNotAllowedError",
                    value: function handleNotAllowedError(error, openTelemetry, videosdkLogs, parentSpan, mediaType) {
                      var err = {};
                      if (error.message === "Permission denied" || error.message === "Permission dismissed") {
                        err = mediaType === "video" ? errors.q.ERROR_CAMERA_ACCESS_DENIED_OR_DISMISSED : errors.q.ERROR_MICROPHONE_ACCESS_DENIED_OR_DISMISSED;
                      } else if (error.message.includes("The request is not allowed by the user agent")) {
                        err = mediaType === "video" ? errors.q.ERROR_CAMERA_PERMISSION_OR_AUTOPLAY_ISSUE : errors.q.ERROR_MICROPHONE_ACCESS_DENIED_OR_DISMISSED;
                      } else if (error.message === "Permission denied by system") {
                        err = mediaType === "video" ? errors.q.ERROR_CAMERA_PERMISSION_DENIED_BY_OS : errors.q.ERROR_MICROPHONE_PERMISSION_DENIED_BY_OS;
                      } else {
                        err = mediaType === "video" ? errors.q.ERROR_GET_VIDEO_MEDIA_PERMISSION_DENIED : errors.q.ERROR_GET_AUDIO_MEDIA_PERMISSION_DENIED;
                      }
                      videosdkLogs.pushLogs({
                        logText: err.message,
                        logType: "ERROR",
                        attributes: {
                          error: "Error in ".concat(mediaType === "video" ? "enableWebcam()" : "enableMic()", " :: ").concat(error.message)
                        },
                        dashboardLog: true
                      });
                      openTelemetry.completeSpan({
                        message: mediaType === "video" ? "Error in enableWebcam() :: occurred in creating video track, ".concat(err.message) : "Error in enableMic() :: occurred in creating audio track, ".concat(err.message),
                        span: parentSpan,
                        status: 2
                      });
                      return err;
                    }
                  }, {
                    key: "handleNotReadableError",
                    value: function handleNotReadableError(error, openTelemetry, videosdkLogs, parentSpan, mediaType) {
                      var err = {};
                      if (error.message === "Device in use") {
                        err = mediaType === "video" ? errors.q.ERROR_CAMERA_IN_USE : errors.q.ERROR_MICROPHONE_IN_USE;
                      } else {
                        err = mediaType === "video" ? errors.q.ERROR_VIDEO_SOURCE_INITIATION_FAILED : errors.q.ERROR_MICROPHONE_IN_USE;
                      }
                      videosdkLogs.pushLogs({
                        logText: err.message,
                        logType: "ERROR",
                        attributes: {
                          error: "Error in ".concat(mediaType === "video" ? "enableWebcam()" : "enableMic()", " :: ").concat(error.message)
                        },
                        dashboardLog: true
                      });
                      openTelemetry.completeSpan({
                        message: mediaType === "video" ? "Error in enableWebcam() :: occurred in creating video track, ".concat(err.message) : "Error in enableMic() :: occurred in creating audio track, ".concat(err.message),
                        span: parentSpan,
                        status: 2
                      });
                      return err;
                    }
                  }, {
                    key: "disableWebcam",
                    value: function() {
                      var _disableWebcam = (0, asyncToGenerator.A)(regenerator_default().mark(function _callee62() {
                        var _this$_openTelemetry185, _this$_openTelemetry187;
                        var parentSpan, disableWebcamSpan, _this$_openTelemetry186, _this$_videosdkLogs91, internalSpan, action, _this$_openTelemetry188, _this$_openTelemetry189, _this$_videosdkLogs92, _this$_openTelemetry190, _this$_openTelemetry191, _args62 = arguments, _t58;
                        return regenerator_default().wrap(function(_context62) {
                          while (1) switch (_context62.prev = _context62.next) {
                            case 0:
                              parentSpan = _args62.length > 0 && _args62[0] !== void 0 ? _args62[0] : void 0;
                              disableWebcamSpan = (_this$_openTelemetry185 = this._openTelemetry) === null || _this$_openTelemetry185 === void 0 ? void 0 : _this$_openTelemetry185.trace({
                                spanName: "disableWebcam() Calling",
                                status: 1,
                                span: parentSpan ? parentSpan : null
                              });
                              logger.debug("disableWebcam()");
                              this._webcamEnabled = false;
                              if (this._webcamProducer) {
                                _context62.next = 1;
                                break;
                              }
                              (_this$_openTelemetry186 = this._openTelemetry) === null || _this$_openTelemetry186 === void 0 || _this$_openTelemetry186.completeSpan({
                                span: disableWebcamSpan,
                                status: 2,
                                message: "Error in disableWebcam() :: Webcam Producer Not found"
                              });
                              (_this$_videosdkLogs91 = this._videosdkLogs) === null || _this$_videosdkLogs91 === void 0 || _this$_videosdkLogs91.pushLogs({
                                logText: "Attempted to call disableWebcam() multiple times",
                                attributes: {
                                  error: "Error in disableWebcam() :: Webcam is already disabled"
                                },
                                logType: "ERROR",
                                dashboardLog: true
                              });
                              return _context62.abrupt("return");
                            case 1:
                              internalSpan = (_this$_openTelemetry187 = this._openTelemetry) === null || _this$_openTelemetry187 === void 0 ? void 0 : _this$_openTelemetry187.trace({
                                spanName: "Closing Webcam Producer",
                                span: disableWebcamSpan,
                                status: 1
                              });
                              this._webcamProducer.close();
                              action = removeProducer(this._webcamProducer.id);
                              store.dispatch(action);
                              this._eventEmitter.emit(action.type, action.payload);
                              _context62.prev = 2;
                              _context62.next = 3;
                              return this._socketRequest("closeProducer", {
                                producerId: this._webcamProducer.id
                              });
                            case 3:
                              (_this$_openTelemetry188 = this._openTelemetry) === null || _this$_openTelemetry188 === void 0 || _this$_openTelemetry188.completeSpan({
                                span: internalSpan,
                                status: 1,
                                message: "Requested Server to Close Producer"
                              });
                              this._webcamProducer = null;
                              (_this$_openTelemetry189 = this._openTelemetry) === null || _this$_openTelemetry189 === void 0 || _this$_openTelemetry189.completeSpan({
                                span: disableWebcamSpan,
                                status: 1,
                                message: "Webcam Disabled Successfully"
                              });
                              _context62.next = 5;
                              break;
                            case 4:
                              _context62.prev = 4;
                              _t58 = _context62["catch"](2);
                              (_this$_videosdkLogs92 = this._videosdkLogs) === null || _this$_videosdkLogs92 === void 0 || _this$_videosdkLogs92.pushLogs({
                                logText: "Error in disableWebcam() :: Failed to close server-side webcam producer",
                                logType: "ERROR",
                                attributes: {
                                  error: _t58.message
                                },
                                dashboardLog: true
                              });
                              (_this$_openTelemetry190 = this._openTelemetry) === null || _this$_openTelemetry190 === void 0 || _this$_openTelemetry190.completeSpan({
                                span: internalSpan,
                                status: 2,
                                message: "Error in disableWebcam() :: closing server-side webcam Producer: ".concat(_t58)
                              });
                              (_this$_openTelemetry191 = this._openTelemetry) === null || _this$_openTelemetry191 === void 0 || _this$_openTelemetry191.completeSpan({
                                span: disableWebcamSpan,
                                status: 2,
                                message: "Error in disableWebcam() :: closing server-side webcam Producer: ".concat(_t58)
                              });
                              store.dispatch(notify({
                                type: "error",
                                text: "Error closing server-side webcam Producer: ".concat(_t58)
                              }));
                            case 5:
                            case "end":
                              return _context62.stop();
                          }
                        }, _callee62, this, [[2, 4]]);
                      }));
                      function disableWebcam() {
                        return _disableWebcam.apply(this, arguments);
                      }
                      return disableWebcam;
                    }()
                    /**
                     *
                     * @returns {Array<{deviceId: string, label: string}>}
                     */
                  }, {
                    key: "getMics",
                    value: function() {
                      var _getMics = (0, asyncToGenerator.A)(regenerator_default().mark(function _callee63() {
                        var micArr, _this$_videosdkLogs93, _t59;
                        return regenerator_default().wrap(function(_context63) {
                          while (1) switch (_context63.prev = _context63.next) {
                            case 0:
                              micArr = [];
                              _context63.prev = 1;
                              _context63.next = 2;
                              return this._updateMics();
                            case 2:
                              this._mics.forEach(function(value2, key) {
                                micArr.push({
                                  deviceId: key,
                                  label: value2.label
                                });
                              });
                              _context63.next = 4;
                              break;
                            case 3:
                              _context63.prev = 3;
                              _t59 = _context63["catch"](1);
                              logger.error("getMics() | Error", _t59);
                              (_this$_videosdkLogs93 = this._videosdkLogs) === null || _this$_videosdkLogs93 === void 0 || _this$_videosdkLogs93.pushLogs({
                                logText: _t59.message,
                                logType: "ERROR",
                                attributes: {
                                  error: "Error in getMics() :: Not able to get Mic List"
                                },
                                dashboardLog: true
                              });
                            case 4:
                              return _context63.abrupt("return", micArr);
                            case 5:
                            case "end":
                              return _context63.stop();
                          }
                        }, _callee63, this, [[1, 3]]);
                      }));
                      function getMics() {
                        return _getMics.apply(this, arguments);
                      }
                      return getMics;
                    }()
                  }, {
                    key: "changeMic",
                    value: function() {
                      var _changeMic = (0, asyncToGenerator.A)(regenerator_default().mark(function _callee64(object) {
                        var _this$_openTelemetry192;
                        var changeMicSpan, _this$_openTelemetry193, _this$_openTelemetry194, _this$_openTelemetry195, micId, array, len, deviceId, idx, internalSpan, _this$_videosdkLogs94, _this$_openTelemetry196, _this$_videosdkLogs95, _t60;
                        return regenerator_default().wrap(function(_context64) {
                          while (1) switch (_context64.prev = _context64.next) {
                            case 0:
                              changeMicSpan = (_this$_openTelemetry192 = this._openTelemetry) === null || _this$_openTelemetry192 === void 0 ? void 0 : _this$_openTelemetry192.trace({
                                spanName: "changeMic() Calling"
                              });
                              _context64.prev = 1;
                              if (!((0, esm_typeof.A)(object) == "object")) {
                                _context64.next = 4;
                                break;
                              }
                              _context64.next = 2;
                              return this.disableMic(true, changeMicSpan);
                            case 2:
                              _context64.next = 3;
                              return this.enableMic(object, changeMicSpan);
                            case 3:
                              _context64.next = 9;
                              break;
                            case 4:
                              micId = object;
                              _context64.next = 5;
                              return this._updateMics();
                            case 5:
                              array = Array.from(this._mics.keys());
                              len = array.length;
                              deviceId = this._mic.device ? this._mic.device.deviceId : void 0;
                              if (micId != void 0 && micId != null) {
                                idx = array.indexOf(micId);
                              } else {
                                idx = array.indexOf(deviceId);
                                if (idx < len - 1) idx++;
                                else idx = 0;
                              }
                              this._mic.device = this._mics.get(array[idx]);
                              internalSpan = (_this$_openTelemetry193 = this._openTelemetry) === null || _this$_openTelemetry193 === void 0 ? void 0 : _this$_openTelemetry193.trace({
                                spanName: "Getting Selected Mic",
                                span: changeMicSpan,
                                attributes: {
                                  selectedWebcam: this._mic.device ? JSON.stringify(this._mic.device) : "No Mic devices"
                                }
                              });
                              if (this._mic.device) {
                                _context64.next = 6;
                                break;
                              }
                              (_this$_videosdkLogs94 = this._videosdkLogs) === null || _this$_videosdkLogs94 === void 0 || _this$_videosdkLogs94.pushLogs({
                                logText: "Error changeMic : No mic Found",
                                logType: "ERROR"
                              });
                              throw new Error("No mic Found");
                            case 6:
                              _context64.next = 7;
                              return this.disableMic(true, changeMicSpan);
                            case 7:
                              _context64.next = 8;
                              return this.enableMic(void 0, changeMicSpan);
                            case 8:
                              (_this$_openTelemetry194 = this._openTelemetry) === null || _this$_openTelemetry194 === void 0 || _this$_openTelemetry194.completeSpan({
                                span: internalSpan,
                                status: 1,
                                message: "Done"
                              });
                              (_this$_openTelemetry195 = this._openTelemetry) === null || _this$_openTelemetry195 === void 0 || _this$_openTelemetry195.completeSpan({
                                span: changeMicSpan,
                                status: 1,
                                message: "changeMic() Ending"
                              });
                            case 9:
                              _context64.next = 11;
                              break;
                            case 10:
                              _context64.prev = 10;
                              _t60 = _context64["catch"](1);
                              (_this$_openTelemetry196 = this._openTelemetry) === null || _this$_openTelemetry196 === void 0 || _this$_openTelemetry196.completeSpan({
                                span: changeMicSpan,
                                status: 2,
                                message: "changeMic() | Error ".concat(_t60)
                              });
                              (_this$_videosdkLogs95 = this._videosdkLogs) === null || _this$_videosdkLogs95 === void 0 || _this$_videosdkLogs95.pushLogs({
                                logText: "Error changeMic() | Error",
                                logType: "ERROR",
                                attributes: {
                                  error: _t60.message
                                }
                              });
                            case 11:
                            case "end":
                              return _context64.stop();
                          }
                        }, _callee64, this, [[1, 10]]);
                      }));
                      function changeMic(_x64) {
                        return _changeMic.apply(this, arguments);
                      }
                      return changeMic;
                    }()
                    /**
                     *
                     * @returns {Array<{deviceId: string, label: string, facingMode: "environment" | "front"}>}
                     */
                  }, {
                    key: "getWebcams",
                    value: function() {
                      var _getWebcams = (0, asyncToGenerator.A)(regenerator_default().mark(function _callee65() {
                        var webcamArr, _this$_videosdkLogs96, _t61;
                        return regenerator_default().wrap(function(_context65) {
                          while (1) switch (_context65.prev = _context65.next) {
                            case 0:
                              webcamArr = [];
                              _context65.prev = 1;
                              _context65.next = 2;
                              return this._updateWebcams();
                            case 2:
                              this._webcams.forEach(function(value2, key) {
                                webcamArr.push({
                                  deviceId: key,
                                  label: value2.label,
                                  facingMode: value2.facing || "environment"
                                });
                              });
                              _context65.next = 4;
                              break;
                            case 3:
                              _context65.prev = 3;
                              _t61 = _context65["catch"](1);
                              logger.error("getWebcams() | failed %o", _t61);
                              (_this$_videosdkLogs96 = this._videosdkLogs) === null || _this$_videosdkLogs96 === void 0 || _this$_videosdkLogs96.pushLogs({
                                logText: _t61.message,
                                logType: "ERROR",
                                attributes: {
                                  error: "Error in getWebcams() :: Not able to get Webcam List"
                                },
                                dashboardLog: true
                              });
                            case 4:
                              return _context65.abrupt("return", webcamArr);
                            case 5:
                            case "end":
                              return _context65.stop();
                          }
                        }, _callee65, this, [[1, 3]]);
                      }));
                      function getWebcams() {
                        return _getWebcams.apply(this, arguments);
                      }
                      return getWebcams;
                    }()
                  }, {
                    key: "replaceWebcamStream",
                    value: function() {
                      var _replaceWebcamStream = (0, asyncToGenerator.A)(regenerator_default().mark(function _callee66(stream) {
                        var track;
                        return regenerator_default().wrap(function(_context66) {
                          while (1) switch (_context66.prev = _context66.next) {
                            case 0:
                              if (!this._webcamProducer) {
                                _context66.next = 2;
                                break;
                              }
                              track = stream.getVideoTracks()[0];
                              _context66.next = 1;
                              return this._webcamProducer.replaceTrack({
                                track
                              });
                            case 1:
                              this._eventEmitter.emit("UPDATE_PRODUCER", {
                                producer: this._webcamProducer
                              });
                              _context66.next = 4;
                              break;
                            case 2:
                              _context66.next = 3;
                              return this.disableWebcam();
                            case 3:
                              _context66.next = 4;
                              return this.enableWebcam(stream);
                            case 4:
                            case "end":
                              return _context66.stop();
                          }
                        }, _callee66, this);
                      }));
                      function replaceWebcamStream(_x65) {
                        return _replaceWebcamStream.apply(this, arguments);
                      }
                      return replaceWebcamStream;
                    }()
                    // @type of object = string means webcamId is passed
                    // @type of object = object means customTrack is passed
                  }, {
                    key: "changeWebcam",
                    value: function() {
                      var _changeWebcam = (0, asyncToGenerator.A)(regenerator_default().mark(function _callee67(object) {
                        var _this$_openTelemetry197;
                        var changeWebcamSpan, _this$_videosdkLogs97, _this$_openTelemetry198, _this$_openTelemetry199, _this$_openTelemetry200, array, len, deviceId, idx, internalSpan, _this$_videosdkLogs98, _this$_videosdkLogs99, _this$_openTelemetry201, _t62, _t63;
                        return regenerator_default().wrap(function(_context67) {
                          while (1) switch (_context67.prev = _context67.next) {
                            case 0:
                              changeWebcamSpan = (_this$_openTelemetry197 = this._openTelemetry) === null || _this$_openTelemetry197 === void 0 ? void 0 : _this$_openTelemetry197.trace({
                                spanName: "changeWebcam() Calling"
                              });
                              if (!((0, esm_typeof.A)(object) === "object")) {
                                _context67.next = 6;
                                break;
                              }
                              _context67.prev = 1;
                              _context67.next = 2;
                              return this.disableWebcam(changeWebcamSpan);
                            case 2:
                              _context67.next = 3;
                              return this.enableWebcam(object, changeWebcamSpan);
                            case 3:
                              _context67.next = 5;
                              break;
                            case 4:
                              _context67.prev = 4;
                              _t62 = _context67["catch"](1);
                              logger.error("changeWebcam() | failed: %o", _t62);
                              (_this$_videosdkLogs97 = this._videosdkLogs) === null || _this$_videosdkLogs97 === void 0 || _this$_videosdkLogs97.pushLogs({
                                logText: "Error Could not change webcam",
                                logType: "ERROR",
                                attributes: {
                                  object: JSON.stringify(object),
                                  error: _t62.message
                                }
                              });
                              store.dispatch(notify({
                                type: "error",
                                text: "Could not change webcam: ".concat(_t62)
                              }));
                            case 5:
                              _context67.next = 12;
                              break;
                            case 6:
                              _context67.prev = 6;
                              _context67.next = 7;
                              return this._updateWebcams(changeWebcamSpan);
                            case 7:
                              array = Array.from(this._webcams.keys());
                              len = array.length;
                              deviceId = this._webcam.device ? this._webcam.device.deviceId : void 0;
                              if (object != null && object != void 0) {
                                idx = array.indexOf(object);
                              } else {
                                idx = array.indexOf(deviceId);
                                if (idx < len - 1) idx++;
                                else idx = 0;
                              }
                              this._webcam.device = this._webcams.get(array[idx]);
                              logger.debug("changeWebcam() | new selected webcam [device:%o]", this._webcam.device);
                              this._webcam.resolution = this._webcam.resolution || "hd";
                              internalSpan = (_this$_openTelemetry198 = this._openTelemetry) === null || _this$_openTelemetry198 === void 0 ? void 0 : _this$_openTelemetry198.trace({
                                spanName: "Getting Selected Webcam",
                                span: changeWebcamSpan,
                                attributes: {
                                  selectedWebcam: this._webcam.device ? JSON.stringify(this._webcam.device) : "No webcam devices"
                                }
                              });
                              if (this._webcam.device) {
                                _context67.next = 8;
                                break;
                              }
                              (_this$_videosdkLogs98 = this._videosdkLogs) === null || _this$_videosdkLogs98 === void 0 || _this$_videosdkLogs98.pushLogs({
                                logText: "Error changeWebcam : No webcam Found",
                                logType: "ERROR"
                              });
                              throw new Error("no webcam devices");
                            case 8:
                              _context67.next = 9;
                              return this.disableWebcam(changeWebcamSpan);
                            case 9:
                              _context67.next = 10;
                              return this.enableWebcam(void 0, changeWebcamSpan);
                            case 10:
                              (_this$_openTelemetry199 = this._openTelemetry) === null || _this$_openTelemetry199 === void 0 || _this$_openTelemetry199.completeSpan({
                                span: internalSpan,
                                status: 1,
                                message: "Done"
                              });
                              (_this$_openTelemetry200 = this._openTelemetry) === null || _this$_openTelemetry200 === void 0 || _this$_openTelemetry200.completeSpan({
                                span: changeWebcamSpan,
                                status: 1,
                                message: "changeWebcam() Ending"
                              });
                              return _context67.abrupt("return");
                            case 11:
                              _context67.prev = 11;
                              _t63 = _context67["catch"](6);
                              logger.error("changeWebcam() | failed: %o", _t63);
                              (_this$_videosdkLogs99 = this._videosdkLogs) === null || _this$_videosdkLogs99 === void 0 || _this$_videosdkLogs99.pushLogs({
                                logText: "Error Could not change webcam",
                                logType: "ERROR",
                                attributes: {
                                  object: JSON.stringify(object),
                                  error: _t63.message
                                }
                              });
                              (_this$_openTelemetry201 = this._openTelemetry) === null || _this$_openTelemetry201 === void 0 || _this$_openTelemetry201.completeSpan({
                                span: changeWebcamSpan,
                                status: 2,
                                message: "Could not change webcam ".concat(_t63)
                              });
                              store.dispatch(notify({
                                type: "error",
                                text: "Could not change webcam: ".concat(_t63)
                              }));
                            case 12:
                            case "end":
                              return _context67.stop();
                          }
                        }, _callee67, this, [[1, 4], [6, 11]]);
                      }));
                      function changeWebcam(_x66) {
                        return _changeWebcam.apply(this, arguments);
                      }
                      return changeWebcam;
                    }()
                  }, {
                    key: "changeWebcamResolution",
                    value: function() {
                      var _changeWebcamResolution = (0, asyncToGenerator.A)(regenerator_default().mark(function _callee68() {
                        var stream, _this$_videosdkLogs100, track, _this$_videosdkLogs101, _t64, _t65, _t66;
                        return regenerator_default().wrap(function(_context68) {
                          while (1) switch (_context68.prev = _context68.next) {
                            case 0:
                              logger.debug("changeWebcamResolution()");
                              _context68.prev = 1;
                              _t64 = this._webcam.resolution;
                              _context68.next = _t64 === "qvga" ? 2 : _t64 === "vga" ? 3 : _t64 === "hd" ? 4 : 5;
                              break;
                            case 2:
                              this._webcam.resolution = "vga";
                              return _context68.abrupt("continue", 6);
                            case 3:
                              this._webcam.resolution = "hd";
                              return _context68.abrupt("continue", 6);
                            case 4:
                              this._webcam.resolution = "qvga";
                              return _context68.abrupt("continue", 6);
                            case 5:
                              this._webcam.resolution = "hd";
                            case 6:
                              logger.debug("changeWebcamResolution() | calling getUserMedia()");
                              _context68.prev = 7;
                              _context68.next = 8;
                              return navigator.mediaDevices.getUserMedia({
                                video: RoomClient_objectSpread({
                                  deviceId: {
                                    exact: this._webcam.device.deviceId
                                  }
                                }, VIDEO_CONSTRAINS[this._webcam.resolution])
                              });
                            case 8:
                              stream = _context68.sent;
                              _context68.next = 10;
                              break;
                            case 9:
                              _context68.prev = 9;
                              _t65 = _context68["catch"](7);
                              (_this$_videosdkLogs100 = this._videosdkLogs) === null || _this$_videosdkLogs100 === void 0 || _this$_videosdkLogs100.pushLogs({
                                logText: "Error in getUserMedia for changeWebcamResolution",
                                logType: "ERROR",
                                attributes: {
                                  error: JSON.stringify(_t65)
                                }
                              });
                              if (_t65.message === "Permission denied" || _t65.name === "NotAllowedError") {
                                this._emitError(errors.q.ERROR_GET_VIDEO_MEDIA_PERMISSION_DENIED);
                              } else {
                                this._emitError(errors.q.ERROR_GET_VIDEO_MEDIA);
                              }
                              return _context68.abrupt("return");
                            case 10:
                              track = stream.getVideoTracks()[0];
                              _context68.next = 11;
                              return this._webcamProducer.replaceTrack({
                                track
                              });
                            case 11:
                              store.dispatch(setProducerTrack(this._webcamProducer.id, track));
                              _context68.next = 13;
                              break;
                            case 12:
                              _context68.prev = 12;
                              _t66 = _context68["catch"](1);
                              logger.error("changeWebcamResolution() | failed: %o", _t66);
                              (_this$_videosdkLogs101 = this._videosdkLogs) === null || _this$_videosdkLogs101 === void 0 || _this$_videosdkLogs101.pushLogs({
                                logText: "Error Could not change webcam resolution",
                                logType: "ERROR",
                                attributes: {
                                  error: _t66.message
                                }
                              });
                              store.dispatch(notify({
                                type: "error",
                                text: "Could not change webcam resolution: ".concat(_t66)
                              }));
                            case 13:
                            case "end":
                              return _context68.stop();
                          }
                        }, _callee68, this, [[1, 12], [7, 9]]);
                      }));
                      function changeWebcamResolution() {
                        return _changeWebcamResolution.apply(this, arguments);
                      }
                      return changeWebcamResolution;
                    }()
                  }, {
                    key: "enableShare",
                    value: function() {
                      var _enableShare = (0, asyncToGenerator.A)(regenerator_default().mark(function _callee69() {
                        var _this$_openTelemetry202, _this6 = this;
                        var customScreenSharingTrack, enableShareSpan, _this$_openTelemetry203, _this$_openTelemetry204, videoTrack, audioTrack, encodings, _this$_openTelemetry205, _this$_openTelemetry209, _this$_openTelemetry210, _this$_openTelemetry211, _this$_openTelemetry212, _this$_openTelemetry215, trackSpan, _videoTrack$getConstr, height, frameRate, screenShareProfilesData, simulcastEncodings, _this$_openTelemetry208, stream, _this$_videosdkLogs102, _this$_openTelemetry206, _this$_openTelemetry207, internalSpan, codec, codecOptions, _this$_videosdkLogs103, _this$_videosdkLogs104, action, _this$_openTelemetry213, _this$_openTelemetry214, audioCodecOptions, _action8, _this$_videosdkLogs105, _this$_openTelemetry216, _this$_videosdkLogs106, reportCounter, probe, _reportCounter, _probe2, _args69 = arguments, _t67, _t68, _t69;
                        return regenerator_default().wrap(function(_context69) {
                          while (1) switch (_context69.prev = _context69.next) {
                            case 0:
                              customScreenSharingTrack = _args69.length > 0 && _args69[0] !== void 0 ? _args69[0] : void 0;
                              enableShareSpan = (_this$_openTelemetry202 = this._openTelemetry) === null || _this$_openTelemetry202 === void 0 ? void 0 : _this$_openTelemetry202.trace({
                                spanName: "enableShare() Calling ".concat(!!customScreenSharingTrack ? "With Custom Video Track" : "Without Custom Video Track "),
                                attributes: {
                                  customShareConfig: customScreenSharingTrack ? JSON.stringify(customScreenSharingTrack) : "Not Specify Custom Track"
                                }
                              });
                              logger.debug("enableShare()");
                              if (!this._shareProducer) {
                                _context69.next = 1;
                                break;
                              }
                              (_this$_openTelemetry203 = this._openTelemetry) === null || _this$_openTelemetry203 === void 0 || _this$_openTelemetry203.completeSpan({
                                span: enableShareSpan,
                                status: 2,
                                message: "Screen Share Producer found"
                              });
                              return _context69.abrupt("return");
                            case 1:
                              if (this._mediasoupDevice.canProduce("video")) {
                                _context69.next = 2;
                                break;
                              }
                              (_this$_openTelemetry204 = this._openTelemetry) === null || _this$_openTelemetry204 === void 0 || _this$_openTelemetry204.completeSpan({
                                span: enableShareSpan,
                                status: 2,
                                message: "enableShare() | cannot produce video"
                              });
                              logger.error("enableShare() | cannot produce video");
                              return _context69.abrupt("return");
                            case 2:
                              encodings = [];
                              store.dispatch(setShareInProgress(true));
                              _context69.prev = 3;
                              logger.debug("enableShare() | calling getUserMedia()");
                              trackSpan = (_this$_openTelemetry205 = this._openTelemetry) === null || _this$_openTelemetry205 === void 0 ? void 0 : _this$_openTelemetry205.trace({
                                spanName: "Creating Track",
                                span: enableShareSpan
                              });
                              if (!(customScreenSharingTrack && customScreenSharingTrack.active)) {
                                _context69.next = 4;
                                break;
                              }
                              videoTrack = customScreenSharingTrack.getVideoTracks()[0];
                              audioTrack = customScreenSharingTrack.getAudioTracks()[0];
                              if (customScreenSharingTrack.multiStream) {
                                _videoTrack$getConstr = videoTrack.getConstraints(), height = _videoTrack$getConstr.height, frameRate = _videoTrack$getConstr.frameRate;
                                screenShareProfilesData = config2.$.screenShareProfiles["h".concat(height, "p_").concat(frameRate, "fps")];
                                simulcastEncodings = [{
                                  maxBitrate: screenShareProfilesData.bitrates.high,
                                  maxFramerate: frameRate,
                                  scalabilityMode: "S3T3",
                                  dtx: true
                                }, {
                                  maxBitrate: screenShareProfilesData.bitrates.medium,
                                  maxFramerate: frameRate,
                                  scalabilityMode: "S2T3",
                                  dtx: true
                                }, {
                                  maxBitrate: screenShareProfilesData.bitrates.low,
                                  maxFramerate: frameRate,
                                  scalabilityMode: "S1T3",
                                  dtx: true
                                }];
                                encodings = simulcastEncodings;
                              } else {
                                encodings = SCREEN_SHARING_SIMULCAST_ENCODINGS;
                              }
                              _context69.next = 9;
                              break;
                            case 4:
                              _context69.prev = 4;
                              _context69.next = 5;
                              return navigator.mediaDevices.getDisplayMedia({
                                audio: true,
                                video: {
                                  width: {
                                    max: 1920
                                  },
                                  height: {
                                    max: 1080
                                  },
                                  frameRate: {
                                    max: 10
                                  }
                                }
                              });
                            case 5:
                              stream = _context69.sent;
                              _context69.next = 7;
                              break;
                            case 6:
                              _context69.prev = 6;
                              _t67 = _context69["catch"](4);
                              (_this$_videosdkLogs102 = this._videosdkLogs) === null || _this$_videosdkLogs102 === void 0 || _this$_videosdkLogs102.pushLogs({
                                logText: "Error in getDisplayMedia for screen share",
                                logType: "ERROR",
                                attributes: {
                                  error: JSON.stringify(_t67)
                                }
                              });
                              (_this$_openTelemetry206 = this._openTelemetry) === null || _this$_openTelemetry206 === void 0 || _this$_openTelemetry206.completeSpan({
                                span: enableShareSpan,
                                status: 2,
                                message: "Error in getDisplayMedia for screen share ".concat(_t67)
                              });
                              if (_t67.message === "Permission denied" || _t67.name === "NotAllowedError") {
                                this._emitError(errors.q.ERROR_GET_DISPLAY_MEDIA_PERMISSION_DENIED);
                              } else {
                                this._emitError(errors.q.ERROR_GET_DISPLAY_MEDIA);
                              }
                              return _context69.abrupt("return");
                            case 7:
                              if (stream) {
                                _context69.next = 8;
                                break;
                              }
                              store.dispatch(setShareInProgress(true));
                              (_this$_openTelemetry207 = this._openTelemetry) === null || _this$_openTelemetry207 === void 0 || _this$_openTelemetry207.completeSpan({
                                span: enableShareSpan,
                                status: 2,
                                message: "Stream not found"
                              });
                              return _context69.abrupt("return");
                            case 8:
                              videoTrack = stream.getVideoTracks()[0];
                              audioTrack = stream.getAudioTracks()[0];
                              encodings = SCREEN_SHARING_SIMULCAST_ENCODINGS;
                              (_this$_openTelemetry208 = this._openTelemetry) === null || _this$_openTelemetry208 === void 0 || _this$_openTelemetry208.completeSpan({
                                message: "Track Generated with height ".concat(videoTrack.getSettings().height, " and width ").concat(videoTrack.getSettings().width),
                                span: trackSpan,
                                status: 1
                              });
                            case 9:
                              internalSpan = (_this$_openTelemetry209 = this._openTelemetry) === null || _this$_openTelemetry209 === void 0 ? void 0 : _this$_openTelemetry209.trace({
                                spanName: "Generating Producer Configuration",
                                span: enableShareSpan
                              });
                              codecOptions = {
                                videoGoogleStartBitrate: 1e3
                              };
                              if (!this._forceH264) {
                                _context69.next = 11;
                                break;
                              }
                              codec = this._mediasoupDevice.rtpCapabilities.codecs.find(function(c) {
                                return c.mimeType.toLowerCase() === "video/h264";
                              });
                              if (codec) {
                                _context69.next = 10;
                                break;
                              }
                              (_this$_videosdkLogs103 = this._videosdkLogs) === null || _this$_videosdkLogs103 === void 0 || _this$_videosdkLogs103.pushLogs({
                                logText: "Error EnableShare : desired H264 codec+configuration is not supported",
                                logType: "ERROR"
                              });
                              throw new Error("desired H264 codec+configuration is not supported");
                            case 10:
                              _context69.next = 12;
                              break;
                            case 11:
                              if (!this._forceVP9) {
                                _context69.next = 12;
                                break;
                              }
                              codec = this._mediasoupDevice.rtpCapabilities.codecs.find(function(c) {
                                return c.mimeType.toLowerCase() === "video/vp9";
                              });
                              if (codec) {
                                _context69.next = 12;
                                break;
                              }
                              (_this$_videosdkLogs104 = this._videosdkLogs) === null || _this$_videosdkLogs104 === void 0 || _this$_videosdkLogs104.pushLogs({
                                logText: "Error EnableShare :desired VP9 codec+configuration is not supported",
                                logType: "ERROR"
                              });
                              throw new Error("desired VP9 codec+configuration is not supported");
                            case 12:
                              (_this$_openTelemetry210 = this._openTelemetry) === null || _this$_openTelemetry210 === void 0 || _this$_openTelemetry210.completeSpan({
                                span: internalSpan,
                                status: 1,
                                message: "Producer Configuration Generated"
                              });
                              internalSpan = (_this$_openTelemetry211 = this._openTelemetry) === null || _this$_openTelemetry211 === void 0 ? void 0 : _this$_openTelemetry211.trace({
                                spanName: "Creating Share Producer",
                                span: enableShareSpan
                              });
                              _context69.next = 13;
                              return this._sendTransport.produce({
                                track: videoTrack,
                                encodings: encodings.length > 0 ? encodings : SCREEN_SHARING_SIMULCAST_ENCODINGS,
                                codecOptions,
                                codec,
                                appData: {
                                  share: true,
                                  isEncrypted: this.isE2EEEnabled
                                },
                                onRtpSender: function onRtpSender(rtpSender) {
                                  if (_this6.e2eeManager) {
                                    rtpSender.senderStreams = rtpSender.createEncodedStreams();
                                  }
                                }
                              });
                            case 13:
                              this._shareProducer = _context69.sent;
                              if (this.e2eeManager) {
                                this.e2eeManager.emit("NEW_PRODUCER", this._shareProducer);
                              }
                              action = addProducer({
                                id: this._shareProducer.id,
                                type: "share",
                                paused: this._shareProducer.paused,
                                track: this._shareProducer.track,
                                rtpParameters: this._shareProducer.rtpParameters,
                                codec: this._shareProducer.rtpParameters.codecs[0].mimeType.split("/")[1],
                                appData: {
                                  share: true,
                                  isEncrypted: this.isE2EEEnabled
                                },
                                instance: this._shareProducer,
                                rtpSender: this._shareProducer.rtpSender
                              });
                              store.dispatch(action);
                              this._eventEmitter.emit(action.type, action.payload);
                              this._shareProducer.on("transportclose", function() {
                                var _this6$_shareProducer;
                                var action2 = removeProducer(_this6._shareProducer.id);
                                store.dispatch(action2);
                                _this6._eventEmitter.emit(action2.type, action2.payload);
                                (_this6$_shareProducer = _this6._shareProducer) === null || _this6$_shareProducer === void 0 || _this6$_shareProducer.close();
                                _this6._shareProducer = null;
                              });
                              this._shareProducer.on("trackended", function() {
                                var _this6$_openTelemetry;
                                (_this6$_openTelemetry = _this6._openTelemetry) === null || _this6$_openTelemetry === void 0 || _this6$_openTelemetry.traceAutoComplete({
                                  spanName: "this._shareProducer trackended or Share disconnected!",
                                  span: enableShareSpan,
                                  status: 2
                                });
                                store.dispatch(notify({
                                  type: "error",
                                  text: "Share disconnected!"
                                }));
                                _this6.disableShare()["catch"](function() {
                                });
                              });
                              (_this$_openTelemetry212 = this._openTelemetry) === null || _this$_openTelemetry212 === void 0 || _this$_openTelemetry212.completeSpan({
                                span: internalSpan,
                                status: 1,
                                message: "Share Producer Created"
                              });
                              if (!audioTrack) {
                                _context69.next = 18;
                                break;
                              }
                              _context69.prev = 14;
                              audioCodecOptions = {
                                opusStereo: 1,
                                opusDtx: 1
                              };
                              internalSpan = (_this$_openTelemetry213 = this._openTelemetry) === null || _this$_openTelemetry213 === void 0 ? void 0 : _this$_openTelemetry213.trace({
                                spanName: "Creating Share Audio Producer",
                                span: enableShareSpan
                              });
                              _context69.next = 15;
                              return this._sendTransport.produce({
                                track: audioTrack,
                                codecOptions: audioCodecOptions,
                                appData: {
                                  share: true,
                                  isEncrypted: this.isE2EEEnabled
                                },
                                onRtpSender: function onRtpSender(rtpSender) {
                                  if (_this6.e2eeManager) {
                                    rtpSender.senderStreams = rtpSender.createEncodedStreams();
                                  }
                                }
                              });
                            case 15:
                              this._shareAudioProducer = _context69.sent;
                              _action8 = addProducer({
                                id: this._shareAudioProducer.id,
                                type: "share",
                                paused: this._shareAudioProducer.paused,
                                track: this._shareAudioProducer.track,
                                rtpParameters: this._shareAudioProducer.rtpParameters,
                                codec: this._shareAudioProducer.rtpParameters.codecs[0].mimeType.split("/")[1],
                                appData: {
                                  share: true,
                                  isEncrypted: this.isE2EEEnabled
                                },
                                instance: this._shareAudioProducer,
                                rtpSender: this._shareAudioProducer.rtpSender
                              });
                              store.dispatch(_action8);
                              if (this.e2eeManager) {
                                this.e2eeManager.emit("NEW_PRODUCER", this._shareAudioProducer);
                              }
                              this._eventEmitter.emit(_action8.type, _action8.payload);
                              this._shareAudioProducer.on("transportclose", function() {
                                var _this6$_shareAudioPro;
                                var action2 = removeProducer(_this6._shareAudioProducer.id);
                                store.dispatch(action2);
                                _this6._eventEmitter.emit(action2.type, action2.payload);
                                (_this6$_shareAudioPro = _this6._shareAudioProducer) === null || _this6$_shareAudioPro === void 0 || _this6$_shareAudioPro.close();
                                _this6._shareAudioProducer = null;
                              });
                              this._shareAudioProducer.on("trackended", function() {
                                var _this6$_openTelemetry2;
                                (_this6$_openTelemetry2 = _this6._openTelemetry) === null || _this6$_openTelemetry2 === void 0 || _this6$_openTelemetry2.traceAutoComplete({
                                  spanName: "this._shareAudioProducer trackended",
                                  span: enableShareSpan,
                                  status: 2
                                });
                                store.dispatch(notify({
                                  type: "error",
                                  text: "Share disconnected!"
                                }));
                              });
                              (_this$_openTelemetry214 = this._openTelemetry) === null || _this$_openTelemetry214 === void 0 || _this$_openTelemetry214.completeSpan({
                                span: internalSpan,
                                status: 1,
                                message: "Share Audio Producer Created"
                              });
                              _context69.next = 18;
                              break;
                            case 16:
                              _context69.prev = 16;
                              _t68 = _context69["catch"](14);
                              _context69.next = 17;
                              return this._socketRequest("produceError", {
                                mediaType: "shareAudio",
                                message: _t68.message
                              });
                            case 17:
                              (_this$_videosdkLogs105 = this._videosdkLogs) === null || _this$_videosdkLogs105 === void 0 || _this$_videosdkLogs105.pushLogs({
                                logText: "Error in shareAudio produceError",
                                logType: "ERROR",
                                attributes: {
                                  error: _t68.message
                                }
                              });
                            case 18:
                              (_this$_openTelemetry215 = this._openTelemetry) === null || _this$_openTelemetry215 === void 0 || _this$_openTelemetry215.completeSpan({
                                span: enableShareSpan,
                                status: 1,
                                message: "Enable Share Successful"
                              });
                              _context69.next = 21;
                              break;
                            case 19:
                              _context69.prev = 19;
                              _t69 = _context69["catch"](3);
                              logger.error("enableShare() | failed:%o", _t69);
                              (_this$_openTelemetry216 = this._openTelemetry) === null || _this$_openTelemetry216 === void 0 || _this$_openTelemetry216.completeSpan({
                                span: enableShareSpan,
                                status: 2,
                                attributes: {
                                  error: _t69.message
                                },
                                message: "Error in enableShare video produceError"
                              });
                              console.log("screen share catch", _t69.message);
                              (_this$_videosdkLogs106 = this._videosdkLogs) === null || _this$_videosdkLogs106 === void 0 || _this$_videosdkLogs106.pushLogs({
                                logText: "Error in enableShare video produceError",
                                logType: "ERROR",
                                attributes: {
                                  error: _t69.message
                                }
                              });
                              if (_t69.name !== "NotAllowedError") {
                                store.dispatch(notify({
                                  type: "error",
                                  text: "Error sharing: ".concat(_t69)
                                }));
                              }
                              _context69.next = 20;
                              return this._socketRequest("produceError", {
                                mediaType: "share",
                                message: _t69.message
                              });
                            case 20:
                              if (videoTrack) videoTrack.stop();
                              if (audioTrack) audioTrack.stop();
                            case 21:
                              store.dispatch(setShareInProgress(false));
                              if (this._shareProducer) {
                                reportCounter = 0;
                                probe = this._metrics.addNewProbe(this._shareProducer, "share_producer");
                                probe.onStatsCollected = function(report) {
                                  try {
                                    if (!_this6._stats.producerStats) {
                                      _this6._stats.producerStats = {};
                                    }
                                    if (!_this6._stats.producerStats["share"]) {
                                      _this6._stats.producerStats["share"] = [];
                                    }
                                    if (_this6._shareProducer) {
                                      var _this6$_shareProducer2;
                                      _this6._latestStats[(_this6$_shareProducer2 = _this6._shareProducer) === null || _this6$_shareProducer2 === void 0 ? void 0 : _this6$_shareProducer2.id] = [];
                                    }
                                    report["video"].forEach(function(stat) {
                                      if (_this6._shareProducer) {
                                        var _this6$_shareProducer3;
                                        _this6._latestStats[(_this6$_shareProducer3 = _this6._shareProducer) === null || _this6$_shareProducer3 === void 0 ? void 0 : _this6$_shareProducer3.id].push(stat);
                                      }
                                    });
                                    if (reportCounter % 5 == 0 && _this6._shareProducer != null) {
                                      _this6._stats["producerStats"]["share"].push({
                                        timestamp: /* @__PURE__ */ new Date(),
                                        stats: _this6._latestStats[_this6._shareProducer.id]
                                      });
                                    }
                                    reportCounter++;
                                  } catch (error) {
                                    var _this6$_videosdkLogs;
                                    (_this6$_videosdkLogs = _this6._videosdkLogs) === null || _this6$_videosdkLogs === void 0 || _this6$_videosdkLogs.pushLogs({
                                      logText: "Error PRODUCER Stats ERROR",
                                      logType: "ERROR",
                                      attributes: {
                                        error: error.message
                                      }
                                    });
                                  }
                                };
                                probe.start();
                                this._shareProducer.observer.on("close", function() {
                                  probe.stop();
                                  _this6._metrics.removeExistingProbe(probe);
                                });
                              }
                              if (this._shareAudioProducer) {
                                _reportCounter = 0;
                                _probe2 = this._metrics.addNewProbe(this._shareAudioProducer, "share_audio_producer");
                                _probe2.onStatsCollected = function(report) {
                                  try {
                                    if (!_this6._stats.producerStats) {
                                      _this6._stats.producerStats = {};
                                    }
                                    if (!_this6._stats.producerStats["shareAudio"]) {
                                      _this6._stats.producerStats["shareAudio"] = [];
                                    }
                                    if (_this6._shareAudioProducer) {
                                      var _this6$_shareAudioPro2;
                                      _this6._latestStats[(_this6$_shareAudioPro2 = _this6._shareAudioProducer) === null || _this6$_shareAudioPro2 === void 0 ? void 0 : _this6$_shareAudioPro2.id] = [];
                                    }
                                    report["audio"].forEach(function(stat) {
                                      if (_this6._shareAudioProducer) {
                                        var _this6$_shareAudioPro3;
                                        _this6._latestStats[(_this6$_shareAudioPro3 = _this6._shareAudioProducer) === null || _this6$_shareAudioPro3 === void 0 ? void 0 : _this6$_shareAudioPro3.id].push(stat);
                                      }
                                    });
                                    if (_reportCounter % 5 == 0 && _this6._shareAudioProducer != null) {
                                      _this6._stats["producerStats"]["shareAudio"].push(RoomClient_objectSpread({
                                        timestamp: /* @__PURE__ */ new Date()
                                      }, _this6._latestStats[_this6._shareAudioProducer.id] ? _this6._latestStats[_this6._shareAudioProducer.id][0] : {}));
                                    }
                                    _reportCounter++;
                                  } catch (error) {
                                    var _this6$_videosdkLogs2;
                                    (_this6$_videosdkLogs2 = _this6._videosdkLogs) === null || _this6$_videosdkLogs2 === void 0 || _this6$_videosdkLogs2.pushLogs({
                                      logText: "Error PRODUCER Stats ERROR",
                                      logType: "ERROR",
                                      attributes: {
                                        error: error.message
                                      }
                                    });
                                  }
                                };
                                _probe2.start();
                                this._shareAudioProducer.observer.on("close", function() {
                                  _probe2.stop();
                                  _this6._metrics.removeExistingProbe(_probe2);
                                });
                              }
                            case 22:
                            case "end":
                              return _context69.stop();
                          }
                        }, _callee69, this, [[3, 19], [4, 6], [14, 16]]);
                      }));
                      function enableShare() {
                        return _enableShare.apply(this, arguments);
                      }
                      return enableShare;
                    }()
                  }, {
                    key: "disableShare",
                    value: function() {
                      var _disableShare = (0, asyncToGenerator.A)(regenerator_default().mark(function _callee70() {
                        var _this$_openTelemetry217, _this$_openTelemetry219, _this$_openTelemetry224;
                        var disableShareSpan, _this$_openTelemetry218, internalSpan, action, _this$_openTelemetry220, _this$_openTelemetry221, disableAudioShareSpan, _this$_openTelemetry222, _this$_openTelemetry223, _this$_videosdkLogs107, _t70;
                        return regenerator_default().wrap(function(_context70) {
                          while (1) switch (_context70.prev = _context70.next) {
                            case 0:
                              logger.debug("disableShare()");
                              disableShareSpan = (_this$_openTelemetry217 = this._openTelemetry) === null || _this$_openTelemetry217 === void 0 ? void 0 : _this$_openTelemetry217.trace({
                                spanName: "disableShare() Calling",
                                status: 1
                              });
                              if (this._shareProducer) {
                                _context70.next = 1;
                                break;
                              }
                              (_this$_openTelemetry218 = this._openTelemetry) === null || _this$_openTelemetry218 === void 0 || _this$_openTelemetry218.completeSpan({
                                span: disableShareSpan,
                                status: 2,
                                message: "Share Producer Not found"
                              });
                              return _context70.abrupt("return");
                            case 1:
                              internalSpan = (_this$_openTelemetry219 = this._openTelemetry) === null || _this$_openTelemetry219 === void 0 ? void 0 : _this$_openTelemetry219.trace({
                                spanName: "Closing Share Producer",
                                span: disableShareSpan,
                                status: 1
                              });
                              this._shareProducer.close();
                              action = removeProducer(this._shareProducer.id);
                              store.dispatch(action);
                              this._eventEmitter.emit(action.type, action.payload);
                              if (this._shareAudioProducer) {
                                disableAudioShareSpan = (_this$_openTelemetry220 = this._openTelemetry) === null || _this$_openTelemetry220 === void 0 ? void 0 : _this$_openTelemetry220.trace({
                                  spanName: "Closing Share Audio Producer",
                                  span: disableShareSpan,
                                  status: 1
                                });
                                this._shareAudioProducer.close();
                                action = removeProducer(this._shareAudioProducer.id);
                                store.dispatch(action);
                                this._eventEmitter.emit(action.type, action.payload);
                                (_this$_openTelemetry221 = this._openTelemetry) === null || _this$_openTelemetry221 === void 0 || _this$_openTelemetry221.completeSpan({
                                  span: disableAudioShareSpan,
                                  status: 1,
                                  message: "Closed Share Audio Producer"
                                });
                              }
                              _context70.prev = 2;
                              _context70.next = 3;
                              return this._socketRequest("closeProducer", {
                                producerId: this._shareProducer.id
                              });
                            case 3:
                              if (!(this, this._shareAudioProducer)) {
                                _context70.next = 4;
                                break;
                              }
                              _context70.next = 4;
                              return this._socketRequest("closeProducer", {
                                producerId: this._shareAudioProducer.id
                              });
                            case 4:
                              (_this$_openTelemetry222 = this._openTelemetry) === null || _this$_openTelemetry222 === void 0 || _this$_openTelemetry222.completeSpan({
                                span: internalSpan,
                                status: 1,
                                message: "Requested Server to Close Producer"
                              });
                              _context70.next = 6;
                              break;
                            case 5:
                              _context70.prev = 5;
                              _t70 = _context70["catch"](2);
                              store.dispatch(notify({
                                type: "error",
                                text: "Error closing server-side share Producer: ".concat(_t70)
                              }));
                              (_this$_openTelemetry223 = this._openTelemetry) === null || _this$_openTelemetry223 === void 0 || _this$_openTelemetry223.completeSpan({
                                span: disableShareSpan,
                                status: 2,
                                message: "Error closing server-side share Producer ".concat(_t70)
                              });
                              (_this$_videosdkLogs107 = this._videosdkLogs) === null || _this$_videosdkLogs107 === void 0 || _this$_videosdkLogs107.pushLogs({
                                logText: "Error closing server-side share Producer",
                                logType: "ERROR",
                                attributes: {
                                  error: _t70.message
                                }
                              });
                            case 6:
                              this._shareProducer = null;
                              this._shareAudioProducer = null;
                              (_this$_openTelemetry224 = this._openTelemetry) === null || _this$_openTelemetry224 === void 0 || _this$_openTelemetry224.completeSpan({
                                span: disableShareSpan,
                                status: 1,
                                message: "Screen Share Disabled Successfully"
                              });
                            case 7:
                            case "end":
                              return _context70.stop();
                          }
                        }, _callee70, this, [[2, 5]]);
                      }));
                      function disableShare() {
                        return _disableShare.apply(this, arguments);
                      }
                      return disableShare;
                    }()
                  }, {
                    key: "enableAudioOnly",
                    value: function() {
                      var _enableAudioOnly = (0, asyncToGenerator.A)(regenerator_default().mark(function _callee71() {
                        var _iterator2, _step2, consumer, _t71;
                        return regenerator_default().wrap(function(_context71) {
                          while (1) switch (_context71.prev = _context71.next) {
                            case 0:
                              logger.debug("enableAudioOnly()");
                              store.dispatch(setAudioOnlyInProgress(true));
                              this.disableWebcam();
                              _iterator2 = RoomClient_createForOfIteratorHelper(this._consumers.values());
                              _context71.prev = 1;
                              _iterator2.s();
                            case 2:
                              if ((_step2 = _iterator2.n()).done) {
                                _context71.next = 5;
                                break;
                              }
                              consumer = _step2.value;
                              if (!(consumer.kind !== "video")) {
                                _context71.next = 3;
                                break;
                              }
                              return _context71.abrupt("continue", 4);
                            case 3:
                              this._pauseConsumer(consumer);
                            case 4:
                              _context71.next = 2;
                              break;
                            case 5:
                              _context71.next = 7;
                              break;
                            case 6:
                              _context71.prev = 6;
                              _t71 = _context71["catch"](1);
                              _iterator2.e(_t71);
                            case 7:
                              _context71.prev = 7;
                              _iterator2.f();
                              return _context71.finish(7);
                            case 8:
                              store.dispatch(setAudioOnlyState(true));
                              store.dispatch(setAudioOnlyInProgress(false));
                            case 9:
                            case "end":
                              return _context71.stop();
                          }
                        }, _callee71, this, [[1, 6, 7, 8]]);
                      }));
                      function enableAudioOnly() {
                        return _enableAudioOnly.apply(this, arguments);
                      }
                      return enableAudioOnly;
                    }()
                  }, {
                    key: "disableAudioOnly",
                    value: function() {
                      var _disableAudioOnly = (0, asyncToGenerator.A)(regenerator_default().mark(function _callee72() {
                        var _iterator3, _step3, consumer, _t72;
                        return regenerator_default().wrap(function(_context72) {
                          while (1) switch (_context72.prev = _context72.next) {
                            case 0:
                              logger.debug("disableAudioOnly()");
                              store.dispatch(setAudioOnlyInProgress(true));
                              if (!this._webcamProducer && this._produce && (getDevices() || {}).webcamEnabled) {
                                this.enableWebcam();
                              }
                              _iterator3 = RoomClient_createForOfIteratorHelper(this._consumers.values());
                              _context72.prev = 1;
                              _iterator3.s();
                            case 2:
                              if ((_step3 = _iterator3.n()).done) {
                                _context72.next = 5;
                                break;
                              }
                              consumer = _step3.value;
                              if (!(consumer.kind !== "video")) {
                                _context72.next = 3;
                                break;
                              }
                              return _context72.abrupt("continue", 4);
                            case 3:
                              this._resumeConsumer(consumer);
                            case 4:
                              _context72.next = 2;
                              break;
                            case 5:
                              _context72.next = 7;
                              break;
                            case 6:
                              _context72.prev = 6;
                              _t72 = _context72["catch"](1);
                              _iterator3.e(_t72);
                            case 7:
                              _context72.prev = 7;
                              _iterator3.f();
                              return _context72.finish(7);
                            case 8:
                              store.dispatch(setAudioOnlyState(false));
                              store.dispatch(setAudioOnlyInProgress(false));
                            case 9:
                            case "end":
                              return _context72.stop();
                          }
                        }, _callee72, this, [[1, 6, 7, 8]]);
                      }));
                      function disableAudioOnly() {
                        return _disableAudioOnly.apply(this, arguments);
                      }
                      return disableAudioOnly;
                    }()
                  }, {
                    key: "muteAudio",
                    value: function() {
                      var _muteAudio = (0, asyncToGenerator.A)(regenerator_default().mark(function _callee73() {
                        return regenerator_default().wrap(function(_context73) {
                          while (1) switch (_context73.prev = _context73.next) {
                            case 0:
                              logger.debug("muteAudio()");
                              store.dispatch(setAudioMutedState(true));
                            case 1:
                            case "end":
                              return _context73.stop();
                          }
                        }, _callee73);
                      }));
                      function muteAudio() {
                        return _muteAudio.apply(this, arguments);
                      }
                      return muteAudio;
                    }()
                  }, {
                    key: "unmuteAudio",
                    value: function() {
                      var _unmuteAudio = (0, asyncToGenerator.A)(regenerator_default().mark(function _callee74() {
                        return regenerator_default().wrap(function(_context74) {
                          while (1) switch (_context74.prev = _context74.next) {
                            case 0:
                              logger.debug("unmuteAudio()");
                              store.dispatch(setAudioMutedState(false));
                            case 1:
                            case "end":
                              return _context74.stop();
                          }
                        }, _callee74);
                      }));
                      function unmuteAudio() {
                        return _unmuteAudio.apply(this, arguments);
                      }
                      return unmuteAudio;
                    }()
                  }, {
                    key: "handleRemoteRestartIce",
                    value: function() {
                      var _handleRemoteRestartIce = (0, asyncToGenerator.A)(regenerator_default().mark(function _callee75(_ref18) {
                        var _this$_sendTransport5, _this$_recvTransport4;
                        var iceParameters, transportId, internalSpan, _this$_openTelemetry225, _this$_openTelemetry226, _this$_videosdkLogs108, _t73;
                        return regenerator_default().wrap(function(_context75) {
                          while (1) switch (_context75.prev = _context75.next) {
                            case 0:
                              iceParameters = _ref18.iceParameters, transportId = _ref18.transportId, internalSpan = _ref18.internalSpan;
                              if (transportId === ((_this$_sendTransport5 = this._sendTransport) === null || _this$_sendTransport5 === void 0 ? void 0 : _this$_sendTransport5.id)) {
                                this._sendTransport.restartIce({
                                  iceParameters
                                });
                              }
                              if (transportId === ((_this$_recvTransport4 = this._recvTransport) === null || _this$_recvTransport4 === void 0 ? void 0 : _this$_recvTransport4.id)) {
                                this._recvTransport.restartIce({
                                  iceParameters
                                });
                              }
                              _context75.prev = 1;
                              _context75.next = 2;
                              return this._socketRequest("iceRestarted", {
                                transportId
                              });
                            case 2:
                              (_this$_openTelemetry225 = this._openTelemetry) === null || _this$_openTelemetry225 === void 0 || _this$_openTelemetry225.completeSpan({
                                span: internalSpan,
                                status: 1,
                                message: "iceRestarted"
                              });
                              _context75.next = 4;
                              break;
                            case 3:
                              _context75.prev = 3;
                              _t73 = _context75["catch"](1);
                              (_this$_openTelemetry226 = this._openTelemetry) === null || _this$_openTelemetry226 === void 0 || _this$_openTelemetry226.completeSpan({
                                span: internalSpan,
                                status: 2,
                                message: "handleRemoteRestartIce() ICE restart failed ".concat(_t73)
                              });
                              (_this$_videosdkLogs108 = this._videosdkLogs) === null || _this$_videosdkLogs108 === void 0 || _this$_videosdkLogs108.pushLogs({
                                logText: "Error handleRemoteRestartIce() ICE restart failed",
                                logType: "ERROR",
                                attributes: {
                                  error: _t73.message
                                }
                              });
                              store.dispatch(notify({
                                type: "error",
                                text: "ICE restart failed: ".concat(_t73)
                              }));
                            case 4:
                            case "end":
                              return _context75.stop();
                          }
                        }, _callee75, this, [[1, 3]]);
                      }));
                      function handleRemoteRestartIce(_x67) {
                        return _handleRemoteRestartIce.apply(this, arguments);
                      }
                      return handleRemoteRestartIce;
                    }()
                  }, {
                    key: "restartIce",
                    value: function() {
                      var _restartIce = (0, asyncToGenerator.A)(regenerator_default().mark(function _callee76() {
                        var iceParameters, _iceParameters, _this$_videosdkLogs109, _t74;
                        return regenerator_default().wrap(function(_context76) {
                          while (1) switch (_context76.prev = _context76.next) {
                            case 0:
                              logger.debug("restartIce()");
                              store.dispatch(setRestartIceInProgress(true));
                              _context76.prev = 1;
                              if (!this._sendTransport) {
                                _context76.next = 3;
                                break;
                              }
                              _context76.next = 2;
                              return this._socketRequest("restartIce", {
                                transportId: this._sendTransport.id
                              });
                            case 2:
                              iceParameters = _context76.sent;
                              _context76.next = 3;
                              return this._sendTransport.restartIce({
                                iceParameters
                              });
                            case 3:
                              if (!this._recvTransport) {
                                _context76.next = 5;
                                break;
                              }
                              _context76.next = 4;
                              return this._socketRequest("restartIce", {
                                transportId: this._recvTransport.id
                              });
                            case 4:
                              _iceParameters = _context76.sent;
                              _context76.next = 5;
                              return this._recvTransport.restartIce({
                                iceParameters: _iceParameters
                              });
                            case 5:
                              store.dispatch(notify({
                                text: "ICE restarted"
                              }));
                              _context76.next = 7;
                              break;
                            case 6:
                              _context76.prev = 6;
                              _t74 = _context76["catch"](1);
                              logger.error("restartIce() | failed:%o", _t74);
                              store.dispatch(notify({
                                type: "error",
                                text: "ICE restart failed: ".concat(_t74)
                              }));
                              (_this$_videosdkLogs109 = this._videosdkLogs) === null || _this$_videosdkLogs109 === void 0 || _this$_videosdkLogs109.pushLogs({
                                logText: "Error restartIce() ICE restart failed",
                                logType: "ERROR",
                                attributes: {
                                  error: _t74.message
                                }
                              });
                            case 7:
                              store.dispatch(setRestartIceInProgress(false));
                            case 8:
                            case "end":
                              return _context76.stop();
                          }
                        }, _callee76, this, [[1, 6]]);
                      }));
                      function restartIce() {
                        return _restartIce.apply(this, arguments);
                      }
                      return restartIce;
                    }()
                  }, {
                    key: "_socketRequest",
                    value: function() {
                      var _socketRequest2 = (0, asyncToGenerator.A)(regenerator_default().mark(function _callee77(event) {
                        var _this7 = this;
                        var data, _args77 = arguments;
                        return regenerator_default().wrap(function(_context77) {
                          while (1) switch (_context77.prev = _context77.next) {
                            case 0:
                              data = _args77.length > 1 && _args77[1] !== void 0 ? _args77[1] : {};
                              return _context77.abrupt("return", new Promise(function(resolve, reject) {
                                _this7._webSocket.emit("request", {
                                  method: event,
                                  request: true,
                                  data
                                }, function(response) {
                                  if (response !== null && response !== void 0 && response.error) {
                                    reject(new Error(response.error));
                                  } else {
                                    resolve(response.data);
                                  }
                                });
                              }));
                            case 1:
                            case "end":
                              return _context77.stop();
                          }
                        }, _callee77);
                      }));
                      function _socketRequest(_x68) {
                        return _socketRequest2.apply(this, arguments);
                      }
                      return _socketRequest;
                    }()
                  }, {
                    key: "_socketRequestForPubsub",
                    value: function() {
                      var _socketRequestForPubsub2 = (0, asyncToGenerator.A)(regenerator_default().mark(function _callee78(event) {
                        var _this8 = this;
                        var data, _args78 = arguments;
                        return regenerator_default().wrap(function(_context78) {
                          while (1) switch (_context78.prev = _context78.next) {
                            case 0:
                              data = _args78.length > 1 && _args78[1] !== void 0 ? _args78[1] : {};
                              return _context78.abrupt("return", new Promise(function(resolve, reject) {
                                _this8._webSocket.timeout(3e4).emit("request", {
                                  method: event,
                                  request: true,
                                  data
                                }, function(err, response) {
                                  if (err) {
                                    return reject(err);
                                  }
                                  if (response !== null && response !== void 0 && response.error) {
                                    reject(new Error(response.error));
                                  } else {
                                    resolve(response.data);
                                  }
                                });
                              }));
                            case 1:
                            case "end":
                              return _context78.stop();
                          }
                        }, _callee78);
                      }));
                      function _socketRequestForPubsub(_x69) {
                        return _socketRequestForPubsub2.apply(this, arguments);
                      }
                      return _socketRequestForPubsub;
                    }()
                  }, {
                    key: "setMaxSendingSpatialLayer",
                    value: function() {
                      var _setMaxSendingSpatialLayer = (0, asyncToGenerator.A)(regenerator_default().mark(function _callee79(spatialLayer) {
                        var _this$_videosdkLogs110, _t75;
                        return regenerator_default().wrap(function(_context79) {
                          while (1) switch (_context79.prev = _context79.next) {
                            case 0:
                              logger.debug("setMaxSendingSpatialLayer() [spatialLayer:%s]", spatialLayer);
                              _context79.prev = 1;
                              if (!this._webcamProducer) {
                                _context79.next = 3;
                                break;
                              }
                              _context79.next = 2;
                              return this._webcamProducer.setMaxSpatialLayer(spatialLayer);
                            case 2:
                              _context79.next = 4;
                              break;
                            case 3:
                              if (!this._shareProducer) {
                                _context79.next = 4;
                                break;
                              }
                              _context79.next = 4;
                              return this._shareProducer.setMaxSpatialLayer(spatialLayer);
                            case 4:
                              _context79.next = 6;
                              break;
                            case 5:
                              _context79.prev = 5;
                              _t75 = _context79["catch"](1);
                              logger.error("setMaxSendingSpatialLayer() | failed:%o", _t75);
                              (_this$_videosdkLogs110 = this._videosdkLogs) === null || _this$_videosdkLogs110 === void 0 || _this$_videosdkLogs110.pushLogs({
                                logText: "Error setting max sending video spatial layer",
                                logType: "ERROR",
                                attributes: {
                                  error: _t75.message
                                }
                              });
                              store.dispatch(notify({
                                type: "error",
                                text: "Error setting max sending video spatial layer: ".concat(_t75)
                              }));
                            case 6:
                            case "end":
                              return _context79.stop();
                          }
                        }, _callee79, this, [[1, 5]]);
                      }));
                      function setMaxSendingSpatialLayer(_x70) {
                        return _setMaxSendingSpatialLayer.apply(this, arguments);
                      }
                      return setMaxSendingSpatialLayer;
                    }()
                    /**
                     *
                     * @param {"low" | "med" | 'high'} quality
                     */
                  }, {
                    key: "setWebcamQuality",
                    value: function() {
                      var _setWebcamQuality = (0, asyncToGenerator.A)(regenerator_default().mark(function _callee80(quality) {
                        var resolution, spatialLayers;
                        return regenerator_default().wrap(function(_context80) {
                          while (1) switch (_context80.prev = _context80.next) {
                            case 0:
                              if (this._webcamProducer) {
                                _context80.next = 1;
                                break;
                              }
                              return _context80.abrupt("return");
                            case 1:
                              resolution = this._webcam.resolution;
                              spatialLayers = VIDEO_LAYERS[resolution][quality].s;
                              if (!(this._webcamProducer.maxSpatialLayer == spatialLayers)) {
                                _context80.next = 2;
                                break;
                              }
                              return _context80.abrupt("return");
                            case 2:
                              _context80.next = 3;
                              return this._webcamProducer.setMaxSpatialLayer(spatialLayers);
                            case 3:
                            case "end":
                              return _context80.stop();
                          }
                        }, _callee80, this);
                      }));
                      function setWebcamQuality(_x71) {
                        return _setWebcamQuality.apply(this, arguments);
                      }
                      return setWebcamQuality;
                    }()
                  }, {
                    key: "setConsumerScreenShareQuality",
                    value: function() {
                      var _setConsumerScreenShareQuality = (0, asyncToGenerator.A)(regenerator_default().mark(function _callee81(consumerId, quality) {
                        var _this$_openTelemetry227, _this$_openTelemetry228, _this$_openTelemetry229;
                        var setScreenShareQualitySpan, qualities, selectedQuality;
                        return regenerator_default().wrap(function(_context81) {
                          while (1) switch (_context81.prev = _context81.next) {
                            case 0:
                              setScreenShareQualitySpan = (_this$_openTelemetry227 = this._openTelemetry) === null || _this$_openTelemetry227 === void 0 ? void 0 : _this$_openTelemetry227.trace({
                                spanName: 'Setting "'.concat(quality, '" Quality for Screen Share')
                              });
                              qualities = {
                                high: {
                                  spatialLayer: 2,
                                  temporalLayer: 2
                                },
                                med: {
                                  spatialLayer: 1,
                                  temporalLayer: 2
                                },
                                low: {
                                  spatialLayer: 0,
                                  temporalLayer: 2
                                }
                              };
                              selectedQuality = qualities[quality] || qualities.high;
                              (_this$_openTelemetry228 = this._openTelemetry) === null || _this$_openTelemetry228 === void 0 || _this$_openTelemetry228.traceAutoComplete({
                                spanName: "Getting spatial & temporal layers",
                                span: setScreenShareQualitySpan,
                                attributes: {
                                  selectedQuality
                                },
                                status: 1
                              });
                              _context81.next = 1;
                              return this.setConsumerPreferredLayers(consumerId, selectedQuality.spatialLayer, selectedQuality.temporalLayer);
                            case 1:
                              (_this$_openTelemetry229 = this._openTelemetry) === null || _this$_openTelemetry229 === void 0 || _this$_openTelemetry229.completeSpan({
                                message: "Done",
                                span: setScreenShareQualitySpan,
                                status: 1
                              });
                            case 2:
                            case "end":
                              return _context81.stop();
                          }
                        }, _callee81, this);
                      }));
                      function setConsumerScreenShareQuality(_x72, _x73) {
                        return _setConsumerScreenShareQuality.apply(this, arguments);
                      }
                      return setConsumerScreenShareQuality;
                    }()
                  }, {
                    key: "setConsumerQuality",
                    value: function() {
                      var _setConsumerQuality = (0, asyncToGenerator.A)(regenerator_default().mark(function _callee82(consumerId, quality) {
                        var _this$_openTelemetry230, _this$_openTelemetry231, _this$_openTelemetry232;
                        var resolution, setWebcamQualitySpan, spatialLayers, temporalLayers;
                        return regenerator_default().wrap(function(_context82) {
                          while (1) switch (_context82.prev = _context82.next) {
                            case 0:
                              resolution = this._webcam.resolution;
                              setWebcamQualitySpan = (_this$_openTelemetry230 = this._openTelemetry) === null || _this$_openTelemetry230 === void 0 ? void 0 : _this$_openTelemetry230.trace({
                                spanName: 'Setting "'.concat(quality, '" Quality')
                              });
                              spatialLayers = VIDEO_LAYERS[resolution][quality].s;
                              temporalLayers = VIDEO_LAYERS[resolution][quality].t;
                              (_this$_openTelemetry231 = this._openTelemetry) === null || _this$_openTelemetry231 === void 0 || _this$_openTelemetry231.traceAutoComplete({
                                spanName: "Getting spatial & temporal layers",
                                span: setWebcamQualitySpan,
                                attributes: {
                                  spatialLayers: JSON.parse(spatialLayers),
                                  temporalLayers: JSON.parse(temporalLayers)
                                },
                                status: 1
                              });
                              _context82.next = 1;
                              return this.setConsumerPreferredLayers(consumerId, spatialLayers, temporalLayers);
                            case 1:
                              (_this$_openTelemetry232 = this._openTelemetry) === null || _this$_openTelemetry232 === void 0 || _this$_openTelemetry232.completeSpan({
                                message: "Done",
                                span: setWebcamQualitySpan,
                                status: 1
                              });
                            case 2:
                            case "end":
                              return _context82.stop();
                          }
                        }, _callee82, this);
                      }));
                      function setConsumerQuality(_x74, _x75) {
                        return _setConsumerQuality.apply(this, arguments);
                      }
                      return setConsumerQuality;
                    }()
                  }, {
                    key: "setViewPort",
                    value: function() {
                      var _setViewPort = (0, asyncToGenerator.A)(regenerator_default().mark(function _callee83(consumer, viewportWidth, viewportHeight) {
                        var _getAdaptivePreffered, consumerId, newPreferredSpatialLayer, newPreferredTemporalLayer;
                        return regenerator_default().wrap(function(_context83) {
                          while (1) switch (_context83.prev = _context83.next) {
                            case 0:
                              if (this._consumers.get(consumer.id)) {
                                _context83.next = 1;
                                break;
                              }
                              return _context83.abrupt("return");
                            case 1:
                              _getAdaptivePreffered = (0, sdkCapabilities.ed)(this._consumers.get(consumer.id), viewportWidth, viewportHeight), consumerId = _getAdaptivePreffered.consumerId, newPreferredSpatialLayer = _getAdaptivePreffered.newPreferredSpatialLayer, newPreferredTemporalLayer = _getAdaptivePreffered.newPreferredTemporalLayer;
                              if (!(newPreferredSpatialLayer === consumer.preferredSpatialLayer && newPreferredTemporalLayer === consumer.preferredTemporalLayer)) {
                                _context83.next = 2;
                                break;
                              }
                              return _context83.abrupt("return");
                            case 2:
                              if (!consumerId) {
                                _context83.next = 3;
                                break;
                              }
                              _context83.next = 3;
                              return this.setConsumerPreferredLayers(consumerId, newPreferredSpatialLayer, newPreferredTemporalLayer);
                            case 3:
                            case "end":
                              return _context83.stop();
                          }
                        }, _callee83, this);
                      }));
                      function setViewPort(_x76, _x77, _x78) {
                        return _setViewPort.apply(this, arguments);
                      }
                      return setViewPort;
                    }()
                  }, {
                    key: "setConsumerPreferredLayers",
                    value: function() {
                      var _setConsumerPreferredLayers = (0, asyncToGenerator.A)(regenerator_default().mark(function _callee84(consumerId, spatialLayer, temporalLayer) {
                        var consumer, _this$_videosdkLogs111, _t76;
                        return regenerator_default().wrap(function(_context84) {
                          while (1) switch (_context84.prev = _context84.next) {
                            case 0:
                              logger.debug("setConsumerPreferredLayers() [consumerId:%s, spatialLayer:%s, temporalLayer:%s]", consumerId, spatialLayer, temporalLayer);
                              _context84.prev = 1;
                              consumer = this._consumers.get(consumerId);
                              if (consumer.spatialLayers > 1) {
                                consumer.preferredSpatialLayer = spatialLayer;
                                consumer.preferredTemporalLayer = temporalLayer;
                              }
                              _context84.next = 2;
                              return this._socketRequest("setConsumerPreferredLayers", {
                                consumerId,
                                spatialLayer,
                                temporalLayer
                              });
                            case 2:
                              store.dispatch(stateActions_setConsumerPreferredLayers(consumerId, spatialLayer, temporalLayer));
                              _context84.next = 4;
                              break;
                            case 3:
                              _context84.prev = 3;
                              _t76 = _context84["catch"](1);
                              logger.error("setConsumerPreferredLayers() | failed:%o", _t76);
                              (_this$_videosdkLogs111 = this._videosdkLogs) === null || _this$_videosdkLogs111 === void 0 || _this$_videosdkLogs111.pushLogs({
                                logText: "Error setting Consumer preferred layers:",
                                logType: "ERROR",
                                attributes: {
                                  error: _t76.message
                                }
                              });
                              store.dispatch(notify({
                                type: "error",
                                text: "Error setting Consumer preferred layers: ".concat(_t76)
                              }));
                            case 4:
                            case "end":
                              return _context84.stop();
                          }
                        }, _callee84, this, [[1, 3]]);
                      }));
                      function setConsumerPreferredLayers(_x79, _x80, _x81) {
                        return _setConsumerPreferredLayers.apply(this, arguments);
                      }
                      return setConsumerPreferredLayers;
                    }()
                  }, {
                    key: "setConsumerPriority",
                    value: function() {
                      var _setConsumerPriority = (0, asyncToGenerator.A)(regenerator_default().mark(function _callee85(consumerId, priority) {
                        var _this$_videosdkLogs112, _t77;
                        return regenerator_default().wrap(function(_context85) {
                          while (1) switch (_context85.prev = _context85.next) {
                            case 0:
                              logger.debug("setConsumerPriority() [consumerId:%s, priority:%d]", consumerId, priority);
                              _context85.prev = 1;
                              _context85.next = 2;
                              return this._socketRequest("setConsumerPriority", {
                                consumerId,
                                priority
                              });
                            case 2:
                              store.dispatch(stateActions_setConsumerPriority(consumerId, priority));
                              _context85.next = 4;
                              break;
                            case 3:
                              _context85.prev = 3;
                              _t77 = _context85["catch"](1);
                              logger.error("setConsumerPriority() | failed:%o", _t77);
                              (_this$_videosdkLogs112 = this._videosdkLogs) === null || _this$_videosdkLogs112 === void 0 || _this$_videosdkLogs112.pushLogs({
                                logText: "Error setting Consumer priority",
                                logType: "ERROR",
                                attributes: {
                                  error: _t77.message
                                }
                              });
                              store.dispatch(notify({
                                type: "error",
                                text: "Error setting Consumer priority: ".concat(_t77)
                              }));
                            case 4:
                            case "end":
                              return _context85.stop();
                          }
                        }, _callee85, this, [[1, 3]]);
                      }));
                      function setConsumerPriority(_x82, _x83) {
                        return _setConsumerPriority.apply(this, arguments);
                      }
                      return setConsumerPriority;
                    }()
                  }, {
                    key: "requestConsumerKeyFrame",
                    value: function() {
                      var _requestConsumerKeyFrame = (0, asyncToGenerator.A)(regenerator_default().mark(function _callee86(consumerId) {
                        var _this$_videosdkLogs113, _t78;
                        return regenerator_default().wrap(function(_context86) {
                          while (1) switch (_context86.prev = _context86.next) {
                            case 0:
                              logger.debug("requestConsumerKeyFrame() [consumerId:%s]", consumerId);
                              _context86.prev = 1;
                              _context86.next = 2;
                              return this._socketRequest("requestConsumerKeyFrame", {
                                consumerId
                              });
                            case 2:
                              store.dispatch(notify({
                                text: "Keyframe requested for video consumer"
                              }));
                              _context86.next = 4;
                              break;
                            case 3:
                              _context86.prev = 3;
                              _t78 = _context86["catch"](1);
                              logger.error("requestConsumerKeyFrame() | failed:%o", _t78);
                              (_this$_videosdkLogs113 = this._videosdkLogs) === null || _this$_videosdkLogs113 === void 0 || _this$_videosdkLogs113.pushLogs({
                                logText: "Error requesting key frame for Consumer",
                                logType: "ERROR",
                                attributes: {
                                  error: _t78.message
                                }
                              });
                              store.dispatch(notify({
                                type: "error",
                                text: "Error requesting key frame for Consumer: ".concat(_t78)
                              }));
                            case 4:
                            case "end":
                              return _context86.stop();
                          }
                        }, _callee86, this, [[1, 3]]);
                      }));
                      function requestConsumerKeyFrame(_x84) {
                        return _requestConsumerKeyFrame.apply(this, arguments);
                      }
                      return requestConsumerKeyFrame;
                    }()
                  }, {
                    key: "enableChatDataProducer",
                    value: function() {
                      var _enableChatDataProducer = (0, asyncToGenerator.A)(regenerator_default().mark(function _callee87() {
                        var _this9 = this;
                        var _this$_videosdkLogs114, _t79;
                        return regenerator_default().wrap(function(_context87) {
                          while (1) switch (_context87.prev = _context87.next) {
                            case 0:
                              logger.debug("enableChatDataProducer()");
                              _context87.prev = 1;
                              _context87.next = 2;
                              return this._sendTransport.produceData({
                                ordered: true,
                                maxRetransmits: 5,
                                label: "reliable_data_producer",
                                appData: {
                                  info: "my-chat-DataProducer"
                                }
                              });
                            case 2:
                              this._reliableDataProducer = _context87.sent;
                              this._reliableDataProducer.bufferedAmountLowThreshold = 65535;
                              _context87.next = 3;
                              return this._sendTransport.produceData({
                                ordered: false,
                                label: "unreliable_data_producer",
                                appData: {
                                  info: "my-chat-DataProducer"
                                }
                              });
                            case 3:
                              this._unreliableDataProducer = _context87.sent;
                              this._unreliableDataProducer.bufferedAmountLowThreshold = 65535;
                              store.dispatch(addDataProducer({
                                id: this._reliableDataProducer.id,
                                sctpStreamParameters: this._reliableDataProducer.sctpStreamParameters,
                                label: this._reliableDataProducer.label,
                                protocol: this._reliableDataProducer.protocol
                              }));
                              this._reliableDataProducer.on("transportclose", function() {
                                _this9._reliableDataProducer = null;
                              });
                              this._reliableDataProducer.on("open", function() {
                                logger.debug('chat DataProducer "open" event');
                              });
                              this._reliableDataProducer.on("close", function() {
                                logger.error('chat DataProducer "close" event');
                                _this9._reliableDataProducer = null;
                                store.dispatch(notify({
                                  type: "error",
                                  text: "Chat DataProducer closed"
                                }));
                              });
                              this._reliableDataProducer.on("error", function(error) {
                                logger.error('chat DataProducer "error" event:%o', error);
                                store.dispatch(notify({
                                  type: "error",
                                  text: "Chat DataProducer error: ".concat(error)
                                }));
                              });
                              store.dispatch(addDataProducer({
                                id: this._unreliableDataProducer.id,
                                sctpStreamParameters: this._unreliableDataProducer.sctpStreamParameters,
                                label: this._unreliableDataProducer.label,
                                protocol: this._unreliableDataProducer.protocol
                              }));
                              this._unreliableDataProducer.on("transportclose", function() {
                                _this9._unreliableDataProducer = null;
                              });
                              this._unreliableDataProducer.on("open", function() {
                                logger.debug('unreliable DataProducer "open" event');
                              });
                              this._unreliableDataProducer.on("close", function() {
                                logger.error('unreliable DataProducer "close" event');
                                _this9._unreliableDataProducer = null;
                                store.dispatch(notify({
                                  type: "error",
                                  text: "unreliable DataProducer closed"
                                }));
                              });
                              this._unreliableDataProducer.on("error", function(error) {
                                logger.error('unreliable DataProducer "error" event:%o', error);
                                store.dispatch(notify({
                                  type: "error",
                                  text: "unreliable DataProducer error: ".concat(error)
                                }));
                              });
                              _context87.next = 5;
                              break;
                            case 4:
                              _context87.prev = 4;
                              _t79 = _context87["catch"](1);
                              logger.error("enableChatDataProducer() | failed:%o", _t79);
                              (_this$_videosdkLogs114 = this._videosdkLogs) === null || _this$_videosdkLogs114 === void 0 || _this$_videosdkLogs114.pushLogs({
                                logText: "Error enabling chat DataProducer",
                                logType: "ERROR",
                                attributes: {
                                  error: _t79.message
                                }
                              });
                              store.dispatch(notify({
                                type: "error",
                                text: "Error enabling chat DataProducer: ".concat(_t79)
                              }));
                              throw _t79;
                            case 5:
                            case "end":
                              return _context87.stop();
                          }
                        }, _callee87, this, [[1, 4]]);
                      }));
                      function enableChatDataProducer() {
                        return _enableChatDataProducer.apply(this, arguments);
                      }
                      return enableChatDataProducer;
                    }()
                  }, {
                    key: "send",
                    value: function() {
                      var _send = (0, asyncToGenerator.A)(regenerator_default().mark(function _callee88(payload) {
                        var _this0 = this;
                        var opts, isValid, size, _args88 = arguments, _t80;
                        return regenerator_default().wrap(function(_context88) {
                          while (1) switch (_context88.prev = _context88.next) {
                            case 0:
                              opts = _args88.length > 1 && _args88[1] !== void 0 ? _args88[1] : {
                                reliability: reliabilityModes.y.RELIABLE
                              };
                              _context88.prev = 1;
                              isValid = typeof payload === "string" || payload instanceof Blob || payload instanceof ArrayBuffer || ArrayBuffer.isView(payload);
                              if (isValid) {
                                _context88.next = 2;
                                break;
                              }
                              throw new TypeError("Invalid payload type. Expected string | Blob | ArrayBuffer | ArrayBufferView");
                            case 2:
                              size = 0;
                              if (typeof payload === "string") {
                                size = new TextEncoder().encode(payload).length;
                              } else if (payload instanceof Blob) {
                                size = payload.size;
                              } else if (payload instanceof ArrayBuffer) {
                                size = payload.byteLength;
                              } else if (ArrayBuffer.isView(payload)) {
                                size = payload.byteLength;
                              }
                              if (!(size > 15 * 1024)) {
                                _context88.next = 3;
                                break;
                              }
                              throw new Error("Payload too large: ".concat(size, " bytes. Max allowed is 15 KiB."));
                            case 3:
                              if (!(!this._sendTransport || this._sendTransport.connectionState !== "connected")) {
                                _context88.next = 4;
                                break;
                              }
                              throw new Error("Cannot send message, Network is not available.");
                            case 4:
                              if (!(opts.reliability === reliabilityModes.y.RELIABLE)) {
                                _context88.next = 6;
                                break;
                              }
                              if (!(this._reliableDataProducer.bufferedAmount > this._reliableDataProducer.bufferedAmountLowThreshold)) {
                                _context88.next = 5;
                                break;
                              }
                              logger.warn("Buffer full, waiting to resume");
                              return _context88.abrupt("return", new Promise(function(resolve, reject) {
                                var _resumeHandler = function resumeHandler() {
                                  try {
                                    _this0._reliableDataProducer.send(payload);
                                    resolve(true);
                                  } catch (err) {
                                    reject(err);
                                  } finally {
                                    _this0._reliableDataProducer.off("bufferedamountlow", _resumeHandler);
                                  }
                                };
                                _this0._reliableDataProducer.on("bufferedamountlow", _resumeHandler);
                              }));
                            case 5:
                              this._reliableDataProducer.send(payload);
                              return _context88.abrupt("return", true);
                            case 6:
                              if (!(opts.reliability === reliabilityModes.y.UNRELIABLE)) {
                                _context88.next = 8;
                                break;
                              }
                              if (!(this._unreliableDataProducer.bufferedAmount > this._unreliableDataProducer.bufferedAmountLowThreshold)) {
                                _context88.next = 7;
                                break;
                              }
                              logger.warn("Buffer full, waiting to resume");
                              return _context88.abrupt("return", new Promise(function(resolve, reject) {
                                var _resumeHandler2 = function resumeHandler() {
                                  try {
                                    _this0._unreliableDataProducer.send(payload);
                                    resolve(true);
                                  } catch (err) {
                                    reject(err);
                                  } finally {
                                    _this0._unreliableDataProducer.off("bufferedamountlow", _resumeHandler2);
                                  }
                                };
                                _this0._unreliableDataProducer.on("bufferedamountlow", _resumeHandler2);
                              }));
                            case 7:
                              this._unreliableDataProducer.send(payload);
                              return _context88.abrupt("return", true);
                            case 8:
                              _context88.next = 10;
                              break;
                            case 9:
                              _context88.prev = 9;
                              _t80 = _context88["catch"](1);
                              logger.error("DataProducer.send() failed:%o", _t80);
                              store.dispatch(notify({
                                type: "error",
                                text: "DataProducer.send() failed: ".concat(_t80)
                              }));
                              throw _t80;
                            case 10:
                            case "end":
                              return _context88.stop();
                          }
                        }, _callee88, this, [[1, 9]]);
                      }));
                      function send(_x85) {
                        return _send.apply(this, arguments);
                      }
                      return send;
                    }()
                  }, {
                    key: "changeDisplayName",
                    value: function() {
                      var _changeDisplayName = (0, asyncToGenerator.A)(regenerator_default().mark(function _callee89(displayName) {
                        var _t81;
                        return regenerator_default().wrap(function(_context89) {
                          while (1) switch (_context89.prev = _context89.next) {
                            case 0:
                              logger.debug('changeDisplayName() [displayName:"%s"]', displayName);
                              setUser({
                                displayName
                              });
                              _context89.prev = 1;
                              _context89.next = 2;
                              return this._socketRequest("changeDisplayName", {
                                displayName
                              });
                            case 2:
                              this._displayName = displayName;
                              store.dispatch(setDisplayName(displayName));
                              store.dispatch(notify({
                                text: "Display name changed"
                              }));
                              _context89.next = 4;
                              break;
                            case 3:
                              _context89.prev = 3;
                              _t81 = _context89["catch"](1);
                              logger.error("changeDisplayName() | failed: %o", _t81);
                              store.dispatch(notify({
                                type: "error",
                                text: "Could not change display name: ".concat(_t81)
                              }));
                              store.dispatch(setDisplayName());
                            case 4:
                            case "end":
                              return _context89.stop();
                          }
                        }, _callee89, this, [[1, 3]]);
                      }));
                      function changeDisplayName(_x86) {
                        return _changeDisplayName.apply(this, arguments);
                      }
                      return changeDisplayName;
                    }()
                  }, {
                    key: "openConnection",
                    value: function() {
                      var _openConnection = (0, asyncToGenerator.A)(regenerator_default().mark(function _callee90(_ref19) {
                        var roomId, payload;
                        return regenerator_default().wrap(function(_context90) {
                          while (1) switch (_context90.prev = _context90.next) {
                            case 0:
                              roomId = _ref19.roomId, payload = _ref19.payload;
                              _context90.next = 1;
                              return this._socketRequest("openConnection", {
                                roomId,
                                payload
                              })["catch"](function(err) {
                                throw new Error(err);
                              });
                            case 1:
                            case "end":
                              return _context90.stop();
                          }
                        }, _callee90, this);
                      }));
                      function openConnection(_x87) {
                        return _openConnection.apply(this, arguments);
                      }
                      return openConnection;
                    }()
                  }, {
                    key: "closeConnection",
                    value: function() {
                      var _closeConnection = (0, asyncToGenerator.A)(regenerator_default().mark(function _callee91(roomId) {
                        return regenerator_default().wrap(function(_context91) {
                          while (1) switch (_context91.prev = _context91.next) {
                            case 0:
                              _context91.next = 1;
                              return this._socketRequest("closeConnection", {
                                roomId
                              });
                            case 1:
                            case "end":
                              return _context91.stop();
                          }
                        }, _callee91, this);
                      }));
                      function closeConnection(_x88) {
                        return _closeConnection.apply(this, arguments);
                      }
                      return closeConnection;
                    }()
                  }, {
                    key: "switchPeerRoom",
                    value: function() {
                      var _switchPeerRoom = (0, asyncToGenerator.A)(regenerator_default().mark(function _callee92(_ref20) {
                        var peerId, roomId, payload, token;
                        return regenerator_default().wrap(function(_context92) {
                          while (1) switch (_context92.prev = _context92.next) {
                            case 0:
                              peerId = _ref20.peerId, roomId = _ref20.roomId, payload = _ref20.payload, token = _ref20.token;
                              _context92.next = 1;
                              return this._socketRequest("switchPeerRoom", {
                                roomId,
                                peerId,
                                payload,
                                token
                              });
                            case 1:
                            case "end":
                              return _context92.stop();
                          }
                        }, _callee92, this);
                      }));
                      function switchPeerRoom(_x89) {
                        return _switchPeerRoom.apply(this, arguments);
                      }
                      return switchPeerRoom;
                    }()
                  }, {
                    key: "connectionSwitchPeerRoom",
                    value: function() {
                      var _connectionSwitchPeerRoom = (0, asyncToGenerator.A)(regenerator_default().mark(function _callee93(_ref21) {
                        var roomId, connectionRoomId, peerId, payload, token;
                        return regenerator_default().wrap(function(_context93) {
                          while (1) switch (_context93.prev = _context93.next) {
                            case 0:
                              roomId = _ref21.roomId, connectionRoomId = _ref21.connectionRoomId, peerId = _ref21.peerId, payload = _ref21.payload, token = _ref21.token;
                              _context93.next = 1;
                              return this._socketRequest("connectionSwitchPeerRoom", {
                                roomId,
                                connectionRoomId,
                                peerId,
                                payload,
                                token
                              });
                            case 1:
                            case "end":
                              return _context93.stop();
                          }
                        }, _callee93, this);
                      }));
                      function connectionSwitchPeerRoom(_x90) {
                        return _connectionSwitchPeerRoom.apply(this, arguments);
                      }
                      return connectionSwitchPeerRoom;
                    }()
                  }, {
                    key: "connectionSendChatMessage",
                    value: function() {
                      var _connectionSendChatMessage = (0, asyncToGenerator.A)(regenerator_default().mark(function _callee94(_ref22) {
                        var roomId, message;
                        return regenerator_default().wrap(function(_context94) {
                          while (1) switch (_context94.prev = _context94.next) {
                            case 0:
                              roomId = _ref22.roomId, message = _ref22.message;
                              _context94.next = 1;
                              return this._socketRequest("connectionSendChatMessage", {
                                roomId,
                                message
                              });
                            case 1:
                            case "end":
                              return _context94.stop();
                          }
                        }, _callee94, this);
                      }));
                      function connectionSendChatMessage(_x91) {
                        return _connectionSendChatMessage.apply(this, arguments);
                      }
                      return connectionSendChatMessage;
                    }()
                  }, {
                    key: "connectionEndMeeting",
                    value: function() {
                      var _connectionEndMeeting = (0, asyncToGenerator.A)(regenerator_default().mark(function _callee95(_ref23) {
                        var roomId;
                        return regenerator_default().wrap(function(_context95) {
                          while (1) switch (_context95.prev = _context95.next) {
                            case 0:
                              roomId = _ref23.roomId;
                              _context95.next = 1;
                              return this._socketRequest("connectionCloseRoom", {
                                roomId
                              });
                            case 1:
                            case "end":
                              return _context95.stop();
                          }
                        }, _callee95, this);
                      }));
                      function connectionEndMeeting(_x92) {
                        return _connectionEndMeeting.apply(this, arguments);
                      }
                      return connectionEndMeeting;
                    }()
                  }, {
                    key: "setValue",
                    value: function() {
                      var _setValue = (0, asyncToGenerator.A)(regenerator_default().mark(function _callee96(key, value2) {
                        var sizeInBytes, resp, _t82;
                        return regenerator_default().wrap(function(_context96) {
                          while (1) switch (_context96.prev = _context96.next) {
                            case 0:
                              _context96.prev = 0;
                              if (!(key === void 0 || key === null)) {
                                _context96.next = 1;
                                break;
                              }
                              throw new Error("The 'key' parameter is required.");
                            case 1:
                              if (!(typeof key !== "string")) {
                                _context96.next = 2;
                                break;
                              }
                              throw new TypeError("Invalid type for 'key'. Expected a string.");
                            case 2:
                              if (!(value2 !== null && typeof value2 !== "string")) {
                                _context96.next = 3;
                                break;
                              }
                              throw new TypeError("Invalid type for 'value'. Expected a string or null.");
                            case 3:
                              if (!(value2 !== null)) {
                                _context96.next = 4;
                                break;
                              }
                              sizeInBytes = new TextEncoder().encode(value2).length;
                              if (!(sizeInBytes > 1024)) {
                                _context96.next = 4;
                                break;
                              }
                              throw new Error("Payload too large: ".concat(sizeInBytes, " bytes. Maximum allowed size is 1024 bytes (1KB)."));
                            case 4:
                              _context96.next = 5;
                              return this._socketRequest("realtimeStoreSet", {
                                key,
                                value: value2
                              });
                            case 5:
                              resp = _context96.sent;
                              if (!(resp.status === "error")) {
                                _context96.next = 6;
                                break;
                              }
                              throw new Error(resp.message ? resp.message : "Something went wrong while setting value in Realtime Store");
                            case 6:
                              _context96.next = 8;
                              break;
                            case 7:
                              _context96.prev = 7;
                              _t82 = _context96["catch"](0);
                              console.error("Failed to set value for key '".concat(key, "':"), _t82.message);
                              throw _t82;
                            case 8:
                            case "end":
                              return _context96.stop();
                          }
                        }, _callee96, this, [[0, 7]]);
                      }));
                      function setValue(_x93, _x94) {
                        return _setValue.apply(this, arguments);
                      }
                      return setValue;
                    }()
                  }, {
                    key: "getValue",
                    value: function() {
                      var _getValue = (0, asyncToGenerator.A)(regenerator_default().mark(function _callee97(key) {
                        var response, _t83;
                        return regenerator_default().wrap(function(_context97) {
                          while (1) switch (_context97.prev = _context97.next) {
                            case 0:
                              _context97.prev = 0;
                              if (!(key === void 0 || key === null)) {
                                _context97.next = 1;
                                break;
                              }
                              throw new Error("The 'key' parameter is required.");
                            case 1:
                              if (!(typeof key !== "string")) {
                                _context97.next = 2;
                                break;
                              }
                              throw new TypeError("Invalid type for 'key'. Expected a string.");
                            case 2:
                              _context97.next = 3;
                              return this._socketRequest("realtimeStoreGet", {
                                key
                              });
                            case 3:
                              response = _context97.sent;
                              if (!(response && response.status === "ok" && response.value)) {
                                _context97.next = 4;
                                break;
                              }
                              return _context97.abrupt("return", response.value);
                            case 4:
                              if (!(response.status === "error")) {
                                _context97.next = 5;
                                break;
                              }
                              throw new Error(response.message ? response.message : "Something went wrong while getting value from Realtime Store");
                            case 5:
                              return _context97.abrupt("return", null);
                            case 6:
                              _context97.prev = 6;
                              _t83 = _context97["catch"](0);
                              console.error("Failed to get value for key '".concat(key, "':"), _t83.message);
                              throw _t83;
                            case 7:
                            case "end":
                              return _context97.stop();
                          }
                        }, _callee97, this, [[0, 6]]);
                      }));
                      function getValue(_x95) {
                        return _getValue.apply(this, arguments);
                      }
                      return getValue;
                    }()
                  }, {
                    key: "observe",
                    value: function() {
                      var _observe = (0, asyncToGenerator.A)(regenerator_default().mark(function _callee98(key) {
                        var _this$_videosdkLogs115, _this$_videosdkLogs116, _t84;
                        return regenerator_default().wrap(function(_context98) {
                          while (1) switch (_context98.prev = _context98.next) {
                            case 0:
                              if (!this._closed) {
                                _context98.next = 1;
                                break;
                              }
                              return _context98.abrupt("return");
                            case 1:
                              _context98.prev = 1;
                              _context98.next = 2;
                              return this._socketRequest("realtimeStoreObserve", {
                                key
                              });
                            case 2:
                              (_this$_videosdkLogs115 = this._videosdkLogs) === null || _this$_videosdkLogs115 === void 0 || _this$_videosdkLogs115.pushLogs({
                                logText: "RealtimeStore observation started successfully for key '".concat(key, "'."),
                                logType: "INFO"
                              });
                              _context98.next = 4;
                              break;
                            case 3:
                              _context98.prev = 3;
                              _t84 = _context98["catch"](1);
                              (_this$_videosdkLogs116 = this._videosdkLogs) === null || _this$_videosdkLogs116 === void 0 || _this$_videosdkLogs116.pushLogs({
                                logText: "Error observe() | failed",
                                logType: "ERROR",
                                attributes: {
                                  error: _t84.message
                                }
                              });
                              throw _t84;
                            case 4:
                            case "end":
                              return _context98.stop();
                          }
                        }, _callee98, this, [[1, 3]]);
                      }));
                      function observe(_x96) {
                        return _observe.apply(this, arguments);
                      }
                      return observe;
                    }()
                  }, {
                    key: "stopObserving",
                    value: function() {
                      var _stopObserving = (0, asyncToGenerator.A)(regenerator_default().mark(function _callee99(key) {
                        var _this$_videosdkLogs117, _this$_videosdkLogs118, _t85;
                        return regenerator_default().wrap(function(_context99) {
                          while (1) switch (_context99.prev = _context99.next) {
                            case 0:
                              if (!this._closed) {
                                _context99.next = 1;
                                break;
                              }
                              return _context99.abrupt("return");
                            case 1:
                              _context99.prev = 1;
                              _context99.next = 2;
                              return this._socketRequest("realtimeStoreStopObserve", {
                                key
                              });
                            case 2:
                              (_this$_videosdkLogs117 = this._videosdkLogs) === null || _this$_videosdkLogs117 === void 0 || _this$_videosdkLogs117.pushLogs({
                                logText: "RealtimeStore observation stopped successfully for key '".concat(key, "'."),
                                logType: "INFO"
                              });
                              _context99.next = 4;
                              break;
                            case 3:
                              _context99.prev = 3;
                              _t85 = _context99["catch"](1);
                              (_this$_videosdkLogs118 = this._videosdkLogs) === null || _this$_videosdkLogs118 === void 0 || _this$_videosdkLogs118.pushLogs({
                                logText: "Error stopObserving() | failed",
                                logType: "ERROR",
                                attributes: {
                                  error: _t85.message
                                }
                              });
                              throw _t85;
                            case 4:
                            case "end":
                              return _context99.stop();
                          }
                        }, _callee99, this, [[1, 3]]);
                      }));
                      function stopObserving(_x97) {
                        return _stopObserving.apply(this, arguments);
                      }
                      return stopObserving;
                    }()
                  }, {
                    key: "pubsubPublish",
                    value: function() {
                      var _pubsubPublish = (0, asyncToGenerator.A)(regenerator_default().mark(function _callee100(topic, message, options, payload) {
                        var sendOnly, sendOnlyToString, _iterator4, _step4, s, _this$_videosdkLogs119, _t86;
                        return regenerator_default().wrap(function(_context100) {
                          while (1) switch (_context100.prev = _context100.next) {
                            case 0:
                              _context100.prev = 0;
                              if (options !== null && options !== void 0 && options.sendOnly) {
                                sendOnly = options.sendOnly;
                                sendOnlyToString = [];
                                if (sendOnly) {
                                  _iterator4 = RoomClient_createForOfIteratorHelper(sendOnly);
                                  try {
                                    for (_iterator4.s(); !(_step4 = _iterator4.n()).done; ) {
                                      s = _step4.value;
                                      if (s) {
                                        sendOnlyToString.push(s.toString());
                                      }
                                    }
                                  } catch (err) {
                                    _iterator4.e(err);
                                  } finally {
                                    _iterator4.f();
                                  }
                                }
                                options.sendOnly = sendOnlyToString;
                              }
                              _context100.next = 1;
                              return this._socketRequestForPubsub("pubsubPublish", {
                                topic,
                                message,
                                options,
                                payload
                              });
                            case 1:
                              _context100.next = 3;
                              break;
                            case 2:
                              _context100.prev = 2;
                              _t86 = _context100["catch"](0);
                              (_this$_videosdkLogs119 = this._videosdkLogs) === null || _this$_videosdkLogs119 === void 0 || _this$_videosdkLogs119.pushLogs({
                                logText: "Error pubsubPublish() | failed",
                                logType: "ERROR",
                                attributes: {
                                  error: _t86.message
                                }
                              });
                              logger.error("pubsubPublish() | failed: %o", _t86);
                              throw new Error("".concat(_t86.message === "operation has timed out" ? "Message publishing timed out. Please check your network connection and try again." : "Pubsub Publish Error : ".concat(_t86.message)));
                            case 3:
                            case "end":
                              return _context100.stop();
                          }
                        }, _callee100, this, [[0, 2]]);
                      }));
                      function pubsubPublish(_x98, _x99, _x100, _x101) {
                        return _pubsubPublish.apply(this, arguments);
                      }
                      return pubsubPublish;
                    }()
                  }, {
                    key: "pubsubSubscribe",
                    value: function() {
                      var _pubsubSubscribe = (0, asyncToGenerator.A)(regenerator_default().mark(function _callee101(topic) {
                        var messageArr, _this$_videosdkLogs120, _t87;
                        return regenerator_default().wrap(function(_context101) {
                          while (1) switch (_context101.prev = _context101.next) {
                            case 0:
                              if (!this._closed) {
                                _context101.next = 1;
                                break;
                              }
                              return _context101.abrupt("return");
                            case 1:
                              _context101.prev = 1;
                              _context101.next = 2;
                              return this._socketRequest("pubsubSubscribe", {
                                topic
                              });
                            case 2:
                              messageArr = _context101.sent;
                              return _context101.abrupt("return", messageArr);
                            case 3:
                              _context101.prev = 3;
                              _t87 = _context101["catch"](1);
                              (_this$_videosdkLogs120 = this._videosdkLogs) === null || _this$_videosdkLogs120 === void 0 || _this$_videosdkLogs120.pushLogs({
                                logText: "Error pubsubSubscribe() | failed",
                                logType: "ERROR",
                                attributes: {
                                  error: _t87.message
                                }
                              });
                              logger.error("pubsubSubscribe() | failed: %o", _t87);
                            case 4:
                            case "end":
                              return _context101.stop();
                          }
                        }, _callee101, this, [[1, 3]]);
                      }));
                      function pubsubSubscribe(_x102) {
                        return _pubsubSubscribe.apply(this, arguments);
                      }
                      return pubsubSubscribe;
                    }()
                  }, {
                    key: "pubsubUnsubscribe",
                    value: function() {
                      var _pubsubUnsubscribe = (0, asyncToGenerator.A)(regenerator_default().mark(function _callee102(topic) {
                        var _this$_videosdkLogs121, _this$_videosdkLogs122, _t88;
                        return regenerator_default().wrap(function(_context102) {
                          while (1) switch (_context102.prev = _context102.next) {
                            case 0:
                              if (!this._closed) {
                                _context102.next = 1;
                                break;
                              }
                              return _context102.abrupt("return");
                            case 1:
                              _context102.prev = 1;
                              _context102.next = 2;
                              return this._socketRequest("pubsubUnsubscribe", {
                                topic
                              });
                            case 2:
                              (_this$_videosdkLogs121 = this._videosdkLogs) === null || _this$_videosdkLogs121 === void 0 || _this$_videosdkLogs121.pushLogs({
                                logText: "Pubsub Unsubscribing Successfully for topic ".concat(topic),
                                logType: "INFO"
                              });
                              _context102.next = 4;
                              break;
                            case 3:
                              _context102.prev = 3;
                              _t88 = _context102["catch"](1);
                              (_this$_videosdkLogs122 = this._videosdkLogs) === null || _this$_videosdkLogs122 === void 0 || _this$_videosdkLogs122.pushLogs({
                                logText: "Error pubsubUnsubscribe() | failed",
                                logType: "ERROR",
                                attributes: {
                                  error: _t88.message
                                }
                              });
                              logger.error("pubsubUnsubscribe() | failed: %o", _t88);
                            case 4:
                            case "end":
                              return _context102.stop();
                          }
                        }, _callee102, this, [[1, 3]]);
                      }));
                      function pubsubUnsubscribe(_x103) {
                        return _pubsubUnsubscribe.apply(this, arguments);
                      }
                      return pubsubUnsubscribe;
                    }()
                  }, {
                    key: "closeRoom",
                    value: function() {
                      var _closeRoom = (0, asyncToGenerator.A)(regenerator_default().mark(function _callee103() {
                        return regenerator_default().wrap(function(_context103) {
                          while (1) switch (_context103.prev = _context103.next) {
                            case 0:
                              _context103.next = 1;
                              return this._socketRequest("closeRoom", {});
                            case 1:
                            case "end":
                              return _context103.stop();
                          }
                        }, _callee103, this);
                      }));
                      function closeRoom() {
                        return _closeRoom.apply(this, arguments);
                      }
                      return closeRoom;
                    }()
                  }, {
                    key: "removePeer",
                    value: function() {
                      var _removePeer = (0, asyncToGenerator.A)(regenerator_default().mark(function _callee104(peerId) {
                        var _this$_openTelemetry233;
                        return regenerator_default().wrap(function(_context104) {
                          while (1) switch (_context104.prev = _context104.next) {
                            case 0:
                              (_this$_openTelemetry233 = this._openTelemetry) === null || _this$_openTelemetry233 === void 0 || _this$_openTelemetry233.traceAutoComplete({
                                spanName: "Removing peer ".concat(peerId),
                                status: 1
                              });
                              if (!(peerId == null)) {
                                _context104.next = 1;
                                break;
                              }
                              return _context104.abrupt("return");
                            case 1:
                              _context104.next = 2;
                              return this._socketRequest("removePeer", {
                                peerId
                              });
                            case 2:
                            case "end":
                              return _context104.stop();
                          }
                        }, _callee104, this);
                      }));
                      function removePeer2(_x104) {
                        return _removePeer.apply(this, arguments);
                      }
                      return removePeer2;
                    }()
                  }, {
                    key: "getSendTransportRemoteStats",
                    value: function() {
                      var _getSendTransportRemoteStats = (0, asyncToGenerator.A)(regenerator_default().mark(function _callee105() {
                        return regenerator_default().wrap(function(_context105) {
                          while (1) switch (_context105.prev = _context105.next) {
                            case 0:
                              logger.debug("getSendTransportRemoteStats()");
                              if (this._sendTransport) {
                                _context105.next = 1;
                                break;
                              }
                              return _context105.abrupt("return");
                            case 1:
                              return _context105.abrupt("return", this._socketRequest("getTransportStats", {
                                transportId: this._sendTransport.id
                              }));
                            case 2:
                            case "end":
                              return _context105.stop();
                          }
                        }, _callee105, this);
                      }));
                      function getSendTransportRemoteStats() {
                        return _getSendTransportRemoteStats.apply(this, arguments);
                      }
                      return getSendTransportRemoteStats;
                    }()
                  }, {
                    key: "getRecvTransportRemoteStats",
                    value: function() {
                      var _getRecvTransportRemoteStats = (0, asyncToGenerator.A)(regenerator_default().mark(function _callee106() {
                        return regenerator_default().wrap(function(_context106) {
                          while (1) switch (_context106.prev = _context106.next) {
                            case 0:
                              logger.debug("getRecvTransportRemoteStats()");
                              if (this._recvTransport) {
                                _context106.next = 1;
                                break;
                              }
                              return _context106.abrupt("return");
                            case 1:
                              return _context106.abrupt("return", this._socketRequest("getTransportStats", {
                                transportId: this._recvTransport.id
                              }));
                            case 2:
                            case "end":
                              return _context106.stop();
                          }
                        }, _callee106, this);
                      }));
                      function getRecvTransportRemoteStats() {
                        return _getRecvTransportRemoteStats.apply(this, arguments);
                      }
                      return getRecvTransportRemoteStats;
                    }()
                    /**
                     *
                     * @returns {Promise<[{
                     *   bitrate: number,
                     *   roundTripTime: number,
                     *   jitter: number,
                     *   totalPackets: number,
                     *   packetsLost: number,
                     *   network: String,
                     *   codec: String,
                     * }]>}
                     */
                  }, {
                    key: "getAudioRemoteStats",
                    value: function() {
                      var _getAudioRemoteStats = (0, asyncToGenerator.A)(regenerator_default().mark(function _callee107() {
                        var producer;
                        return regenerator_default().wrap(function(_context107) {
                          while (1) switch (_context107.prev = _context107.next) {
                            case 0:
                              logger.debug("getAudioRemoteStats()");
                              producer = this._micProducer;
                              if (producer) {
                                _context107.next = 1;
                                break;
                              }
                              return _context107.abrupt("return");
                            case 1:
                              return _context107.abrupt("return", this._latestStats[producer.id]);
                            case 2:
                            case "end":
                              return _context107.stop();
                          }
                        }, _callee107, this);
                      }));
                      function getAudioRemoteStats() {
                        return _getAudioRemoteStats.apply(this, arguments);
                      }
                      return getAudioRemoteStats;
                    }()
                  }, {
                    key: "getVideoRemoteStats",
                    value: function() {
                      var _getVideoRemoteStats = (0, asyncToGenerator.A)(regenerator_default().mark(function _callee108() {
                        var producer;
                        return regenerator_default().wrap(function(_context108) {
                          while (1) switch (_context108.prev = _context108.next) {
                            case 0:
                              logger.debug("getVideoRemoteStats()");
                              producer = this._webcamProducer;
                              if (producer) {
                                _context108.next = 1;
                                break;
                              }
                              return _context108.abrupt("return");
                            case 1:
                              return _context108.abrupt("return", this._latestStats[producer.id]);
                            case 2:
                            case "end":
                              return _context108.stop();
                          }
                        }, _callee108, this);
                      }));
                      function getVideoRemoteStats() {
                        return _getVideoRemoteStats.apply(this, arguments);
                      }
                      return getVideoRemoteStats;
                    }()
                  }, {
                    key: "getShareRemoteStats",
                    value: function() {
                      var _getShareRemoteStats = (0, asyncToGenerator.A)(regenerator_default().mark(function _callee109() {
                        var producer;
                        return regenerator_default().wrap(function(_context109) {
                          while (1) switch (_context109.prev = _context109.next) {
                            case 0:
                              logger.debug("getVideoRemoteStats()");
                              producer = this._shareProducer;
                              if (producer) {
                                _context109.next = 1;
                                break;
                              }
                              return _context109.abrupt("return");
                            case 1:
                              return _context109.abrupt("return", this._latestStats[producer.id]);
                            case 2:
                            case "end":
                              return _context109.stop();
                          }
                        }, _callee109, this);
                      }));
                      function getShareRemoteStats() {
                        return _getShareRemoteStats.apply(this, arguments);
                      }
                      return getShareRemoteStats;
                    }()
                  }, {
                    key: "getShareAudioRemoteStats",
                    value: function() {
                      var _getShareAudioRemoteStats = (0, asyncToGenerator.A)(regenerator_default().mark(function _callee110() {
                        var shareAudioProducer;
                        return regenerator_default().wrap(function(_context110) {
                          while (1) switch (_context110.prev = _context110.next) {
                            case 0:
                              shareAudioProducer = this._shareAudioProducer;
                              if (shareAudioProducer) {
                                _context110.next = 1;
                                break;
                              }
                              return _context110.abrupt("return");
                            case 1:
                              return _context110.abrupt("return", this._latestStats[shareAudioProducer.id]);
                            case 2:
                            case "end":
                              return _context110.stop();
                          }
                        }, _callee110, this);
                      }));
                      function getShareAudioRemoteStats() {
                        return _getShareAudioRemoteStats.apply(this, arguments);
                      }
                      return getShareAudioRemoteStats;
                    }()
                    /**
                     *
                     * @param {string} consumerId
                     * @returns {Promise<[{
                     *   bitrate: number,
                     *   rtt: number,
                     *   network:String,
                     *   codec: String,
                     *   jitter: number,
                     *   totalPackets: number,
                     *   packetsLost: number,
                     *   concealmentEvents: number,
                     *   insertedSamplesForDecelaration: number,
                     *   removedSamplesForAccelaration: number,
                     *   size:Object
                     * }]>}
                     */
                  }, {
                    key: "getConsumerRemoteStats",
                    value: function() {
                      var _getConsumerRemoteStats = (0, asyncToGenerator.A)(regenerator_default().mark(function _callee111(consumerId) {
                        var consumer, result;
                        return regenerator_default().wrap(function(_context111) {
                          while (1) switch (_context111.prev = _context111.next) {
                            case 0:
                              logger.debug("getConsumerRemoteStats()");
                              consumer = this._consumers.get(consumerId);
                              if (consumer) {
                                _context111.next = 1;
                                break;
                              }
                              return _context111.abrupt("return");
                            case 1:
                              if (this._latestStats[consumerId]) {
                                this._latestStats[consumerId][0].currentSpatialLayer = consumer.currentSpatialLayer;
                                this._latestStats[consumerId][0].currentTemporalLayer = consumer.currentTemporalLayer;
                                this._latestStats[consumerId][0].preferredSpatialLayer = consumer.preferredSpatialLayer;
                                this._latestStats[consumerId][0].preferredTemporalLayer = consumer.preferredTemporalLayer;
                              }
                              result = consumer.track.id.replace(/[{}]/g, "");
                              return _context111.abrupt("return", this._latestStats[result]);
                            case 2:
                            case "end":
                              return _context111.stop();
                          }
                        }, _callee111, this);
                      }));
                      function getConsumerRemoteStats(_x105) {
                        return _getConsumerRemoteStats.apply(this, arguments);
                      }
                      return getConsumerRemoteStats;
                    }()
                  }, {
                    key: "getChatDataProducerRemoteStats",
                    value: function() {
                      var _getChatDataProducerRemoteStats = (0, asyncToGenerator.A)(regenerator_default().mark(function _callee112() {
                        var dataProducer;
                        return regenerator_default().wrap(function(_context112) {
                          while (1) switch (_context112.prev = _context112.next) {
                            case 0:
                              logger.debug("getChatDataProducerRemoteStats()");
                              dataProducer = this._reliableDataProducer;
                              if (dataProducer) {
                                _context112.next = 1;
                                break;
                              }
                              return _context112.abrupt("return");
                            case 1:
                              return _context112.abrupt("return", this._socketRequest("getDataProducerStats", {
                                dataProducerId: dataProducer.id
                              }));
                            case 2:
                            case "end":
                              return _context112.stop();
                          }
                        }, _callee112, this);
                      }));
                      function getChatDataProducerRemoteStats() {
                        return _getChatDataProducerRemoteStats.apply(this, arguments);
                      }
                      return getChatDataProducerRemoteStats;
                    }()
                  }, {
                    key: "getDataConsumerRemoteStats",
                    value: function() {
                      var _getDataConsumerRemoteStats = (0, asyncToGenerator.A)(regenerator_default().mark(function _callee113(dataConsumerId) {
                        var dataConsumer;
                        return regenerator_default().wrap(function(_context113) {
                          while (1) switch (_context113.prev = _context113.next) {
                            case 0:
                              logger.debug("getDataConsumerRemoteStats()");
                              dataConsumer = this._dataConsumers.get(dataConsumerId);
                              if (dataConsumer) {
                                _context113.next = 1;
                                break;
                              }
                              return _context113.abrupt("return");
                            case 1:
                              return _context113.abrupt("return", this._socketRequest("getDataConsumerStats", {
                                dataConsumerId
                              }));
                            case 2:
                            case "end":
                              return _context113.stop();
                          }
                        }, _callee113, this);
                      }));
                      function getDataConsumerRemoteStats(_x106) {
                        return _getDataConsumerRemoteStats.apply(this, arguments);
                      }
                      return getDataConsumerRemoteStats;
                    }()
                  }, {
                    key: "getSendTransportLocalStats",
                    value: function() {
                      var _getSendTransportLocalStats = (0, asyncToGenerator.A)(regenerator_default().mark(function _callee114() {
                        return regenerator_default().wrap(function(_context114) {
                          while (1) switch (_context114.prev = _context114.next) {
                            case 0:
                              logger.debug("getSendTransportLocalStats()");
                              if (this._sendTransport) {
                                _context114.next = 1;
                                break;
                              }
                              return _context114.abrupt("return");
                            case 1:
                              return _context114.abrupt("return", this._sendTransport.getStats());
                            case 2:
                            case "end":
                              return _context114.stop();
                          }
                        }, _callee114, this);
                      }));
                      function getSendTransportLocalStats() {
                        return _getSendTransportLocalStats.apply(this, arguments);
                      }
                      return getSendTransportLocalStats;
                    }()
                  }, {
                    key: "getRecvTransportLocalStats",
                    value: function() {
                      var _getRecvTransportLocalStats = (0, asyncToGenerator.A)(regenerator_default().mark(function _callee115() {
                        return regenerator_default().wrap(function(_context115) {
                          while (1) switch (_context115.prev = _context115.next) {
                            case 0:
                              logger.debug("getRecvTransportLocalStats()");
                              if (this._recvTransport) {
                                _context115.next = 1;
                                break;
                              }
                              return _context115.abrupt("return");
                            case 1:
                              return _context115.abrupt("return", this._recvTransport.getStats());
                            case 2:
                            case "end":
                              return _context115.stop();
                          }
                        }, _callee115, this);
                      }));
                      function getRecvTransportLocalStats() {
                        return _getRecvTransportLocalStats.apply(this, arguments);
                      }
                      return getRecvTransportLocalStats;
                    }()
                  }, {
                    key: "getAudioLocalStats",
                    value: function() {
                      var _getAudioLocalStats = (0, asyncToGenerator.A)(regenerator_default().mark(function _callee116() {
                        return regenerator_default().wrap(function(_context116) {
                          while (1) switch (_context116.prev = _context116.next) {
                            case 0:
                              logger.debug("getAudioLocalStats()");
                              if (this._micProducer) {
                                _context116.next = 1;
                                break;
                              }
                              return _context116.abrupt("return");
                            case 1:
                              return _context116.abrupt("return", this._micProducer.getStats());
                            case 2:
                            case "end":
                              return _context116.stop();
                          }
                        }, _callee116, this);
                      }));
                      function getAudioLocalStats() {
                        return _getAudioLocalStats.apply(this, arguments);
                      }
                      return getAudioLocalStats;
                    }()
                  }, {
                    key: "getVideoLocalStats",
                    value: function() {
                      var _getVideoLocalStats = (0, asyncToGenerator.A)(regenerator_default().mark(function _callee117() {
                        var producer;
                        return regenerator_default().wrap(function(_context117) {
                          while (1) switch (_context117.prev = _context117.next) {
                            case 0:
                              logger.debug("getVideoLocalStats()");
                              producer = this._webcamProducer || this._shareProducer;
                              if (producer) {
                                _context117.next = 1;
                                break;
                              }
                              return _context117.abrupt("return");
                            case 1:
                              return _context117.abrupt("return", producer.getStats());
                            case 2:
                            case "end":
                              return _context117.stop();
                          }
                        }, _callee117, this);
                      }));
                      function getVideoLocalStats() {
                        return _getVideoLocalStats.apply(this, arguments);
                      }
                      return getVideoLocalStats;
                    }()
                  }, {
                    key: "getConsumerLocalStats",
                    value: function() {
                      var _getConsumerLocalStats = (0, asyncToGenerator.A)(regenerator_default().mark(function _callee118(consumerId) {
                        var consumer;
                        return regenerator_default().wrap(function(_context118) {
                          while (1) switch (_context118.prev = _context118.next) {
                            case 0:
                              consumer = this._consumers.get(consumerId);
                              if (consumer) {
                                _context118.next = 1;
                                break;
                              }
                              return _context118.abrupt("return");
                            case 1:
                              return _context118.abrupt("return", consumer.getStats());
                            case 2:
                            case "end":
                              return _context118.stop();
                          }
                        }, _callee118, this);
                      }));
                      function getConsumerLocalStats(_x107) {
                        return _getConsumerLocalStats.apply(this, arguments);
                      }
                      return getConsumerLocalStats;
                    }()
                  }, {
                    key: "getTransportRemoteStats",
                    value: function() {
                      var _getTransportRemoteStats = (0, asyncToGenerator.A)(regenerator_default().mark(function _callee119(_ref24) {
                        var _response$recv, _response$recv2;
                        var participantId, response, result;
                        return regenerator_default().wrap(function(_context119) {
                          while (1) switch (_context119.prev = _context119.next) {
                            case 0:
                              participantId = _ref24.participantId;
                              if (participantId) {
                                _context119.next = 1;
                                break;
                              }
                              return _context119.abrupt("return");
                            case 1:
                              _context119.next = 2;
                              return this._socketRequest("getTransportStats", {
                                peerId: participantId
                              });
                            case 2:
                              response = _context119.sent;
                              result = {
                                availableBitrate: response === null || response === void 0 || (_response$recv = response.recv) === null || _response$recv === void 0 ? void 0 : _response$recv.availableBitrate,
                                targetBitrate: response === null || response === void 0 || (_response$recv2 = response.recv) === null || _response$recv2 === void 0 ? void 0 : _response$recv2.targetBitrate
                              };
                              return _context119.abrupt("return", result);
                            case 3:
                            case "end":
                              return _context119.stop();
                          }
                        }, _callee119, this);
                      }));
                      function getTransportRemoteStats(_x108) {
                        return _getTransportRemoteStats.apply(this, arguments);
                      }
                      return getTransportRemoteStats;
                    }()
                  }, {
                    key: "applyNetworkThrottle",
                    value: function() {
                      var _applyNetworkThrottle = (0, asyncToGenerator.A)(regenerator_default().mark(function _callee120(_ref25) {
                        var uplink, downlink, rtt, secret, _t89;
                        return regenerator_default().wrap(function(_context120) {
                          while (1) switch (_context120.prev = _context120.next) {
                            case 0:
                              uplink = _ref25.uplink, downlink = _ref25.downlink, rtt = _ref25.rtt, secret = _ref25.secret;
                              logger.debug("applyNetworkThrottle() [uplink:%s, downlink:%s, rtt:%s]", uplink, downlink, rtt);
                              _context120.prev = 1;
                              _context120.next = 2;
                              return this._socketRequest("applyNetworkThrottle", {
                                uplink,
                                downlink,
                                rtt,
                                secret
                              });
                            case 2:
                              _context120.next = 4;
                              break;
                            case 3:
                              _context120.prev = 3;
                              _t89 = _context120["catch"](1);
                              logger.error("applyNetworkThrottle() | failed:%o", _t89);
                              store.dispatch(notify({
                                type: "error",
                                text: "Error applying network throttle: ".concat(_t89)
                              }));
                            case 4:
                            case "end":
                              return _context120.stop();
                          }
                        }, _callee120, this, [[1, 3]]);
                      }));
                      function applyNetworkThrottle(_x109) {
                        return _applyNetworkThrottle.apply(this, arguments);
                      }
                      return applyNetworkThrottle;
                    }()
                  }, {
                    key: "resetNetworkThrottle",
                    value: function() {
                      var _resetNetworkThrottle = (0, asyncToGenerator.A)(regenerator_default().mark(function _callee121(_ref26) {
                        var _ref26$silent, silent, secret, _t90;
                        return regenerator_default().wrap(function(_context121) {
                          while (1) switch (_context121.prev = _context121.next) {
                            case 0:
                              _ref26$silent = _ref26.silent, silent = _ref26$silent === void 0 ? false : _ref26$silent, secret = _ref26.secret;
                              logger.debug("resetNetworkThrottle()");
                              _context121.prev = 1;
                              _context121.next = 2;
                              return this._socketRequest("resetNetworkThrottle", {
                                secret
                              });
                            case 2:
                              _context121.next = 4;
                              break;
                            case 3:
                              _context121.prev = 3;
                              _t90 = _context121["catch"](1);
                              if (!silent) {
                                logger.error("resetNetworkThrottle() | failed:%o", _t90);
                                store.dispatch(notify({
                                  type: "error",
                                  text: "Error resetting network throttle: ".concat(_t90)
                                }));
                              }
                            case 4:
                            case "end":
                              return _context121.stop();
                          }
                        }, _callee121, this, [[1, 3]]);
                      }));
                      function resetNetworkThrottle(_x110) {
                        return _resetNetworkThrottle.apply(this, arguments);
                      }
                      return resetNetworkThrottle;
                    }()
                  }, {
                    key: "createProducerTransport",
                    value: function() {
                      var _createProducerTransport = (0, asyncToGenerator.A)(regenerator_default().mark(function _callee126(transportInfo, parentSpan) {
                        var _this$_openTelemetry234, _this1 = this, _this$_openTelemetry235;
                        var id, iceParameters, iceCandidates, dtlsParameters, sctpParameters, producerTransportspan, outbTraces, remoteInbTraces, ewmaRttInMs, congested, cpuLimited, bandwidthLimited;
                        return regenerator_default().wrap(function(_context126) {
                          while (1) switch (_context126.prev = _context126.next) {
                            case 0:
                              id = transportInfo.id, iceParameters = transportInfo.iceParameters, iceCandidates = transportInfo.iceCandidates, dtlsParameters = transportInfo.dtlsParameters, sctpParameters = transportInfo.sctpParameters;
                              producerTransportspan = (_this$_openTelemetry234 = this._openTelemetry) === null || _this$_openTelemetry234 === void 0 ? void 0 : _this$_openTelemetry234.trace({
                                spanName: "Creating Send Transport",
                                span: parentSpan ? parentSpan : null
                              });
                              this._sendTransport = this._mediasoupDevice.createSendTransport({
                                id,
                                iceParameters,
                                iceCandidates,
                                dtlsParameters,
                                sctpParameters,
                                iceServers: this._iceServers
                              });
                              outbTraces = /* @__PURE__ */ new Map();
                              remoteInbTraces = /* @__PURE__ */ new Map();
                              congested = false;
                              cpuLimited = false;
                              bandwidthLimited = false;
                              this._sendTransportInternal = setInterval((0, asyncToGenerator.A)(regenerator_default().mark(function _callee122() {
                                var roundTripTimeMeasurements, reports, _this1$_sendTransport, avgRoundTripTimeInMs, isCurrentlyBandwidthLimited, isCurrentlyCPULimited, _this1$_videosdkLogs, _this1$_videosdkLogs2, _this1$_videosdkLogs3, _this1$_videosdkLogs4, _this1$_videosdkLogs5, _this1$_videosdkLogs6, _t91;
                                return regenerator_default().wrap(function(_context122) {
                                  while (1) switch (_context122.prev = _context122.next) {
                                    case 0:
                                      roundTripTimeMeasurements = [];
                                      _context122.prev = 1;
                                      _context122.next = 2;
                                      return (_this1$_sendTransport = _this1._sendTransport) === null || _this1$_sendTransport === void 0 ? void 0 : _this1$_sendTransport.getStats();
                                    case 2:
                                      reports = _context122.sent;
                                      _context122.next = 4;
                                      break;
                                    case 3:
                                      _context122.prev = 3;
                                      _t91 = _context122["catch"](1);
                                      console.error("Error fetching stats:", _t91);
                                      return _context122.abrupt("return");
                                    case 4:
                                      try {
                                        reports.forEach(function(report) {
                                          try {
                                            if (report.type === "outbound-rtp") {
                                              var newTrace = {
                                                qualityLimitationReason: report.qualityLimitationReason
                                              };
                                              outbTraces.set(report.id, newTrace);
                                            }
                                            if (report.type === "remote-inbound-rtp" && report.totalRoundTripTime && report.roundTripTimeMeasurements) {
                                              var trace = remoteInbTraces.get(report.id);
                                              if (!trace) {
                                                trace = {
                                                  totalRoundTripTime: 0,
                                                  roundTripTimeMeasurements: 0
                                                };
                                                remoteInbTraces.set(report.id, trace);
                                              }
                                              var diffMeasurements = report.roundTripTimeMeasurements - trace.roundTripTimeMeasurements;
                                              var diffTotalRoundTripTime = report.totalRoundTripTime - trace.totalRoundTripTime;
                                              if (diffMeasurements > 0 && diffTotalRoundTripTime > 0) {
                                                var avgRttInInterval = diffTotalRoundTripTime / diffMeasurements;
                                                trace.totalRoundTripTime = report.totalRoundTripTime;
                                                trace.roundTripTimeMeasurements = report.roundTripTimeMeasurements;
                                                roundTripTimeMeasurements.push(avgRttInInterval * 1e3);
                                              }
                                            }
                                          } catch (e) {
                                          }
                                        });
                                        try {
                                          avgRoundTripTimeInMs = roundTripTimeMeasurements.reduce(function(a, b) {
                                            return a + b;
                                          }, 0) / roundTripTimeMeasurements.length;
                                          if (!Number.isNaN(avgRoundTripTimeInMs)) {
                                            if (!ewmaRttInMs) {
                                              ewmaRttInMs = avgRoundTripTimeInMs;
                                            }
                                            isCurrentlyBandwidthLimited = (0, toConsumableArray.A)(outbTraces.values()).some(function(trace) {
                                              return trace.qualityLimitationReason === "bandwidth";
                                            });
                                            isCurrentlyCPULimited = (0, toConsumableArray.A)(outbTraces.values()).some(function(trace) {
                                              return trace.qualityLimitationReason === "cpu";
                                            });
                                            if (!congested && isCurrentlyBandwidthLimited && avgRoundTripTimeInMs - ewmaRttInMs > 50) {
                                              (_this1$_videosdkLogs = _this1._videosdkLogs) === null || _this1$_videosdkLogs === void 0 || _this1$_videosdkLogs.pushLogs({
                                                logType: "WARN",
                                                attributes: {
                                                  avgRoundTripTimeInMs,
                                                  ewmaRttInMs
                                                },
                                                logText: "Send Transport Congestion detected, the network is bandwidth limited and the round trip time is increasing (ewmaRtt: ".concat(ewmaRttInMs, ", avgRoundTripTime: ").concat(avgRoundTripTimeInMs, ")")
                                              });
                                              congested = true;
                                              _this1._eventEmitter.emit("QUALITY_LIMITATION_INTERNAL", {
                                                type: "congestion",
                                                state: "detected",
                                                timestamp: (/* @__PURE__ */ new Date()).getTime()
                                              });
                                            } else if (congested && avgRoundTripTimeInMs - ewmaRttInMs < 30) {
                                              (_this1$_videosdkLogs2 = _this1._videosdkLogs) === null || _this1$_videosdkLogs2 === void 0 || _this1$_videosdkLogs2.pushLogs({
                                                logType: "INFO",
                                                attributes: {
                                                  avgRoundTripTimeInMs,
                                                  ewmaRttInMs
                                                },
                                                logText: "Send Transport  Congestion resolved, the round trip time is back to normal (ewmaRtt: ".concat(ewmaRttInMs, ", avgRoundTripTime: ").concat(avgRoundTripTimeInMs, ")")
                                              });
                                              congested = false;
                                              _this1._eventEmitter.emit("QUALITY_LIMITATION_INTERNAL", {
                                                type: "congestion",
                                                state: "resolved",
                                                timestamp: (/* @__PURE__ */ new Date()).getTime()
                                              });
                                            }
                                            if (isCurrentlyBandwidthLimited && !bandwidthLimited) {
                                              (_this1$_videosdkLogs3 = _this1._videosdkLogs) === null || _this1$_videosdkLogs3 === void 0 || _this1$_videosdkLogs3.pushLogs({
                                                logType: "WARN",
                                                logText: "Bandwidth Limitation detected"
                                              });
                                              _this1._eventEmitter.emit("QUALITY_LIMITATION_INTERNAL", {
                                                type: "bandwidth",
                                                state: "detected",
                                                timestamp: (/* @__PURE__ */ new Date()).getTime()
                                              });
                                              bandwidthLimited = true;
                                            } else if (!isCurrentlyBandwidthLimited && bandwidthLimited) {
                                              (_this1$_videosdkLogs4 = _this1._videosdkLogs) === null || _this1$_videosdkLogs4 === void 0 || _this1$_videosdkLogs4.pushLogs({
                                                logType: "INFO",
                                                logText: "Bandwidth Limitation resolved"
                                              });
                                              _this1._eventEmitter.emit("QUALITY_LIMITATION_INTERNAL", {
                                                type: "bandwidth",
                                                state: "resolved",
                                                timestamp: (/* @__PURE__ */ new Date()).getTime()
                                              });
                                              bandwidthLimited = false;
                                            }
                                            ewmaRttInMs = 0.9 * ewmaRttInMs + 0.1 * avgRoundTripTimeInMs;
                                            if (!cpuLimited && isCurrentlyCPULimited) {
                                              _this1._eventEmitter.emit("QUALITY_LIMITATION_INTERNAL", {
                                                type: "cpu",
                                                state: "detected",
                                                timestamp: (/* @__PURE__ */ new Date()).getTime()
                                              });
                                              (_this1$_videosdkLogs5 = _this1._videosdkLogs) === null || _this1$_videosdkLogs5 === void 0 || _this1$_videosdkLogs5.pushLogs({
                                                logType: "WARN",
                                                logText: "CPU Limitation detected"
                                              });
                                              cpuLimited = true;
                                            } else if (cpuLimited && !isCurrentlyCPULimited) {
                                              _this1._eventEmitter.emit("QUALITY_LIMITATION_INTERNAL", {
                                                type: "cpu",
                                                state: "resolved",
                                                timestamp: (/* @__PURE__ */ new Date()).getTime()
                                              });
                                              (_this1$_videosdkLogs6 = _this1._videosdkLogs) === null || _this1$_videosdkLogs6 === void 0 || _this1$_videosdkLogs6.pushLogs({
                                                logType: "INFO",
                                                logText: "CPU Limitation resolved"
                                              });
                                              cpuLimited = false;
                                            }
                                          }
                                        } catch (eee) {
                                        }
                                      } catch (err) {
                                      }
                                    case 5:
                                    case "end":
                                      return _context122.stop();
                                  }
                                }, _callee122, null, [[1, 3]]);
                              })), 1e3);
                              this._sendTransport.on("connect", function(_ref28, callback, errback) {
                                var _this1$_openTelemetry;
                                var dtlsParameters2 = _ref28.dtlsParameters;
                                (_this1$_openTelemetry = _this1._openTelemetry) === null || _this1$_openTelemetry === void 0 || _this1$_openTelemetry.traceAutoComplete({
                                  spanName: "this._sendTransport `connect` Event : Transport is about to establish the ICE+DTLS connection",
                                  span: producerTransportspan,
                                  status: 1
                                });
                                _this1._socketRequest("connectWebRtcTransport", {
                                  transportId: _this1._sendTransport.id,
                                  dtlsParameters: dtlsParameters2
                                }).then(function() {
                                  callback();
                                })["catch"](function(error) {
                                  errback(error);
                                });
                              });
                              this._sendTransport.on("produce", function() {
                                var _ref30 = (0, asyncToGenerator.A)(regenerator_default().mark(function _callee123(_ref29, callback, errback) {
                                  var kind, rtpParameters, appData, _this1$_openTelemetry2, _yield$_this1$_socket, _id3, _this1$_videosdkLogs7, _t92;
                                  return regenerator_default().wrap(function(_context123) {
                                    while (1) switch (_context123.prev = _context123.next) {
                                      case 0:
                                        kind = _ref29.kind, rtpParameters = _ref29.rtpParameters, appData = _ref29.appData;
                                        _context123.prev = 1;
                                        (_this1$_openTelemetry2 = _this1._openTelemetry) === null || _this1$_openTelemetry2 === void 0 || _this1$_openTelemetry2.traceAutoComplete({
                                          spanName: "this._sendTransport `produce` Event : Transmit information about a new producer ",
                                          span: producerTransportspan,
                                          status: 1
                                        });
                                        _context123.next = 2;
                                        return _this1._socketRequest("produce", {
                                          transportId: _this1._sendTransport.id,
                                          kind,
                                          rtpParameters,
                                          appData
                                        });
                                      case 2:
                                        _yield$_this1$_socket = _context123.sent;
                                        _id3 = _yield$_this1$_socket.id;
                                        callback({
                                          id: _id3
                                        });
                                        _context123.next = 4;
                                        break;
                                      case 3:
                                        _context123.prev = 3;
                                        _t92 = _context123["catch"](1);
                                        (_this1$_videosdkLogs7 = _this1._videosdkLogs) === null || _this1$_videosdkLogs7 === void 0 || _this1$_videosdkLogs7.pushLogs({
                                          logText: 'Error this._sendTransport "produce" Event catch',
                                          logType: "ERROR",
                                          attributes: {
                                            error: _t92.message
                                          }
                                        });
                                        errback(_t92);
                                      case 4:
                                      case "end":
                                        return _context123.stop();
                                    }
                                  }, _callee123, null, [[1, 3]]);
                                }));
                                return function(_x113, _x114, _x115) {
                                  return _ref30.apply(this, arguments);
                                };
                              }());
                              this._sendTransport.on("producedata", function() {
                                var _ref32 = (0, asyncToGenerator.A)(regenerator_default().mark(function _callee124(_ref31, callback, errback) {
                                  var sctpStreamParameters, label, protocol2, appData, _yield$_this1$_socket2, _id4, _this1$_videosdkLogs8, _t93;
                                  return regenerator_default().wrap(function(_context124) {
                                    while (1) switch (_context124.prev = _context124.next) {
                                      case 0:
                                        sctpStreamParameters = _ref31.sctpStreamParameters, label = _ref31.label, protocol2 = _ref31.protocol, appData = _ref31.appData;
                                        _context124.prev = 1;
                                        _context124.next = 2;
                                        return _this1._socketRequest("produceData", {
                                          transportId: _this1._sendTransport.id,
                                          sctpStreamParameters,
                                          label,
                                          protocol: protocol2,
                                          appData
                                        });
                                      case 2:
                                        _yield$_this1$_socket2 = _context124.sent;
                                        _id4 = _yield$_this1$_socket2.id;
                                        callback({
                                          id: _id4
                                        });
                                        _context124.next = 4;
                                        break;
                                      case 3:
                                        _context124.prev = 3;
                                        _t93 = _context124["catch"](1);
                                        (_this1$_videosdkLogs8 = _this1._videosdkLogs) === null || _this1$_videosdkLogs8 === void 0 || _this1$_videosdkLogs8.pushLogs({
                                          logText: "Error producedata event catch",
                                          logType: "ERROR",
                                          attributes: {
                                            error: _t93.message
                                          }
                                        });
                                        errback(_t93);
                                      case 4:
                                      case "end":
                                        return _context124.stop();
                                    }
                                  }, _callee124, null, [[1, 3]]);
                                }));
                                return function(_x116, _x117, _x118) {
                                  return _ref32.apply(this, arguments);
                                };
                              }());
                              this._sendTransport.on("connectionstatechange", function() {
                                var _ref33 = (0, asyncToGenerator.A)(regenerator_default().mark(function _callee125(connectionState) {
                                  var _this1$_openTelemetry3;
                                  var candidates, _this1$_videosdkLogs9, _this1$_videosdkLogs0, _t94;
                                  return regenerator_default().wrap(function(_context125) {
                                    while (1) switch (_context125.prev = _context125.next) {
                                      case 0:
                                        _t94 = Array;
                                        _context125.next = 1;
                                        return _this1._sendTransport.getStats();
                                      case 1:
                                        candidates = _t94.from.call(_t94, _context125.sent).filter(function(_ref34) {
                                          var _ref35 = (0, slicedToArray.A)(_ref34, 2), data = _ref35[1];
                                          return data.type === "local-candidate" || data.type === "remote-candidate";
                                        }).map(function(_ref36) {
                                          var _ref37 = (0, slicedToArray.A)(_ref36, 2), data = _ref37[1];
                                          return data;
                                        });
                                        if (candidates.length > 0) {
                                          (_this1$_videosdkLogs9 = _this1._videosdkLogs) === null || _this1$_videosdkLogs9 === void 0 || _this1$_videosdkLogs9.pushLogs({
                                            logText: 'Send Trasnport State Change "'.concat(connectionState, '" candidates'),
                                            logType: "INFO",
                                            attributes: {
                                              candidates: JSON.stringify(candidates)
                                            }
                                          });
                                        }
                                        if (connectionState === "connected") {
                                          _this1.emitMeetingStateChange(state.CONNECTED);
                                        }
                                        (_this1$_openTelemetry3 = _this1._openTelemetry) === null || _this1$_openTelemetry3 === void 0 || _this1$_openTelemetry3.traceAutoComplete({
                                          spanName: "_sendTransport Event connectionstatechange ".concat(connectionState),
                                          span: producerTransportspan,
                                          status: 1
                                        });
                                        if (connectionState === "failed") {
                                          (_this1$_videosdkLogs0 = _this1._videosdkLogs) === null || _this1$_videosdkLogs0 === void 0 || _this1$_videosdkLogs0.pushLogs({
                                            logText: "ERROR_MEETING_MEDIA_CONNECTION_FAILED",
                                            logType: "ERROR",
                                            attributes: {
                                              error: "Unable to connect to the meeting or media. Please check your network connection, ensure your firewall or security settings are not blocking the application, or try connecting using a different network."
                                            },
                                            dashboardLog: true
                                          });
                                          _this1.restartIce();
                                        }
                                        _this1._transportState = connectionState;
                                      case 2:
                                      case "end":
                                        return _context125.stop();
                                    }
                                  }, _callee125);
                                }));
                                return function(_x119) {
                                  return _ref33.apply(this, arguments);
                                };
                              }());
                              (_this$_openTelemetry235 = this._openTelemetry) === null || _this$_openTelemetry235 === void 0 || _this$_openTelemetry235.completeSpan({
                                span: producerTransportspan,
                                status: 1,
                                message: "Send Transport Created Successfully"
                              });
                            case 1:
                            case "end":
                              return _context126.stop();
                          }
                        }, _callee126, this);
                      }));
                      function createProducerTransport(_x111, _x112) {
                        return _createProducerTransport.apply(this, arguments);
                      }
                      return createProducerTransport;
                    }()
                  }, {
                    key: "createConsumerTransport",
                    value: function() {
                      var _createConsumerTransport = (0, asyncToGenerator.A)(regenerator_default().mark(function _callee128(transportInfo, parentSpan) {
                        var _this$_openTelemetry236, _this10 = this, _this$_openTelemetry237;
                        var id, iceParameters, iceCandidates, dtlsParameters, sctpParameters, consumerTransportspan, reportCounter, probe, traces, freezeTraces, freezeTimestamps, freezeResolvedEmitted;
                        return regenerator_default().wrap(function(_context128) {
                          while (1) switch (_context128.prev = _context128.next) {
                            case 0:
                              id = transportInfo.id, iceParameters = transportInfo.iceParameters, iceCandidates = transportInfo.iceCandidates, dtlsParameters = transportInfo.dtlsParameters, sctpParameters = transportInfo.sctpParameters;
                              consumerTransportspan = (_this$_openTelemetry236 = this._openTelemetry) === null || _this$_openTelemetry236 === void 0 ? void 0 : _this$_openTelemetry236.trace({
                                spanName: "Creating Recieve Transport",
                                span: parentSpan ? parentSpan : null
                              });
                              this._recvTransport = this._mediasoupDevice.createRecvTransport({
                                id,
                                iceParameters,
                                iceCandidates,
                                dtlsParameters,
                                sctpParameters,
                                iceServers: this._iceServers
                              });
                              this._recvTransport.on("connect", function(_ref38, callback, errback) {
                                var _this10$_openTelemetr;
                                var dtlsParameters2 = _ref38.dtlsParameters;
                                (_this10$_openTelemetr = _this10._openTelemetry) === null || _this10$_openTelemetr === void 0 || _this10$_openTelemetr.traceAutoComplete({
                                  spanName: "this._recvTransport `connect` Event : Recieve Transport is about to establish the ICE+DTLS connection",
                                  span: consumerTransportspan,
                                  status: 1
                                });
                                _this10._socketRequest("connectWebRtcTransport", {
                                  transportId: _this10._recvTransport.id,
                                  dtlsParameters: dtlsParameters2
                                }).then(function() {
                                  callback();
                                })["catch"](function(error) {
                                  errback(error);
                                });
                              });
                              this._recvTransport.on("connectionstatechange", function() {
                                var _ref39 = (0, asyncToGenerator.A)(regenerator_default().mark(function _callee127(connectionState) {
                                  var _this10$_openTelemetr2;
                                  var candidates, _this10$_videosdkLogs, _t95;
                                  return regenerator_default().wrap(function(_context127) {
                                    while (1) switch (_context127.prev = _context127.next) {
                                      case 0:
                                        _t95 = Array;
                                        _context127.next = 1;
                                        return _this10._recvTransport.getStats();
                                      case 1:
                                        candidates = _t95.from.call(_t95, _context127.sent).filter(function(_ref40) {
                                          var _ref41 = (0, slicedToArray.A)(_ref40, 2), data = _ref41[1];
                                          return data.type === "local-candidate" || data.type === "remote-candidate";
                                        }).map(function(_ref42) {
                                          var _ref43 = (0, slicedToArray.A)(_ref42, 2), data = _ref43[1];
                                          return data;
                                        });
                                        if (candidates.length > 0) {
                                          (_this10$_videosdkLogs = _this10._videosdkLogs) === null || _this10$_videosdkLogs === void 0 || _this10$_videosdkLogs.pushLogs({
                                            logText: 'Recv Trasnport State Change "'.concat(connectionState, '" candidates'),
                                            logType: "INFO",
                                            attributes: {
                                              candidates: JSON.stringify(candidates)
                                            }
                                          });
                                        }
                                        (_this10$_openTelemetr2 = _this10._openTelemetry) === null || _this10$_openTelemetr2 === void 0 || _this10$_openTelemetr2.traceAutoComplete({
                                          spanName: "_recvTransport Event connectionstatechange ".concat(connectionState),
                                          span: consumerTransportspan,
                                          status: 1
                                        });
                                        if (connectionState === "failed") {
                                          _this10.restartIce();
                                        }
                                        _this10._transportState = connectionState;
                                      case 2:
                                      case "end":
                                        return _context127.stop();
                                    }
                                  }, _callee127);
                                }));
                                return function(_x122) {
                                  return _ref39.apply(this, arguments);
                                };
                              }());
                              reportCounter = 0;
                              probe = this._metrics.addNewProbe(this._recvTransport, "transport");
                              traces = /* @__PURE__ */ new Map();
                              freezeTraces = /* @__PURE__ */ new Map();
                              freezeTimestamps = /* @__PURE__ */ new Map();
                              freezeResolvedEmitted = /* @__PURE__ */ new Set();
                              probe.onStatsCollected = function(report) {
                                try {
                                  var processStat = function processStat2(stat, consumer, consumerType) {
                                    if (!_this10._stats.consumerStats) {
                                      _this10._stats.consumerStats = {};
                                    }
                                    var peerId = consumer.appData.peerId;
                                    if (!_this10._stats.consumerStats[peerId]) {
                                      _this10._stats.consumerStats[peerId] = {};
                                    }
                                    if (!_this10._stats.consumerStats[peerId][consumerType]) {
                                      _this10._stats.consumerStats[peerId][consumerType] = [];
                                    }
                                    _this10._latestStats[consumer.track.id.replace(/[{}]/g, "")] = [stat];
                                    if (reportCounter % 5 === 0) {
                                      _this10._stats.consumerStats[peerId][consumerType].push(stat);
                                    }
                                  };
                                  var processReport = function processReport2(reportType) {
                                    report[reportType].forEach(function(stat) {
                                      var _iterator5 = RoomClient_createForOfIteratorHelper(_this10._consumers), _step5;
                                      try {
                                        for (_iterator5.s(); !(_step5 = _iterator5.n()).done; ) {
                                          var _step5$value = (0, slicedToArray.A)(_step5.value, 2), _id5 = _step5$value[0], consumer = _step5$value[1];
                                          var consumerTrackId = consumer.track.id.replace(/[{}]/g, "");
                                          if (consumerTrackId === stat.trackId) {
                                            var consumerType = consumer.appData["share"] ? consumer.kind === "audio" ? "shareAudio" : "share" : consumer.kind;
                                            processStat(stat, consumer, consumerType);
                                            if (consumerType === "audio" || consumerType === "shareAudio") return;
                                            if (stat.bitrate > 0) {
                                              if (traces.has(consumerTrackId)) {
                                                traces["delete"](consumerTrackId);
                                              }
                                            } else {
                                              var trace = traces.get(consumerTrackId);
                                              if (!trace) {
                                                traces.set(consumerTrackId, {
                                                  detected: Date.now()
                                                });
                                              } else if (trace.detected + 5e3 < Date.now()) {
                                                _this10._eventEmitter.emit("STREAM_STATE_CHANGED", {
                                                  state: "stuck",
                                                  peerId: consumer.appData.peerId,
                                                  streamId: consumerTrackId
                                                });
                                              }
                                            }
                                            var trackId = stat.trackId, freezeCount = stat.freezeCount;
                                            if (!trackId || freezeCount === void 0) return;
                                            var lastFreezeCount = freezeTraces.get(trackId);
                                            if (lastFreezeCount === void 0) {
                                              freezeTraces.set(trackId, freezeCount);
                                              return;
                                            }
                                            if (freezeCount > lastFreezeCount) {
                                              _this10._eventEmitter.emit("STREAM_STATE_CHANGED", {
                                                state: "freeze-detected",
                                                peerId: consumer.appData.peerId,
                                                streamId: consumerTrackId
                                              });
                                              freezeTimestamps.set(trackId, Date.now());
                                              freezeResolvedEmitted["delete"](trackId);
                                            } else {
                                              var lastFreezeAt = freezeTimestamps.get(trackId);
                                              if (lastFreezeAt && !freezeResolvedEmitted.has(trackId)) {
                                                var timeSinceLastFreeze = Date.now() - lastFreezeAt;
                                                if (timeSinceLastFreeze > 5e3) {
                                                  _this10._eventEmitter.emit("STREAM_STATE_CHANGED", {
                                                    state: "freeze-resolved",
                                                    peerId: consumer.appData.peerId,
                                                    streamId: consumerTrackId
                                                  });
                                                  freezeResolvedEmitted.add(trackId);
                                                }
                                              }
                                            }
                                            freezeTraces.set(trackId, freezeCount);
                                          }
                                        }
                                      } catch (err) {
                                        _iterator5.e(err);
                                      } finally {
                                        _iterator5.f();
                                      }
                                    });
                                  };
                                  processReport("audio");
                                  processReport("video");
                                  reportCounter++;
                                } catch (error) {
                                  var _this10$_videosdkLogs2;
                                  (_this10$_videosdkLogs2 = _this10._videosdkLogs) === null || _this10$_videosdkLogs2 === void 0 || _this10$_videosdkLogs2.pushLogs({
                                    logText: "Error CONSUMER Stats ERROR",
                                    logType: "ERROR",
                                    attributes: {
                                      error: error.message
                                    }
                                  });
                                  console.log("CONSUMER CATCH", error);
                                }
                              };
                              probe.start();
                              this._recvTransport.observer.on("close", function() {
                                probe.stop();
                                _this10._metrics.removeExistingProbe(probe);
                              });
                              (_this$_openTelemetry237 = this._openTelemetry) === null || _this$_openTelemetry237 === void 0 || _this$_openTelemetry237.completeSpan({
                                span: consumerTransportspan,
                                status: 1,
                                message: "Recieve Transport Created Successfully"
                              });
                            case 1:
                            case "end":
                              return _context128.stop();
                          }
                        }, _callee128, this);
                      }));
                      function createConsumerTransport(_x120, _x121) {
                        return _createConsumerTransport.apply(this, arguments);
                      }
                      return createConsumerTransport;
                    }()
                  }, {
                    key: "emitMeetingStateChange",
                    value: function emitMeetingStateChange(newState) {
                      this._eventEmitter.emit("MEETING_STATE_CHANGED", {
                        state: newState
                      });
                      this._meetingConnectionState = newState;
                    }
                  }, {
                    key: "joinRoom",
                    value: function() {
                      var _joinRoom = (0, asyncToGenerator.A)(regenerator_default().mark(function _callee129() {
                        var _this$_openTelemetry238, _routerRtpCapabilitie3, _this$_openTelemetry239, _this$_mediasoupDevic, _this$_mediasoupDevic2, _this$_openTelemetry240, _this$_openTelemetry243, routerSpan, routerRtpCapabilities, transportInfo, _transportInfo2, _yield$this$_socketRe, peers, poll, messages, _iterator6, _step6, peer, action, _this$_openTelemetry241, devicesCookie, _this$_openTelemetry242, _store$getState5, me, _this$_videosdkLogs123, _this$_openTelemetry244, _t96;
                        return regenerator_default().wrap(function(_context129) {
                          while (1) switch (_context129.prev = _context129.next) {
                            case 0:
                              logger.debug("joinRoom()");
                              _context129.prev = 1;
                              routerSpan = (_this$_openTelemetry238 = this._openTelemetry) === null || _this$_openTelemetry238 === void 0 ? void 0 : _this$_openTelemetry238.trace({
                                spanName: "Loading Router Capabilities",
                                span: this._joinSpan
                              });
                              this._mediasoupDevice = new lib.pF({
                                handlerName: this._handlerName
                              });
                              _context129.next = 2;
                              return this._socketRequest("getRouterRtpCapabilities");
                            case 2:
                              routerRtpCapabilities = _context129.sent;
                              routerRtpCapabilities.headerExtensions = (_routerRtpCapabilitie3 = routerRtpCapabilities.headerExtensions) === null || _routerRtpCapabilitie3 === void 0 ? void 0 : _routerRtpCapabilitie3.filter(function(c) {
                                return c.uri != "urn:3gpp:video-orientation";
                              });
                              _context129.next = 3;
                              return this._mediasoupDevice.load({
                                routerRtpCapabilities
                              });
                            case 3:
                              (_this$_openTelemetry239 = this._openTelemetry) === null || _this$_openTelemetry239 === void 0 || _this$_openTelemetry239.completeSpan({
                                span: routerSpan,
                                status: 1,
                                attributes: {
                                  routerRtpCapabilities: JSON.stringify(routerRtpCapabilities).toString()
                                },
                                message: "Router Capabilities Loaded"
                              });
                              if (!this._produce) {
                                _context129.next = 5;
                                break;
                              }
                              _context129.next = 4;
                              return this._socketRequest("createWebRtcTransport", {
                                preferredProtocol: this._preferredProtocol,
                                producing: true,
                                consuming: false,
                                sctpCapabilities: this._mediasoupDevice.sctpCapabilities
                              });
                            case 4:
                              transportInfo = _context129.sent;
                              this.createProducerTransport(transportInfo, this._joinSpan);
                            case 5:
                              if (!this._consume) {
                                _context129.next = 7;
                                break;
                              }
                              _context129.next = 6;
                              return this._socketRequest("createWebRtcTransport", {
                                preferredProtocol: this._preferredProtocol,
                                producing: false,
                                consuming: true,
                                sctpCapabilities: this._mediasoupDevice.sctpCapabilities
                              });
                            case 6:
                              _transportInfo2 = _context129.sent;
                              this.createConsumerTransport(_transportInfo2, this._joinSpan);
                            case 7:
                              _context129.next = 8;
                              return this._socketRequest("join", {
                                displayName: this._displayName,
                                device: this._device,
                                secret: this._secret,
                                rtpCapabilities: (_this$_mediasoupDevic = this._mediasoupDevice) === null || _this$_mediasoupDevic === void 0 ? void 0 : _this$_mediasoupDevic.rtpCapabilities,
                                sctpCapabilities: (_this$_mediasoupDevic2 = this._mediasoupDevice) === null || _this$_mediasoupDevic2 === void 0 ? void 0 : _this$_mediasoupDevic2.sctpCapabilities,
                                deviceInfo: this._deviceInfo,
                                debugMode: this._debugMode,
                                autoConsume: this._autoConsume,
                                metaData: this._metaData
                              });
                            case 8:
                              _yield$this$_socketRe = _context129.sent;
                              peers = _yield$this$_socketRe.peers;
                              poll = _yield$this$_socketRe.poll;
                              messages = _yield$this$_socketRe.messages;
                              store.dispatch(setRoomState("connected"));
                              (_this$_openTelemetry240 = this._openTelemetry) === null || _this$_openTelemetry240 === void 0 || _this$_openTelemetry240.traceAutoComplete({
                                spanName: "Emitted `MEETING_JOINED` Event",
                                span: this._joinSpan,
                                status: 1
                              });
                              this._eventEmitter.emit("MEETING_JOINED", {
                                peers,
                                poll,
                                messages,
                                baseUrl: this._baseUrl
                              });
                              store.dispatch(removeAllNotifications());
                              store.dispatch(notify({
                                text: "You are in the room!",
                                timeout: 3e3
                              }));
                              _iterator6 = RoomClient_createForOfIteratorHelper(peers);
                              try {
                                for (_iterator6.s(); !(_step6 = _iterator6.n()).done; ) {
                                  peer = _step6.value;
                                  action = addPeer(RoomClient_objectSpread(RoomClient_objectSpread({}, peer), {}, {
                                    consumers: [],
                                    dataConsumers: []
                                  }));
                                  store.dispatch(action);
                                  this._eventEmitter.emit(action.type, action.payload);
                                }
                              } catch (err) {
                                _iterator6.e(err);
                              } finally {
                                _iterator6.f();
                              }
                              if (this._produce) {
                                store.dispatch(setMediaCapabilities({
                                  canSendMic: this._mediasoupDevice.canProduce("audio"),
                                  canSendWebcam: this._mediasoupDevice.canProduce("video")
                                }));
                                if (this._micEnabled) {
                                  this.enableMic(this.customMicrophoneAudioTrack, this._joinSpan);
                                } else {
                                  if (this.customMicrophoneAudioTrack) {
                                    (_this$_openTelemetry241 = this._openTelemetry) === null || _this$_openTelemetry241 === void 0 || _this$_openTelemetry241.traceAutoComplete({
                                      spanName: "Disposing Audio Track",
                                      span: this._joinSpan,
                                      status: 2
                                    });
                                    this.customMicrophoneAudioTrack.getTracks().forEach(function(track) {
                                      track.stop();
                                    });
                                  }
                                }
                                devicesCookie = getDevices();
                                if (this._webcamEnabled && (!devicesCookie || devicesCookie.webcamEnabled || this._externalVideo)) {
                                  this.enableWebcam(this.customCameraVideoTrack, this._joinSpan);
                                } else {
                                  if (this.customCameraVideoTrack) {
                                    (_this$_openTelemetry242 = this._openTelemetry) === null || _this$_openTelemetry242 === void 0 || _this$_openTelemetry242.traceAutoComplete({
                                      spanName: "Disposing Video Track",
                                      span: this._joinSpan,
                                      status: 2
                                    });
                                    this.customCameraVideoTrack.getTracks().forEach(function(track) {
                                      track.stop();
                                    });
                                  }
                                }
                                this.enableChatDataProducer();
                              }
                              if (window.SHOW_INFO) {
                                _store$getState5 = store.getState(), me = _store$getState5.me;
                                store.dispatch(setRoomStatsPeerId(me.id));
                              }
                              (_this$_openTelemetry243 = this._openTelemetry) === null || _this$_openTelemetry243 === void 0 || _this$_openTelemetry243.completeSpan({
                                span: this._joinSpan,
                                status: 1,
                                message: "Room Joined"
                              });
                              _context129.next = 10;
                              break;
                            case 9:
                              _context129.prev = 9;
                              _t96 = _context129["catch"](1);
                              logger.error("joinRoom() failed:%o", _t96);
                              (_this$_videosdkLogs123 = this._videosdkLogs) === null || _this$_videosdkLogs123 === void 0 || _this$_videosdkLogs123.pushLogs({
                                logText: "Error Could not join the room",
                                logType: "ERROR",
                                attributes: {
                                  error: _t96.message
                                }
                              });
                              (_this$_openTelemetry244 = this._openTelemetry) === null || _this$_openTelemetry244 === void 0 || _this$_openTelemetry244.completeSpan({
                                span: this._joinSpan,
                                status: 2,
                                message: "Could not join the room ".concat(_t96)
                              });
                              store.dispatch(notify({
                                type: "error",
                                text: "Could not join the room: ".concat(_t96)
                              }));
                              this.close({
                                sendLeft: true,
                                meetingLeftReason: "".concat(LeaveReason.t["JOIN_ROOM_FAILED"].message, ". Error : ").concat(_t96.message),
                                code: LeaveReason.t["JOIN_ROOM_FAILED"].code
                              });
                            case 10:
                            case "end":
                              return _context129.stop();
                          }
                        }, _callee129, this, [[1, 9]]);
                      }));
                      function joinRoom() {
                        return _joinRoom.apply(this, arguments);
                      }
                      return joinRoom;
                    }()
                  }, {
                    key: "switchingRoom",
                    value: function() {
                      var _switchingRoom = (0, asyncToGenerator.A)(regenerator_default().mark(function _callee130(switchingRoomId) {
                        var _this$_openTelemetry245;
                        var switchRoomSpan, _this$_openTelemetry246, _this$_mediasoupDevic3, _this$_mediasoupDevic4, _this$_openTelemetry247, _this$_openTelemetry248, joinRequestSpan, _yield$this$_socketRe2, peers, poll, messages, _iterator7, _step7, peer, action, _this$_videosdkLogs124, _this$_openTelemetry249, _t97;
                        return regenerator_default().wrap(function(_context130) {
                          while (1) switch (_context130.prev = _context130.next) {
                            case 0:
                              switchRoomSpan = (_this$_openTelemetry245 = this._openTelemetry) === null || _this$_openTelemetry245 === void 0 ? void 0 : _this$_openTelemetry245.trace({
                                name: "switchingRoom() start",
                                attributes: {
                                  "room.id": switchingRoomId,
                                  "peer.id": this._peerId,
                                  display_name: this._displayName
                                }
                              });
                              _context130.prev = 1;
                              joinRequestSpan = (_this$_openTelemetry246 = this._openTelemetry) === null || _this$_openTelemetry246 === void 0 ? void 0 : _this$_openTelemetry246.trace({
                                name: "switch room join request",
                                parentSpan: switchRoomSpan
                              });
                              _context130.next = 2;
                              return this._socketRequest("join", {
                                displayName: this._displayName,
                                device: this._device,
                                secret: this._secret,
                                rtpCapabilities: (_this$_mediasoupDevic3 = this._mediasoupDevice) === null || _this$_mediasoupDevic3 === void 0 ? void 0 : _this$_mediasoupDevic3.rtpCapabilities,
                                sctpCapabilities: (_this$_mediasoupDevic4 = this._mediasoupDevice) === null || _this$_mediasoupDevic4 === void 0 ? void 0 : _this$_mediasoupDevic4.sctpCapabilities,
                                deviceInfo: this._deviceInfo,
                                debugMode: this._debugMode,
                                autoConsume: this._autoConsume,
                                metaData: this._metaData,
                                switchingRoom: true
                              });
                            case 2:
                              _yield$this$_socketRe2 = _context130.sent;
                              peers = _yield$this$_socketRe2.peers;
                              poll = _yield$this$_socketRe2.poll;
                              messages = _yield$this$_socketRe2.messages;
                              (_this$_openTelemetry247 = this._openTelemetry) === null || _this$_openTelemetry247 === void 0 || _this$_openTelemetry247.completeSpan({
                                span: joinRequestSpan,
                                status: 1,
                                message: "Join request successful in switched room"
                              });
                              store.dispatch(setRoomState("connected"));
                              this._eventEmitter.emit("MEETING_JOINED", {
                                switchRoomId: switchingRoomId,
                                peers,
                                poll,
                                messages,
                                baseUrl: this._baseUrl
                              });
                              store.dispatch(removeAllNotifications());
                              store.dispatch(notify({
                                text: "You are in the room!",
                                timeout: 3e3
                              }));
                              _iterator7 = RoomClient_createForOfIteratorHelper(peers);
                              try {
                                for (_iterator7.s(); !(_step7 = _iterator7.n()).done; ) {
                                  peer = _step7.value;
                                  action = addPeer(RoomClient_objectSpread(RoomClient_objectSpread({}, peer), {}, {
                                    consumers: [],
                                    dataConsumers: []
                                  }));
                                  store.dispatch(action);
                                  this._eventEmitter.emit(action.type, action.payload);
                                }
                              } catch (err) {
                                _iterator7.e(err);
                              } finally {
                                _iterator7.f();
                              }
                              (_this$_openTelemetry248 = this._openTelemetry) === null || _this$_openTelemetry248 === void 0 || _this$_openTelemetry248.completeSpan({
                                span: switchRoomSpan,
                                status: 1,
                                message: "Room switch completed successfully"
                              });
                              _context130.next = 4;
                              break;
                            case 3:
                              _context130.prev = 3;
                              _t97 = _context130["catch"](1);
                              logger.error("joinRoom() failed:%o", _t97);
                              (_this$_videosdkLogs124 = this._videosdkLogs) === null || _this$_videosdkLogs124 === void 0 || _this$_videosdkLogs124.pushLogs({
                                logText: "Error Could not join the switched room",
                                logType: "ERROR",
                                attributes: {
                                  error: _t97.message
                                }
                              });
                              (_this$_openTelemetry249 = this._openTelemetry) === null || _this$_openTelemetry249 === void 0 || _this$_openTelemetry249.completeSpan({
                                span: switchRoomSpan,
                                status: 2,
                                message: "Room switch failed: ".concat(_t97.message)
                              });
                              store.dispatch(notify({
                                type: "error",
                                text: "Could not join the switched room: ".concat(_t97)
                              }));
                              this.close({
                                sendLeft: true,
                                meetingLeftReason: "".concat(LeaveReason.t["SWITCH_ROOM_FAILED"].message, ". Error : ").concat(_t97.message),
                                code: LeaveReason.t["SWITCH_ROOM_FAILED"].code
                              });
                            case 4:
                            case "end":
                              return _context130.stop();
                          }
                        }, _callee130, this, [[1, 3]]);
                      }));
                      function switchingRoom(_x123) {
                        return _switchingRoom.apply(this, arguments);
                      }
                      return switchingRoom;
                    }()
                  }, {
                    key: "_updateMics",
                    value: function() {
                      var _updateMics2 = (0, asyncToGenerator.A)(regenerator_default().mark(function _callee131() {
                        var _this$_openTelemetry250;
                        var parentSpan, updateMicSpan, _this$_openTelemetry251, _this$_openTelemetry252, devices, _iterator8, _step8, device, array, len, currentMicId, _this$_openTelemetry253, sdkError, _this$_openTelemetry254, _args131 = arguments, _t98;
                        return regenerator_default().wrap(function(_context131) {
                          while (1) switch (_context131.prev = _context131.next) {
                            case 0:
                              parentSpan = _args131.length > 0 && _args131[0] !== void 0 ? _args131[0] : void 0;
                              this._mics = /* @__PURE__ */ new Map();
                              logger.debug("_updateMics() |");
                              updateMicSpan = (_this$_openTelemetry250 = this._openTelemetry) === null || _this$_openTelemetry250 === void 0 ? void 0 : _this$_openTelemetry250.trace({
                                spanName: "_updateMics() Calling for Getting System Mic list",
                                span: parentSpan ? parentSpan : null
                              });
                              _context131.prev = 1;
                              _context131.next = 2;
                              return navigator.mediaDevices.enumerateDevices();
                            case 2:
                              devices = _context131.sent;
                              (_this$_openTelemetry251 = this._openTelemetry) === null || _this$_openTelemetry251 === void 0 || _this$_openTelemetry251.traceAutoComplete({
                                spanName: "Getting System Mic list",
                                span: updateMicSpan,
                                status: 1,
                                attributes: {
                                  systemDevice: devices ? JSON.stringify(devices) : "Device not found"
                                }
                              });
                              _iterator8 = RoomClient_createForOfIteratorHelper(devices);
                              try {
                                for (_iterator8.s(); !(_step8 = _iterator8.n()).done; ) {
                                  device = _step8.value;
                                  if (device.kind == "audioinput") this._mics.set(device.deviceId, device);
                                }
                              } catch (err) {
                                _iterator8.e(err);
                              } finally {
                                _iterator8.f();
                              }
                              array = Array.from(this._mics.values());
                              len = array.length;
                              currentMicId = this._mic.device ? this._mic.device.deviceId : void 0;
                              if (len === 0) {
                                this._mic.device = null;
                              } else if (!this._mics.has(currentMicId)) {
                                this._mic.device = array[0];
                              }
                              (_this$_openTelemetry252 = this._openTelemetry) === null || _this$_openTelemetry252 === void 0 || _this$_openTelemetry252.completeSpan({
                                span: updateMicSpan,
                                status: 1,
                                message: "Update Mic"
                              });
                              _context131.next = 5;
                              break;
                            case 3:
                              _context131.prev = 3;
                              _t98 = _context131["catch"](1);
                              if (!(_t98 instanceof TypeError)) {
                                _context131.next = 5;
                                break;
                              }
                              if (!(_t98.name === "TypeError")) {
                                _context131.next = 4;
                                break;
                              }
                              sdkError = errors.q.ERROR_MICROPHONE_ACCESS_UNAVAILABLE;
                              this._emitError(sdkError);
                              (_this$_openTelemetry253 = this._openTelemetry) === null || _this$_openTelemetry253 === void 0 || _this$_openTelemetry253.completeSpan({
                                span: updateMicSpan,
                                status: 2,
                                message: "Error in updateMics() :: ".concat(sdkError.message)
                              });
                              throw new Error(sdkError.message);
                            case 4:
                              (_this$_openTelemetry254 = this._openTelemetry) === null || _this$_openTelemetry254 === void 0 || _this$_openTelemetry254.completeSpan({
                                span: updateMicSpan,
                                status: 2,
                                message: "Error in updateMics() :: ".concat(_t98.message)
                              });
                              throw new Error(_t98.message);
                            case 5:
                            case "end":
                              return _context131.stop();
                          }
                        }, _callee131, this, [[1, 3]]);
                      }));
                      function _updateMics() {
                        return _updateMics2.apply(this, arguments);
                      }
                      return _updateMics;
                    }()
                  }, {
                    key: "_updateWebcams",
                    value: function() {
                      var _updateWebcams2 = (0, asyncToGenerator.A)(regenerator_default().mark(function _callee132() {
                        var _this$_openTelemetry255, _this11 = this;
                        var parentSpan, updateWebcamSpan, _this$_openTelemetry256, _this$_openTelemetry257, devices, isReactNative2, _iterator9, _step9, device, array, len, currentWebcamId, _array$find, selectedCam, _this$_openTelemetry258, sdkError, _this$_openTelemetry259, _args132 = arguments, _t99, _t100;
                        return regenerator_default().wrap(function(_context132) {
                          while (1) switch (_context132.prev = _context132.next) {
                            case 0:
                              parentSpan = _args132.length > 0 && _args132[0] !== void 0 ? _args132[0] : void 0;
                              logger.debug("_updateWebcams()");
                              this._webcams = /* @__PURE__ */ new Map();
                              logger.debug("_updateWebcams() | calling enumerateDevices()");
                              updateWebcamSpan = (_this$_openTelemetry255 = this._openTelemetry) === null || _this$_openTelemetry255 === void 0 ? void 0 : _this$_openTelemetry255.trace({
                                spanName: "_updateWebcams() Calling for Getting System Webcam list",
                                span: parentSpan ? parentSpan : null
                              });
                              _context132.prev = 1;
                              _context132.next = 2;
                              return navigator.mediaDevices.enumerateDevices();
                            case 2:
                              devices = _context132.sent;
                              isReactNative2 = this._deviceInfo.sdkType === "react-native";
                              (_this$_openTelemetry256 = this._openTelemetry) === null || _this$_openTelemetry256 === void 0 || _this$_openTelemetry256.traceAutoComplete({
                                spanName: "Getting System Webcam list",
                                span: updateWebcamSpan,
                                status: 1,
                                attributes: {
                                  systemDevice: devices ? JSON.stringify(devices) : "Device not found"
                                }
                              });
                              _iterator9 = RoomClient_createForOfIteratorHelper(devices);
                              _context132.prev = 3;
                              _iterator9.s();
                            case 4:
                              if ((_step9 = _iterator9.n()).done) {
                                _context132.next = 7;
                                break;
                              }
                              device = _step9.value;
                              if (!(device.kind !== "videoinput")) {
                                _context132.next = 5;
                                break;
                              }
                              return _context132.abrupt("continue", 6);
                            case 5:
                              this._webcams.set(device.deviceId, device);
                            case 6:
                              _context132.next = 4;
                              break;
                            case 7:
                              _context132.next = 9;
                              break;
                            case 8:
                              _context132.prev = 8;
                              _t99 = _context132["catch"](3);
                              _iterator9.e(_t99);
                            case 9:
                              _context132.prev = 9;
                              _iterator9.f();
                              return _context132.finish(9);
                            case 10:
                              array = Array.from(this._webcams.values());
                              len = array.length;
                              currentWebcamId = this._webcam.device ? this._webcam.device.deviceId : void 0;
                              if (currentWebcamId) {
                                this._defaultCameraIndex = currentWebcamId;
                              }
                              logger.debug("_updateWebcams() [webcams:%o]", array);
                              if (len === 0) this._webcam.device = null;
                              else {
                                if (isReactNative2) {
                                  if (currentWebcamId == void 0 || !this._webcams.has(currentWebcamId)) {
                                    selectedCam = (_array$find = array.find(function(d) {
                                      return d.facing === _this11._defaultCamera;
                                    })) !== null && _array$find !== void 0 ? _array$find : array[0];
                                    this._webcam.device = selectedCam;
                                  }
                                } else {
                                  if (!this._webcams.has(currentWebcamId)) {
                                    this._webcam.device = array[0];
                                  }
                                }
                              }
                              (_this$_openTelemetry257 = this._openTelemetry) === null || _this$_openTelemetry257 === void 0 || _this$_openTelemetry257.completeSpan({
                                span: updateWebcamSpan,
                                status: 1,
                                message: "Update Webcam"
                              });
                              store.dispatch(setCanChangeWebcam(this._webcams.size > 1));
                              _context132.next = 13;
                              break;
                            case 11:
                              _context132.prev = 11;
                              _t100 = _context132["catch"](1);
                              if (!(_t100 instanceof TypeError)) {
                                _context132.next = 13;
                                break;
                              }
                              if (!(_t100.name === "TypeError")) {
                                _context132.next = 12;
                                break;
                              }
                              sdkError = errors.q.ERROR_CAMERA_ACCESS_UNAVAILABLE;
                              this._emitError(sdkError);
                              (_this$_openTelemetry258 = this._openTelemetry) === null || _this$_openTelemetry258 === void 0 || _this$_openTelemetry258.completeSpan({
                                span: updateWebcamSpan,
                                status: 2,
                                message: "Error in updateWebcams() :: ".concat(sdkError.message)
                              });
                              throw new Error(sdkError.message);
                            case 12:
                              (_this$_openTelemetry259 = this._openTelemetry) === null || _this$_openTelemetry259 === void 0 || _this$_openTelemetry259.completeSpan({
                                span: updateWebcamSpan,
                                status: 2,
                                message: "Error in updateWebcams() :: ".concat(_t100.message)
                              });
                              throw new Error(_t100.message);
                            case 13:
                            case "end":
                              return _context132.stop();
                          }
                        }, _callee132, this, [[1, 11], [3, 8, 9, 10]]);
                      }));
                      function _updateWebcams() {
                        return _updateWebcams2.apply(this, arguments);
                      }
                      return _updateWebcams;
                    }()
                  }, {
                    key: "_getWebcamType",
                    value: function _getWebcamType(device) {
                      if (/(back|rear)/i.test(device.label)) {
                        logger.debug("_getWebcamType() | it seems to be a back camera");
                        return "back";
                      } else {
                        logger.debug("_getWebcamType() | it seems to be a front camera");
                        return "front";
                      }
                    }
                  }, {
                    key: "_pauseConsumer",
                    value: function() {
                      var _pauseConsumer2 = (0, asyncToGenerator.A)(regenerator_default().mark(function _callee133(consumer) {
                        var _this$_videosdkLogs125, _t101;
                        return regenerator_default().wrap(function(_context133) {
                          while (1) switch (_context133.prev = _context133.next) {
                            case 0:
                              if (!consumer.paused) {
                                _context133.next = 1;
                                break;
                              }
                              return _context133.abrupt("return");
                            case 1:
                              _context133.prev = 1;
                              _context133.next = 2;
                              return this._socketRequest("pauseConsumer", {
                                consumerId: consumer.id
                              });
                            case 2:
                              consumer.pause();
                              store.dispatch(setConsumerPaused(consumer.id, "local"));
                              _context133.next = 4;
                              break;
                            case 3:
                              _context133.prev = 3;
                              _t101 = _context133["catch"](1);
                              logger.error("_pauseConsumer() | failed:%o", _t101);
                              (_this$_videosdkLogs125 = this._videosdkLogs) === null || _this$_videosdkLogs125 === void 0 || _this$_videosdkLogs125.pushLogs({
                                logText: "Error pausing Consumer",
                                logType: "ERROR",
                                attributes: {
                                  error: _t101.message
                                }
                              });
                              store.dispatch(notify({
                                type: "error",
                                text: "Error pausing Consumer: ".concat(_t101)
                              }));
                            case 4:
                            case "end":
                              return _context133.stop();
                          }
                        }, _callee133, this, [[1, 3]]);
                      }));
                      function _pauseConsumer(_x124) {
                        return _pauseConsumer2.apply(this, arguments);
                      }
                      return _pauseConsumer;
                    }()
                  }, {
                    key: "_resumeConsumer",
                    value: function() {
                      var _resumeConsumer2 = (0, asyncToGenerator.A)(regenerator_default().mark(function _callee134(consumer) {
                        var _this$_videosdkLogs126, _t102;
                        return regenerator_default().wrap(function(_context134) {
                          while (1) switch (_context134.prev = _context134.next) {
                            case 0:
                              if (consumer.paused) {
                                _context134.next = 1;
                                break;
                              }
                              return _context134.abrupt("return");
                            case 1:
                              _context134.prev = 1;
                              _context134.next = 2;
                              return this._socketRequest("resumeConsumer", {
                                consumerId: consumer.id
                              });
                            case 2:
                              consumer.resume();
                              store.dispatch(setConsumerResumed(consumer.id, "local"));
                              _context134.next = 4;
                              break;
                            case 3:
                              _context134.prev = 3;
                              _t102 = _context134["catch"](1);
                              logger.error("_resumeConsumer() | failed:%o", _t102);
                              (_this$_videosdkLogs126 = this._videosdkLogs) === null || _this$_videosdkLogs126 === void 0 || _this$_videosdkLogs126.pushLogs({
                                logText: "Error resuming Consumer",
                                logType: "ERROR",
                                attributes: {
                                  error: _t102.message
                                }
                              });
                              store.dispatch(notify({
                                type: "error",
                                text: "Error resuming Consumer: ".concat(_t102)
                              }));
                            case 4:
                            case "end":
                              return _context134.stop();
                          }
                        }, _callee134, this, [[1, 3]]);
                      }));
                      function _resumeConsumer(_x125) {
                        return _resumeConsumer2.apply(this, arguments);
                      }
                      return _resumeConsumer;
                    }()
                  }, {
                    key: "_getExternalVideoStream",
                    value: function() {
                      var _getExternalVideoStream2 = (0, asyncToGenerator.A)(regenerator_default().mark(function _callee135() {
                        var _this12 = this;
                        return regenerator_default().wrap(function(_context135) {
                          while (1) switch (_context135.prev = _context135.next) {
                            case 0:
                              if (!this._externalVideoStream) {
                                _context135.next = 1;
                                break;
                              }
                              return _context135.abrupt("return", this._externalVideoStream);
                            case 1:
                              if (!(this._externalVideo.readyState < 3)) {
                                _context135.next = 2;
                                break;
                              }
                              _context135.next = 2;
                              return new Promise(function(resolve) {
                                return _this12._externalVideo.addEventListener("canplay", resolve);
                              });
                            case 2:
                              if (!this._externalVideo.captureStream) {
                                _context135.next = 3;
                                break;
                              }
                              this._externalVideoStream = this._externalVideo.captureStream();
                              _context135.next = 5;
                              break;
                            case 3:
                              if (!this._externalVideo.mozCaptureStream) {
                                _context135.next = 4;
                                break;
                              }
                              this._externalVideoStream = this._externalVideo.mozCaptureStream();
                              _context135.next = 5;
                              break;
                            case 4:
                              throw new Error("video.captureStream() not supported");
                            case 5:
                              return _context135.abrupt("return", this._externalVideoStream);
                            case 6:
                            case "end":
                              return _context135.stop();
                          }
                        }, _callee135, this);
                      }));
                      function _getExternalVideoStream() {
                        return _getExternalVideoStream2.apply(this, arguments);
                      }
                      return _getExternalVideoStream;
                    }()
                  }, {
                    key: "toggleE2EEEnabled",
                    value: function() {
                      var _toggleE2EEEnabled = (0, asyncToGenerator.A)(regenerator_default().mark(function _callee136(enabled) {
                        return regenerator_default().wrap(function(_context136) {
                          while (1) switch (_context136.prev = _context136.next) {
                            case 0:
                              if (!this.e2eeManager) {
                                _context136.next = 1;
                                break;
                              }
                              if (this._peerId) {
                                this.e2eeManager.setParticipantCryptorEnabled(enabled, this._peerId);
                              }
                              this.isE2EEEnabled = enabled;
                              _context136.next = 2;
                              break;
                            case 1:
                              throw Error("e2ee not configured, please set e2ee settings within the room options");
                            case 2:
                            case "end":
                              return _context136.stop();
                          }
                        }, _callee136, this);
                      }));
                      function toggleE2EEEnabled(_x126) {
                        return _toggleE2EEEnabled.apply(this, arguments);
                      }
                      return toggleE2EEEnabled;
                    }()
                  }, {
                    key: "_emitError",
                    value: function _emitError(error) {
                      this._eventEmitter.emit("ERROR", error);
                    }
                  }], [{
                    key: "init",
                    value: (
                      /**
                       * @param  {Object} data
                       * @param  {Object} data.store - The Redux store.
                       */
                      function init(data) {
                        store = data.store;
                      }
                    )
                  }]);
                }();
                function _setupE2EE(_x127) {
                  return _setupE2EE2.apply(this, arguments);
                }
                function _setupE2EE2() {
                  _setupE2EE2 = (0, asyncToGenerator.A)(regenerator_default().mark(function _callee137(keyProvider) {
                    var _this13 = this;
                    var _this$e2eeManager, _t103, _t104, _t105, _t106, _t107;
                    return regenerator_default().wrap(function(_context137) {
                      while (1) switch (_context137.prev = _context137.next) {
                        case 0:
                          _context137.prev = 0;
                          if (this.e2eeManager) {
                            _context137.next = 2;
                            break;
                          }
                          _t103 = E2EEManager;
                          _t104 = keyProvider;
                          _context137.next = 1;
                          return createE2EEWorker();
                        case 1:
                          _t105 = _context137.sent;
                          _t106 = {
                            keyProvider: _t104,
                            worker: _t105
                          };
                          this.e2eeManager = new _t103(_t106);
                          this.e2eeManager.on(e2ee_events.KS.ParticipantEncryptionStatusChanged, function(enabled) {
                            _this13.isE2EEEnabled = enabled;
                          });
                          this.e2eeManager.on(e2ee_events.KS.E2EEStateChange, function(data) {
                            _this13._eventEmitter.emit("E2EE_STATE_CHANGE", data);
                          });
                          (_this$e2eeManager = this.e2eeManager) === null || _this$e2eeManager === void 0 || _this$e2eeManager.setup(this);
                          this.toggleE2EEEnabled(true);
                        case 2:
                          _context137.next = 4;
                          break;
                        case 3:
                          _context137.prev = 3;
                          _t107 = _context137["catch"](0);
                          console.error("Error setting up E2EE: ", _t107);
                          throw new Error("Error setting up E2EE: " + _t107.message);
                        case 4:
                        case "end":
                          return _context137.stop();
                      }
                    }, _callee137, this, [[0, 3]]);
                  }));
                  return _setupE2EE2.apply(this, arguments);
                }
              }
            ),
            /***/
            2067: (
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                "use strict";
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  y: () => (
                    /* binding */
                    reliabilityMode
                  )
                  /* harmony export */
                });
                var reliabilityMode = {
                  RELIABLE: "RELIABLE",
                  UNRELIABLE: "UNRELIABLE"
                };
              }
            ),
            /***/
            2073: (
              /***/
              function(module2, exports2, __webpack_require__2) {
                ;
                (function(root, factory, undef) {
                  if (true) {
                    module2.exports = exports2 = factory(__webpack_require__2(9021), __webpack_require__2(7165));
                  } else {
                  }
                })(this, function(CryptoJS) {
                  CryptoJS.pad.AnsiX923 = {
                    pad: function(data, blockSize) {
                      var dataSigBytes = data.sigBytes;
                      var blockSizeBytes = blockSize * 4;
                      var nPaddingBytes = blockSizeBytes - dataSigBytes % blockSizeBytes;
                      var lastBytePos = dataSigBytes + nPaddingBytes - 1;
                      data.clamp();
                      data.words[lastBytePos >>> 2] |= nPaddingBytes << 24 - lastBytePos % 4 * 8;
                      data.sigBytes += nPaddingBytes;
                    },
                    unpad: function(data) {
                      var nPaddingBytes = data.words[data.sigBytes - 1 >>> 2] & 255;
                      data.sigBytes -= nPaddingBytes;
                    }
                  };
                  return CryptoJS.pad.Ansix923;
                });
              }
            ),
            /***/
            2107: (
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                "use strict";
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  kR: () => (
                    /* binding */
                    isSendRecvMode
                  ),
                  /* harmony export */
                  nI: () => (
                    /* binding */
                    modes
                  ),
                  /* harmony export */
                  wZ: () => (
                    /* binding */
                    isViewerMode
                  )
                  /* harmony export */
                });
                var modes = {
                  /** @deprecated CONFERENCE mode is deprecated and will be removed in future versions. Use SEND_AND_RECV mode instead. */
                  CONFERENCE: "CONFERENCE",
                  /** @deprecated VIEWER mode is deprecated and will be removed in future versions. Use SIGNALLING_ONLY mode instead. */
                  VIEWER: "VIEWER",
                  SEND_AND_RECV: "SEND_AND_RECV",
                  SIGNALLING_ONLY: "SIGNALLING_ONLY",
                  RECV_ONLY: "RECV_ONLY"
                };
                function isSendRecvMode(mode) {
                  return mode === modes.CONFERENCE || mode === modes.SEND_AND_RECV;
                }
                function isViewerMode(mode) {
                  return mode === modes.VIEWER || mode === modes.SIGNALLING_ONLY;
                }
                function isRecvOnlyMode(mode) {
                  return mode === modes.RECV_ONLY;
                }
              }
            ),
            /***/
            2109: (
              /***/
              function(module2, exports2, __webpack_require__2) {
                var __WEBPACK_AMD_DEFINE_RESULT__;
                (function(window2, undefined2) {
                  "use strict";
                  var LIBVERSION = "2.0.6", UA_MAX_LENGTH = 500, USER_AGENT = "user-agent", EMPTY = "", UNKNOWN = "?", TYPEOF = {
                    FUNCTION: "function",
                    OBJECT: "object",
                    STRING: "string",
                    UNDEFINED: "undefined"
                  }, BROWSER = "browser", CPU = "cpu", DEVICE = "device", ENGINE = "engine", OS = "os", RESULT = "result", NAME = "name", TYPE = "type", VENDOR = "vendor", VERSION = "version", ARCHITECTURE = "architecture", MAJOR = "major", MODEL = "model", CONSOLE = "console", MOBILE = "mobile", TABLET = "tablet", SMARTTV = "smarttv", WEARABLE = "wearable", XR = "xr", EMBEDDED = "embedded", INAPP = "inapp", BRANDS = "brands", FORMFACTORS = "formFactors", FULLVERLIST = "fullVersionList", PLATFORM = "platform", PLATFORMVER = "platformVersion", BITNESS = "bitness", CH = "sec-ch-ua", CH_FULL_VER_LIST = CH + "-full-version-list", CH_ARCH = CH + "-arch", CH_BITNESS = CH + "-" + BITNESS, CH_FORM_FACTORS = CH + "-form-factors", CH_MOBILE = CH + "-" + MOBILE, CH_MODEL = CH + "-" + MODEL, CH_PLATFORM = CH + "-" + PLATFORM, CH_PLATFORM_VER = CH_PLATFORM + "-version", CH_ALL_VALUES = [BRANDS, FULLVERLIST, MOBILE, MODEL, PLATFORM, PLATFORMVER, ARCHITECTURE, FORMFACTORS, BITNESS], AMAZON = "Amazon", APPLE = "Apple", ASUS = "ASUS", BLACKBERRY = "BlackBerry", GOOGLE = "Google", HUAWEI = "Huawei", LENOVO = "Lenovo", HONOR = "Honor", LG = "LG", MICROSOFT = "Microsoft", MOTOROLA = "Motorola", NVIDIA = "Nvidia", ONEPLUS = "OnePlus", OPPO = "OPPO", SAMSUNG = "Samsung", SHARP = "Sharp", SONY = "Sony", XIAOMI = "Xiaomi", ZEBRA = "Zebra", CHROME = "Chrome", CHROMIUM = "Chromium", CHROMECAST = "Chromecast", EDGE = "Edge", FIREFOX = "Firefox", OPERA = "Opera", FACEBOOK = "Facebook", SOGOU = "Sogou", PREFIX_MOBILE = "Mobile ", SUFFIX_BROWSER = " Browser", WINDOWS = "Windows";
                  var isWindow = typeof window2 !== TYPEOF.UNDEFINED, NAVIGATOR = isWindow && window2.navigator ? window2.navigator : undefined2, NAVIGATOR_UADATA = NAVIGATOR && NAVIGATOR.userAgentData ? NAVIGATOR.userAgentData : undefined2;
                  var extend = function(defaultRgx, extensions) {
                    var mergedRgx = {};
                    var extraRgx = extensions;
                    if (!isExtensions(extensions)) {
                      extraRgx = {};
                      for (var i in extensions) {
                        for (var j in extensions[i]) {
                          extraRgx[j] = extensions[i][j].concat(extraRgx[j] ? extraRgx[j] : []);
                        }
                      }
                    }
                    for (var k in defaultRgx) {
                      mergedRgx[k] = extraRgx[k] && extraRgx[k].length % 2 === 0 ? extraRgx[k].concat(defaultRgx[k]) : defaultRgx[k];
                    }
                    return mergedRgx;
                  }, enumerize = function(arr) {
                    var enums = {};
                    for (var i = 0; i < arr.length; i++) {
                      enums[arr[i].toUpperCase()] = arr[i];
                    }
                    return enums;
                  }, has = function(str1, str2) {
                    if (typeof str1 === TYPEOF.OBJECT && str1.length > 0) {
                      for (var i in str1) {
                        if (lowerize(str2) == lowerize(str1[i])) return true;
                      }
                      return false;
                    }
                    return isString(str1) ? lowerize(str2) == lowerize(str1) : false;
                  }, isExtensions = function(obj, deep) {
                    for (var prop in obj) {
                      return /^(browser|cpu|device|engine|os)$/.test(prop) || (deep ? isExtensions(obj[prop]) : false);
                    }
                  }, isString = function(val) {
                    return typeof val === TYPEOF.STRING;
                  }, itemListToArray = function(header) {
                    if (!header) return undefined2;
                    var arr = [];
                    var tokens = strip(/\\?\"/g, header).split(",");
                    for (var i = 0; i < tokens.length; i++) {
                      if (tokens[i].indexOf(";") > -1) {
                        var token = trim(tokens[i]).split(";v=");
                        arr[i] = { brand: token[0], version: token[1] };
                      } else {
                        arr[i] = trim(tokens[i]);
                      }
                    }
                    return arr;
                  }, lowerize = function(str) {
                    return isString(str) ? str.toLowerCase() : str;
                  }, majorize = function(version2) {
                    return isString(version2) ? strip(/[^\d\.]/g, version2).split(".")[0] : undefined2;
                  }, setProps = function(arr) {
                    for (var i in arr) {
                      if (!arr.hasOwnProperty(i)) continue;
                      var propName = arr[i];
                      if (typeof propName == TYPEOF.OBJECT && propName.length == 2) {
                        this[propName[0]] = propName[1];
                      } else {
                        this[propName] = undefined2;
                      }
                    }
                    return this;
                  }, strip = function(pattern, str) {
                    return isString(str) ? str.replace(pattern, EMPTY) : str;
                  }, stripQuotes = function(str) {
                    return strip(/\\?\"/g, str);
                  }, trim = function(str, len) {
                    str = strip(/^\s\s*/, String(str));
                    return typeof len === TYPEOF.UNDEFINED ? str : str.substring(0, len);
                  };
                  var rgxMapper = function(ua, arrays) {
                    if (!ua || !arrays) return;
                    var i = 0, j, k, p, q, matches, match;
                    while (i < arrays.length && !matches) {
                      var regex = arrays[i], props = arrays[i + 1];
                      j = k = 0;
                      while (j < regex.length && !matches) {
                        if (!regex[j]) {
                          break;
                        }
                        matches = regex[j++].exec(ua);
                        if (!!matches) {
                          for (p = 0; p < props.length; p++) {
                            match = matches[++k];
                            q = props[p];
                            if (typeof q === TYPEOF.OBJECT && q.length > 0) {
                              if (q.length === 2) {
                                if (typeof q[1] == TYPEOF.FUNCTION) {
                                  this[q[0]] = q[1].call(this, match);
                                } else {
                                  this[q[0]] = q[1];
                                }
                              } else if (q.length >= 3) {
                                if (typeof q[1] === TYPEOF.FUNCTION && !(q[1].exec && q[1].test)) {
                                  if (q.length > 3) {
                                    this[q[0]] = match ? q[1].apply(this, q.slice(2)) : undefined2;
                                  } else {
                                    this[q[0]] = match ? q[1].call(this, match, q[2]) : undefined2;
                                  }
                                } else {
                                  if (q.length == 3) {
                                    this[q[0]] = match ? match.replace(q[1], q[2]) : undefined2;
                                  } else if (q.length == 4) {
                                    this[q[0]] = match ? q[3].call(this, match.replace(q[1], q[2])) : undefined2;
                                  } else if (q.length > 4) {
                                    this[q[0]] = match ? q[3].apply(this, [match.replace(q[1], q[2])].concat(q.slice(4))) : undefined2;
                                  }
                                }
                              }
                            } else {
                              this[q] = match ? match : undefined2;
                            }
                          }
                        }
                      }
                      i += 2;
                    }
                  }, strMapper = function(str, map) {
                    for (var i in map) {
                      if (typeof map[i] === TYPEOF.OBJECT && map[i].length > 0) {
                        for (var j = 0; j < map[i].length; j++) {
                          if (has(map[i][j], str)) {
                            return i === UNKNOWN ? undefined2 : i;
                          }
                        }
                      } else if (has(map[i], str)) {
                        return i === UNKNOWN ? undefined2 : i;
                      }
                    }
                    return map.hasOwnProperty("*") ? map["*"] : str;
                  };
                  var windowsVersionMap = {
                    "ME": "4.90",
                    "NT 3.51": "3.51",
                    "NT 4.0": "4.0",
                    "2000": ["5.0", "5.01"],
                    "XP": ["5.1", "5.2"],
                    "Vista": "6.0",
                    "7": "6.1",
                    "8": "6.2",
                    "8.1": "6.3",
                    "10": ["6.4", "10.0"],
                    "NT": ""
                  }, formFactorsMap = {
                    "embedded": "Automotive",
                    "mobile": "Mobile",
                    "tablet": ["Tablet", "EInk"],
                    "smarttv": "TV",
                    "wearable": "Watch",
                    "xr": ["VR", "XR"],
                    "?": ["Desktop", "Unknown"],
                    "*": undefined2
                  }, browserHintsMap = {
                    "Chrome": "Google Chrome",
                    "Edge": "Microsoft Edge",
                    "Edge WebView2": "Microsoft Edge WebView2",
                    "Chrome WebView": "Android WebView",
                    "Chrome Headless": "HeadlessChrome",
                    "Huawei Browser": "HuaweiBrowser",
                    "MIUI Browser": "Miui Browser",
                    "Opera Mobi": "OperaMobile",
                    "Yandex": "YaBrowser"
                  };
                  var defaultRegexes = {
                    browser: [
                      [
                        // Most common regardless engine
                        /\b(?:crmo|crios)\/([\w\.]+)/i
                        // Chrome for Android/iOS
                      ],
                      [VERSION, [NAME, PREFIX_MOBILE + "Chrome"]],
                      [
                        /webview.+edge\/([\w\.]+)/i
                        // Microsoft Edge
                      ],
                      [VERSION, [NAME, EDGE + " WebView"]],
                      [
                        /edg(?:e|ios|a)?\/([\w\.]+)/i
                      ],
                      [VERSION, [NAME, "Edge"]],
                      [
                        // Presto based
                        /(opera mini)\/([-\w\.]+)/i,
                        // Opera Mini
                        /(opera [mobiletab]{3,6})\b.+version\/([-\w\.]+)/i,
                        // Opera Mobi/Tablet
                        /(opera)(?:.+version\/|[\/ ]+)([\w\.]+)/i
                        // Opera
                      ],
                      [NAME, VERSION],
                      [
                        /opios[\/ ]+([\w\.]+)/i
                        // Opera mini on iphone >= 8.0
                      ],
                      [VERSION, [NAME, OPERA + " Mini"]],
                      [
                        /\bop(?:rg)?x\/([\w\.]+)/i
                        // Opera GX
                      ],
                      [VERSION, [NAME, OPERA + " GX"]],
                      [
                        /\bopr\/([\w\.]+)/i
                        // Opera Webkit
                      ],
                      [VERSION, [NAME, OPERA]],
                      [
                        // Mixed
                        /\bb[ai]*d(?:uhd|[ub]*[aekoprswx]{5,6})[\/ ]?([\w\.]+)/i
                        // Baidu
                      ],
                      [VERSION, [NAME, "Baidu"]],
                      [
                        /\b(?:mxbrowser|mxios|myie2)\/?([-\w\.]*)\b/i
                        // Maxthon
                      ],
                      [VERSION, [NAME, "Maxthon"]],
                      [
                        /(kindle)\/([\w\.]+)/i,
                        // Kindle
                        /(lunascape|maxthon|netfront|jasmine|blazer|sleipnir)[\/ ]?([\w\.]*)/i,
                        // Lunascape/Maxthon/Netfront/Jasmine/Blazer/Sleipnir
                        // Trident based
                        /(avant|iemobile|slim(?:browser|boat|jet))[\/ ]?([\d\.]*)/i,
                        // Avant/IEMobile/SlimBrowser/SlimBoat/Slimjet
                        /(?:ms|\()(ie) ([\w\.]+)/i,
                        // Internet Explorer
                        // Blink/Webkit/KHTML based                                         // Flock/RockMelt/Midori/Epiphany/Silk/Skyfire/Bolt/Iron/Iridium/PhantomJS/Bowser/QupZilla/Falkon/LG Browser/Otter/qutebrowser/Dooble/Palemoon
                        /(flock|rockmelt|midori|epiphany|silk|skyfire|ovibrowser|bolt|iron|vivaldi|iridium|phantomjs|bowser|qupzilla|falkon|rekonq|puffin|brave|whale(?!.+naver)|qqbrowserlite|duckduckgo|klar|helio|(?=comodo_)?dragon|otter|dooble|(?:lg |qute)browser|palemoon)\/([-\w\.]+)/i,
                        // Rekonq/Puffin/Brave/Whale/QQBrowserLite/QQ//Vivaldi/DuckDuckGo/Klar/Helio/Dragon
                        /(heytap|ovi|115|surf|qwant)browser\/([\d\.]+)/i,
                        // HeyTap/Ovi/115/Surf
                        /(qwant)(?:ios|mobile)\/([\d\.]+)/i,
                        // Qwant
                        /(ecosia|weibo)(?:__| \w+@)([\d\.]+)/i
                        // Ecosia/Weibo
                      ],
                      [NAME, VERSION],
                      [
                        /quark(?:pc)?\/([-\w\.]+)/i
                        // Quark
                      ],
                      [VERSION, [NAME, "Quark"]],
                      [
                        /\bddg\/([\w\.]+)/i
                        // DuckDuckGo
                      ],
                      [VERSION, [NAME, "DuckDuckGo"]],
                      [
                        /(?:\buc? ?browser|(?:juc.+)ucweb)[\/ ]?([\w\.]+)/i
                        // UCBrowser
                      ],
                      [VERSION, [NAME, "UCBrowser"]],
                      [
                        /microm.+\bqbcore\/([\w\.]+)/i,
                        // WeChat Desktop for Windows Built-in Browser
                        /\bqbcore\/([\w\.]+).+microm/i,
                        /micromessenger\/([\w\.]+)/i
                        // WeChat
                      ],
                      [VERSION, [NAME, "WeChat"]],
                      [
                        /konqueror\/([\w\.]+)/i
                        // Konqueror
                      ],
                      [VERSION, [NAME, "Konqueror"]],
                      [
                        /trident.+rv[: ]([\w\.]{1,9})\b.+like gecko/i
                        // IE11
                      ],
                      [VERSION, [NAME, "IE"]],
                      [
                        /ya(?:search)?browser\/([\w\.]+)/i
                        // Yandex
                      ],
                      [VERSION, [NAME, "Yandex"]],
                      [
                        /slbrowser\/([\w\.]+)/i
                        // Smart Lenovo Browser
                      ],
                      [VERSION, [NAME, "Smart " + LENOVO + SUFFIX_BROWSER]],
                      [
                        /(avast|avg)\/([\w\.]+)/i
                        // Avast/AVG Secure Browser
                      ],
                      [[NAME, /(.+)/, "$1 Secure" + SUFFIX_BROWSER], VERSION],
                      [
                        /\bfocus\/([\w\.]+)/i
                        // Firefox Focus
                      ],
                      [VERSION, [NAME, FIREFOX + " Focus"]],
                      [
                        /\bopt\/([\w\.]+)/i
                        // Opera Touch
                      ],
                      [VERSION, [NAME, OPERA + " Touch"]],
                      [
                        /coc_coc\w+\/([\w\.]+)/i
                        // Coc Coc Browser
                      ],
                      [VERSION, [NAME, "Coc Coc"]],
                      [
                        /dolfin\/([\w\.]+)/i
                        // Dolphin
                      ],
                      [VERSION, [NAME, "Dolphin"]],
                      [
                        /coast\/([\w\.]+)/i
                        // Opera Coast
                      ],
                      [VERSION, [NAME, OPERA + " Coast"]],
                      [
                        /miuibrowser\/([\w\.]+)/i
                        // MIUI Browser
                      ],
                      [VERSION, [NAME, "MIUI" + SUFFIX_BROWSER]],
                      [
                        /fxios\/([\w\.-]+)/i
                        // Firefox for iOS
                      ],
                      [VERSION, [NAME, PREFIX_MOBILE + FIREFOX]],
                      [
                        /\bqihoobrowser\/?([\w\.]*)/i
                        // 360
                      ],
                      [VERSION, [NAME, "360"]],
                      [
                        /\b(qq)\/([\w\.]+)/i
                        // QQ
                      ],
                      [[NAME, /(.+)/, "$1Browser"], VERSION],
                      [
                        /(oculus|sailfish|huawei|vivo|pico)browser\/([\w\.]+)/i
                      ],
                      [[NAME, /(.+)/, "$1" + SUFFIX_BROWSER], VERSION],
                      [
                        // Oculus/Sailfish/HuaweiBrowser/VivoBrowser/PicoBrowser
                        /samsungbrowser\/([\w\.]+)/i
                        // Samsung Internet
                      ],
                      [VERSION, [NAME, SAMSUNG + " Internet"]],
                      [
                        /metasr[\/ ]?([\d\.]+)/i
                        // Sogou Explorer
                      ],
                      [VERSION, [NAME, SOGOU + " Explorer"]],
                      [
                        /(sogou)mo\w+\/([\d\.]+)/i
                        // Sogou Mobile
                      ],
                      [[NAME, SOGOU + " Mobile"], VERSION],
                      [
                        /(electron)\/([\w\.]+) safari/i,
                        // Electron-based App
                        /(tesla)(?: qtcarbrowser|\/(20\d\d\.[-\w\.]+))/i,
                        // Tesla
                        /m?(qqbrowser|2345(?=browser|chrome|explorer))\w*[\/ ]?v?([\w\.]+)/i
                        // QQ/2345
                      ],
                      [NAME, VERSION],
                      [
                        /(lbbrowser|rekonq)/i
                        // LieBao Browser/Rekonq
                      ],
                      [NAME],
                      [
                        /ome\/([\w\.]+) \w* ?(iron) saf/i,
                        // Iron
                        /ome\/([\w\.]+).+qihu (360)[es]e/i
                        // 360
                      ],
                      [VERSION, NAME],
                      [
                        // WebView
                        /((?:fban\/fbios|fb_iab\/fb4a)(?!.+fbav)|;fbav\/([\w\.]+);)/i
                        // Facebook App for iOS & Android
                      ],
                      [[NAME, FACEBOOK], VERSION, [TYPE, INAPP]],
                      [
                        /(kakao(?:talk|story))[\/ ]([\w\.]+)/i,
                        // Kakao App
                        /(naver)\(.*?(\d+\.[\w\.]+).*\)/i,
                        // Naver InApp
                        /(daum)apps[\/ ]([\w\.]+)/i,
                        // Daum App
                        /safari (line)\/([\w\.]+)/i,
                        // Line App for iOS
                        /\b(line)\/([\w\.]+)\/iab/i,
                        // Line App for Android
                        /(alipay)client\/([\w\.]+)/i,
                        // Alipay
                        /(twitter)(?:and| f.+e\/([\w\.]+))/i,
                        // Twitter
                        /(bing)(?:web|sapphire)\/([\w\.]+)/i,
                        // Bing
                        /(instagram|snapchat|klarna)[\/ ]([-\w\.]+)/i
                        // Instagram/Snapchat/Klarna
                      ],
                      [NAME, VERSION, [TYPE, INAPP]],
                      [
                        /\bgsa\/([\w\.]+) .*safari\//i
                        // Google Search Appliance on iOS
                      ],
                      [VERSION, [NAME, "GSA"], [TYPE, INAPP]],
                      [
                        /musical_ly(?:.+app_?version\/|_)([\w\.]+)/i
                        // TikTok
                      ],
                      [VERSION, [NAME, "TikTok"], [TYPE, INAPP]],
                      [
                        /\[(linkedin)app\]/i
                        // LinkedIn App for iOS & Android
                      ],
                      [NAME, [TYPE, INAPP]],
                      [
                        /(zalo(?:app)?)[\/\sa-z]*([\w\.-]+)/i
                        // Zalo 
                      ],
                      [[NAME, /(.+)/, "Zalo"], VERSION, [TYPE, INAPP]],
                      [
                        /(chromium)[\/ ]([-\w\.]+)/i
                        // Chromium
                      ],
                      [NAME, VERSION],
                      [
                        /headlesschrome(?:\/([\w\.]+)| )/i
                        // Chrome Headless
                      ],
                      [VERSION, [NAME, CHROME + " Headless"]],
                      [
                        /wv\).+chrome\/([\w\.]+).+edgw\//i
                        // Edge WebView2
                      ],
                      [VERSION, [NAME, EDGE + " WebView2"]],
                      [
                        / wv\).+(chrome)\/([\w\.]+)/i
                        // Chrome WebView
                      ],
                      [[NAME, CHROME + " WebView"], VERSION],
                      [
                        /droid.+ version\/([\w\.]+)\b.+(?:mobile safari|safari)/i
                        // Android Browser
                      ],
                      [VERSION, [NAME, "Android" + SUFFIX_BROWSER]],
                      [
                        /chrome\/([\w\.]+) mobile/i
                        // Chrome Mobile
                      ],
                      [VERSION, [NAME, PREFIX_MOBILE + "Chrome"]],
                      [
                        /(chrome|omniweb|arora|[tizenoka]{5} ?browser)\/v?([\w\.]+)/i
                        // Chrome/OmniWeb/Arora/Tizen/Nokia
                      ],
                      [NAME, VERSION],
                      [
                        /version\/([\w\.\,]+) .*mobile(?:\/\w+ | ?)safari/i
                        // Safari Mobile
                      ],
                      [VERSION, [NAME, PREFIX_MOBILE + "Safari"]],
                      [
                        /iphone .*mobile(?:\/\w+ | ?)safari/i
                      ],
                      [[NAME, PREFIX_MOBILE + "Safari"]],
                      [
                        /version\/([\w\.\,]+) .*(safari)/i
                        // Safari
                      ],
                      [VERSION, NAME],
                      [
                        /webkit.+?(mobile ?safari|safari)(\/[\w\.]+)/i
                        // Safari < 3.0
                      ],
                      [NAME, [VERSION, "1"]],
                      [
                        /(webkit|khtml)\/([\w\.]+)/i
                      ],
                      [NAME, VERSION],
                      [
                        // Gecko based
                        /(?:mobile|tablet);.*(firefox)\/([\w\.-]+)/i
                        // Firefox Mobile
                      ],
                      [[NAME, PREFIX_MOBILE + FIREFOX], VERSION],
                      [
                        /(navigator|netscape\d?)\/([-\w\.]+)/i
                        // Netscape
                      ],
                      [[NAME, "Netscape"], VERSION],
                      [
                        /(wolvic|librewolf)\/([\w\.]+)/i
                        // Wolvic/LibreWolf
                      ],
                      [NAME, VERSION],
                      [
                        /mobile vr; rv:([\w\.]+)\).+firefox/i
                        // Firefox Reality
                      ],
                      [VERSION, [NAME, FIREFOX + " Reality"]],
                      [
                        /ekiohf.+(flow)\/([\w\.]+)/i,
                        // Flow
                        /(swiftfox)/i,
                        // Swiftfox
                        /(icedragon|iceweasel|camino|chimera|fennec|maemo browser|minimo|conkeror)[\/ ]?([\w\.\+]+)/i,
                        // IceDragon/Iceweasel/Camino/Chimera/Fennec/Maemo/Minimo/Conkeror
                        /(seamonkey|k-meleon|icecat|iceape|firebird|phoenix|basilisk|waterfox)\/([-\w\.]+)$/i,
                        // Firefox/SeaMonkey/K-Meleon/IceCat/IceApe/Firebird/Phoenix
                        /(firefox)\/([\w\.]+)/i,
                        // Other Firefox-based
                        /(mozilla)\/([\w\.]+(?= .+rv\:.+gecko\/\d+)|[0-4][\w\.]+(?!.+compatible))/i,
                        // Mozilla
                        // Other
                        /(amaya|dillo|doris|icab|ladybird|lynx|mosaic|netsurf|obigo|polaris|w3m|(?:go|ice|up)[\. ]?browser)[-\/ ]?v?([\w\.]+)/i,
                        // Polaris/Lynx/Dillo/iCab/Doris/Amaya/w3m/NetSurf/Obigo/Mosaic/Go/ICE/UP.Browser/Ladybird
                        /\b(links) \(([\w\.]+)/i
                        // Links
                      ],
                      [NAME, [VERSION, /_/g, "."]],
                      [
                        /(cobalt)\/([\w\.]+)/i
                        // Cobalt
                      ],
                      [NAME, [VERSION, /[^\d\.]+./, EMPTY]]
                    ],
                    cpu: [
                      [
                        /\b((amd|x|x86[-_]?|wow|win)64)\b/i
                        // AMD64 (x64)
                      ],
                      [[ARCHITECTURE, "amd64"]],
                      [
                        /(ia32(?=;))/i,
                        // IA32 (quicktime)
                        /\b((i[346]|x)86)(pc)?\b/i
                        // IA32 (x86)
                      ],
                      [[ARCHITECTURE, "ia32"]],
                      [
                        /\b(aarch64|arm(v?[89]e?l?|_?64))\b/i
                        // ARM64
                      ],
                      [[ARCHITECTURE, "arm64"]],
                      [
                        /\b(arm(v[67])?ht?n?[fl]p?)\b/i
                        // ARMHF
                      ],
                      [[ARCHITECTURE, "armhf"]],
                      [
                        // PocketPC mistakenly identified as PowerPC
                        /( (ce|mobile); ppc;|\/[\w\.]+arm\b)/i
                      ],
                      [[ARCHITECTURE, "arm"]],
                      [
                        / sun4\w[;\)]/i
                        // SPARC
                      ],
                      [[ARCHITECTURE, "sparc"]],
                      [
                        // IA64, 68K, ARM/64, AVR/32, IRIX/64, MIPS/64, SPARC/64, PA-RISC
                        /\b(avr32|ia64(?=;)|68k(?=\))|\barm(?=v([1-7]|[5-7]1)l?|;|eabi)|(irix|mips|sparc)(64)?\b|pa-risc)/i,
                        /((ppc|powerpc)(64)?)( mac|;|\))/i,
                        // PowerPC
                        /(?:osf1|[freopnt]{3,4}bsd) (alpha)/i
                        // Alpha
                      ],
                      [[ARCHITECTURE, /ower/, EMPTY, lowerize]],
                      [
                        /mc680.0/i
                      ],
                      [[ARCHITECTURE, "68k"]],
                      [
                        /winnt.+\[axp/i
                      ],
                      [[ARCHITECTURE, "alpha"]]
                    ],
                    device: [
                      [
                        //////////////////////////
                        // MOBILES & TABLETS
                        /////////////////////////
                        // Samsung
                        /\b(sch-i[89]0\d|shw-m380s|sm-[ptx]\w{2,4}|gt-[pn]\d{2,4}|sgh-t8[56]9|nexus 10)/i
                      ],
                      [MODEL, [VENDOR, SAMSUNG], [TYPE, TABLET]],
                      [
                        /\b((?:s[cgp]h|gt|sm)-(?![lr])\w+|sc[g-]?[\d]+a?|galaxy nexus)/i,
                        /samsung[- ]((?!sm-[lr]|browser)[-\w]+)/i,
                        /sec-(sgh\w+)/i
                      ],
                      [MODEL, [VENDOR, SAMSUNG], [TYPE, MOBILE]],
                      [
                        // Apple
                        /(?:\/|\()(ip(?:hone|od)[\w, ]*)[\/\);]/i
                        // iPod/iPhone
                      ],
                      [MODEL, [VENDOR, APPLE], [TYPE, MOBILE]],
                      [
                        /\b(?:ios|apple\w+)\/.+[\(\/](ipad)/i,
                        // iPad
                        /\b(ipad)[\d,]*[;\] ].+(mac |i(pad)?)os/i
                      ],
                      [MODEL, [VENDOR, APPLE], [TYPE, TABLET]],
                      [
                        /(macintosh);/i
                      ],
                      [MODEL, [VENDOR, APPLE]],
                      [
                        // Sharp
                        /\b(sh-?[altvz]?\d\d[a-ekm]?)/i
                      ],
                      [MODEL, [VENDOR, SHARP], [TYPE, MOBILE]],
                      [
                        // Honor
                        /\b((?:brt|eln|hey2?|gdi|jdn)-a?[lnw]09|(?:ag[rm]3?|jdn2|kob2)-a?[lw]0[09]hn)(?: bui|\)|;)/i
                      ],
                      [MODEL, [VENDOR, HONOR], [TYPE, TABLET]],
                      [
                        /honor([-\w ]+)[;\)]/i
                      ],
                      [MODEL, [VENDOR, HONOR], [TYPE, MOBILE]],
                      [
                        // Huawei
                        /\b((?:ag[rs][2356]?k?|bah[234]?|bg[2o]|bt[kv]|cmr|cpn|db[ry]2?|jdn2|got|kob2?k?|mon|pce|scm|sht?|[tw]gr|vrd)-[ad]?[lw][0125][09]b?|605hw|bg2-u03|(?:gem|fdr|m2|ple|t1)-[7a]0[1-4][lu]|t1-a2[13][lw]|mediapad[\w\. ]*(?= bui|\)))\b(?!.+d\/s)/i
                      ],
                      [MODEL, [VENDOR, HUAWEI], [TYPE, TABLET]],
                      [
                        /(?:huawei) ?([-\w ]+)[;\)]/i,
                        /\b(nexus 6p|\w{2,4}e?-[atu]?[ln][\dx][\dc][adnt]?)\b(?!.+d\/s)/i
                      ],
                      [MODEL, [VENDOR, HUAWEI], [TYPE, MOBILE]],
                      [
                        // Xiaomi
                        /oid[^\)]+; (2[\dbc]{4}(182|283|rp\w{2})[cgl]|m2105k81a?c)(?: bui|\))/i,
                        /\b(?:xiao)?((?:red)?mi[-_ ]?pad[\w- ]*)(?: bui|\))/i
                        // Mi Pad tablets
                      ],
                      [[MODEL, /_/g, " "], [VENDOR, XIAOMI], [TYPE, TABLET]],
                      [
                        /\b(poco[\w ]+|m2\d{3}j\d\d[a-z]{2})(?: bui|\))/i,
                        // Xiaomi POCO
                        /\b; (\w+) build\/hm\1/i,
                        // Xiaomi Hongmi 'numeric' models
                        /\b(hm[-_ ]?note?[_ ]?(?:\d\w)?) bui/i,
                        // Xiaomi Hongmi
                        /\b(redmi[\-_ ]?(?:note|k)?[\w_ ]+)(?: bui|\))/i,
                        // Xiaomi Redmi
                        /oid[^\)]+; (m?[12][0-389][01]\w{3,6}[c-y])( bui|; wv|\))/i,
                        // Xiaomi Redmi 'numeric' models
                        /\b(mi[-_ ]?(?:a\d|one|one[_ ]plus|note|max|cc)?[_ ]?(?:\d{0,2}\w?)[_ ]?(?:plus|se|lite|pro)?( 5g|lte)?)(?: bui|\))/i,
                        // Xiaomi Mi
                        / ([\w ]+) miui\/v?\d/i
                      ],
                      [[MODEL, /_/g, " "], [VENDOR, XIAOMI], [TYPE, MOBILE]],
                      [
                        // OnePlus
                        /droid.+; (cph2[3-6]\d[13579]|((gm|hd)19|(ac|be|in|kb)20|(d[en]|eb|le|mt)21|ne22)[0-2]\d|p[g-k]\w[1m]10)\b/i,
                        /(?:one)?(?:plus)? (a\d0\d\d)(?: b|\))/i
                      ],
                      [MODEL, [VENDOR, ONEPLUS], [TYPE, MOBILE]],
                      [
                        // OPPO
                        /; (\w+) bui.+ oppo/i,
                        /\b(cph[12]\d{3}|p(?:af|c[al]|d\w|e[ar])[mt]\d0|x9007|a101op)\b/i
                      ],
                      [MODEL, [VENDOR, OPPO], [TYPE, MOBILE]],
                      [
                        /\b(opd2(\d{3}a?))(?: bui|\))/i
                      ],
                      [MODEL, [VENDOR, strMapper, { "OnePlus": ["203", "304", "403", "404", "413", "415"], "*": OPPO }], [TYPE, TABLET]],
                      [
                        // BLU
                        /(vivo (5r?|6|8l?|go|one|s|x[il]?[2-4]?)[\w\+ ]*)(?: bui|\))/i
                        // Vivo series
                      ],
                      [MODEL, [VENDOR, "BLU"], [TYPE, MOBILE]],
                      [
                        // Vivo
                        /; vivo (\w+)(?: bui|\))/i,
                        /\b(v[12]\d{3}\w?[at])(?: bui|;)/i
                      ],
                      [MODEL, [VENDOR, "Vivo"], [TYPE, MOBILE]],
                      [
                        // Realme
                        /\b(rmx[1-3]\d{3})(?: bui|;|\))/i
                      ],
                      [MODEL, [VENDOR, "Realme"], [TYPE, MOBILE]],
                      [
                        // Lenovo
                        /(ideatab[-\w ]+|602lv|d-42a|a101lv|a2109a|a3500-hv|s[56]000|pb-6505[my]|tb-?x?\d{3,4}(?:f[cu]|xu|[av])|yt\d?-[jx]?\d+[lfmx])( bui|;|\)|\/)/i,
                        /lenovo ?(b[68]0[08]0-?[hf]?|tab(?:[\w- ]+?)|tb[\w-]{6,7})( bui|;|\)|\/)/i
                      ],
                      [MODEL, [VENDOR, LENOVO], [TYPE, TABLET]],
                      [
                        /lenovo[-_ ]?([-\w ]+?)(?: bui|\)|\/)/i
                      ],
                      [MODEL, [VENDOR, LENOVO], [TYPE, MOBILE]],
                      [
                        // Motorola
                        /\b(milestone|droid(?:[2-4x]| (?:bionic|x2|pro|razr))?:?( 4g)?)\b[\w ]+build\//i,
                        /\bmot(?:orola)?[- ]([\w\s]+)(\)| bui)/i,
                        /((?:moto(?! 360)[-\w\(\) ]+|xt\d{3,4}[cgkosw\+]?[-\d]*|nexus 6)(?= bui|\)))/i
                      ],
                      [MODEL, [VENDOR, MOTOROLA], [TYPE, MOBILE]],
                      [
                        /\b(mz60\d|xoom[2 ]{0,2}) build\//i
                      ],
                      [MODEL, [VENDOR, MOTOROLA], [TYPE, TABLET]],
                      [
                        // LG
                        /((?=lg)?[vl]k\-?\d{3}) bui| 3\.[-\w; ]{10}lg?-([06cv9]{3,4})/i
                      ],
                      [MODEL, [VENDOR, LG], [TYPE, TABLET]],
                      [
                        /(lm(?:-?f100[nv]?|-[\w\.]+)(?= bui|\))|nexus [45])/i,
                        /\blg[-e;\/ ]+(?!.*(?:browser|netcast|android tv|watch|webos))(\w+)/i,
                        /\blg-?([\d\w]+) bui/i
                      ],
                      [MODEL, [VENDOR, LG], [TYPE, MOBILE]],
                      [
                        // Nokia
                        /(nokia) (t[12][01])/i
                      ],
                      [VENDOR, MODEL, [TYPE, TABLET]],
                      [
                        /(?:maemo|nokia).*(n900|lumia \d+|rm-\d+)/i,
                        /nokia[-_ ]?(([-\w\. ]*?))( bui|\)|;|\/)/i
                      ],
                      [[MODEL, /_/g, " "], [TYPE, MOBILE], [VENDOR, "Nokia"]],
                      [
                        // Google
                        /(pixel (c|tablet))\b/i
                        // Google Pixel C/Tablet
                      ],
                      [MODEL, [VENDOR, GOOGLE], [TYPE, TABLET]],
                      [
                        // Google Pixel
                        /droid.+;(?: google)? (g(01[13]a|020[aem]|025[jn]|1b60|1f8f|2ybb|4s1m|576d|5nz6|8hhn|8vou|a02099|c15s|d1yq|e2ae|ec77|gh2x|kv4x|p4bc|pj41|r83y|tt9q|ur25|wvk6)|pixel[\d ]*a?( pro)?( xl)?( fold)?( \(5g\))?)( bui|\))/i
                      ],
                      [MODEL, [VENDOR, GOOGLE], [TYPE, MOBILE]],
                      [
                        /(google) (pixelbook( go)?)/i
                      ],
                      [VENDOR, MODEL],
                      [
                        // Sony
                        /droid.+; (a?\d[0-2]{2}so|[c-g]\d{4}|so[-gl]\w+|xq-\w\w\d\d)(?= bui|\).+chrome\/(?![1-6]{0,1}\d\.))/i
                      ],
                      [MODEL, [VENDOR, SONY], [TYPE, MOBILE]],
                      [
                        /sony tablet [ps]/i,
                        /\b(?:sony)?sgp\w+(?: bui|\))/i
                      ],
                      [[MODEL, "Xperia Tablet"], [VENDOR, SONY], [TYPE, TABLET]],
                      [
                        // Amazon
                        /(alexa)webm/i,
                        /(kf[a-z]{2}wi|aeo(?!bc)\w\w)( bui|\))/i,
                        // Kindle Fire without Silk / Echo Show
                        /(kf[a-z]+)( bui|\)).+silk\//i
                        // Kindle Fire HD
                      ],
                      [MODEL, [VENDOR, AMAZON], [TYPE, TABLET]],
                      [
                        /((?:sd|kf)[0349hijorstuw]+)( bui|\)).+silk\//i
                        // Fire Phone
                      ],
                      [[MODEL, /(.+)/g, "Fire Phone $1"], [VENDOR, AMAZON], [TYPE, MOBILE]],
                      [
                        // BlackBerry
                        /(playbook);[-\w\),; ]+(rim)/i
                        // BlackBerry PlayBook
                      ],
                      [MODEL, VENDOR, [TYPE, TABLET]],
                      [
                        /\b((?:bb[a-f]|st[hv])100-\d)/i,
                        /(?:blackberry|\(bb10;) (\w+)/i
                      ],
                      [MODEL, [VENDOR, BLACKBERRY], [TYPE, MOBILE]],
                      [
                        // Asus
                        /(?:\b|asus_)(transfo[prime ]{4,10} \w+|eeepc|slider \w+|nexus 7|padfone|p00[cj])/i
                      ],
                      [MODEL, [VENDOR, ASUS], [TYPE, TABLET]],
                      [
                        / (z[bes]6[027][012][km][ls]|zenfone \d\w?)\b/i
                      ],
                      [MODEL, [VENDOR, ASUS], [TYPE, MOBILE]],
                      [
                        // HTC
                        /(nexus 9)/i
                        // HTC Nexus 9
                      ],
                      [MODEL, [VENDOR, "HTC"], [TYPE, TABLET]],
                      [
                        /(htc)[-;_ ]{1,2}([\w ]+(?=\)| bui)|\w+)/i,
                        // HTC
                        // ZTE
                        /(zte)[- ]([\w ]+?)(?: bui|\/|\))/i,
                        /(alcatel|geeksphone|nexian|panasonic(?!(?:;|\.))|sony(?!-bra))[-_ ]?([-\w]*)/i
                        // Alcatel/GeeksPhone/Nexian/Panasonic/Sony
                      ],
                      [VENDOR, [MODEL, /_/g, " "], [TYPE, MOBILE]],
                      [
                        // TCL
                        /tcl (xess p17aa)/i,
                        /droid [\w\.]+; ((?:8[14]9[16]|9(?:0(?:48|60|8[01])|1(?:3[27]|66)|2(?:6[69]|9[56])|466))[gqswx])(_\w(\w|\w\w))?(\)| bui)/i
                      ],
                      [MODEL, [VENDOR, "TCL"], [TYPE, TABLET]],
                      [
                        /droid [\w\.]+; (418(?:7d|8v)|5087z|5102l|61(?:02[dh]|25[adfh]|27[ai]|56[dh]|59k|65[ah])|a509dl|t(?:43(?:0w|1[adepqu])|50(?:6d|7[adju])|6(?:09dl|10k|12b|71[efho]|76[hjk])|7(?:66[ahju]|67[hw]|7[045][bh]|71[hk]|73o|76[ho]|79w|81[hks]?|82h|90[bhsy]|99b)|810[hs]))(_\w(\w|\w\w))?(\)| bui)/i
                      ],
                      [MODEL, [VENDOR, "TCL"], [TYPE, MOBILE]],
                      [
                        // itel
                        /(itel) ((\w+))/i
                      ],
                      [[VENDOR, lowerize], MODEL, [TYPE, strMapper, { "tablet": ["p10001l", "w7001"], "*": "mobile" }]],
                      [
                        // Acer
                        /droid.+; ([ab][1-7]-?[0178a]\d\d?)/i
                      ],
                      [MODEL, [VENDOR, "Acer"], [TYPE, TABLET]],
                      [
                        // Meizu
                        /droid.+; (m[1-5] note) bui/i,
                        /\bmz-([-\w]{2,})/i
                      ],
                      [MODEL, [VENDOR, "Meizu"], [TYPE, MOBILE]],
                      [
                        // Ulefone
                        /; ((?:power )?armor(?:[\w ]{0,8}))(?: bui|\))/i
                      ],
                      [MODEL, [VENDOR, "Ulefone"], [TYPE, MOBILE]],
                      [
                        // Energizer
                        /; (energy ?\w+)(?: bui|\))/i,
                        /; energizer ([\w ]+)(?: bui|\))/i
                      ],
                      [MODEL, [VENDOR, "Energizer"], [TYPE, MOBILE]],
                      [
                        // Cat
                        /; cat (b35);/i,
                        /; (b15q?|s22 flip|s48c|s62 pro)(?: bui|\))/i
                      ],
                      [MODEL, [VENDOR, "Cat"], [TYPE, MOBILE]],
                      [
                        // Smartfren
                        /((?:new )?andromax[\w- ]+)(?: bui|\))/i
                      ],
                      [MODEL, [VENDOR, "Smartfren"], [TYPE, MOBILE]],
                      [
                        // Nothing
                        /droid.+; (a(in)?(0(15|59|6[35])|142)p?)/i
                      ],
                      [MODEL, [VENDOR, "Nothing"], [TYPE, MOBILE]],
                      [
                        // Archos
                        /; (x67 5g|tikeasy \w+|ac[1789]\d\w+)( b|\))/i,
                        /archos ?(5|gamepad2?|([\w ]*[t1789]|hello) ?\d+[\w ]*)( b|\))/i
                      ],
                      [MODEL, [VENDOR, "Archos"], [TYPE, TABLET]],
                      [
                        /archos ([\w ]+)( b|\))/i,
                        /; (ac[3-6]\d\w{2,8})( b|\))/i
                      ],
                      [MODEL, [VENDOR, "Archos"], [TYPE, MOBILE]],
                      [
                        // HMD
                        /; (n159v)/i
                      ],
                      [MODEL, [VENDOR, "HMD"], [TYPE, MOBILE]],
                      [
                        // MIXED
                        /(imo) (tab \w+)/i,
                        // IMO
                        /(infinix|tecno) (x1101b?|p904|dp(7c|8d|10a)( pro)?|p70[1-3]a?|p904|t1101)/i
                        // Infinix XPad / Tecno
                      ],
                      [VENDOR, MODEL, [TYPE, TABLET]],
                      [
                        /(blackberry|benq|palm(?=\-)|sonyericsson|acer|asus(?! zenw)|dell|jolla|meizu|motorola|polytron|tecno|micromax|advan)[-_ ]?([-\w]*)/i,
                        // BlackBerry/BenQ/Palm/Sony-Ericsson/Acer/Asus/Dell/Meizu/Motorola/Polytron/Tecno/Micromax/Advan
                        // BLU/HMD/IMO/Infinix/Lava/OnePlus/TCL/Wiko
                        /; (blu|hmd|imo|infinix|lava|oneplus|tcl|wiko)[_ ]([\w\+ ]+?)(?: bui|\)|; r)/i,
                        /(hp) ([\w ]+\w)/i,
                        // HP iPAQ
                        /(microsoft); (lumia[\w ]+)/i,
                        // Microsoft Lumia
                        /(oppo) ?([\w ]+) bui/i,
                        // OPPO
                        /(hisense) ([ehv][\w ]+)\)/i,
                        // Hisense
                        /droid[^;]+; (philips)[_ ]([sv-x][\d]{3,4}[xz]?)/i
                        // Philips
                      ],
                      [VENDOR, MODEL, [TYPE, MOBILE]],
                      [
                        /(kobo)\s(ereader|touch)/i,
                        // Kobo
                        /(hp).+(touchpad(?!.+tablet)|tablet)/i,
                        // HP TouchPad
                        /(kindle)\/([\w\.]+)/i
                        // Kindle
                      ],
                      [VENDOR, MODEL, [TYPE, TABLET]],
                      [
                        /(surface duo)/i
                        // Surface Duo
                      ],
                      [MODEL, [VENDOR, MICROSOFT], [TYPE, TABLET]],
                      [
                        /droid [\d\.]+; (fp\du?)(?: b|\))/i
                        // Fairphone
                      ],
                      [MODEL, [VENDOR, "Fairphone"], [TYPE, MOBILE]],
                      [
                        /((?:tegranote|shield t(?!.+d tv))[\w- ]*?)(?: b|\))/i
                        // Nvidia Tablets
                      ],
                      [MODEL, [VENDOR, NVIDIA], [TYPE, TABLET]],
                      [
                        /(sprint) (\w+)/i
                        // Sprint Phones
                      ],
                      [VENDOR, MODEL, [TYPE, MOBILE]],
                      [
                        /(kin\.[onetw]{3})/i
                        // Microsoft Kin
                      ],
                      [[MODEL, /\./g, " "], [VENDOR, MICROSOFT], [TYPE, MOBILE]],
                      [
                        /droid.+; ([c6]+|et5[16]|mc[239][23]x?|vc8[03]x?)\)/i
                        // Zebra
                      ],
                      [MODEL, [VENDOR, ZEBRA], [TYPE, TABLET]],
                      [
                        /droid.+; (ec30|ps20|tc[2-8]\d[kx])\)/i
                      ],
                      [MODEL, [VENDOR, ZEBRA], [TYPE, MOBILE]],
                      [
                        ///////////////////
                        // SMARTTVS
                        ///////////////////
                        /(philips)[\w ]+tv/i,
                        // Philips
                        /smart-tv.+(samsung)/i
                        // Samsung
                      ],
                      [VENDOR, [TYPE, SMARTTV]],
                      [
                        /hbbtv.+maple;(\d+)/i
                      ],
                      [[MODEL, /^/, "SmartTV"], [VENDOR, SAMSUNG], [TYPE, SMARTTV]],
                      [
                        /(vizio)(?: |.+model\/)(\w+-\w+)/i,
                        // Vizio
                        /tcast.+(lg)e?. ([-\w]+)/i
                        // LG SmartTV
                      ],
                      [VENDOR, MODEL, [TYPE, SMARTTV]],
                      [
                        /(nux; netcast.+smarttv|lg (netcast\.tv-201\d|android tv))/i
                      ],
                      [[VENDOR, LG], [TYPE, SMARTTV]],
                      [
                        /(apple) ?tv/i
                        // Apple TV
                      ],
                      [VENDOR, [MODEL, APPLE + " TV"], [TYPE, SMARTTV]],
                      [
                        /crkey.*devicetype\/chromecast/i
                        // Google Chromecast Third Generation
                      ],
                      [[MODEL, CHROMECAST + " Third Generation"], [VENDOR, GOOGLE], [TYPE, SMARTTV]],
                      [
                        /crkey.*devicetype\/([^/]*)/i
                        // Google Chromecast with specific device type
                      ],
                      [[MODEL, /^/, "Chromecast "], [VENDOR, GOOGLE], [TYPE, SMARTTV]],
                      [
                        /fuchsia.*crkey/i
                        // Google Chromecast Nest Hub
                      ],
                      [[MODEL, CHROMECAST + " Nest Hub"], [VENDOR, GOOGLE], [TYPE, SMARTTV]],
                      [
                        /crkey/i
                        // Google Chromecast, Linux-based or unknown
                      ],
                      [[MODEL, CHROMECAST], [VENDOR, GOOGLE], [TYPE, SMARTTV]],
                      [
                        /(portaltv)/i
                        // Facebook Portal TV
                      ],
                      [MODEL, [VENDOR, FACEBOOK], [TYPE, SMARTTV]],
                      [
                        /droid.+aft(\w+)( bui|\))/i
                        // Fire TV
                      ],
                      [MODEL, [VENDOR, AMAZON], [TYPE, SMARTTV]],
                      [
                        /(shield \w+ tv)/i
                        // Nvidia Shield TV
                      ],
                      [MODEL, [VENDOR, NVIDIA], [TYPE, SMARTTV]],
                      [
                        /\(dtv[\);].+(aquos)/i,
                        /(aquos-tv[\w ]+)\)/i
                        // Sharp
                      ],
                      [MODEL, [VENDOR, SHARP], [TYPE, SMARTTV]],
                      [
                        /(bravia[\w ]+)( bui|\))/i
                        // Sony
                      ],
                      [MODEL, [VENDOR, SONY], [TYPE, SMARTTV]],
                      [
                        /(mi(tv|box)-?\w+) bui/i
                        // Xiaomi
                      ],
                      [MODEL, [VENDOR, XIAOMI], [TYPE, SMARTTV]],
                      [
                        /Hbbtv.*(technisat) (.*);/i
                        // TechniSAT
                      ],
                      [VENDOR, MODEL, [TYPE, SMARTTV]],
                      [
                        /\b(roku)[\dx]*[\)\/]((?:dvp-)?[\d\.]*)/i,
                        // Roku
                        /hbbtv\/\d+\.\d+\.\d+ +\([\w\+ ]*; *([\w\d][^;]*);([^;]*)/i
                        // HbbTV devices
                      ],
                      [[VENDOR, /.+\/(\w+)/, "$1", strMapper, { "LG": "lge" }], [MODEL, trim], [TYPE, SMARTTV]],
                      [
                        ///////////////////
                        // CONSOLES
                        ///////////////////
                        /(playstation \w+)/i
                        // Playstation
                      ],
                      [MODEL, [VENDOR, SONY], [TYPE, CONSOLE]],
                      [
                        /\b(xbox(?: one)?(?!; xbox))[\); ]/i
                        // Microsoft Xbox
                      ],
                      [MODEL, [VENDOR, MICROSOFT], [TYPE, CONSOLE]],
                      [
                        /(ouya)/i,
                        // Ouya
                        /(nintendo) (\w+)/i,
                        // Nintendo
                        /(retroid) (pocket ([^\)]+))/i
                        // Retroid Pocket
                      ],
                      [VENDOR, MODEL, [TYPE, CONSOLE]],
                      [
                        /droid.+; (shield)( bui|\))/i
                        // Nvidia Portable
                      ],
                      [MODEL, [VENDOR, NVIDIA], [TYPE, CONSOLE]],
                      [
                        ///////////////////
                        // WEARABLES
                        ///////////////////
                        /\b(sm-[lr]\d\d[0156][fnuw]?s?|gear live)\b/i
                        // Samsung Galaxy Watch
                      ],
                      [MODEL, [VENDOR, SAMSUNG], [TYPE, WEARABLE]],
                      [
                        /((pebble))app/i,
                        // Pebble
                        /(asus|google|lg|oppo) ((pixel |zen)?watch[\w ]*)( bui|\))/i
                        // Asus ZenWatch / LG Watch / Pixel Watch
                      ],
                      [VENDOR, MODEL, [TYPE, WEARABLE]],
                      [
                        /(ow(?:19|20)?we?[1-3]{1,3})/i
                        // Oppo Watch
                      ],
                      [MODEL, [VENDOR, OPPO], [TYPE, WEARABLE]],
                      [
                        /(watch)(?: ?os[,\/]|\d,\d\/)[\d\.]+/i
                        // Apple Watch
                      ],
                      [MODEL, [VENDOR, APPLE], [TYPE, WEARABLE]],
                      [
                        /(opwwe\d{3})/i
                        // OnePlus Watch
                      ],
                      [MODEL, [VENDOR, ONEPLUS], [TYPE, WEARABLE]],
                      [
                        /(moto 360)/i
                        // Motorola 360
                      ],
                      [MODEL, [VENDOR, MOTOROLA], [TYPE, WEARABLE]],
                      [
                        /(smartwatch 3)/i
                        // Sony SmartWatch
                      ],
                      [MODEL, [VENDOR, SONY], [TYPE, WEARABLE]],
                      [
                        /(g watch r)/i
                        // LG G Watch R
                      ],
                      [MODEL, [VENDOR, LG], [TYPE, WEARABLE]],
                      [
                        /droid.+; (wt63?0{2,3})\)/i
                      ],
                      [MODEL, [VENDOR, ZEBRA], [TYPE, WEARABLE]],
                      [
                        ///////////////////
                        // XR
                        ///////////////////
                        /droid.+; (glass) \d/i
                        // Google Glass
                      ],
                      [MODEL, [VENDOR, GOOGLE], [TYPE, XR]],
                      [
                        /(pico) ([\w ]+) os\d/i
                        // Pico
                      ],
                      [VENDOR, MODEL, [TYPE, XR]],
                      [
                        /(quest( \d| pro)?s?).+vr/i
                        // Meta Quest
                      ],
                      [MODEL, [VENDOR, FACEBOOK], [TYPE, XR]],
                      [
                        /mobile vr; rv.+firefox/i
                        // Unidentifiable VR device using Firefox Reality / Wolvic
                      ],
                      [[TYPE, XR]],
                      [
                        ///////////////////
                        // EMBEDDED
                        ///////////////////
                        /(tesla)(?: qtcarbrowser|\/[-\w\.]+)/i
                        // Tesla
                      ],
                      [VENDOR, [TYPE, EMBEDDED]],
                      [
                        /(aeobc)\b/i
                        // Echo Dot
                      ],
                      [MODEL, [VENDOR, AMAZON], [TYPE, EMBEDDED]],
                      [
                        /(homepod).+mac os/i
                        // Apple HomePod
                      ],
                      [MODEL, [VENDOR, APPLE], [TYPE, EMBEDDED]],
                      [
                        /windows iot/i
                        // Unidentifiable embedded device using Windows IoT
                      ],
                      [[TYPE, EMBEDDED]],
                      [
                        ////////////////////
                        // MIXED (GENERIC)
                        ///////////////////
                        /droid.+; ([\w- ]+) (4k|android|smart|google)[- ]?tv/i
                        // Unidentifiable SmartTV
                      ],
                      [MODEL, [TYPE, SMARTTV]],
                      [
                        /\b((4k|android|smart|opera)[- ]?tv|tv; rv:|large screen[\w ]+safari)\b/i
                      ],
                      [[TYPE, SMARTTV]],
                      [
                        /droid .+?; ([^;]+?)(?: bui|; wv\)|\) applew|; hmsc).+?(mobile|vr|\d) safari/i
                      ],
                      [MODEL, [TYPE, strMapper, { "mobile": "Mobile", "xr": "VR", "*": TABLET }]],
                      [
                        /\b((tablet|tab)[;\/]|focus\/\d(?!.+mobile))/i
                        // Unidentifiable Tablet
                      ],
                      [[TYPE, TABLET]],
                      [
                        /(phone|mobile(?:[;\/]| [ \w\/\.]*safari)|pda(?=.+windows ce))/i
                        // Unidentifiable Mobile
                      ],
                      [[TYPE, MOBILE]],
                      [
                        /droid .+?; ([\w\. -]+)( bui|\))/i
                        // Generic Android Device
                      ],
                      [MODEL, [VENDOR, "Generic"]]
                    ],
                    engine: [
                      [
                        /windows.+ edge\/([\w\.]+)/i
                        // EdgeHTML
                      ],
                      [VERSION, [NAME, EDGE + "HTML"]],
                      [
                        /(arkweb)\/([\w\.]+)/i
                        // ArkWeb
                      ],
                      [NAME, VERSION],
                      [
                        /webkit\/537\.36.+chrome\/(?!27)([\w\.]+)/i
                        // Blink
                      ],
                      [VERSION, [NAME, "Blink"]],
                      [
                        /(presto)\/([\w\.]+)/i,
                        // Presto
                        /(webkit|trident|netfront|netsurf|amaya|lynx|w3m|goanna|servo)\/([\w\.]+)/i,
                        // WebKit/Trident/NetFront/NetSurf/Amaya/Lynx/w3m/Goanna/Servo
                        /ekioh(flow)\/([\w\.]+)/i,
                        // Flow
                        /(khtml|tasman|links)[\/ ]\(?([\w\.]+)/i,
                        // KHTML/Tasman/Links
                        /(icab)[\/ ]([23]\.[\d\.]+)/i,
                        // iCab
                        /\b(libweb)/i
                        // LibWeb
                      ],
                      [NAME, VERSION],
                      [
                        /ladybird\//i
                      ],
                      [[NAME, "LibWeb"]],
                      [
                        /rv\:([\w\.]{1,9})\b.+(gecko)/i
                        // Gecko
                      ],
                      [VERSION, NAME]
                    ],
                    os: [
                      [
                        // Windows
                        /(windows nt) (6\.[23]); arm/i
                        // Windows RT
                      ],
                      [[NAME, /N/, "R"], [VERSION, strMapper, windowsVersionMap]],
                      [
                        /(windows (?:phone|mobile|iot))(?: os)?[\/ ]?([\d\.]*( se)?)/i,
                        // Windows IoT/Mobile/Phone
                        // Windows NT/3.1/95/98/ME/2000/XP/Vista/7/8/8.1/10/11
                        /(windows)[\/ ](1[01]|2000|3\.1|7|8(\.1)?|9[58]|me|server 20\d\d( r2)?|vista|xp)/i
                      ],
                      [NAME, VERSION],
                      [
                        /windows nt ?([\d\.\)]*)(?!.+xbox)/i,
                        /\bwin(?=3| ?9|n)(?:nt| 9x )?([\d\.;]*)/i
                      ],
                      [[VERSION, /(;|\))/g, "", strMapper, windowsVersionMap], [NAME, WINDOWS]],
                      [
                        /(windows ce)\/?([\d\.]*)/i
                        // Windows CE
                      ],
                      [NAME, VERSION],
                      [
                        // iOS/macOS
                        /[adehimnop]{4,7}\b(?:.*os ([\w]+) like mac|; opera)/i,
                        // iOS
                        /(?:ios;fbsv|ios(?=.+ip(?:ad|hone))|ip(?:ad|hone)(?: |.+i(?:pad)?)os)[\/ ]([\w\.]+)/i,
                        /cfnetwork\/.+darwin/i
                      ],
                      [[VERSION, /_/g, "."], [NAME, "iOS"]],
                      [
                        /(mac os x) ?([\w\. ]*)/i,
                        /(macintosh|mac_powerpc\b)(?!.+(haiku|morphos))/i
                        // Mac OS
                      ],
                      [[NAME, "macOS"], [VERSION, /_/g, "."]],
                      [
                        // Google Chromecast
                        /android ([\d\.]+).*crkey/i
                        // Google Chromecast, Android-based
                      ],
                      [VERSION, [NAME, CHROMECAST + " Android"]],
                      [
                        /fuchsia.*crkey\/([\d\.]+)/i
                        // Google Chromecast, Fuchsia-based
                      ],
                      [VERSION, [NAME, CHROMECAST + " Fuchsia"]],
                      [
                        /crkey\/([\d\.]+).*devicetype\/smartspeaker/i
                        // Google Chromecast, Linux-based Smart Speaker
                      ],
                      [VERSION, [NAME, CHROMECAST + " SmartSpeaker"]],
                      [
                        /linux.*crkey\/([\d\.]+)/i
                        // Google Chromecast, Legacy Linux-based
                      ],
                      [VERSION, [NAME, CHROMECAST + " Linux"]],
                      [
                        /crkey\/([\d\.]+)/i
                        // Google Chromecast, unknown
                      ],
                      [VERSION, [NAME, CHROMECAST]],
                      [
                        // Mobile OSes
                        /droid ([\w\.]+)\b.+(android[- ]x86)/i
                        // Android-x86
                      ],
                      [VERSION, NAME],
                      [
                        /(ubuntu) ([\w\.]+) like android/i
                        // Ubuntu Touch
                      ],
                      [[NAME, /(.+)/, "$1 Touch"], VERSION],
                      [
                        /(harmonyos)[\/ ]?([\d\.]*)/i,
                        // HarmonyOS
                        // Android/Blackberry/WebOS/QNX/Bada/RIM/KaiOS/Maemo/MeeGo/S40/Sailfish OS/OpenHarmony/Tizen
                        /(android|bada|blackberry|kaios|maemo|meego|openharmony|qnx|rim tablet os|sailfish|series40|symbian|tizen)\w*[-\/\.; ]?([\d\.]*)/i
                      ],
                      [NAME, VERSION],
                      [
                        /\(bb(10);/i
                        // BlackBerry 10
                      ],
                      [VERSION, [NAME, BLACKBERRY]],
                      [
                        /(?:symbian ?os|symbos|s60(?=;)|series ?60)[-\/ ]?([\w\.]*)/i
                        // Symbian
                      ],
                      [VERSION, [NAME, "Symbian"]],
                      [
                        /mozilla\/[\d\.]+ \((?:mobile|tablet|tv|mobile; [\w ]+); rv:.+ gecko\/([\w\.]+)/i
                        // Firefox OS
                      ],
                      [VERSION, [NAME, FIREFOX + " OS"]],
                      [
                        /\b(?:hp)?wos(?:browser)?\/([\w\.]+)/i,
                        // WebOS
                        /webos(?:[ \/]?|\.tv-20(?=2[2-9]))(\d[\d\.]*)/i
                      ],
                      [VERSION, [NAME, "webOS"]],
                      [
                        /web0s;.+?(?:chr[o0]me|safari)\/(\d+)/i
                        // https://webostv.developer.lge.com/develop/specifications/web-api-and-web-engine
                      ],
                      [[VERSION, strMapper, { "25": "120", "24": "108", "23": "94", "22": "87", "6": "79", "5": "68", "4": "53", "3": "38", "2": "538", "1": "537", "*": "TV" }], [NAME, "webOS"]],
                      [
                        /watch(?: ?os[,\/]|\d,\d\/)([\d\.]+)/i
                        // watchOS
                      ],
                      [VERSION, [NAME, "watchOS"]],
                      [
                        // Google ChromeOS
                        /(cros) [\w]+(?:\)| ([\w\.]+)\b)/i
                        // Chromium OS
                      ],
                      [[NAME, "Chrome OS"], VERSION],
                      [
                        // Smart TVs
                        /panasonic;(viera)/i,
                        // Panasonic Viera
                        /(netrange)mmh/i,
                        // Netrange
                        /(nettv)\/(\d+\.[\w\.]+)/i,
                        // NetTV
                        // Console
                        /(nintendo|playstation) (\w+)/i,
                        // Nintendo/Playstation
                        /(xbox); +xbox ([^\);]+)/i,
                        // Microsoft Xbox (360, One, X, S, Series X, Series S)
                        /(pico) .+os([\w\.]+)/i,
                        // Pico
                        // Other
                        /\b(joli|palm)\b ?(?:os)?\/?([\w\.]*)/i,
                        // Joli/Palm
                        /linux.+(mint)[\/\(\) ]?([\w\.]*)/i,
                        // Mint
                        /(mageia|vectorlinux|fuchsia|arcaos|arch(?= ?linux))[;l ]([\d\.]*)/i,
                        // Mageia/VectorLinux/Fuchsia/ArcaOS/Arch
                        /([kxln]?ubuntu|debian|suse|opensuse|gentoo|slackware|fedora|mandriva|centos|pclinuxos|red ?hat|zenwalk|linpus|raspbian|plan 9|minix|risc os|contiki|deepin|manjaro|elementary os|sabayon|linspire|knoppix)(?: gnu[\/ ]linux)?(?: enterprise)?(?:[- ]linux)?(?:-gnu)?[-\/ ]?(?!chrom|package)([-\w\.]*)/i,
                        // Ubuntu/Debian/SUSE/Gentoo/Slackware/Fedora/Mandriva/CentOS/PCLinuxOS/RedHat/Zenwalk/Linpus/Raspbian/Plan9/Minix/RISCOS/Contiki/Deepin/Manjaro/elementary/Sabayon/Linspire/Knoppix
                        /((?:open)?solaris)[-\/ ]?([\w\.]*)/i,
                        // Solaris
                        /\b(aix)[; ]([1-9\.]{0,4})/i,
                        // AIX
                        /(hurd|linux|morphos)(?: (?:arm|x86|ppc)\w*| ?)([\w\.]*)/i,
                        // Hurd/Linux/MorphOS
                        /(gnu) ?([\w\.]*)/i,
                        // GNU
                        /\b([-frentopcghs]{0,5}bsd|dragonfly)[\/ ]?(?!amd|[ix346]{1,2}86)([\w\.]*)/i,
                        // FreeBSD/NetBSD/OpenBSD/PC-BSD/GhostBSD/DragonFly
                        /(haiku) ?(r\d)?/i
                        // Haiku
                      ],
                      [NAME, VERSION],
                      [
                        /(sunos) ?([\d\.]*)/i
                        // Solaris
                      ],
                      [[NAME, "Solaris"], VERSION],
                      [
                        /\b(beos|os\/2|amigaos|openvms|hp-ux|serenityos)/i,
                        // BeOS/OS2/AmigaOS/OpenVMS/HP-UX/SerenityOS
                        /(unix) ?([\w\.]*)/i
                        // UNIX
                      ],
                      [NAME, VERSION]
                    ]
                  };
                  var defaultProps = function() {
                    var props = { init: {}, isIgnore: {}, isIgnoreRgx: {}, toString: {} };
                    setProps.call(props.init, [
                      [BROWSER, [NAME, VERSION, MAJOR, TYPE]],
                      [CPU, [ARCHITECTURE]],
                      [DEVICE, [TYPE, MODEL, VENDOR]],
                      [ENGINE, [NAME, VERSION]],
                      [OS, [NAME, VERSION]]
                    ]);
                    setProps.call(props.isIgnore, [
                      [BROWSER, [VERSION, MAJOR]],
                      [ENGINE, [VERSION]],
                      [OS, [VERSION]]
                    ]);
                    setProps.call(props.isIgnoreRgx, [
                      [BROWSER, / ?browser$/i],
                      [OS, / ?os$/i]
                    ]);
                    setProps.call(props.toString, [
                      [BROWSER, [NAME, VERSION]],
                      [CPU, [ARCHITECTURE]],
                      [DEVICE, [VENDOR, MODEL]],
                      [ENGINE, [NAME, VERSION]],
                      [OS, [NAME, VERSION]]
                    ]);
                    return props;
                  }();
                  var createIData = function(item, itemType) {
                    var init_props = defaultProps.init[itemType], is_ignoreProps = defaultProps.isIgnore[itemType] || 0, is_ignoreRgx = defaultProps.isIgnoreRgx[itemType] || 0, toString_props = defaultProps.toString[itemType] || 0;
                    function IData() {
                      setProps.call(this, init_props);
                    }
                    IData.prototype.getItem = function() {
                      return item;
                    };
                    IData.prototype.withClientHints = function() {
                      if (!NAVIGATOR_UADATA) {
                        return item.parseCH().get();
                      }
                      return NAVIGATOR_UADATA.getHighEntropyValues(CH_ALL_VALUES).then(function(res) {
                        return item.setCH(new UACHData(res, false)).parseCH().get();
                      });
                    };
                    IData.prototype.withFeatureCheck = function() {
                      return item.detectFeature().get();
                    };
                    if (itemType != RESULT) {
                      IData.prototype.is = function(strToCheck) {
                        var is = false;
                        for (var i in this) {
                          if (this.hasOwnProperty(i) && !has(is_ignoreProps, i) && lowerize(is_ignoreRgx ? strip(is_ignoreRgx, this[i]) : this[i]) == lowerize(is_ignoreRgx ? strip(is_ignoreRgx, strToCheck) : strToCheck)) {
                            is = true;
                            if (strToCheck != TYPEOF.UNDEFINED) break;
                          } else if (strToCheck == TYPEOF.UNDEFINED && is) {
                            is = !is;
                            break;
                          }
                        }
                        return is;
                      };
                      IData.prototype.toString = function() {
                        var str = EMPTY;
                        for (var i in toString_props) {
                          if (typeof this[toString_props[i]] !== TYPEOF.UNDEFINED) {
                            str += (str ? " " : EMPTY) + this[toString_props[i]];
                          }
                        }
                        return str || TYPEOF.UNDEFINED;
                      };
                    }
                    if (!NAVIGATOR_UADATA) {
                      IData.prototype.then = function(cb) {
                        var that = this;
                        var IDataResolve = function() {
                          for (var prop in that) {
                            if (that.hasOwnProperty(prop)) {
                              this[prop] = that[prop];
                            }
                          }
                        };
                        IDataResolve.prototype = {
                          is: IData.prototype.is,
                          toString: IData.prototype.toString
                        };
                        var resolveData = new IDataResolve();
                        cb(resolveData);
                        return resolveData;
                      };
                    }
                    return new IData();
                  };
                  function UACHData(uach, isHttpUACH) {
                    uach = uach || {};
                    setProps.call(this, CH_ALL_VALUES);
                    if (isHttpUACH) {
                      setProps.call(this, [
                        [BRANDS, itemListToArray(uach[CH])],
                        [FULLVERLIST, itemListToArray(uach[CH_FULL_VER_LIST])],
                        [MOBILE, /\?1/.test(uach[CH_MOBILE])],
                        [MODEL, stripQuotes(uach[CH_MODEL])],
                        [PLATFORM, stripQuotes(uach[CH_PLATFORM])],
                        [PLATFORMVER, stripQuotes(uach[CH_PLATFORM_VER])],
                        [ARCHITECTURE, stripQuotes(uach[CH_ARCH])],
                        [FORMFACTORS, itemListToArray(uach[CH_FORM_FACTORS])],
                        [BITNESS, stripQuotes(uach[CH_BITNESS])]
                      ]);
                    } else {
                      for (var prop in uach) {
                        if (this.hasOwnProperty(prop) && typeof uach[prop] !== TYPEOF.UNDEFINED) this[prop] = uach[prop];
                      }
                    }
                  }
                  function UAItem(itemType, ua, rgxMap, uaCH) {
                    this.get = function(prop) {
                      if (!prop) return this.data;
                      return this.data.hasOwnProperty(prop) ? this.data[prop] : undefined2;
                    };
                    this.set = function(prop, val) {
                      this.data[prop] = val;
                      return this;
                    };
                    this.setCH = function(ch) {
                      this.uaCH = ch;
                      return this;
                    };
                    this.detectFeature = function() {
                      if (NAVIGATOR && NAVIGATOR.userAgent == this.ua) {
                        switch (this.itemType) {
                          case BROWSER:
                            if (NAVIGATOR.brave && typeof NAVIGATOR.brave.isBrave == TYPEOF.FUNCTION) {
                              this.set(NAME, "Brave");
                            }
                            break;
                          case DEVICE:
                            if (!this.get(TYPE) && NAVIGATOR_UADATA && NAVIGATOR_UADATA[MOBILE]) {
                              this.set(TYPE, MOBILE);
                            }
                            if (this.get(MODEL) == "Macintosh" && NAVIGATOR && typeof NAVIGATOR.standalone !== TYPEOF.UNDEFINED && NAVIGATOR.maxTouchPoints && NAVIGATOR.maxTouchPoints > 2) {
                              this.set(MODEL, "iPad").set(TYPE, TABLET);
                            }
                            break;
                          case OS:
                            if (!this.get(NAME) && NAVIGATOR_UADATA && NAVIGATOR_UADATA[PLATFORM]) {
                              this.set(NAME, NAVIGATOR_UADATA[PLATFORM]);
                            }
                            break;
                          case RESULT:
                            var data = this.data;
                            var detect = function(itemType2) {
                              return data[itemType2].getItem().detectFeature().get();
                            };
                            this.set(BROWSER, detect(BROWSER)).set(CPU, detect(CPU)).set(DEVICE, detect(DEVICE)).set(ENGINE, detect(ENGINE)).set(OS, detect(OS));
                        }
                      }
                      return this;
                    };
                    this.parseUA = function() {
                      if (this.itemType != RESULT) {
                        rgxMapper.call(this.data, this.ua, this.rgxMap);
                      }
                      switch (this.itemType) {
                        case BROWSER:
                          this.set(MAJOR, majorize(this.get(VERSION)));
                          break;
                        case OS:
                          if (this.get(NAME) == "iOS" && this.get(VERSION) == "18.6") {
                            var realVersion = /\) Version\/([\d\.]+)/.exec(this.ua);
                            if (realVersion && parseInt(realVersion[1].substring(0, 2), 10) >= 26) {
                              this.set(VERSION, realVersion[1]);
                            }
                          }
                          break;
                      }
                      return this;
                    };
                    this.parseCH = function() {
                      var uaCH2 = this.uaCH, rgxMap2 = this.rgxMap;
                      switch (this.itemType) {
                        case BROWSER:
                        case ENGINE:
                          var brands = uaCH2[FULLVERLIST] || uaCH2[BRANDS], prevName;
                          if (brands) {
                            for (var i = 0; i < brands.length; i++) {
                              var brandName = brands[i].brand || brands[i], brandVersion = brands[i].version;
                              if (this.itemType == BROWSER && !/not.a.brand/i.test(brandName) && (!prevName || /Chrom/.test(prevName) && brandName != CHROMIUM || prevName == EDGE && /WebView2/.test(brandName))) {
                                brandName = strMapper(brandName, browserHintsMap);
                                prevName = this.get(NAME);
                                if (!(prevName && !/Chrom/.test(prevName) && /Chrom/.test(brandName))) {
                                  this.set(NAME, brandName).set(VERSION, brandVersion).set(MAJOR, majorize(brandVersion));
                                }
                                prevName = brandName;
                              }
                              if (this.itemType == ENGINE && brandName == CHROMIUM) {
                                this.set(VERSION, brandVersion);
                              }
                            }
                          }
                          break;
                        case CPU:
                          var archName = uaCH2[ARCHITECTURE];
                          if (archName) {
                            if (archName && uaCH2[BITNESS] == "64") archName += "64";
                            rgxMapper.call(this.data, archName + ";", rgxMap2);
                          }
                          break;
                        case DEVICE:
                          if (uaCH2[MOBILE]) {
                            this.set(TYPE, MOBILE);
                          }
                          if (uaCH2[MODEL]) {
                            this.set(MODEL, uaCH2[MODEL]);
                            if (!this.get(TYPE) || !this.get(VENDOR)) {
                              var reParse = {};
                              rgxMapper.call(reParse, "droid 9; " + uaCH2[MODEL] + ")", rgxMap2);
                              if (!this.get(TYPE) && !!reParse.type) {
                                this.set(TYPE, reParse.type);
                              }
                              if (!this.get(VENDOR) && !!reParse.vendor) {
                                this.set(VENDOR, reParse.vendor);
                              }
                            }
                          }
                          if (uaCH2[FORMFACTORS]) {
                            var ff;
                            if (typeof uaCH2[FORMFACTORS] !== "string") {
                              var idx = 0;
                              while (!ff && idx < uaCH2[FORMFACTORS].length) {
                                ff = strMapper(uaCH2[FORMFACTORS][idx++], formFactorsMap);
                              }
                            } else {
                              ff = strMapper(uaCH2[FORMFACTORS], formFactorsMap);
                            }
                            this.set(TYPE, ff);
                          }
                          break;
                        case OS:
                          var osName = uaCH2[PLATFORM];
                          if (osName) {
                            var osVersion = uaCH2[PLATFORMVER];
                            if (osName == WINDOWS) osVersion = parseInt(majorize(osVersion), 10) >= 13 ? "11" : "10";
                            this.set(NAME, osName).set(VERSION, osVersion);
                          }
                          if (this.get(NAME) == WINDOWS && uaCH2[MODEL] == "Xbox") {
                            this.set(NAME, "Xbox").set(VERSION, undefined2);
                          }
                          break;
                        case RESULT:
                          var data = this.data;
                          var parse = function(itemType2) {
                            return data[itemType2].getItem().setCH(uaCH2).parseCH().get();
                          };
                          this.set(BROWSER, parse(BROWSER)).set(CPU, parse(CPU)).set(DEVICE, parse(DEVICE)).set(ENGINE, parse(ENGINE)).set(OS, parse(OS));
                      }
                      return this;
                    };
                    setProps.call(this, [
                      ["itemType", itemType],
                      ["ua", ua],
                      ["uaCH", uaCH],
                      ["rgxMap", rgxMap],
                      ["data", createIData(this, itemType)]
                    ]);
                    return this;
                  }
                  function UAParser(ua, extensions, headers) {
                    if (typeof ua === TYPEOF.OBJECT) {
                      if (isExtensions(ua, true)) {
                        if (typeof extensions === TYPEOF.OBJECT) {
                          headers = extensions;
                        }
                        extensions = ua;
                      } else {
                        headers = ua;
                        extensions = undefined2;
                      }
                      ua = undefined2;
                    } else if (typeof ua === TYPEOF.STRING && !isExtensions(extensions, true)) {
                      headers = extensions;
                      extensions = undefined2;
                    }
                    if (headers) {
                      if (typeof headers.append === TYPEOF.FUNCTION) {
                        var kv = {};
                        headers.forEach(function(v, k) {
                          kv[String(k).toLowerCase()] = v;
                        });
                        headers = kv;
                      } else {
                        var normalized = {};
                        for (var header in headers) {
                          if (headers.hasOwnProperty(header)) {
                            normalized[String(header).toLowerCase()] = headers[header];
                          }
                        }
                        headers = normalized;
                      }
                    }
                    if (!(this instanceof UAParser)) {
                      return new UAParser(ua, extensions, headers).getResult();
                    }
                    var userAgent = typeof ua === TYPEOF.STRING ? ua : (
                      // Passed user-agent string
                      headers && headers[USER_AGENT] ? headers[USER_AGENT] : (
                        // User-Agent from passed headers
                        NAVIGATOR && NAVIGATOR.userAgent ? NAVIGATOR.userAgent : (
                          // navigator.userAgent
                          EMPTY
                        )
                      )
                    ), httpUACH = new UACHData(headers, true), regexMap = extensions ? extend(defaultRegexes, extensions) : defaultRegexes, createItemFunc = function(itemType) {
                      if (itemType == RESULT) {
                        return function() {
                          return new UAItem(itemType, userAgent, regexMap, httpUACH).set("ua", userAgent).set(BROWSER, this.getBrowser()).set(CPU, this.getCPU()).set(DEVICE, this.getDevice()).set(ENGINE, this.getEngine()).set(OS, this.getOS()).get();
                        };
                      } else {
                        return function() {
                          return new UAItem(itemType, userAgent, regexMap[itemType], httpUACH).parseUA().get();
                        };
                      }
                    };
                    setProps.call(this, [
                      ["getBrowser", createItemFunc(BROWSER)],
                      ["getCPU", createItemFunc(CPU)],
                      ["getDevice", createItemFunc(DEVICE)],
                      ["getEngine", createItemFunc(ENGINE)],
                      ["getOS", createItemFunc(OS)],
                      ["getResult", createItemFunc(RESULT)],
                      ["getUA", function() {
                        return userAgent;
                      }],
                      ["setUA", function(ua2) {
                        if (isString(ua2)) userAgent = trim(ua2, UA_MAX_LENGTH);
                        return this;
                      }]
                    ]).setUA(userAgent);
                    return this;
                  }
                  UAParser.VERSION = LIBVERSION;
                  UAParser.BROWSER = enumerize([NAME, VERSION, MAJOR, TYPE]);
                  UAParser.CPU = enumerize([ARCHITECTURE]);
                  UAParser.DEVICE = enumerize([MODEL, VENDOR, TYPE, CONSOLE, MOBILE, SMARTTV, TABLET, WEARABLE, EMBEDDED]);
                  UAParser.ENGINE = UAParser.OS = enumerize([NAME, VERSION]);
                  if (typeof exports2 !== TYPEOF.UNDEFINED) {
                    if ("object" !== TYPEOF.UNDEFINED && module2.exports) {
                      exports2 = module2.exports = UAParser;
                    }
                    exports2.UAParser = UAParser;
                  } else {
                    if ("function" === TYPEOF.FUNCTION && __webpack_require__2.amdO) {
                      !(__WEBPACK_AMD_DEFINE_RESULT__ = (function() {
                        return UAParser;
                      }).call(exports2, __webpack_require__2, exports2, module2), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined2 && (module2.exports = __WEBPACK_AMD_DEFINE_RESULT__));
                    } else if (isWindow) {
                      window2.UAParser = UAParser;
                    }
                  }
                  var $ = isWindow && (window2.jQuery || window2.Zepto);
                  if ($ && !$.ua) {
                    var parser = new UAParser();
                    $.ua = parser.getResult();
                    $.ua.get = function() {
                      return parser.getUA();
                    };
                    $.ua.set = function(ua) {
                      parser.setUA(ua);
                      var result = parser.getResult();
                      for (var prop in result) {
                        $.ua[prop] = result[prop];
                      }
                    };
                  }
                })(typeof window === "object" ? window : this);
              }
            ),
            /***/
            2155: (
              /***/
              function(module2, exports2, __webpack_require__2) {
                ;
                (function(root, factory, undef) {
                  if (true) {
                    module2.exports = exports2 = factory(__webpack_require__2(9021), __webpack_require__2(7165));
                  } else {
                  }
                })(this, function(CryptoJS) {
                  CryptoJS.pad.ZeroPadding = {
                    pad: function(data, blockSize) {
                      var blockSizeBytes = blockSize * 4;
                      data.clamp();
                      data.sigBytes += blockSizeBytes - (data.sigBytes % blockSizeBytes || blockSizeBytes);
                    },
                    unpad: function(data) {
                      var dataWords = data.words;
                      var i = data.sigBytes - 1;
                      for (var i = data.sigBytes - 1; i >= 0; i--) {
                        if (dataWords[i >>> 2] >>> 24 - i % 4 * 8 & 255) {
                          data.sigBytes = i + 1;
                          break;
                        }
                      }
                    }
                  };
                  return CryptoJS.pad.ZeroPadding;
                });
              }
            ),
            /***/
            2169: (
              /***/
              function(module2, exports2, __webpack_require__2) {
                ;
                (function(root, factory, undef) {
                  if (true) {
                    module2.exports = exports2 = factory(__webpack_require__2(9021), __webpack_require__2(7165));
                  } else {
                  }
                })(this, function(CryptoJS) {
                  CryptoJS.mode.CFB = function() {
                    var CFB = CryptoJS.lib.BlockCipherMode.extend();
                    CFB.Encryptor = CFB.extend({
                      processBlock: function(words, offset) {
                        var cipher = this._cipher;
                        var blockSize = cipher.blockSize;
                        generateKeystreamAndEncrypt.call(this, words, offset, blockSize, cipher);
                        this._prevBlock = words.slice(offset, offset + blockSize);
                      }
                    });
                    CFB.Decryptor = CFB.extend({
                      processBlock: function(words, offset) {
                        var cipher = this._cipher;
                        var blockSize = cipher.blockSize;
                        var thisBlock = words.slice(offset, offset + blockSize);
                        generateKeystreamAndEncrypt.call(this, words, offset, blockSize, cipher);
                        this._prevBlock = thisBlock;
                      }
                    });
                    function generateKeystreamAndEncrypt(words, offset, blockSize, cipher) {
                      var keystream;
                      var iv = this._iv;
                      if (iv) {
                        keystream = iv.slice(0);
                        this._iv = void 0;
                      } else {
                        keystream = this._prevBlock;
                      }
                      cipher.encryptBlock(keystream, 0);
                      for (var i = 0; i < blockSize; i++) {
                        words[offset + i] ^= keystream[i];
                      }
                    }
                    return CFB;
                  }();
                  return CryptoJS.mode.CFB;
                });
              }
            ),
            /***/
            2183: (
              /***/
              (__unused_webpack_module, exports2, __webpack_require__2) => {
                "use strict";
                Object.defineProperty(exports2, "__esModule", { value: true });
                exports2.Chrome111 = void 0;
                const sdpTransform = __webpack_require__2(7363);
                const enhancedEvents_1 = __webpack_require__2(3953);
                const Logger_1 = __webpack_require__2(2994);
                const ortc = __webpack_require__2(8046);
                const errors_1 = __webpack_require__2(4893);
                const scalabilityModes_1 = __webpack_require__2(3303);
                const sdpCommonUtils = __webpack_require__2(5544);
                const sdpUnifiedPlanUtils = __webpack_require__2(5938);
                const ortcUtils = __webpack_require__2(4256);
                const RemoteSdp_1 = __webpack_require__2(1305);
                const logger = new Logger_1.Logger("Chrome111");
                const NAME = "Chrome111";
                const SCTP_NUM_STREAMS = { OS: 1024, MIS: 1024 };
                class Chrome111 extends enhancedEvents_1.EnhancedEventEmitter {
                  constructor({ direction, iceParameters, iceCandidates, dtlsParameters, sctpParameters, iceServers, iceTransportPolicy, additionalSettings, getSendExtendedRtpCapabilities }) {
                    super();
                    // Closed flag.
                    __publicField(this, "_closed", false);
                    // Handler direction.
                    __publicField(this, "_direction");
                    // Remote SDP handler.
                    __publicField(this, "_remoteSdp");
                    // Callback to request sending extended RTP capabilities on demand.
                    __publicField(this, "_getSendExtendedRtpCapabilities");
                    // Initial server side DTLS role. If not 'auto', it will force the opposite
                    // value in client side.
                    __publicField(this, "_forcedLocalDtlsRole");
                    // RTCPeerConnection instance.
                    __publicField(this, "_pc");
                    // Map of RTCTransceivers indexed by MID.
                    __publicField(this, "_mapMidTransceiver", /* @__PURE__ */ new Map());
                    // Local stream for sending.
                    __publicField(this, "_sendStream", new MediaStream());
                    // Whether a DataChannel m=application section has been created.
                    __publicField(this, "_hasDataChannelMediaSection", false);
                    // Sending DataChannel id value counter. Incremented for each new DataChannel.
                    __publicField(this, "_nextSendSctpStreamId", 0);
                    // Got transport local and remote parameters.
                    __publicField(this, "_transportReady", false);
                    __publicField(this, "onIceGatheringStateChange", () => {
                      this.emit("@icegatheringstatechange", this._pc.iceGatheringState);
                    });
                    __publicField(this, "onIceCandidateError", (event) => {
                      this.emit("@icecandidateerror", event);
                    });
                    __publicField(this, "onConnectionStateChange", () => {
                      this.emit("@connectionstatechange", this._pc.connectionState);
                    });
                    __publicField(this, "onIceConnectionStateChange", () => {
                      switch (this._pc.iceConnectionState) {
                        case "checking": {
                          this.emit("@connectionstatechange", "connecting");
                          break;
                        }
                        case "connected":
                        case "completed": {
                          this.emit("@connectionstatechange", "connected");
                          break;
                        }
                        case "failed": {
                          this.emit("@connectionstatechange", "failed");
                          break;
                        }
                        case "disconnected": {
                          this.emit("@connectionstatechange", "disconnected");
                          break;
                        }
                        case "closed": {
                          this.emit("@connectionstatechange", "closed");
                          break;
                        }
                      }
                    });
                    logger.debug("constructor()");
                    this._direction = direction;
                    this._remoteSdp = new RemoteSdp_1.RemoteSdp({
                      iceParameters,
                      iceCandidates,
                      dtlsParameters,
                      sctpParameters
                    });
                    this._getSendExtendedRtpCapabilities = getSendExtendedRtpCapabilities;
                    if (dtlsParameters.role && dtlsParameters.role !== "auto") {
                      this._forcedLocalDtlsRole = dtlsParameters.role === "server" ? "client" : "server";
                    }
                    this._pc = new RTCPeerConnection({
                      iceServers: iceServers ?? [],
                      iceTransportPolicy: iceTransportPolicy ?? "all",
                      bundlePolicy: "max-bundle",
                      rtcpMuxPolicy: "require",
                      ...additionalSettings
                    });
                    this._pc.addEventListener("icegatheringstatechange", this.onIceGatheringStateChange);
                    this._pc.addEventListener("icecandidateerror", this.onIceCandidateError);
                    if (this._pc.connectionState) {
                      this._pc.addEventListener("connectionstatechange", this.onConnectionStateChange);
                    } else {
                      logger.warn("run() | pc.connectionState not supported, using pc.iceConnectionState");
                      this._pc.addEventListener("iceconnectionstatechange", this.onIceConnectionStateChange);
                    }
                  }
                  /**
                   * Creates a factory function.
                   */
                  static createFactory() {
                    return {
                      name: NAME,
                      factory: (options) => new Chrome111(options),
                      getNativeRtpCapabilities: async () => {
                        logger.debug("getNativeRtpCapabilities()");
                        let pc = new RTCPeerConnection({
                          iceServers: [],
                          iceTransportPolicy: "all",
                          bundlePolicy: "max-bundle",
                          rtcpMuxPolicy: "require"
                        });
                        try {
                          pc.addTransceiver("audio");
                          pc.addTransceiver("video", {
                            sendEncodings: [{ scalabilityMode: "L3T3" }]
                          });
                          const offer = await pc.createOffer();
                          try {
                            pc.close();
                          } catch (error) {
                          }
                          pc = void 0;
                          const sdpObject = sdpTransform.parse(offer.sdp);
                          const nativeRtpCapabilities = Chrome111.getLocalRtpCapabilities(sdpObject);
                          return nativeRtpCapabilities;
                        } catch (error) {
                          try {
                            pc == null ? void 0 : pc.close();
                          } catch (error2) {
                          }
                          pc = void 0;
                          throw error;
                        }
                      },
                      getNativeSctpCapabilities: async () => {
                        logger.debug("getNativeSctpCapabilities()");
                        return {
                          numStreams: SCTP_NUM_STREAMS
                        };
                      }
                    };
                  }
                  static getLocalRtpCapabilities(localSdpObject) {
                    const nativeRtpCapabilities = sdpCommonUtils.extractRtpCapabilities({
                      sdpObject: localSdpObject
                    });
                    ortc.validateAndNormalizeRtpCapabilities(nativeRtpCapabilities);
                    ortcUtils.addNackSupportForOpus(nativeRtpCapabilities);
                    return nativeRtpCapabilities;
                  }
                  get name() {
                    return NAME;
                  }
                  close() {
                    logger.debug("close()");
                    if (this._closed) {
                      return;
                    }
                    this._closed = true;
                    try {
                      this._pc.close();
                    } catch (error) {
                    }
                    this._pc.removeEventListener("icegatheringstatechange", this.onIceGatheringStateChange);
                    this._pc.removeEventListener("icecandidateerror", this.onIceCandidateError);
                    this._pc.removeEventListener("connectionstatechange", this.onConnectionStateChange);
                    this._pc.removeEventListener("iceconnectionstatechange", this.onIceConnectionStateChange);
                    this.emit("@close");
                    super.close();
                  }
                  async updateIceServers(iceServers) {
                    this.assertNotClosed();
                    logger.debug("updateIceServers()");
                    const configuration = this._pc.getConfiguration();
                    configuration.iceServers = iceServers;
                    this._pc.setConfiguration(configuration);
                  }
                  async restartIce(iceParameters) {
                    this.assertNotClosed();
                    logger.debug("restartIce()");
                    this._remoteSdp.updateIceParameters(iceParameters);
                    if (!this._transportReady) {
                      return;
                    }
                    if (this._direction === "send") {
                      const offer = await this._pc.createOffer({ iceRestart: true });
                      logger.debug("restartIce() | calling pc.setLocalDescription() [offer:%o]", offer);
                      await this._pc.setLocalDescription(offer);
                      const answer = {
                        type: "answer",
                        sdp: this._remoteSdp.getSdp()
                      };
                      logger.debug("restartIce() | calling pc.setRemoteDescription() [answer:%o]", answer);
                      await this._pc.setRemoteDescription(answer);
                    } else {
                      const offer = {
                        type: "offer",
                        sdp: this._remoteSdp.getSdp()
                      };
                      logger.debug("restartIce() | calling pc.setRemoteDescription() [offer:%o]", offer);
                      await this._pc.setRemoteDescription(offer);
                      const answer = await this._pc.createAnswer();
                      logger.debug("restartIce() | calling pc.setLocalDescription() [answer:%o]", answer);
                      await this._pc.setLocalDescription(answer);
                    }
                  }
                  async getTransportStats() {
                    this.assertNotClosed();
                    return this._pc.getStats();
                  }
                  async send({ track, encodings, codecOptions, codec, onRtpSender }) {
                    this.assertNotClosed();
                    this.assertSendDirection();
                    logger.debug("send() [kind:%s, track.id:%s]", track.kind, track.id);
                    if (encodings && encodings.length > 1) {
                      let maxTemporalLayers = 1;
                      for (const encoding of encodings) {
                        const temporalLayers = encoding.scalabilityMode ? (0, scalabilityModes_1.parse)(encoding.scalabilityMode).temporalLayers : 3;
                        if (temporalLayers > maxTemporalLayers) {
                          maxTemporalLayers = temporalLayers;
                        }
                      }
                      encodings.forEach((encoding, idx) => {
                        encoding.rid = `r${idx}`;
                        encoding.scalabilityMode = `L1T${maxTemporalLayers}`;
                      });
                    }
                    const mediaSectionIdx = this._remoteSdp.getNextMediaSectionIdx();
                    const transceiver = this._pc.addTransceiver(track, {
                      direction: "sendonly",
                      streams: [this._sendStream],
                      sendEncodings: encodings
                    });
                    if (onRtpSender) {
                      onRtpSender(transceiver.sender);
                    }
                    const offer = await this._pc.createOffer();
                    let localSdpObject = sdpTransform.parse(offer.sdp);
                    if (localSdpObject.extmapAllowMixed) {
                      this._remoteSdp.setSessionExtmapAllowMixed();
                    }
                    const nativeRtpCapabilities = Chrome111.getLocalRtpCapabilities(localSdpObject);
                    const sendExtendedRtpCapabilities = this._getSendExtendedRtpCapabilities(nativeRtpCapabilities);
                    const sendingRtpParameters = ortc.getSendingRtpParameters(track.kind, sendExtendedRtpCapabilities);
                    sendingRtpParameters.codecs = ortc.reduceCodecs(sendingRtpParameters.codecs, codec);
                    const sendingRemoteRtpParameters = ortc.getSendingRemoteRtpParameters(track.kind, sendExtendedRtpCapabilities);
                    sendingRemoteRtpParameters.codecs = ortc.reduceCodecs(sendingRemoteRtpParameters.codecs, codec);
                    if (!this._transportReady) {
                      await this.setupTransport({
                        localDtlsRole: this._forcedLocalDtlsRole ?? "client",
                        localSdpObject
                      });
                    }
                    logger.debug("send() | calling pc.setLocalDescription() [offer:%o]", offer);
                    await this._pc.setLocalDescription(offer);
                    const localId = transceiver.mid;
                    sendingRtpParameters.mid = localId;
                    localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
                    const offerMediaObject = localSdpObject.media[mediaSectionIdx.idx];
                    sendingRtpParameters.rtcp.cname = sdpCommonUtils.getCname({
                      offerMediaObject
                    });
                    if (!encodings) {
                      sendingRtpParameters.encodings = sdpUnifiedPlanUtils.getRtpEncodings({
                        offerMediaObject
                      });
                    } else if (encodings.length === 1) {
                      const newEncodings = sdpUnifiedPlanUtils.getRtpEncodings({
                        offerMediaObject
                      });
                      Object.assign(newEncodings[0], encodings[0]);
                      sendingRtpParameters.encodings = newEncodings;
                    } else {
                      sendingRtpParameters.encodings = encodings;
                    }
                    this._remoteSdp.send({
                      offerMediaObject,
                      reuseMid: mediaSectionIdx.reuseMid,
                      offerRtpParameters: sendingRtpParameters,
                      answerRtpParameters: sendingRemoteRtpParameters,
                      codecOptions
                    });
                    const answer = {
                      type: "answer",
                      sdp: this._remoteSdp.getSdp()
                    };
                    logger.debug("send() | calling pc.setRemoteDescription() [answer:%o]", answer);
                    await this._pc.setRemoteDescription(answer);
                    this._mapMidTransceiver.set(localId, transceiver);
                    return {
                      localId,
                      rtpParameters: sendingRtpParameters,
                      rtpSender: transceiver.sender
                    };
                  }
                  async stopSending(localId) {
                    this.assertSendDirection();
                    logger.debug("stopSending() [localId:%s]", localId);
                    if (this._closed) {
                      return;
                    }
                    const transceiver = this._mapMidTransceiver.get(localId);
                    if (!transceiver) {
                      throw new Error("associated RTCRtpTransceiver not found");
                    }
                    void transceiver.sender.replaceTrack(null);
                    this._pc.removeTrack(transceiver.sender);
                    const mediaSectionClosed = this._remoteSdp.closeMediaSection(transceiver.mid);
                    if (mediaSectionClosed) {
                      try {
                        transceiver.stop();
                      } catch (error) {
                      }
                    }
                    const offer = await this._pc.createOffer();
                    logger.debug("stopSending() | calling pc.setLocalDescription() [offer:%o]", offer);
                    await this._pc.setLocalDescription(offer);
                    const answer = {
                      type: "answer",
                      sdp: this._remoteSdp.getSdp()
                    };
                    logger.debug("stopSending() | calling pc.setRemoteDescription() [answer:%o]", answer);
                    await this._pc.setRemoteDescription(answer);
                    this._mapMidTransceiver.delete(localId);
                  }
                  async pauseSending(localId) {
                    this.assertNotClosed();
                    this.assertSendDirection();
                    logger.debug("pauseSending() [localId:%s]", localId);
                    const transceiver = this._mapMidTransceiver.get(localId);
                    if (!transceiver) {
                      throw new Error("associated RTCRtpTransceiver not found");
                    }
                    transceiver.direction = "inactive";
                    this._remoteSdp.pauseMediaSection(localId);
                    const offer = await this._pc.createOffer();
                    logger.debug("pauseSending() | calling pc.setLocalDescription() [offer:%o]", offer);
                    await this._pc.setLocalDescription(offer);
                    const answer = {
                      type: "answer",
                      sdp: this._remoteSdp.getSdp()
                    };
                    logger.debug("pauseSending() | calling pc.setRemoteDescription() [answer:%o]", answer);
                    await this._pc.setRemoteDescription(answer);
                  }
                  async resumeSending(localId) {
                    this.assertNotClosed();
                    this.assertSendDirection();
                    logger.debug("resumeSending() [localId:%s]", localId);
                    const transceiver = this._mapMidTransceiver.get(localId);
                    this._remoteSdp.resumeSendingMediaSection(localId);
                    if (!transceiver) {
                      throw new Error("associated RTCRtpTransceiver not found");
                    }
                    transceiver.direction = "sendonly";
                    const offer = await this._pc.createOffer();
                    logger.debug("resumeSending() | calling pc.setLocalDescription() [offer:%o]", offer);
                    await this._pc.setLocalDescription(offer);
                    const answer = {
                      type: "answer",
                      sdp: this._remoteSdp.getSdp()
                    };
                    logger.debug("resumeSending() | calling pc.setRemoteDescription() [answer:%o]", answer);
                    await this._pc.setRemoteDescription(answer);
                  }
                  async replaceTrack(localId, track) {
                    this.assertNotClosed();
                    this.assertSendDirection();
                    if (track) {
                      logger.debug("replaceTrack() [localId:%s, track.id:%s]", localId, track.id);
                    } else {
                      logger.debug("replaceTrack() [localId:%s, no track]", localId);
                    }
                    const transceiver = this._mapMidTransceiver.get(localId);
                    if (!transceiver) {
                      throw new Error("associated RTCRtpTransceiver not found");
                    }
                    await transceiver.sender.replaceTrack(track);
                  }
                  async setMaxSpatialLayer(localId, spatialLayer) {
                    this.assertNotClosed();
                    this.assertSendDirection();
                    logger.debug("setMaxSpatialLayer() [localId:%s, spatialLayer:%s]", localId, spatialLayer);
                    const transceiver = this._mapMidTransceiver.get(localId);
                    if (!transceiver) {
                      throw new Error("associated RTCRtpTransceiver not found");
                    }
                    const parameters = transceiver.sender.getParameters();
                    parameters.encodings.forEach((encoding, idx) => {
                      if (idx <= spatialLayer) {
                        encoding.active = true;
                      } else {
                        encoding.active = false;
                      }
                    });
                    await transceiver.sender.setParameters(parameters);
                    this._remoteSdp.muxMediaSectionSimulcast(localId, parameters.encodings);
                    const offer = await this._pc.createOffer();
                    logger.debug("setMaxSpatialLayer() | calling pc.setLocalDescription() [offer:%o]", offer);
                    await this._pc.setLocalDescription(offer);
                    const answer = {
                      type: "answer",
                      sdp: this._remoteSdp.getSdp()
                    };
                    logger.debug("setMaxSpatialLayer() | calling pc.setRemoteDescription() [answer:%o]", answer);
                    await this._pc.setRemoteDescription(answer);
                  }
                  async setRtpEncodingParameters(localId, params) {
                    this.assertNotClosed();
                    this.assertSendDirection();
                    logger.debug("setRtpEncodingParameters() [localId:%s, params:%o]", localId, params);
                    const transceiver = this._mapMidTransceiver.get(localId);
                    if (!transceiver) {
                      throw new Error("associated RTCRtpTransceiver not found");
                    }
                    const parameters = transceiver.sender.getParameters();
                    parameters.encodings.forEach((encoding, idx) => {
                      parameters.encodings[idx] = { ...encoding, ...params };
                    });
                    await transceiver.sender.setParameters(parameters);
                    this._remoteSdp.muxMediaSectionSimulcast(localId, parameters.encodings);
                    const offer = await this._pc.createOffer();
                    logger.debug("setRtpEncodingParameters() | calling pc.setLocalDescription() [offer:%o]", offer);
                    await this._pc.setLocalDescription(offer);
                    const answer = {
                      type: "answer",
                      sdp: this._remoteSdp.getSdp()
                    };
                    logger.debug("setRtpEncodingParameters() | calling pc.setRemoteDescription() [answer:%o]", answer);
                    await this._pc.setRemoteDescription(answer);
                  }
                  async getSenderStats(localId) {
                    this.assertNotClosed();
                    this.assertSendDirection();
                    const transceiver = this._mapMidTransceiver.get(localId);
                    if (!transceiver) {
                      throw new Error("associated RTCRtpTransceiver not found");
                    }
                    return transceiver.sender.getStats();
                  }
                  async sendDataChannel({ ordered, maxPacketLifeTime, maxRetransmits, label, protocol }) {
                    this.assertNotClosed();
                    this.assertSendDirection();
                    const options = {
                      negotiated: true,
                      id: this._nextSendSctpStreamId,
                      ordered,
                      maxPacketLifeTime,
                      maxRetransmits,
                      protocol
                    };
                    logger.debug("sendDataChannel() [options:%o]", options);
                    const dataChannel = this._pc.createDataChannel(label, options);
                    this._nextSendSctpStreamId = ++this._nextSendSctpStreamId % SCTP_NUM_STREAMS.MIS;
                    if (!this._hasDataChannelMediaSection) {
                      const offer = await this._pc.createOffer();
                      const localSdpObject = sdpTransform.parse(offer.sdp);
                      const offerMediaObject = localSdpObject.media.find((m) => m.type === "application");
                      if (!this._transportReady) {
                        await this.setupTransport({
                          localDtlsRole: this._forcedLocalDtlsRole ?? "client",
                          localSdpObject
                        });
                      }
                      logger.debug("sendDataChannel() | calling pc.setLocalDescription() [offer:%o]", offer);
                      await this._pc.setLocalDescription(offer);
                      this._remoteSdp.sendSctpAssociation({ offerMediaObject });
                      const answer = {
                        type: "answer",
                        sdp: this._remoteSdp.getSdp()
                      };
                      logger.debug("sendDataChannel() | calling pc.setRemoteDescription() [answer:%o]", answer);
                      await this._pc.setRemoteDescription(answer);
                      this._hasDataChannelMediaSection = true;
                    }
                    const sctpStreamParameters = {
                      streamId: options.id,
                      ordered: options.ordered,
                      maxPacketLifeTime: options.maxPacketLifeTime,
                      maxRetransmits: options.maxRetransmits
                    };
                    return { dataChannel, sctpStreamParameters };
                  }
                  async receive(optionsList) {
                    this.assertNotClosed();
                    this.assertRecvDirection();
                    const results = [];
                    const mapLocalId = /* @__PURE__ */ new Map();
                    for (const options of optionsList) {
                      const { trackId, kind, rtpParameters, streamId } = options;
                      logger.debug("receive() [trackId:%s, kind:%s]", trackId, kind);
                      const localId = rtpParameters.mid ?? String(this._mapMidTransceiver.size);
                      mapLocalId.set(trackId, localId);
                      this._remoteSdp.receive({
                        mid: localId,
                        kind,
                        offerRtpParameters: rtpParameters,
                        streamId: streamId ?? rtpParameters.rtcp.cname,
                        trackId
                      });
                    }
                    const offer = {
                      type: "offer",
                      sdp: this._remoteSdp.getSdp()
                    };
                    logger.debug("receive() | calling pc.setRemoteDescription() [offer:%o]", offer);
                    await this._pc.setRemoteDescription(offer);
                    for (const options of optionsList) {
                      const { trackId, onRtpReceiver } = options;
                      if (onRtpReceiver) {
                        const localId = mapLocalId.get(trackId);
                        const transceiver = this._pc.getTransceivers().find((t) => t.mid === localId);
                        if (!transceiver) {
                          throw new Error("transceiver not found");
                        }
                        onRtpReceiver(transceiver.receiver);
                      }
                    }
                    let answer = await this._pc.createAnswer();
                    const localSdpObject = sdpTransform.parse(answer.sdp);
                    for (const options of optionsList) {
                      const { trackId, rtpParameters } = options;
                      const localId = mapLocalId.get(trackId);
                      const answerMediaObject = localSdpObject.media.find((m) => String(m.mid) === localId);
                      sdpCommonUtils.applyCodecParameters({
                        offerRtpParameters: rtpParameters,
                        answerMediaObject
                      });
                    }
                    answer = {
                      type: "answer",
                      sdp: sdpTransform.write(localSdpObject)
                    };
                    if (!this._transportReady) {
                      await this.setupTransport({
                        localDtlsRole: this._forcedLocalDtlsRole ?? "client",
                        localSdpObject
                      });
                    }
                    logger.debug("receive() | calling pc.setLocalDescription() [answer:%o]", answer);
                    await this._pc.setLocalDescription(answer);
                    for (const options of optionsList) {
                      const { trackId } = options;
                      const localId = mapLocalId.get(trackId);
                      const transceiver = this._pc.getTransceivers().find((t) => t.mid === localId);
                      if (!transceiver) {
                        throw new Error("new RTCRtpTransceiver not found");
                      } else {
                        this._mapMidTransceiver.set(localId, transceiver);
                        results.push({
                          localId,
                          track: transceiver.receiver.track,
                          rtpReceiver: transceiver.receiver
                        });
                      }
                    }
                    return results;
                  }
                  async stopReceiving(localIds) {
                    this.assertRecvDirection();
                    if (this._closed) {
                      return;
                    }
                    for (const localId of localIds) {
                      logger.debug("stopReceiving() [localId:%s]", localId);
                      const transceiver = this._mapMidTransceiver.get(localId);
                      if (!transceiver) {
                        throw new Error("associated RTCRtpTransceiver not found");
                      }
                      this._remoteSdp.closeMediaSection(transceiver.mid);
                    }
                    const offer = {
                      type: "offer",
                      sdp: this._remoteSdp.getSdp()
                    };
                    logger.debug("stopReceiving() | calling pc.setRemoteDescription() [offer:%o]", offer);
                    await this._pc.setRemoteDescription(offer);
                    const answer = await this._pc.createAnswer();
                    logger.debug("stopReceiving() | calling pc.setLocalDescription() [answer:%o]", answer);
                    await this._pc.setLocalDescription(answer);
                    for (const localId of localIds) {
                      this._mapMidTransceiver.delete(localId);
                    }
                  }
                  async pauseReceiving(localIds) {
                    this.assertNotClosed();
                    this.assertRecvDirection();
                    for (const localId of localIds) {
                      logger.debug("pauseReceiving() [localId:%s]", localId);
                      const transceiver = this._mapMidTransceiver.get(localId);
                      if (!transceiver) {
                        throw new Error("associated RTCRtpTransceiver not found");
                      }
                      transceiver.direction = "inactive";
                      this._remoteSdp.pauseMediaSection(localId);
                    }
                    const offer = {
                      type: "offer",
                      sdp: this._remoteSdp.getSdp()
                    };
                    logger.debug("pauseReceiving() | calling pc.setRemoteDescription() [offer:%o]", offer);
                    await this._pc.setRemoteDescription(offer);
                    const answer = await this._pc.createAnswer();
                    logger.debug("pauseReceiving() | calling pc.setLocalDescription() [answer:%o]", answer);
                    await this._pc.setLocalDescription(answer);
                  }
                  async resumeReceiving(localIds) {
                    this.assertNotClosed();
                    this.assertRecvDirection();
                    for (const localId of localIds) {
                      logger.debug("resumeReceiving() [localId:%s]", localId);
                      const transceiver = this._mapMidTransceiver.get(localId);
                      if (!transceiver) {
                        throw new Error("associated RTCRtpTransceiver not found");
                      }
                      transceiver.direction = "recvonly";
                      this._remoteSdp.resumeReceivingMediaSection(localId);
                    }
                    const offer = {
                      type: "offer",
                      sdp: this._remoteSdp.getSdp()
                    };
                    logger.debug("resumeReceiving() | calling pc.setRemoteDescription() [offer:%o]", offer);
                    await this._pc.setRemoteDescription(offer);
                    const answer = await this._pc.createAnswer();
                    logger.debug("resumeReceiving() | calling pc.setLocalDescription() [answer:%o]", answer);
                    await this._pc.setLocalDescription(answer);
                  }
                  async getReceiverStats(localId) {
                    this.assertNotClosed();
                    this.assertRecvDirection();
                    const transceiver = this._mapMidTransceiver.get(localId);
                    if (!transceiver) {
                      throw new Error("associated RTCRtpTransceiver not found");
                    }
                    return transceiver.receiver.getStats();
                  }
                  async receiveDataChannel({ sctpStreamParameters, label, protocol }) {
                    this.assertNotClosed();
                    this.assertRecvDirection();
                    const { streamId, ordered, maxPacketLifeTime, maxRetransmits } = sctpStreamParameters;
                    const options = {
                      negotiated: true,
                      id: streamId,
                      ordered,
                      maxPacketLifeTime,
                      maxRetransmits,
                      protocol
                    };
                    logger.debug("receiveDataChannel() [options:%o]", options);
                    const dataChannel = this._pc.createDataChannel(label, options);
                    if (!this._hasDataChannelMediaSection) {
                      this._remoteSdp.receiveSctpAssociation();
                      const offer = {
                        type: "offer",
                        sdp: this._remoteSdp.getSdp()
                      };
                      logger.debug("receiveDataChannel() | calling pc.setRemoteDescription() [offer:%o]", offer);
                      await this._pc.setRemoteDescription(offer);
                      const answer = await this._pc.createAnswer();
                      if (!this._transportReady) {
                        const localSdpObject = sdpTransform.parse(answer.sdp);
                        await this.setupTransport({
                          localDtlsRole: this._forcedLocalDtlsRole ?? "client",
                          localSdpObject
                        });
                      }
                      logger.debug("receiveDataChannel() | calling pc.setRemoteDescription() [answer:%o]", answer);
                      await this._pc.setLocalDescription(answer);
                      this._hasDataChannelMediaSection = true;
                    }
                    return { dataChannel };
                  }
                  async setupTransport({ localDtlsRole, localSdpObject }) {
                    if (!localSdpObject) {
                      localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
                    }
                    const dtlsParameters = sdpCommonUtils.extractDtlsParameters({
                      sdpObject: localSdpObject
                    });
                    dtlsParameters.role = localDtlsRole;
                    this._remoteSdp.updateDtlsRole(localDtlsRole === "client" ? "server" : "client");
                    await new Promise((resolve, reject) => {
                      this.safeEmit("@connect", { dtlsParameters }, resolve, reject);
                    });
                    this._transportReady = true;
                  }
                  assertNotClosed() {
                    if (this._closed) {
                      throw new errors_1.InvalidStateError("method called in a closed handler");
                    }
                  }
                  assertSendDirection() {
                    if (this._direction !== "send") {
                      throw new Error('method can just be called for handlers with "send" direction');
                    }
                  }
                  assertRecvDirection() {
                    if (this._direction !== "recv") {
                      throw new Error('method can just be called for handlers with "recv" direction');
                    }
                  }
                }
                exports2.Chrome111 = Chrome111;
              }
            ),
            /***/
            2211: (
              /***/
              (module2) => {
                "use strict";
                var numbers = "0123456789", letters = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz", specials = "!$%^&*()_+|~-=`{}[]:;<>?,./";
                function _defaults(opts) {
                  opts || (opts = {});
                  return {
                    length: opts.length || 8,
                    numeric: typeof opts.numeric === "boolean" ? opts.numeric : true,
                    letters: typeof opts.letters === "boolean" ? opts.letters : true,
                    special: typeof opts.special === "boolean" ? opts.special : false,
                    exclude: Array.isArray(opts.exclude) ? opts.exclude : []
                  };
                }
                function _buildChars(opts) {
                  var chars = "";
                  if (opts.numeric) {
                    chars += numbers;
                  }
                  if (opts.letters) {
                    chars += letters;
                  }
                  if (opts.special) {
                    chars += specials;
                  }
                  for (var i = 0; i <= opts.exclude.length; i++) {
                    chars = chars.replace(opts.exclude[i], "");
                  }
                  return chars;
                }
                module2.exports = function randomString(opts) {
                  opts = _defaults(opts);
                  var i, rn, rnd = "", len = opts.length, exclude = opts.exclude, randomChars = _buildChars(opts);
                  for (i = 1; i <= len; i++) {
                    rnd += randomChars.substring(rn = Math.floor(Math.random() * randomChars.length), rn + 1);
                  }
                  return rnd;
                };
              }
            ),
            /***/
            2215: (
              /***/
              (module2, exports2, __webpack_require__2) => {
                var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;
                ;
                (function(factory) {
                  var registeredInModuleLoader;
                  if (true) {
                    !(__WEBPACK_AMD_DEFINE_FACTORY__ = factory, __WEBPACK_AMD_DEFINE_RESULT__ = typeof __WEBPACK_AMD_DEFINE_FACTORY__ === "function" ? __WEBPACK_AMD_DEFINE_FACTORY__.call(exports2, __webpack_require__2, exports2, module2) : __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__ !== void 0 && (module2.exports = __WEBPACK_AMD_DEFINE_RESULT__));
                    registeredInModuleLoader = true;
                  }
                  if (true) {
                    module2.exports = factory();
                    registeredInModuleLoader = true;
                  }
                  if (!registeredInModuleLoader) {
                    var OldCookies = window.Cookies;
                    var api = window.Cookies = factory();
                    api.noConflict = function() {
                      window.Cookies = OldCookies;
                      return api;
                    };
                  }
                })(function() {
                  function extend() {
                    var i = 0;
                    var result = {};
                    for (; i < arguments.length; i++) {
                      var attributes = arguments[i];
                      for (var key in attributes) {
                        result[key] = attributes[key];
                      }
                    }
                    return result;
                  }
                  function decode(s) {
                    return s.replace(/(%[0-9A-Z]{2})+/g, decodeURIComponent);
                  }
                  function init(converter) {
                    function api() {
                    }
                    function set(key, value, attributes) {
                      if (typeof document === "undefined") {
                        return;
                      }
                      attributes = extend({
                        path: "/"
                      }, api.defaults, attributes);
                      if (typeof attributes.expires === "number") {
                        attributes.expires = new Date(/* @__PURE__ */ new Date() * 1 + attributes.expires * 864e5);
                      }
                      attributes.expires = attributes.expires ? attributes.expires.toUTCString() : "";
                      try {
                        var result = JSON.stringify(value);
                        if (/^[\{\[]/.test(result)) {
                          value = result;
                        }
                      } catch (e) {
                      }
                      value = converter.write ? converter.write(value, key) : encodeURIComponent(String(value)).replace(/%(23|24|26|2B|3A|3C|3E|3D|2F|3F|40|5B|5D|5E|60|7B|7D|7C)/g, decodeURIComponent);
                      key = encodeURIComponent(String(key)).replace(/%(23|24|26|2B|5E|60|7C)/g, decodeURIComponent).replace(/[\(\)]/g, escape);
                      var stringifiedAttributes = "";
                      for (var attributeName in attributes) {
                        if (!attributes[attributeName]) {
                          continue;
                        }
                        stringifiedAttributes += "; " + attributeName;
                        if (attributes[attributeName] === true) {
                          continue;
                        }
                        stringifiedAttributes += "=" + attributes[attributeName].split(";")[0];
                      }
                      return document.cookie = key + "=" + value + stringifiedAttributes;
                    }
                    function get(key, json) {
                      if (typeof document === "undefined") {
                        return;
                      }
                      var jar = {};
                      var cookies = document.cookie ? document.cookie.split("; ") : [];
                      var i = 0;
                      for (; i < cookies.length; i++) {
                        var parts = cookies[i].split("=");
                        var cookie = parts.slice(1).join("=");
                        if (!json && cookie.charAt(0) === '"') {
                          cookie = cookie.slice(1, -1);
                        }
                        try {
                          var name = decode(parts[0]);
                          cookie = (converter.read || converter)(cookie, name) || decode(cookie);
                          if (json) {
                            try {
                              cookie = JSON.parse(cookie);
                            } catch (e) {
                            }
                          }
                          jar[name] = cookie;
                          if (key === name) {
                            break;
                          }
                        } catch (e) {
                        }
                      }
                      return key ? jar[key] : jar;
                    }
                    api.set = set;
                    api.get = function(key) {
                      return get(
                        key,
                        false
                        /* read as raw */
                      );
                    };
                    api.getJSON = function(key) {
                      return get(
                        key,
                        true
                        /* read as json */
                      );
                    };
                    api.remove = function(key, attributes) {
                      set(key, "", extend(attributes, {
                        expires: -1
                      }));
                    };
                    api.defaults = {};
                    api.withConverter = init;
                    return api;
                  }
                  return init(function() {
                  });
                });
              }
            ),
            /***/
            2284: (
              /***/
              (__unused_webpack___webpack_module__, __webpack_exports__2, __webpack_require__2) => {
                "use strict";
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  A: () => (
                    /* binding */
                    _typeof
                  )
                  /* harmony export */
                });
                function _typeof(o) {
                  "@babel/helpers - typeof";
                  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
                    return typeof o2;
                  } : function(o2) {
                    return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
                  }, _typeof(o);
                }
              }
            ),
            /***/
            2292: (
              /***/
              (__unused_webpack_module, exports2, __webpack_require__2) => {
                "use strict";
                Object.defineProperty(exports2, "__esModule", { value: true });
                exports2.Firefox120 = void 0;
                const sdpTransform = __webpack_require__2(7363);
                const enhancedEvents_1 = __webpack_require__2(3953);
                const Logger_1 = __webpack_require__2(2994);
                const errors_1 = __webpack_require__2(4893);
                const ortc = __webpack_require__2(8046);
                const scalabilityModes_1 = __webpack_require__2(3303);
                const sdpCommonUtils = __webpack_require__2(5544);
                const sdpUnifiedPlanUtils = __webpack_require__2(5938);
                const RemoteSdp_1 = __webpack_require__2(1305);
                const logger = new Logger_1.Logger("Firefox120");
                const NAME = "Firefox120";
                const SCTP_NUM_STREAMS = { OS: 16, MIS: 2048 };
                class Firefox120 extends enhancedEvents_1.EnhancedEventEmitter {
                  constructor({ direction, iceParameters, iceCandidates, dtlsParameters, sctpParameters, iceServers, iceTransportPolicy, additionalSettings, getSendExtendedRtpCapabilities }) {
                    super();
                    // Closed flag.
                    __publicField(this, "_closed", false);
                    // Handler direction.
                    __publicField(this, "_direction");
                    // Remote SDP handler.
                    __publicField(this, "_remoteSdp");
                    // Callback to request sending extended RTP capabilities on demand.
                    __publicField(this, "_getSendExtendedRtpCapabilities");
                    // RTCPeerConnection instance.
                    __publicField(this, "_pc");
                    // Map of RTCTransceivers indexed by MID.
                    __publicField(this, "_mapMidTransceiver", /* @__PURE__ */ new Map());
                    // Local stream for sending.
                    __publicField(this, "_sendStream", new MediaStream());
                    // Whether a DataChannel m=application section has been created.
                    __publicField(this, "_hasDataChannelMediaSection", false);
                    // Sending DataChannel id value counter. Incremented for each new DataChannel.
                    __publicField(this, "_nextSendSctpStreamId", 0);
                    // Got transport local and remote parameters.
                    __publicField(this, "_transportReady", false);
                    __publicField(this, "onIceGatheringStateChange", () => {
                      this.emit("@icegatheringstatechange", this._pc.iceGatheringState);
                    });
                    __publicField(this, "onIceCandidateError", (event) => {
                      this.emit("@icecandidateerror", event);
                    });
                    __publicField(this, "onConnectionStateChange", () => {
                      this.emit("@connectionstatechange", this._pc.connectionState);
                    });
                    __publicField(this, "onIceConnectionStateChange", () => {
                      switch (this._pc.iceConnectionState) {
                        case "checking": {
                          this.emit("@connectionstatechange", "connecting");
                          break;
                        }
                        case "connected":
                        case "completed": {
                          this.emit("@connectionstatechange", "connected");
                          break;
                        }
                        case "failed": {
                          this.emit("@connectionstatechange", "failed");
                          break;
                        }
                        case "disconnected": {
                          this.emit("@connectionstatechange", "disconnected");
                          break;
                        }
                        case "closed": {
                          this.emit("@connectionstatechange", "closed");
                          break;
                        }
                      }
                    });
                    logger.debug("constructor()");
                    this._direction = direction;
                    this._remoteSdp = new RemoteSdp_1.RemoteSdp({
                      iceParameters,
                      iceCandidates,
                      dtlsParameters,
                      sctpParameters
                    });
                    this._getSendExtendedRtpCapabilities = getSendExtendedRtpCapabilities;
                    this._pc = new RTCPeerConnection({
                      iceServers: iceServers ?? [],
                      iceTransportPolicy: iceTransportPolicy ?? "all",
                      bundlePolicy: "max-bundle",
                      rtcpMuxPolicy: "require",
                      ...additionalSettings
                    });
                    this._pc.addEventListener("icegatheringstatechange", this.onIceGatheringStateChange);
                    this._pc.addEventListener("icecandidateerror", this.onIceCandidateError);
                    if (this._pc.connectionState) {
                      this._pc.addEventListener("connectionstatechange", this.onConnectionStateChange);
                    } else {
                      logger.warn("run() | pc.connectionState not supported, using pc.iceConnectionState");
                      this._pc.addEventListener("iceconnectionstatechange", this.onIceConnectionStateChange);
                    }
                  }
                  /**
                   * Creates a factory function.
                   */
                  static createFactory() {
                    return {
                      name: NAME,
                      factory: (options) => new Firefox120(options),
                      getNativeRtpCapabilities: async () => {
                        logger.debug("getNativeRtpCapabilities()");
                        let pc = new RTCPeerConnection({
                          iceServers: [],
                          iceTransportPolicy: "all",
                          bundlePolicy: "max-bundle",
                          rtcpMuxPolicy: "require"
                        });
                        const canvas = document.createElement("canvas");
                        canvas.getContext("2d");
                        const fakeStream = canvas.captureStream();
                        const fakeVideoTrack = fakeStream.getVideoTracks()[0];
                        try {
                          pc.addTransceiver("audio", { direction: "sendrecv" });
                          pc.addTransceiver(fakeVideoTrack, {
                            direction: "sendrecv",
                            sendEncodings: [
                              { rid: "r0", maxBitrate: 1e5 },
                              { rid: "r1", maxBitrate: 5e5 }
                            ]
                          });
                          const offer = await pc.createOffer();
                          try {
                            canvas.remove();
                          } catch (error) {
                          }
                          try {
                            fakeVideoTrack.stop();
                          } catch (error) {
                          }
                          try {
                            pc.close();
                          } catch (error) {
                          }
                          pc = void 0;
                          const sdpObject = sdpTransform.parse(offer.sdp);
                          const nativeRtpCapabilities = Firefox120.getLocalRtpCapabilities(sdpObject);
                          return nativeRtpCapabilities;
                        } catch (error) {
                          try {
                            canvas.remove();
                          } catch (error2) {
                          }
                          try {
                            fakeVideoTrack.stop();
                          } catch (error2) {
                          }
                          try {
                            pc == null ? void 0 : pc.close();
                          } catch (error2) {
                          }
                          pc = void 0;
                          throw error;
                        }
                      },
                      getNativeSctpCapabilities: async () => {
                        logger.debug("getNativeSctpCapabilities()");
                        return {
                          numStreams: SCTP_NUM_STREAMS
                        };
                      }
                    };
                  }
                  static getLocalRtpCapabilities(localSdpObject) {
                    const nativeRtpCapabilities = sdpCommonUtils.extractRtpCapabilities({
                      sdpObject: localSdpObject
                    });
                    ortc.validateAndNormalizeRtpCapabilities(nativeRtpCapabilities);
                    return nativeRtpCapabilities;
                  }
                  get name() {
                    return NAME;
                  }
                  close() {
                    logger.debug("close()");
                    if (this._closed) {
                      return;
                    }
                    this._closed = true;
                    try {
                      this._pc.close();
                    } catch (error) {
                    }
                    this._pc.removeEventListener("icegatheringstatechange", this.onIceGatheringStateChange);
                    this._pc.removeEventListener("icecandidateerror", this.onIceCandidateError);
                    this._pc.removeEventListener("connectionstatechange", this.onConnectionStateChange);
                    this._pc.removeEventListener("iceconnectionstatechange", this.onIceConnectionStateChange);
                    this.emit("@close");
                    super.close();
                  }
                  // eslint-disable-next-line @typescript-eslint/no-unused-vars
                  async updateIceServers(iceServers) {
                    this.assertNotClosed();
                    throw new errors_1.UnsupportedError("not supported");
                  }
                  async restartIce(iceParameters) {
                    this.assertNotClosed();
                    logger.debug("restartIce()");
                    this._remoteSdp.updateIceParameters(iceParameters);
                    if (!this._transportReady) {
                      return;
                    }
                    if (this._direction === "send") {
                      const offer = await this._pc.createOffer({ iceRestart: true });
                      logger.debug("restartIce() | calling pc.setLocalDescription() [offer:%o]", offer);
                      await this._pc.setLocalDescription(offer);
                      const answer = {
                        type: "answer",
                        sdp: this._remoteSdp.getSdp()
                      };
                      logger.debug("restartIce() | calling pc.setRemoteDescription() [answer:%o]", answer);
                      await this._pc.setRemoteDescription(answer);
                    } else {
                      const offer = {
                        type: "offer",
                        sdp: this._remoteSdp.getSdp()
                      };
                      logger.debug("restartIce() | calling pc.setRemoteDescription() [offer:%o]", offer);
                      await this._pc.setRemoteDescription(offer);
                      const answer = await this._pc.createAnswer();
                      logger.debug("restartIce() | calling pc.setLocalDescription() [answer:%o]", answer);
                      await this._pc.setLocalDescription(answer);
                    }
                  }
                  async getTransportStats() {
                    this.assertNotClosed();
                    return this._pc.getStats();
                  }
                  async send({ track, encodings, codecOptions, codec, onRtpSender }) {
                    this.assertNotClosed();
                    this.assertSendDirection();
                    logger.debug("send() [kind:%s, track.id:%s]", track.kind, track.id);
                    if (encodings && encodings.length > 1) {
                      encodings.forEach((encoding, idx) => {
                        encoding.rid = `r${idx}`;
                      });
                    }
                    const transceiver = this._pc.addTransceiver(track, {
                      direction: "sendonly",
                      streams: [this._sendStream],
                      sendEncodings: encodings
                    });
                    if (onRtpSender) {
                      onRtpSender(transceiver.sender);
                    }
                    const offer = await this._pc.createOffer();
                    let localSdpObject = sdpTransform.parse(offer.sdp);
                    if (localSdpObject.extmapAllowMixed) {
                      this._remoteSdp.setSessionExtmapAllowMixed();
                    }
                    const nativeRtpCapabilities = Firefox120.getLocalRtpCapabilities(localSdpObject);
                    const sendExtendedRtpCapabilities = this._getSendExtendedRtpCapabilities(nativeRtpCapabilities);
                    const sendingRtpParameters = ortc.getSendingRtpParameters(track.kind, sendExtendedRtpCapabilities);
                    sendingRtpParameters.codecs = ortc.reduceCodecs(sendingRtpParameters.codecs, codec);
                    const sendingRemoteRtpParameters = ortc.getSendingRemoteRtpParameters(track.kind, sendExtendedRtpCapabilities);
                    sendingRemoteRtpParameters.codecs = ortc.reduceCodecs(sendingRemoteRtpParameters.codecs, codec);
                    if (!this._transportReady) {
                      await this.setupTransport({ localDtlsRole: "client", localSdpObject });
                    }
                    const layers = (0, scalabilityModes_1.parse)((encodings ?? [{}])[0].scalabilityMode);
                    logger.debug("send() | calling pc.setLocalDescription() [offer:%o]", offer);
                    await this._pc.setLocalDescription(offer);
                    const localId = transceiver.mid;
                    sendingRtpParameters.mid = localId;
                    localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
                    const offerMediaObject = localSdpObject.media[localSdpObject.media.length - 1];
                    sendingRtpParameters.rtcp.cname = sdpCommonUtils.getCname({
                      offerMediaObject
                    });
                    if (!encodings) {
                      sendingRtpParameters.encodings = sdpUnifiedPlanUtils.getRtpEncodings({
                        offerMediaObject
                      });
                    } else if (encodings.length === 1) {
                      const newEncodings = sdpUnifiedPlanUtils.getRtpEncodings({
                        offerMediaObject
                      });
                      Object.assign(newEncodings[0], encodings[0]);
                      sendingRtpParameters.encodings = newEncodings;
                    } else {
                      sendingRtpParameters.encodings = encodings;
                    }
                    if (sendingRtpParameters.encodings.length > 1 && (sendingRtpParameters.codecs[0].mimeType.toLowerCase() === "video/vp8" || sendingRtpParameters.codecs[0].mimeType.toLowerCase() === "video/h264")) {
                      for (const encoding of sendingRtpParameters.encodings) {
                        if (encoding.scalabilityMode) {
                          encoding.scalabilityMode = `L1T${layers.temporalLayers}`;
                        } else {
                          encoding.scalabilityMode = "L1T3";
                        }
                      }
                    }
                    this._remoteSdp.send({
                      offerMediaObject,
                      offerRtpParameters: sendingRtpParameters,
                      answerRtpParameters: sendingRemoteRtpParameters,
                      codecOptions
                    });
                    const answer = {
                      type: "answer",
                      sdp: this._remoteSdp.getSdp()
                    };
                    logger.debug("send() | calling pc.setRemoteDescription() [answer:%o]", answer);
                    await this._pc.setRemoteDescription(answer);
                    this._mapMidTransceiver.set(localId, transceiver);
                    return {
                      localId,
                      rtpParameters: sendingRtpParameters,
                      rtpSender: transceiver.sender
                    };
                  }
                  async stopSending(localId) {
                    this.assertSendDirection();
                    logger.debug("stopSending() [localId:%s]", localId);
                    if (this._closed) {
                      return;
                    }
                    const transceiver = this._mapMidTransceiver.get(localId);
                    if (!transceiver) {
                      throw new Error("associated transceiver not found");
                    }
                    void transceiver.sender.replaceTrack(null);
                    this._pc.removeTrack(transceiver.sender);
                    this._remoteSdp.disableMediaSection(transceiver.mid);
                    const offer = await this._pc.createOffer();
                    logger.debug("stopSending() | calling pc.setLocalDescription() [offer:%o]", offer);
                    await this._pc.setLocalDescription(offer);
                    const answer = {
                      type: "answer",
                      sdp: this._remoteSdp.getSdp()
                    };
                    logger.debug("stopSending() | calling pc.setRemoteDescription() [answer:%o]", answer);
                    await this._pc.setRemoteDescription(answer);
                    this._mapMidTransceiver.delete(localId);
                  }
                  async pauseSending(localId) {
                    this.assertNotClosed();
                    this.assertSendDirection();
                    logger.debug("pauseSending() [localId:%s]", localId);
                    const transceiver = this._mapMidTransceiver.get(localId);
                    if (!transceiver) {
                      throw new Error("associated RTCRtpTransceiver not found");
                    }
                    transceiver.direction = "inactive";
                    this._remoteSdp.pauseMediaSection(localId);
                    const offer = await this._pc.createOffer();
                    logger.debug("pauseSending() | calling pc.setLocalDescription() [offer:%o]", offer);
                    await this._pc.setLocalDescription(offer);
                    const answer = {
                      type: "answer",
                      sdp: this._remoteSdp.getSdp()
                    };
                    logger.debug("pauseSending() | calling pc.setRemoteDescription() [answer:%o]", answer);
                    await this._pc.setRemoteDescription(answer);
                  }
                  async resumeSending(localId) {
                    this.assertNotClosed();
                    this.assertSendDirection();
                    logger.debug("resumeSending() [localId:%s]", localId);
                    const transceiver = this._mapMidTransceiver.get(localId);
                    if (!transceiver) {
                      throw new Error("associated RTCRtpTransceiver not found");
                    }
                    transceiver.direction = "sendonly";
                    this._remoteSdp.resumeSendingMediaSection(localId);
                    const offer = await this._pc.createOffer();
                    logger.debug("resumeSending() | calling pc.setLocalDescription() [offer:%o]", offer);
                    await this._pc.setLocalDescription(offer);
                    const answer = {
                      type: "answer",
                      sdp: this._remoteSdp.getSdp()
                    };
                    logger.debug("resumeSending() | calling pc.setRemoteDescription() [answer:%o]", answer);
                    await this._pc.setRemoteDescription(answer);
                  }
                  async replaceTrack(localId, track) {
                    this.assertNotClosed();
                    this.assertSendDirection();
                    if (track) {
                      logger.debug("replaceTrack() [localId:%s, track.id:%s]", localId, track.id);
                    } else {
                      logger.debug("replaceTrack() [localId:%s, no track]", localId);
                    }
                    const transceiver = this._mapMidTransceiver.get(localId);
                    if (!transceiver) {
                      throw new Error("associated RTCRtpTransceiver not found");
                    }
                    await transceiver.sender.replaceTrack(track);
                  }
                  async setMaxSpatialLayer(localId, spatialLayer) {
                    this.assertNotClosed();
                    this.assertSendDirection();
                    logger.debug("setMaxSpatialLayer() [localId:%s, spatialLayer:%s]", localId, spatialLayer);
                    const transceiver = this._mapMidTransceiver.get(localId);
                    if (!transceiver) {
                      throw new Error("associated transceiver not found");
                    }
                    const parameters = transceiver.sender.getParameters();
                    parameters.encodings.forEach((encoding, idx) => {
                      if (idx <= spatialLayer) {
                        encoding.active = true;
                      } else {
                        encoding.active = false;
                      }
                    });
                    await transceiver.sender.setParameters(parameters);
                    this._remoteSdp.muxMediaSectionSimulcast(localId, parameters.encodings);
                    const offer = await this._pc.createOffer();
                    logger.debug("setMaxSpatialLayer() | calling pc.setLocalDescription() [offer:%o]", offer);
                    await this._pc.setLocalDescription(offer);
                    const answer = {
                      type: "answer",
                      sdp: this._remoteSdp.getSdp()
                    };
                    logger.debug("setMaxSpatialLayer() | calling pc.setRemoteDescription() [answer:%o]", answer);
                    await this._pc.setRemoteDescription(answer);
                  }
                  async setRtpEncodingParameters(localId, params) {
                    this.assertNotClosed();
                    this.assertSendDirection();
                    logger.debug("setRtpEncodingParameters() [localId:%s, params:%o]", localId, params);
                    const transceiver = this._mapMidTransceiver.get(localId);
                    if (!transceiver) {
                      throw new Error("associated RTCRtpTransceiver not found");
                    }
                    const parameters = transceiver.sender.getParameters();
                    parameters.encodings.forEach((encoding, idx) => {
                      parameters.encodings[idx] = { ...encoding, ...params };
                    });
                    await transceiver.sender.setParameters(parameters);
                    this._remoteSdp.muxMediaSectionSimulcast(localId, parameters.encodings);
                    const offer = await this._pc.createOffer();
                    logger.debug("setRtpEncodingParameters() | calling pc.setLocalDescription() [offer:%o]", offer);
                    await this._pc.setLocalDescription(offer);
                    const answer = {
                      type: "answer",
                      sdp: this._remoteSdp.getSdp()
                    };
                    logger.debug("setRtpEncodingParameters() | calling pc.setRemoteDescription() [answer:%o]", answer);
                    await this._pc.setRemoteDescription(answer);
                  }
                  async getSenderStats(localId) {
                    this.assertNotClosed();
                    this.assertSendDirection();
                    const transceiver = this._mapMidTransceiver.get(localId);
                    if (!transceiver) {
                      throw new Error("associated RTCRtpTransceiver not found");
                    }
                    return transceiver.sender.getStats();
                  }
                  async sendDataChannel({ ordered, maxPacketLifeTime, maxRetransmits, label, protocol }) {
                    this.assertNotClosed();
                    this.assertSendDirection();
                    const options = {
                      negotiated: true,
                      id: this._nextSendSctpStreamId,
                      ordered,
                      maxPacketLifeTime,
                      maxRetransmits,
                      protocol
                    };
                    logger.debug("sendDataChannel() [options:%o]", options);
                    const dataChannel = this._pc.createDataChannel(label, options);
                    this._nextSendSctpStreamId = ++this._nextSendSctpStreamId % SCTP_NUM_STREAMS.MIS;
                    if (!this._hasDataChannelMediaSection) {
                      const offer = await this._pc.createOffer();
                      const localSdpObject = sdpTransform.parse(offer.sdp);
                      const offerMediaObject = localSdpObject.media.find((m) => m.type === "application");
                      if (!this._transportReady) {
                        await this.setupTransport({ localDtlsRole: "client", localSdpObject });
                      }
                      logger.debug("sendDataChannel() | calling pc.setLocalDescription() [offer:%o]", offer);
                      await this._pc.setLocalDescription(offer);
                      this._remoteSdp.sendSctpAssociation({ offerMediaObject });
                      const answer = {
                        type: "answer",
                        sdp: this._remoteSdp.getSdp()
                      };
                      logger.debug("sendDataChannel() | calling pc.setRemoteDescription() [answer:%o]", answer);
                      await this._pc.setRemoteDescription(answer);
                      this._hasDataChannelMediaSection = true;
                    }
                    const sctpStreamParameters = {
                      streamId: options.id,
                      ordered: options.ordered,
                      maxPacketLifeTime: options.maxPacketLifeTime,
                      maxRetransmits: options.maxRetransmits
                    };
                    return { dataChannel, sctpStreamParameters };
                  }
                  async receive(optionsList) {
                    this.assertNotClosed();
                    this.assertRecvDirection();
                    const results = [];
                    const mapLocalId = /* @__PURE__ */ new Map();
                    for (const options of optionsList) {
                      const { trackId, kind, rtpParameters, streamId } = options;
                      logger.debug("receive() [trackId:%s, kind:%s]", trackId, kind);
                      const localId = rtpParameters.mid ?? String(this._mapMidTransceiver.size);
                      mapLocalId.set(trackId, localId);
                      this._remoteSdp.receive({
                        mid: localId,
                        kind,
                        offerRtpParameters: rtpParameters,
                        streamId: streamId ?? rtpParameters.rtcp.cname,
                        trackId
                      });
                    }
                    const offer = {
                      type: "offer",
                      sdp: this._remoteSdp.getSdp()
                    };
                    logger.debug("receive() | calling pc.setRemoteDescription() [offer:%o]", offer);
                    await this._pc.setRemoteDescription(offer);
                    for (const options of optionsList) {
                      const { trackId, onRtpReceiver } = options;
                      if (onRtpReceiver) {
                        const localId = mapLocalId.get(trackId);
                        const transceiver = this._pc.getTransceivers().find((t) => t.mid === localId);
                        if (!transceiver) {
                          throw new Error("transceiver not found");
                        }
                        onRtpReceiver(transceiver.receiver);
                      }
                    }
                    let answer = await this._pc.createAnswer();
                    const localSdpObject = sdpTransform.parse(answer.sdp);
                    for (const options of optionsList) {
                      const { trackId, rtpParameters } = options;
                      const localId = mapLocalId.get(trackId);
                      const answerMediaObject = localSdpObject.media.find((m) => String(m.mid) === localId);
                      sdpCommonUtils.applyCodecParameters({
                        offerRtpParameters: rtpParameters,
                        answerMediaObject
                      });
                      answer = {
                        type: "answer",
                        sdp: sdpTransform.write(localSdpObject)
                      };
                    }
                    if (!this._transportReady) {
                      await this.setupTransport({ localDtlsRole: "client", localSdpObject });
                    }
                    logger.debug("receive() | calling pc.setLocalDescription() [answer:%o]", answer);
                    await this._pc.setLocalDescription(answer);
                    for (const options of optionsList) {
                      const { trackId } = options;
                      const localId = mapLocalId.get(trackId);
                      const transceiver = this._pc.getTransceivers().find((t) => t.mid === localId);
                      if (!transceiver) {
                        throw new Error("new RTCRtpTransceiver not found");
                      }
                      this._mapMidTransceiver.set(localId, transceiver);
                      results.push({
                        localId,
                        track: transceiver.receiver.track,
                        rtpReceiver: transceiver.receiver
                      });
                    }
                    return results;
                  }
                  async stopReceiving(localIds) {
                    this.assertRecvDirection();
                    if (this._closed) {
                      return;
                    }
                    for (const localId of localIds) {
                      logger.debug("stopReceiving() [localId:%s]", localId);
                      const transceiver = this._mapMidTransceiver.get(localId);
                      if (!transceiver) {
                        throw new Error("associated RTCRtpTransceiver not found");
                      }
                      this._remoteSdp.closeMediaSection(transceiver.mid);
                    }
                    const offer = {
                      type: "offer",
                      sdp: this._remoteSdp.getSdp()
                    };
                    logger.debug("stopReceiving() | calling pc.setRemoteDescription() [offer:%o]", offer);
                    await this._pc.setRemoteDescription(offer);
                    const answer = await this._pc.createAnswer();
                    logger.debug("stopReceiving() | calling pc.setLocalDescription() [answer:%o]", answer);
                    await this._pc.setLocalDescription(answer);
                    for (const localId of localIds) {
                      this._mapMidTransceiver.delete(localId);
                    }
                  }
                  async pauseReceiving(localIds) {
                    this.assertNotClosed();
                    this.assertRecvDirection();
                    for (const localId of localIds) {
                      logger.debug("pauseReceiving() [localId:%s]", localId);
                      const transceiver = this._mapMidTransceiver.get(localId);
                      if (!transceiver) {
                        throw new Error("associated RTCRtpTransceiver not found");
                      }
                      transceiver.direction = "inactive";
                      this._remoteSdp.pauseMediaSection(localId);
                    }
                    const offer = {
                      type: "offer",
                      sdp: this._remoteSdp.getSdp()
                    };
                    logger.debug("pauseReceiving() | calling pc.setRemoteDescription() [offer:%o]", offer);
                    await this._pc.setRemoteDescription(offer);
                    const answer = await this._pc.createAnswer();
                    logger.debug("pauseReceiving() | calling pc.setLocalDescription() [answer:%o]", answer);
                    await this._pc.setLocalDescription(answer);
                  }
                  async resumeReceiving(localIds) {
                    this.assertNotClosed();
                    this.assertRecvDirection();
                    for (const localId of localIds) {
                      logger.debug("resumeReceiving() [localId:%s]", localId);
                      const transceiver = this._mapMidTransceiver.get(localId);
                      if (!transceiver) {
                        throw new Error("associated RTCRtpTransceiver not found");
                      }
                      transceiver.direction = "recvonly";
                      this._remoteSdp.resumeReceivingMediaSection(localId);
                    }
                    const offer = {
                      type: "offer",
                      sdp: this._remoteSdp.getSdp()
                    };
                    logger.debug("resumeReceiving() | calling pc.setRemoteDescription() [offer:%o]", offer);
                    await this._pc.setRemoteDescription(offer);
                    const answer = await this._pc.createAnswer();
                    logger.debug("resumeReceiving() | calling pc.setLocalDescription() [answer:%o]", answer);
                    await this._pc.setLocalDescription(answer);
                  }
                  async getReceiverStats(localId) {
                    this.assertRecvDirection();
                    const transceiver = this._mapMidTransceiver.get(localId);
                    if (!transceiver) {
                      throw new Error("associated RTCRtpTransceiver not found");
                    }
                    return transceiver.receiver.getStats();
                  }
                  async receiveDataChannel({ sctpStreamParameters, label, protocol }) {
                    this.assertNotClosed();
                    this.assertRecvDirection();
                    const { streamId, ordered, maxPacketLifeTime, maxRetransmits } = sctpStreamParameters;
                    const options = {
                      negotiated: true,
                      id: streamId,
                      ordered,
                      maxPacketLifeTime,
                      maxRetransmits,
                      protocol
                    };
                    logger.debug("receiveDataChannel() [options:%o]", options);
                    const dataChannel = this._pc.createDataChannel(label, options);
                    if (!this._hasDataChannelMediaSection) {
                      this._remoteSdp.receiveSctpAssociation();
                      const offer = {
                        type: "offer",
                        sdp: this._remoteSdp.getSdp()
                      };
                      logger.debug("receiveDataChannel() | calling pc.setRemoteDescription() [offer:%o]", offer);
                      await this._pc.setRemoteDescription(offer);
                      const answer = await this._pc.createAnswer();
                      if (!this._transportReady) {
                        const localSdpObject = sdpTransform.parse(answer.sdp);
                        await this.setupTransport({ localDtlsRole: "client", localSdpObject });
                      }
                      logger.debug("receiveDataChannel() | calling pc.setRemoteDescription() [answer:%o]", answer);
                      await this._pc.setLocalDescription(answer);
                      this._hasDataChannelMediaSection = true;
                    }
                    return { dataChannel };
                  }
                  async setupTransport({ localDtlsRole, localSdpObject }) {
                    if (!localSdpObject) {
                      localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
                    }
                    const dtlsParameters = sdpCommonUtils.extractDtlsParameters({
                      sdpObject: localSdpObject
                    });
                    dtlsParameters.role = localDtlsRole;
                    this._remoteSdp.updateDtlsRole(localDtlsRole === "client" ? "server" : "client");
                    await new Promise((resolve, reject) => {
                      this.safeEmit("@connect", { dtlsParameters }, resolve, reject);
                    });
                    this._transportReady = true;
                  }
                  assertNotClosed() {
                    if (this._closed) {
                      throw new errors_1.InvalidStateError("method called in a closed handler");
                    }
                  }
                  assertSendDirection() {
                    if (this._direction !== "send") {
                      throw new Error('method can just be called for handlers with "send" direction');
                    }
                  }
                  assertRecvDirection() {
                    if (this._direction !== "recv") {
                      throw new Error('method can just be called for handlers with "recv" direction');
                    }
                  }
                }
                exports2.Firefox120 = Firefox120;
              }
            ),
            /***/
            2614: (
              /***/
              (__unused_webpack_module, exports2) => {
                var IDX = 256, HEX = [], BUFFER;
                while (IDX--) HEX[IDX] = (IDX + 256).toString(16).substring(1);
                function v4() {
                  var i = 0, num, out = "";
                  if (!BUFFER || IDX + 16 > 256) {
                    BUFFER = Array(i = 256);
                    while (i--) BUFFER[i] = 256 * Math.random() | 0;
                    i = IDX = 0;
                  }
                  for (; i < 16; i++) {
                    num = BUFFER[IDX + i];
                    if (i == 6) out += HEX[num & 15 | 64];
                    else if (i == 8) out += HEX[num & 63 | 128];
                    else out += HEX[num];
                    if (i & 1 && i > 1 && i < 11) out += "-";
                  }
                  IDX++;
                  return out;
                }
                exports2.v4 = v4;
              }
            ),
            /***/
            2696: (
              /***/
              function(module2, exports2, __webpack_require__2) {
                ;
                (function(root, factory, undef) {
                  if (true) {
                    module2.exports = exports2 = factory(__webpack_require__2(9021), __webpack_require__2(754), __webpack_require__2(4636), __webpack_require__2(9506), __webpack_require__2(7165));
                  } else {
                  }
                })(this, function(CryptoJS) {
                  (function() {
                    var C = CryptoJS;
                    var C_lib = C.lib;
                    var StreamCipher = C_lib.StreamCipher;
                    var C_algo = C.algo;
                    var S = [];
                    var C_ = [];
                    var G = [];
                    var RabbitLegacy = C_algo.RabbitLegacy = StreamCipher.extend({
                      _doReset: function() {
                        var K = this._key.words;
                        var iv = this.cfg.iv;
                        var X = this._X = [
                          K[0],
                          K[3] << 16 | K[2] >>> 16,
                          K[1],
                          K[0] << 16 | K[3] >>> 16,
                          K[2],
                          K[1] << 16 | K[0] >>> 16,
                          K[3],
                          K[2] << 16 | K[1] >>> 16
                        ];
                        var C2 = this._C = [
                          K[2] << 16 | K[2] >>> 16,
                          K[0] & 4294901760 | K[1] & 65535,
                          K[3] << 16 | K[3] >>> 16,
                          K[1] & 4294901760 | K[2] & 65535,
                          K[0] << 16 | K[0] >>> 16,
                          K[2] & 4294901760 | K[3] & 65535,
                          K[1] << 16 | K[1] >>> 16,
                          K[3] & 4294901760 | K[0] & 65535
                        ];
                        this._b = 0;
                        for (var i = 0; i < 4; i++) {
                          nextState.call(this);
                        }
                        for (var i = 0; i < 8; i++) {
                          C2[i] ^= X[i + 4 & 7];
                        }
                        if (iv) {
                          var IV = iv.words;
                          var IV_0 = IV[0];
                          var IV_1 = IV[1];
                          var i0 = (IV_0 << 8 | IV_0 >>> 24) & 16711935 | (IV_0 << 24 | IV_0 >>> 8) & 4278255360;
                          var i2 = (IV_1 << 8 | IV_1 >>> 24) & 16711935 | (IV_1 << 24 | IV_1 >>> 8) & 4278255360;
                          var i1 = i0 >>> 16 | i2 & 4294901760;
                          var i3 = i2 << 16 | i0 & 65535;
                          C2[0] ^= i0;
                          C2[1] ^= i1;
                          C2[2] ^= i2;
                          C2[3] ^= i3;
                          C2[4] ^= i0;
                          C2[5] ^= i1;
                          C2[6] ^= i2;
                          C2[7] ^= i3;
                          for (var i = 0; i < 4; i++) {
                            nextState.call(this);
                          }
                        }
                      },
                      _doProcessBlock: function(M, offset) {
                        var X = this._X;
                        nextState.call(this);
                        S[0] = X[0] ^ X[5] >>> 16 ^ X[3] << 16;
                        S[1] = X[2] ^ X[7] >>> 16 ^ X[5] << 16;
                        S[2] = X[4] ^ X[1] >>> 16 ^ X[7] << 16;
                        S[3] = X[6] ^ X[3] >>> 16 ^ X[1] << 16;
                        for (var i = 0; i < 4; i++) {
                          S[i] = (S[i] << 8 | S[i] >>> 24) & 16711935 | (S[i] << 24 | S[i] >>> 8) & 4278255360;
                          M[offset + i] ^= S[i];
                        }
                      },
                      blockSize: 128 / 32,
                      ivSize: 64 / 32
                    });
                    function nextState() {
                      var X = this._X;
                      var C2 = this._C;
                      for (var i = 0; i < 8; i++) {
                        C_[i] = C2[i];
                      }
                      C2[0] = C2[0] + 1295307597 + this._b | 0;
                      C2[1] = C2[1] + 3545052371 + (C2[0] >>> 0 < C_[0] >>> 0 ? 1 : 0) | 0;
                      C2[2] = C2[2] + 886263092 + (C2[1] >>> 0 < C_[1] >>> 0 ? 1 : 0) | 0;
                      C2[3] = C2[3] + 1295307597 + (C2[2] >>> 0 < C_[2] >>> 0 ? 1 : 0) | 0;
                      C2[4] = C2[4] + 3545052371 + (C2[3] >>> 0 < C_[3] >>> 0 ? 1 : 0) | 0;
                      C2[5] = C2[5] + 886263092 + (C2[4] >>> 0 < C_[4] >>> 0 ? 1 : 0) | 0;
                      C2[6] = C2[6] + 1295307597 + (C2[5] >>> 0 < C_[5] >>> 0 ? 1 : 0) | 0;
                      C2[7] = C2[7] + 3545052371 + (C2[6] >>> 0 < C_[6] >>> 0 ? 1 : 0) | 0;
                      this._b = C2[7] >>> 0 < C_[7] >>> 0 ? 1 : 0;
                      for (var i = 0; i < 8; i++) {
                        var gx = X[i] + C2[i];
                        var ga = gx & 65535;
                        var gb = gx >>> 16;
                        var gh = ((ga * ga >>> 17) + ga * gb >>> 15) + gb * gb;
                        var gl = ((gx & 4294901760) * gx | 0) + ((gx & 65535) * gx | 0);
                        G[i] = gh ^ gl;
                      }
                      X[0] = G[0] + (G[7] << 16 | G[7] >>> 16) + (G[6] << 16 | G[6] >>> 16) | 0;
                      X[1] = G[1] + (G[0] << 8 | G[0] >>> 24) + G[7] | 0;
                      X[2] = G[2] + (G[1] << 16 | G[1] >>> 16) + (G[0] << 16 | G[0] >>> 16) | 0;
                      X[3] = G[3] + (G[2] << 8 | G[2] >>> 24) + G[1] | 0;
                      X[4] = G[4] + (G[3] << 16 | G[3] >>> 16) + (G[2] << 16 | G[2] >>> 16) | 0;
                      X[5] = G[5] + (G[4] << 8 | G[4] >>> 24) + G[3] | 0;
                      X[6] = G[6] + (G[5] << 16 | G[5] >>> 16) + (G[4] << 16 | G[4] >>> 16) | 0;
                      X[7] = G[7] + (G[6] << 8 | G[6] >>> 24) + G[5] | 0;
                    }
                    C.RabbitLegacy = StreamCipher._createHelper(RabbitLegacy);
                  })();
                  return CryptoJS.RabbitLegacy;
                });
              }
            ),
            /***/
            2731: (
              /***/
              (__unused_webpack_module, exports2, __webpack_require__2) => {
                "use strict";
                Object.defineProperty(exports2, "__esModule", { value: true });
                exports2.FakeHandler = void 0;
                const fake_mediastreamtrack_1 = __webpack_require__2(5328);
                const enhancedEvents_1 = __webpack_require__2(3953);
                const Logger_1 = __webpack_require__2(2994);
                const utils = __webpack_require__2(1765);
                const ortc = __webpack_require__2(8046);
                const errors_1 = __webpack_require__2(4893);
                const FakeEventTarget_1 = __webpack_require__2(3051);
                const logger = new Logger_1.Logger("FakeHandler");
                const NAME = "FakeHandler";
                class FakeHandler extends enhancedEvents_1.EnhancedEventEmitter {
                  constructor({
                    // direction,
                    // iceParameters,
                    // iceCandidates,
                    // dtlsParameters,
                    // sctpParameters,
                    // iceServers,
                    // iceTransportPolicy,
                    // additionalSettings,
                    getSendExtendedRtpCapabilities
                  }, fakeParameters) {
                    super();
                    // Closed flag.
                    __publicField(this, "_closed", false);
                    // Fake parameters source of RTP and SCTP parameters and capabilities.
                    __publicField(this, "_fakeParameters");
                    // Callback to request sending extended RTP capabilities on demand.
                    __publicField(this, "_getSendExtendedRtpCapabilities");
                    // Local RTCP CNAME.
                    __publicField(this, "_cname", `CNAME-${utils.generateRandomNumber()}`);
                    // Got transport local and remote parameters.
                    __publicField(this, "_transportReady", false);
                    // Next localId.
                    __publicField(this, "_nextLocalId", 1);
                    // Sending and receiving tracks indexed by localId.
                    __publicField(this, "_tracks", /* @__PURE__ */ new Map());
                    // DataChannel id value counter. It must be incremented for each new DataChannel.
                    __publicField(this, "_nextSctpStreamId", 0);
                    logger.debug("constructor()");
                    this._getSendExtendedRtpCapabilities = getSendExtendedRtpCapabilities;
                    this._fakeParameters = fakeParameters;
                  }
                  /**
                   * Creates a factory function.
                   */
                  static createFactory(fakeParameters) {
                    return {
                      name: NAME,
                      factory: (options) => new FakeHandler(options, fakeParameters),
                      getNativeRtpCapabilities: async () => {
                        logger.debug("getNativeRtpCapabilities()");
                        return FakeHandler.getLocalRtpCapabilities(fakeParameters);
                      },
                      getNativeSctpCapabilities: async () => {
                        logger.debug("getNativeSctpCapabilities()");
                        return fakeParameters.generateNativeSctpCapabilities();
                      }
                    };
                  }
                  static getLocalRtpCapabilities(fakeParameters) {
                    const nativeRtpCapabilities = fakeParameters.generateNativeRtpCapabilities();
                    ortc.validateAndNormalizeRtpCapabilities(nativeRtpCapabilities);
                    return nativeRtpCapabilities;
                  }
                  get name() {
                    return NAME;
                  }
                  close() {
                    logger.debug("close()");
                    if (this._closed) {
                      return;
                    }
                    this._closed = true;
                    super.close();
                  }
                  // NOTE: Custom method for simulation purposes.
                  setIceGatheringState(iceGatheringState) {
                    this.emit("@icegatheringstatechange", iceGatheringState);
                  }
                  // NOTE: Custom method for simulation purposes.
                  setConnectionState(connectionState) {
                    this.emit("@connectionstatechange", connectionState);
                  }
                  // eslint-disable-next-line @typescript-eslint/no-unused-vars
                  async updateIceServers(iceServers) {
                    this.assertNotClosed();
                    logger.debug("updateIceServers()");
                  }
                  // eslint-disable-next-line @typescript-eslint/no-unused-vars
                  async restartIce(iceParameters) {
                    this.assertNotClosed();
                    logger.debug("restartIce()");
                  }
                  async getTransportStats() {
                    this.assertNotClosed();
                    return /* @__PURE__ */ new Map();
                  }
                  async send({ track, encodings, codecOptions, codec }) {
                    this.assertNotClosed();
                    logger.debug("send() [kind:%s, track.id:%s]", track.kind, track.id);
                    if (!this._transportReady) {
                      await this.setupTransport({ localDtlsRole: "server" });
                    }
                    const nativeRtpCapabilities = FakeHandler.getLocalRtpCapabilities(this._fakeParameters);
                    const sendExtendedRtpCapabilities = this._getSendExtendedRtpCapabilities(nativeRtpCapabilities);
                    const sendingRtpParameters = ortc.getSendingRtpParameters(track.kind, sendExtendedRtpCapabilities);
                    sendingRtpParameters.codecs = ortc.reduceCodecs(sendingRtpParameters.codecs, codec);
                    const useRtx = sendingRtpParameters.codecs.some((_codec) => /.+\/rtx$/i.test(_codec.mimeType));
                    sendingRtpParameters.mid = `mid-${utils.generateRandomNumber()}`;
                    if (!encodings) {
                      encodings = [{}];
                    }
                    for (const encoding of encodings) {
                      encoding.ssrc = utils.generateRandomNumber();
                      if (useRtx) {
                        encoding.rtx = { ssrc: utils.generateRandomNumber() };
                      }
                    }
                    sendingRtpParameters.encodings = encodings;
                    sendingRtpParameters.rtcp = {
                      cname: this._cname,
                      reducedSize: true,
                      mux: true
                    };
                    const localId = this._nextLocalId++;
                    this._tracks.set(localId, track);
                    return { localId: String(localId), rtpParameters: sendingRtpParameters };
                  }
                  async stopSending(localId) {
                    logger.debug("stopSending() [localId:%s]", localId);
                    if (this._closed) {
                      return;
                    }
                    if (!this._tracks.has(Number(localId))) {
                      throw new Error("local track not found");
                    }
                    this._tracks.delete(Number(localId));
                  }
                  // eslint-disable-next-line @typescript-eslint/no-unused-vars
                  async pauseSending(localId) {
                    this.assertNotClosed();
                  }
                  // eslint-disable-next-line @typescript-eslint/no-unused-vars
                  async resumeSending(localId) {
                    this.assertNotClosed();
                  }
                  async replaceTrack(localId, track) {
                    this.assertNotClosed();
                    if (track) {
                      logger.debug("replaceTrack() [localId:%s, track.id:%s]", localId, track.id);
                    } else {
                      logger.debug("replaceTrack() [localId:%s, no track]", localId);
                    }
                    this._tracks.delete(Number(localId));
                    this._tracks.set(Number(localId), track);
                  }
                  async setMaxSpatialLayer(localId, spatialLayer) {
                    this.assertNotClosed();
                    logger.debug("setMaxSpatialLayer() [localId:%s, spatialLayer:%s]", localId, spatialLayer);
                  }
                  async setRtpEncodingParameters(localId, params) {
                    this.assertNotClosed();
                    logger.debug("setRtpEncodingParameters() [localId:%s, params:%o]", localId, params);
                  }
                  // eslint-disable-next-line @typescript-eslint/no-unused-vars
                  async getSenderStats(localId) {
                    this.assertNotClosed();
                    return /* @__PURE__ */ new Map();
                  }
                  async sendDataChannel({ ordered, maxPacketLifeTime, maxRetransmits, label, protocol }) {
                    this.assertNotClosed();
                    if (!this._transportReady) {
                      await this.setupTransport({ localDtlsRole: "server" });
                    }
                    logger.debug("sendDataChannel()");
                    const dataChannel = new FakeRTCDataChannel({
                      id: this._nextSctpStreamId++,
                      ordered,
                      maxPacketLifeTime,
                      maxRetransmits,
                      label,
                      protocol
                    });
                    const sctpStreamParameters = {
                      streamId: this._nextSctpStreamId,
                      ordered,
                      maxPacketLifeTime,
                      maxRetransmits
                    };
                    return { dataChannel, sctpStreamParameters };
                  }
                  async receive(optionsList) {
                    this.assertNotClosed();
                    const results = [];
                    for (const options of optionsList) {
                      const { trackId, kind } = options;
                      if (!this._transportReady) {
                        await this.setupTransport({ localDtlsRole: "client" });
                      }
                      logger.debug("receive() [trackId:%s, kind:%s]", trackId, kind);
                      const localId = this._nextLocalId++;
                      const track = new fake_mediastreamtrack_1.FakeMediaStreamTrack({ kind });
                      this._tracks.set(localId, track);
                      results.push({ localId: String(localId), track });
                    }
                    return results;
                  }
                  async stopReceiving(localIds) {
                    if (this._closed) {
                      return;
                    }
                    for (const localId of localIds) {
                      logger.debug("stopReceiving() [localId:%s]", localId);
                      this._tracks.delete(Number(localId));
                    }
                  }
                  async pauseReceiving(localIds) {
                    this.assertNotClosed();
                  }
                  async resumeReceiving(localIds) {
                    this.assertNotClosed();
                  }
                  // eslint-disable-next-line @typescript-eslint/no-unused-vars
                  async getReceiverStats(localId) {
                    this.assertNotClosed();
                    return /* @__PURE__ */ new Map();
                  }
                  async receiveDataChannel({ sctpStreamParameters, label, protocol }) {
                    this.assertNotClosed();
                    if (!this._transportReady) {
                      await this.setupTransport({ localDtlsRole: "client" });
                    }
                    logger.debug("receiveDataChannel()");
                    const dataChannel = new FakeRTCDataChannel({
                      id: sctpStreamParameters.streamId,
                      ordered: sctpStreamParameters.ordered,
                      maxPacketLifeTime: sctpStreamParameters.maxPacketLifeTime,
                      maxRetransmits: sctpStreamParameters.maxRetransmits,
                      label,
                      protocol
                    });
                    return { dataChannel };
                  }
                  async setupTransport({
                    localDtlsRole,
                    // eslint-disable-next-line @typescript-eslint/no-unused-vars
                    localSdpObject
                  }) {
                    const dtlsParameters = utils.clone(this._fakeParameters.generateLocalDtlsParameters());
                    if (localDtlsRole) {
                      dtlsParameters.role = localDtlsRole;
                    }
                    this.emit("@connectionstatechange", "connecting");
                    await new Promise((resolve, reject) => this.emit("@connect", { dtlsParameters }, resolve, reject));
                    this._transportReady = true;
                  }
                  assertNotClosed() {
                    if (this._closed) {
                      throw new errors_1.InvalidStateError("method called in a closed handler");
                    }
                  }
                }
                exports2.FakeHandler = FakeHandler;
                class FakeRTCDataChannel extends FakeEventTarget_1.FakeEventTarget {
                  constructor({ id, ordered = true, maxPacketLifeTime = null, maxRetransmits = null, label = "", protocol = "" }) {
                    super();
                    // Members for RTCDataChannel standard public getters/setters.
                    __publicField(this, "_id");
                    __publicField(this, "_negotiated", true);
                    // mediasoup just uses negotiated DataChannels.
                    __publicField(this, "_ordered");
                    __publicField(this, "_maxPacketLifeTime");
                    __publicField(this, "_maxRetransmits");
                    __publicField(this, "_label");
                    __publicField(this, "_protocol");
                    __publicField(this, "_readyState", "connecting");
                    __publicField(this, "_bufferedAmount", 0);
                    __publicField(this, "_bufferedAmountLowThreshold", 0);
                    __publicField(this, "_binaryType", "arraybuffer");
                    // Events.
                    __publicField(this, "_onopen", null);
                    __publicField(this, "_onclosing", null);
                    __publicField(this, "_onclose", null);
                    __publicField(this, "_onmessage", null);
                    __publicField(this, "_onbufferedamountlow", null);
                    __publicField(this, "_onerror", null);
                    logger.debug(`constructor() [id:${id}, ordered:${ordered}, maxPacketLifeTime:${maxPacketLifeTime}, maxRetransmits:${maxRetransmits}, label:${label}, protocol:${protocol}`);
                    this._id = id;
                    this._ordered = ordered;
                    this._maxPacketLifeTime = maxPacketLifeTime;
                    this._maxRetransmits = maxRetransmits;
                    this._label = label;
                    this._protocol = protocol;
                  }
                  get id() {
                    return this._id;
                  }
                  get negotiated() {
                    return this._negotiated;
                  }
                  get ordered() {
                    return this._ordered;
                  }
                  get maxPacketLifeTime() {
                    return this._maxPacketLifeTime;
                  }
                  get maxRetransmits() {
                    return this._maxRetransmits;
                  }
                  get label() {
                    return this._label;
                  }
                  get protocol() {
                    return this._protocol;
                  }
                  get readyState() {
                    return this._readyState;
                  }
                  get bufferedAmount() {
                    return this._bufferedAmount;
                  }
                  get bufferedAmountLowThreshold() {
                    return this._bufferedAmountLowThreshold;
                  }
                  set bufferedAmountLowThreshold(value) {
                    this._bufferedAmountLowThreshold = value;
                  }
                  get binaryType() {
                    return this._binaryType;
                  }
                  set binaryType(binaryType) {
                    this._binaryType = binaryType;
                  }
                  get onopen() {
                    return this._onopen;
                  }
                  set onopen(handler) {
                    if (this._onopen) {
                      this.removeEventListener("open", this._onopen);
                    }
                    this._onopen = handler;
                    if (handler) {
                      this.addEventListener("open", handler);
                    }
                  }
                  get onclosing() {
                    return this._onclosing;
                  }
                  set onclosing(handler) {
                    if (this._onclosing) {
                      this.removeEventListener("closing", this._onclosing);
                    }
                    this._onclosing = handler;
                    if (handler) {
                      this.addEventListener("closing", handler);
                    }
                  }
                  get onclose() {
                    return this._onclose;
                  }
                  set onclose(handler) {
                    if (this._onclose) {
                      this.removeEventListener("close", this._onclose);
                    }
                    this._onclose = handler;
                    if (handler) {
                      this.addEventListener("close", handler);
                    }
                  }
                  get onmessage() {
                    return this._onmessage;
                  }
                  set onmessage(handler) {
                    if (this._onmessage) {
                      this.removeEventListener("message", this._onmessage);
                    }
                    this._onmessage = handler;
                    if (handler) {
                      this.addEventListener("message", handler);
                    }
                  }
                  get onbufferedamountlow() {
                    return this._onbufferedamountlow;
                  }
                  set onbufferedamountlow(handler) {
                    if (this._onbufferedamountlow) {
                      this.removeEventListener("bufferedamountlow", this._onbufferedamountlow);
                    }
                    this._onbufferedamountlow = handler;
                    if (handler) {
                      this.addEventListener("bufferedamountlow", handler);
                    }
                  }
                  get onerror() {
                    return this._onerror;
                  }
                  set onerror(handler) {
                    if (this._onerror) {
                      this.removeEventListener("error", this._onerror);
                    }
                    this._onerror = handler;
                    if (handler) {
                      this.addEventListener("error", handler);
                    }
                  }
                  addEventListener(type, listener, options) {
                    super.addEventListener(type, listener, options);
                  }
                  removeEventListener(type, listener, options) {
                    super.removeEventListener(type, listener, options);
                  }
                  close() {
                    if (["closing", "closed"].includes(this._readyState)) {
                      return;
                    }
                    this._readyState = "closed";
                  }
                  /**
                   * We extend the definition of send() to allow Node Buffer. However
                   * ArrayBufferView and Blob do not exist in Node.
                   */
                  // eslint-disable-next-line @typescript-eslint/no-unused-vars
                  send(data) {
                    if (this._readyState !== "open") {
                      throw new errors_1.InvalidStateError("not open");
                    }
                  }
                }
              }
            ),
            /***/
            2901: (
              /***/
              (__unused_webpack___webpack_module__, __webpack_exports__2, __webpack_require__2) => {
                "use strict";
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  A: () => (
                    /* binding */
                    _createClass
                  )
                  /* harmony export */
                });
                var _toPropertyKey_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(816);
                function _defineProperties(e, r) {
                  for (var t = 0; t < r.length; t++) {
                    var o = r[t];
                    o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(e, (0, _toPropertyKey_js__WEBPACK_IMPORTED_MODULE_0__.A)(o.key), o);
                  }
                }
                function _createClass(e, r, t) {
                  return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", {
                    writable: false
                  }), e;
                }
              }
            ),
            /***/
            2994: (
              /***/
              (__unused_webpack_module, exports2, __webpack_require__2) => {
                "use strict";
                Object.defineProperty(exports2, "__esModule", { value: true });
                exports2.Logger = void 0;
                const debug_1 = __webpack_require__2(7833);
                const APP_NAME = "mediasoup-client";
                class Logger {
                  constructor(prefix) {
                    __publicField(this, "_debug");
                    __publicField(this, "_warn");
                    __publicField(this, "_error");
                    if (prefix) {
                      this._debug = (0, debug_1.default)(`${APP_NAME}:${prefix}`);
                      this._warn = (0, debug_1.default)(`${APP_NAME}:WARN:${prefix}`);
                      this._error = (0, debug_1.default)(`${APP_NAME}:ERROR:${prefix}`);
                    } else {
                      this._debug = (0, debug_1.default)(APP_NAME);
                      this._warn = (0, debug_1.default)(`${APP_NAME}:WARN`);
                      this._error = (0, debug_1.default)(`${APP_NAME}:ERROR`);
                    }
                    this._debug.log = console.info.bind(console);
                    this._warn.log = console.warn.bind(console);
                    this._error.log = console.error.bind(console);
                  }
                  get debug() {
                    return this._debug;
                  }
                  get warn() {
                    return this._warn;
                  }
                  get error() {
                    return this._error;
                  }
                }
                exports2.Logger = Logger;
              }
            ),
            /***/
            3009: (
              /***/
              function(module2, exports2, __webpack_require__2) {
                ;
                (function(root, factory) {
                  if (true) {
                    module2.exports = exports2 = factory(__webpack_require__2(9021));
                  } else {
                  }
                })(this, function(CryptoJS) {
                  (function(Math2) {
                    var C = CryptoJS;
                    var C_lib = C.lib;
                    var WordArray = C_lib.WordArray;
                    var Hasher = C_lib.Hasher;
                    var C_algo = C.algo;
                    var H = [];
                    var K = [];
                    (function() {
                      function isPrime(n2) {
                        var sqrtN = Math2.sqrt(n2);
                        for (var factor = 2; factor <= sqrtN; factor++) {
                          if (!(n2 % factor)) {
                            return false;
                          }
                        }
                        return true;
                      }
                      function getFractionalBits(n2) {
                        return (n2 - (n2 | 0)) * 4294967296 | 0;
                      }
                      var n = 2;
                      var nPrime = 0;
                      while (nPrime < 64) {
                        if (isPrime(n)) {
                          if (nPrime < 8) {
                            H[nPrime] = getFractionalBits(Math2.pow(n, 1 / 2));
                          }
                          K[nPrime] = getFractionalBits(Math2.pow(n, 1 / 3));
                          nPrime++;
                        }
                        n++;
                      }
                    })();
                    var W = [];
                    var SHA256 = C_algo.SHA256 = Hasher.extend({
                      _doReset: function() {
                        this._hash = new WordArray.init(H.slice(0));
                      },
                      _doProcessBlock: function(M, offset) {
                        var H2 = this._hash.words;
                        var a = H2[0];
                        var b = H2[1];
                        var c = H2[2];
                        var d = H2[3];
                        var e = H2[4];
                        var f = H2[5];
                        var g = H2[6];
                        var h = H2[7];
                        for (var i = 0; i < 64; i++) {
                          if (i < 16) {
                            W[i] = M[offset + i] | 0;
                          } else {
                            var gamma0x = W[i - 15];
                            var gamma0 = (gamma0x << 25 | gamma0x >>> 7) ^ (gamma0x << 14 | gamma0x >>> 18) ^ gamma0x >>> 3;
                            var gamma1x = W[i - 2];
                            var gamma1 = (gamma1x << 15 | gamma1x >>> 17) ^ (gamma1x << 13 | gamma1x >>> 19) ^ gamma1x >>> 10;
                            W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16];
                          }
                          var ch = e & f ^ ~e & g;
                          var maj = a & b ^ a & c ^ b & c;
                          var sigma0 = (a << 30 | a >>> 2) ^ (a << 19 | a >>> 13) ^ (a << 10 | a >>> 22);
                          var sigma1 = (e << 26 | e >>> 6) ^ (e << 21 | e >>> 11) ^ (e << 7 | e >>> 25);
                          var t1 = h + sigma1 + ch + K[i] + W[i];
                          var t2 = sigma0 + maj;
                          h = g;
                          g = f;
                          f = e;
                          e = d + t1 | 0;
                          d = c;
                          c = b;
                          b = a;
                          a = t1 + t2 | 0;
                        }
                        H2[0] = H2[0] + a | 0;
                        H2[1] = H2[1] + b | 0;
                        H2[2] = H2[2] + c | 0;
                        H2[3] = H2[3] + d | 0;
                        H2[4] = H2[4] + e | 0;
                        H2[5] = H2[5] + f | 0;
                        H2[6] = H2[6] + g | 0;
                        H2[7] = H2[7] + h | 0;
                      },
                      _doFinalize: function() {
                        var data = this._data;
                        var dataWords = data.words;
                        var nBitsTotal = this._nDataBytes * 8;
                        var nBitsLeft = data.sigBytes * 8;
                        dataWords[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;
                        dataWords[(nBitsLeft + 64 >>> 9 << 4) + 14] = Math2.floor(nBitsTotal / 4294967296);
                        dataWords[(nBitsLeft + 64 >>> 9 << 4) + 15] = nBitsTotal;
                        data.sigBytes = dataWords.length * 4;
                        this._process();
                        return this._hash;
                      },
                      clone: function() {
                        var clone = Hasher.clone.call(this);
                        clone._hash = this._hash.clone();
                        return clone;
                      }
                    });
                    C.SHA256 = Hasher._createHelper(SHA256);
                    C.HmacSHA256 = Hasher._createHmacHelper(SHA256);
                  })(Math);
                  return CryptoJS.SHA256;
                });
              }
            ),
            /***/
            3029: (
              /***/
              (__unused_webpack___webpack_module__, __webpack_exports__2, __webpack_require__2) => {
                "use strict";
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  A: () => (
                    /* binding */
                    _classCallCheck
                  )
                  /* harmony export */
                });
                function _classCallCheck(a, n) {
                  if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
                }
              }
            ),
            /***/
            3051: (
              /***/
              (__unused_webpack_module, exports2) => {
                "use strict";
                Object.defineProperty(exports2, "__esModule", { value: true });
                exports2.FakeEventTarget = void 0;
                class FakeEventTarget {
                  constructor() {
                    __publicField(this, "listeners", {});
                  }
                  addEventListener(type, callback, options) {
                    var _a;
                    if (!callback) {
                      return;
                    }
                    (_a = this.listeners)[type] ?? (_a[type] = []);
                    this.listeners[type].push({
                      callback: typeof callback === "function" ? callback : callback.handleEvent,
                      once: typeof options === "object" && options.once === true
                    });
                  }
                  removeEventListener(type, callback, options) {
                    if (!this.listeners[type]) {
                      return;
                    }
                    if (!callback) {
                      return;
                    }
                    this.listeners[type] = this.listeners[type].filter((listener) => listener.callback !== (typeof callback === "function" ? callback : callback.handleEvent));
                  }
                  dispatchEvent(event) {
                    if (!event || typeof event.type !== "string") {
                      throw new Error("invalid event object");
                    }
                    const entries = this.listeners[event.type];
                    if (!entries) {
                      return true;
                    }
                    for (const listener of [...entries]) {
                      try {
                        listener.callback.call(this, event);
                      } catch (error) {
                        setTimeout(() => {
                          throw error;
                        }, 0);
                      }
                      if (listener.once) {
                        this.removeEventListener(event.type, listener.callback);
                      }
                    }
                    return !event.defaultPrevented;
                  }
                }
                exports2.FakeEventTarget = FakeEventTarget;
              }
            ),
            /***/
            3115: (
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                "use strict";
                __webpack_require__2.r(__webpack_exports__2);
                __webpack_require__2.d(__webpack_exports__2, {
                  CameraDeviceInfo: () => (
                    /* reexport */
                    CameraDeviceInfo2
                  ),
                  DeviceInfo: () => (
                    /* reexport */
                    DeviceInfo2
                  ),
                  ExternalE2EEKeyProvider: () => (
                    /* reexport */
                    KeyProvider.l
                  ),
                  MicrophoneDeviceInfo: () => (
                    /* reexport */
                    MicrophoneDeviceInfo2
                  ),
                  VideoSDK: () => (
                    /* binding */
                    VideoSDK2
                  ),
                  ZujoSDK: () => (
                    /* binding */
                    ZujoSDK
                  )
                });
                var esm_typeof = __webpack_require__2(2284);
                var asyncToGenerator = __webpack_require__2(467);
                var classCallCheck = __webpack_require__2(3029);
                var createClass = __webpack_require__2(2901);
                var defineProperty = __webpack_require__2(4467);
                var regenerator = __webpack_require__2(4756);
                var regenerator_default = __webpack_require__2.n(regenerator);
                var es5 = __webpack_require__2(6880);
                var es5_default = __webpack_require__2.n(es5);
                ;
                function ownKeys(e, r) {
                  var t = Object.keys(e);
                  if (Object.getOwnPropertySymbols) {
                    var o = Object.getOwnPropertySymbols(e);
                    r && (o = o.filter(function(r2) {
                      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
                    })), t.push.apply(t, o);
                  }
                  return t;
                }
                function _objectSpread2(e) {
                  for (var r = 1; r < arguments.length; r++) {
                    var t = null != arguments[r] ? arguments[r] : {};
                    r % 2 ? ownKeys(Object(t), true).forEach(function(r2) {
                      (0, defineProperty.A)(e, r2, t[r2]);
                    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r2) {
                      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
                    });
                  }
                  return e;
                }
                ;
                function formatProdErrorMessage(code) {
                  return "Minified Redux error #" + code + "; visit https://redux.js.org/Errors?code=" + code + " for the full message or use the non-minified dev environment for full errors. ";
                }
                var $$observable = function() {
                  return typeof Symbol === "function" && Symbol.observable || "@@observable";
                }();
                var randomString = function randomString2() {
                  return Math.random().toString(36).substring(7).split("").join(".");
                };
                var ActionTypes = {
                  INIT: "@@redux/INIT" + randomString(),
                  REPLACE: "@@redux/REPLACE" + randomString(),
                  PROBE_UNKNOWN_ACTION: function PROBE_UNKNOWN_ACTION() {
                    return "@@redux/PROBE_UNKNOWN_ACTION" + randomString();
                  }
                };
                function isPlainObject(obj) {
                  if (typeof obj !== "object" || obj === null) return false;
                  var proto = obj;
                  while (Object.getPrototypeOf(proto) !== null) {
                    proto = Object.getPrototypeOf(proto);
                  }
                  return Object.getPrototypeOf(obj) === proto;
                }
                function miniKindOf(val) {
                  if (val === void 0) return "undefined";
                  if (val === null) return "null";
                  var type = typeof val;
                  switch (type) {
                    case "boolean":
                    case "string":
                    case "number":
                    case "symbol":
                    case "function": {
                      return type;
                    }
                  }
                  if (Array.isArray(val)) return "array";
                  if (isDate(val)) return "date";
                  if (isError(val)) return "error";
                  var constructorName = ctorName(val);
                  switch (constructorName) {
                    case "Symbol":
                    case "Promise":
                    case "WeakMap":
                    case "WeakSet":
                    case "Map":
                    case "Set":
                      return constructorName;
                  }
                  return type.slice(8, -1).toLowerCase().replace(/\s/g, "");
                }
                function ctorName(val) {
                  return typeof val.constructor === "function" ? val.constructor.name : null;
                }
                function isError(val) {
                  return val instanceof Error || typeof val.message === "string" && val.constructor && typeof val.constructor.stackTraceLimit === "number";
                }
                function isDate(val) {
                  if (val instanceof Date) return true;
                  return typeof val.toDateString === "function" && typeof val.getDate === "function" && typeof val.setDate === "function";
                }
                function kindOf(val) {
                  var typeOfVal = typeof val;
                  if (false) {
                  }
                  return typeOfVal;
                }
                function createStore(reducer, preloadedState, enhancer) {
                  var _ref2;
                  if (typeof preloadedState === "function" && typeof enhancer === "function" || typeof enhancer === "function" && typeof arguments[3] === "function") {
                    throw new Error(true ? formatProdErrorMessage(0) : 0);
                  }
                  if (typeof preloadedState === "function" && typeof enhancer === "undefined") {
                    enhancer = preloadedState;
                    preloadedState = void 0;
                  }
                  if (typeof enhancer !== "undefined") {
                    if (typeof enhancer !== "function") {
                      throw new Error(true ? formatProdErrorMessage(1) : 0);
                    }
                    return enhancer(createStore)(reducer, preloadedState);
                  }
                  if (typeof reducer !== "function") {
                    throw new Error(true ? formatProdErrorMessage(2) : 0);
                  }
                  var currentReducer = reducer;
                  var currentState = preloadedState;
                  var currentListeners = [];
                  var nextListeners = currentListeners;
                  var isDispatching = false;
                  function ensureCanMutateNextListeners() {
                    if (nextListeners === currentListeners) {
                      nextListeners = currentListeners.slice();
                    }
                  }
                  function getState() {
                    if (isDispatching) {
                      throw new Error(true ? formatProdErrorMessage(3) : 0);
                    }
                    return currentState;
                  }
                  function subscribe(listener) {
                    if (typeof listener !== "function") {
                      throw new Error(true ? formatProdErrorMessage(4) : 0);
                    }
                    if (isDispatching) {
                      throw new Error(true ? formatProdErrorMessage(5) : 0);
                    }
                    var isSubscribed = true;
                    ensureCanMutateNextListeners();
                    nextListeners.push(listener);
                    return function unsubscribe() {
                      if (!isSubscribed) {
                        return;
                      }
                      if (isDispatching) {
                        throw new Error(true ? formatProdErrorMessage(6) : 0);
                      }
                      isSubscribed = false;
                      ensureCanMutateNextListeners();
                      var index = nextListeners.indexOf(listener);
                      nextListeners.splice(index, 1);
                      currentListeners = null;
                    };
                  }
                  function dispatch(action) {
                    if (!isPlainObject(action)) {
                      throw new Error(true ? formatProdErrorMessage(7) : 0);
                    }
                    if (typeof action.type === "undefined") {
                      throw new Error(true ? formatProdErrorMessage(8) : 0);
                    }
                    if (isDispatching) {
                      throw new Error(true ? formatProdErrorMessage(9) : 0);
                    }
                    try {
                      isDispatching = true;
                      currentState = currentReducer(currentState, action);
                    } finally {
                      isDispatching = false;
                    }
                    var listeners = currentListeners = nextListeners;
                    for (var i = 0; i < listeners.length; i++) {
                      var listener = listeners[i];
                      listener();
                    }
                    return action;
                  }
                  function replaceReducer(nextReducer) {
                    if (typeof nextReducer !== "function") {
                      throw new Error(true ? formatProdErrorMessage(10) : 0);
                    }
                    currentReducer = nextReducer;
                    dispatch({
                      type: ActionTypes.REPLACE
                    });
                  }
                  function observable() {
                    var _ref;
                    var outerSubscribe = subscribe;
                    return _ref = {
                      /**
                       * The minimal observable subscription method.
                       * @param {Object} observer Any object that can be used as an observer.
                       * The observer object should have a `next` method.
                       * @returns {subscription} An object with an `unsubscribe` method that can
                       * be used to unsubscribe the observable from the store, and prevent further
                       * emission of values from the observable.
                       */
                      subscribe: function subscribe2(observer) {
                        if (typeof observer !== "object" || observer === null) {
                          throw new Error(true ? formatProdErrorMessage(11) : 0);
                        }
                        function observeState() {
                          if (observer.next) {
                            observer.next(getState());
                          }
                        }
                        observeState();
                        var unsubscribe = outerSubscribe(observeState);
                        return {
                          unsubscribe
                        };
                      }
                    }, _ref[$$observable] = function() {
                      return this;
                    }, _ref;
                  }
                  dispatch({
                    type: ActionTypes.INIT
                  });
                  return _ref2 = {
                    dispatch,
                    subscribe,
                    getState,
                    replaceReducer
                  }, _ref2[$$observable] = observable, _ref2;
                }
                var legacy_createStore = (
                  /* unused pure expression or super */
                  null
                );
                function warning(message) {
                  if (typeof console !== "undefined" && typeof console.error === "function") {
                    console.error(message);
                  }
                  try {
                    throw new Error(message);
                  } catch (e) {
                  }
                }
                function getUnexpectedStateShapeWarningMessage(inputState, reducers2, action, unexpectedKeyCache) {
                  var reducerKeys = Object.keys(reducers2);
                  var argumentName = action && action.type === ActionTypes.INIT ? "preloadedState argument passed to createStore" : "previous state received by the reducer";
                  if (reducerKeys.length === 0) {
                    return "Store does not have a valid reducer. Make sure the argument passed to combineReducers is an object whose values are reducers.";
                  }
                  if (!isPlainObject(inputState)) {
                    return "The " + argumentName + ' has unexpected type of "' + kindOf(inputState) + '". Expected argument to be an object with the following ' + ('keys: "' + reducerKeys.join('", "') + '"');
                  }
                  var unexpectedKeys = Object.keys(inputState).filter(function(key) {
                    return !reducers2.hasOwnProperty(key) && !unexpectedKeyCache[key];
                  });
                  unexpectedKeys.forEach(function(key) {
                    unexpectedKeyCache[key] = true;
                  });
                  if (action && action.type === ActionTypes.REPLACE) return;
                  if (unexpectedKeys.length > 0) {
                    return "Unexpected " + (unexpectedKeys.length > 1 ? "keys" : "key") + " " + ('"' + unexpectedKeys.join('", "') + '" found in ' + argumentName + ". ") + "Expected to find one of the known reducer keys instead: " + ('"' + reducerKeys.join('", "') + '". Unexpected keys will be ignored.');
                  }
                }
                function assertReducerShape(reducers2) {
                  Object.keys(reducers2).forEach(function(key) {
                    var reducer = reducers2[key];
                    var initialState2 = reducer(void 0, {
                      type: ActionTypes.INIT
                    });
                    if (typeof initialState2 === "undefined") {
                      throw new Error(true ? formatProdErrorMessage(12) : 0);
                    }
                    if (typeof reducer(void 0, {
                      type: ActionTypes.PROBE_UNKNOWN_ACTION()
                    }) === "undefined") {
                      throw new Error(true ? formatProdErrorMessage(13) : 0);
                    }
                  });
                }
                function combineReducers(reducers2) {
                  var reducerKeys = Object.keys(reducers2);
                  var finalReducers = {};
                  for (var i = 0; i < reducerKeys.length; i++) {
                    var key = reducerKeys[i];
                    if (false) {
                    }
                    if (typeof reducers2[key] === "function") {
                      finalReducers[key] = reducers2[key];
                    }
                  }
                  var finalReducerKeys = Object.keys(finalReducers);
                  var unexpectedKeyCache;
                  if (false) {
                  }
                  var shapeAssertionError;
                  try {
                    assertReducerShape(finalReducers);
                  } catch (e) {
                    shapeAssertionError = e;
                  }
                  return function combination(state, action) {
                    if (state === void 0) {
                      state = {};
                    }
                    if (shapeAssertionError) {
                      throw shapeAssertionError;
                    }
                    if (false) {
                      var warningMessage;
                    }
                    var hasChanged = false;
                    var nextState = {};
                    for (var _i = 0; _i < finalReducerKeys.length; _i++) {
                      var _key = finalReducerKeys[_i];
                      var reducer = finalReducers[_key];
                      var previousStateForKey = state[_key];
                      var nextStateForKey = reducer(previousStateForKey, action);
                      if (typeof nextStateForKey === "undefined") {
                        var actionType = action && action.type;
                        throw new Error(true ? formatProdErrorMessage(14) : 0);
                      }
                      nextState[_key] = nextStateForKey;
                      hasChanged = hasChanged || nextStateForKey !== previousStateForKey;
                    }
                    hasChanged = hasChanged || finalReducerKeys.length !== Object.keys(state).length;
                    return hasChanged ? nextState : state;
                  };
                }
                function bindActionCreator(actionCreator, dispatch) {
                  return function() {
                    return dispatch(actionCreator.apply(this, arguments));
                  };
                }
                function bindActionCreators(actionCreators, dispatch) {
                  if (typeof actionCreators === "function") {
                    return bindActionCreator(actionCreators, dispatch);
                  }
                  if (typeof actionCreators !== "object" || actionCreators === null) {
                    throw new Error(true ? formatProdErrorMessage(16) : 0);
                  }
                  var boundActionCreators = {};
                  for (var key in actionCreators) {
                    var actionCreator = actionCreators[key];
                    if (typeof actionCreator === "function") {
                      boundActionCreators[key] = bindActionCreator(actionCreator, dispatch);
                    }
                  }
                  return boundActionCreators;
                }
                function compose() {
                  for (var _len = arguments.length, funcs = new Array(_len), _key = 0; _key < _len; _key++) {
                    funcs[_key] = arguments[_key];
                  }
                  if (funcs.length === 0) {
                    return function(arg) {
                      return arg;
                    };
                  }
                  if (funcs.length === 1) {
                    return funcs[0];
                  }
                  return funcs.reduce(function(a, b) {
                    return function() {
                      return a(b.apply(void 0, arguments));
                    };
                  });
                }
                function applyMiddleware() {
                  for (var _len = arguments.length, middlewares = new Array(_len), _key = 0; _key < _len; _key++) {
                    middlewares[_key] = arguments[_key];
                  }
                  return function(createStore2) {
                    return function() {
                      var store = createStore2.apply(void 0, arguments);
                      var _dispatch = function dispatch() {
                        throw new Error(true ? formatProdErrorMessage(15) : 0);
                      };
                      var middlewareAPI = {
                        getState: store.getState,
                        dispatch: function dispatch() {
                          return _dispatch.apply(void 0, arguments);
                        }
                      };
                      var chain = middlewares.map(function(middleware) {
                        return middleware(middlewareAPI);
                      });
                      _dispatch = compose.apply(void 0, chain)(store.dispatch);
                      return _objectSpread2(_objectSpread2({}, store), {}, {
                        dispatch: _dispatch
                      });
                    };
                  };
                }
                ;
                function createThunkMiddleware(extraArgument) {
                  var middleware = function middleware2(_ref) {
                    var dispatch = _ref.dispatch, getState = _ref.getState;
                    return function(next) {
                      return function(action) {
                        if (typeof action === "function") {
                          return action(dispatch, getState, extraArgument);
                        }
                        return next(action);
                      };
                    };
                  };
                  return middleware;
                }
                var thunk = createThunkMiddleware();
                thunk.withExtraArgument = createThunkMiddleware;
                const es = thunk;
                var random_string = __webpack_require__2(2211);
                var random_string_default = __webpack_require__2.n(random_string);
                ;
                function room_ownKeys(e, r) {
                  var t = Object.keys(e);
                  if (Object.getOwnPropertySymbols) {
                    var o = Object.getOwnPropertySymbols(e);
                    r && (o = o.filter(function(r2) {
                      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
                    })), t.push.apply(t, o);
                  }
                  return t;
                }
                function _objectSpread(e) {
                  for (var r = 1; r < arguments.length; r++) {
                    var t = null != arguments[r] ? arguments[r] : {};
                    r % 2 ? room_ownKeys(Object(t), true).forEach(function(r2) {
                      (0, defineProperty.A)(e, r2, t[r2]);
                    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : room_ownKeys(Object(t)).forEach(function(r2) {
                      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
                    });
                  }
                  return e;
                }
                var initialState = {
                  url: null,
                  state: "new",
                  // new/connecting/connected/disconnected/closed,
                  activeSpeakerId: null,
                  statsPeerId: null,
                  faceDetection: false
                };
                var room = function room2() {
                  var state = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : initialState;
                  var action = arguments.length > 1 ? arguments[1] : void 0;
                  switch (action.type) {
                    case "SET_ROOM_URL": {
                      var url = action.payload.url;
                      return _objectSpread(_objectSpread({}, state), {}, {
                        url
                      });
                    }
                    case "SET_ROOM_STATE": {
                      var roomState = action.payload.state;
                      if (roomState === "connected") return _objectSpread(_objectSpread({}, state), {}, {
                        state: roomState
                      });
                      else return _objectSpread(_objectSpread({}, state), {}, {
                        state: roomState,
                        activeSpeakerId: null,
                        statsPeerId: null
                      });
                    }
                    case "SET_ROOM_ACTIVE_SPEAKER": {
                      var peerId = action.payload.peerId;
                      return _objectSpread(_objectSpread({}, state), {}, {
                        activeSpeakerId: peerId
                      });
                    }
                    case "SET_ROOM_STATS_PEER_ID": {
                      var _peerId = action.payload.peerId;
                      if (state.statsPeerId === _peerId) return _objectSpread(_objectSpread({}, state), {}, {
                        statsPeerId: null
                      });
                      return _objectSpread(_objectSpread({}, state), {}, {
                        statsPeerId: _peerId
                      });
                    }
                    case "SET_FACE_DETECTION": {
                      var flag = action.payload;
                      return _objectSpread(_objectSpread({}, state), {}, {
                        faceDetection: flag
                      });
                    }
                    case "REMOVE_PEER": {
                      var _peerId2 = action.payload.peerId;
                      var newState = _objectSpread({}, state);
                      if (_peerId2 && _peerId2 === state.activeSpeakerId) newState.activeSpeakerId = null;
                      if (_peerId2 && _peerId2 === state.statsPeerId) newState.statsPeerId = null;
                      return newState;
                    }
                    default:
                      return state;
                  }
                };
                const reducers_room = room;
                ;
                function me_ownKeys(e, r) {
                  var t = Object.keys(e);
                  if (Object.getOwnPropertySymbols) {
                    var o = Object.getOwnPropertySymbols(e);
                    r && (o = o.filter(function(r2) {
                      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
                    })), t.push.apply(t, o);
                  }
                  return t;
                }
                function me_objectSpread(e) {
                  for (var r = 1; r < arguments.length; r++) {
                    var t = null != arguments[r] ? arguments[r] : {};
                    r % 2 ? me_ownKeys(Object(t), true).forEach(function(r2) {
                      (0, defineProperty.A)(e, r2, t[r2]);
                    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : me_ownKeys(Object(t)).forEach(function(r2) {
                      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
                    });
                  }
                  return e;
                }
                var me_initialState = {
                  id: null,
                  displayName: null,
                  displayNameSet: false,
                  device: null,
                  canSendMic: false,
                  canSendWebcam: false,
                  canChangeWebcam: false,
                  webcamInProgress: false,
                  shareInProgress: false,
                  audioOnly: false,
                  audioOnlyInProgress: false,
                  audioMuted: false,
                  restartIceInProgress: false
                };
                var me = function me2() {
                  var state = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : me_initialState;
                  var action = arguments.length > 1 ? arguments[1] : void 0;
                  switch (action.type) {
                    case "SET_ROOM_STATE": {
                      var roomState = action.payload.state;
                      if (roomState === "closed") {
                        return me_objectSpread(me_objectSpread({}, state), {}, {
                          webcamInProgress: false,
                          shareInProgress: false,
                          audioOnly: false,
                          audioOnlyInProgress: false,
                          audioMuted: false,
                          restartIceInProgress: false
                        });
                      } else {
                        return state;
                      }
                    }
                    case "SET_ME": {
                      var _action$payload = action.payload, peerId = _action$payload.peerId, displayName = _action$payload.displayName, displayNameSet = _action$payload.displayNameSet, device = _action$payload.device;
                      return me_objectSpread(me_objectSpread({}, state), {}, {
                        id: peerId,
                        displayName,
                        displayNameSet,
                        device
                      });
                    }
                    case "SET_MEDIA_CAPABILITIES": {
                      var _action$payload2 = action.payload, canSendMic = _action$payload2.canSendMic, canSendWebcam = _action$payload2.canSendWebcam;
                      return me_objectSpread(me_objectSpread({}, state), {}, {
                        canSendMic,
                        canSendWebcam
                      });
                    }
                    case "SET_CAN_CHANGE_WEBCAM": {
                      var canChangeWebcam = action.payload;
                      return me_objectSpread(me_objectSpread({}, state), {}, {
                        canChangeWebcam
                      });
                    }
                    case "SET_WEBCAM_IN_PROGRESS": {
                      var flag = action.payload.flag;
                      return me_objectSpread(me_objectSpread({}, state), {}, {
                        webcamInProgress: flag
                      });
                    }
                    case "SET_SHARE_IN_PROGRESS": {
                      var _flag = action.payload.flag;
                      return me_objectSpread(me_objectSpread({}, state), {}, {
                        shareInProgress: _flag
                      });
                    }
                    case "SET_DISPLAY_NAME": {
                      var _displayName = action.payload.displayName;
                      if (!_displayName) _displayName = state.displayName;
                      return me_objectSpread(me_objectSpread({}, state), {}, {
                        displayName: _displayName,
                        displayNameSet: true
                      });
                    }
                    case "SET_AUDIO_ONLY_STATE": {
                      var enabled = action.payload.enabled;
                      return me_objectSpread(me_objectSpread({}, state), {}, {
                        audioOnly: enabled
                      });
                    }
                    case "SET_AUDIO_ONLY_IN_PROGRESS": {
                      var _flag2 = action.payload.flag;
                      return me_objectSpread(me_objectSpread({}, state), {}, {
                        audioOnlyInProgress: _flag2
                      });
                    }
                    case "SET_AUDIO_MUTED_STATE": {
                      var _enabled = action.payload.enabled;
                      return me_objectSpread(me_objectSpread({}, state), {}, {
                        audioMuted: _enabled
                      });
                    }
                    case "SET_RESTART_ICE_IN_PROGRESS": {
                      var _flag3 = action.payload.flag;
                      return me_objectSpread(me_objectSpread({}, state), {}, {
                        restartIceInProgress: _flag3
                      });
                    }
                    default:
                      return state;
                  }
                };
                const reducers_me = me;
                ;
                function producers_ownKeys(e, r) {
                  var t = Object.keys(e);
                  if (Object.getOwnPropertySymbols) {
                    var o = Object.getOwnPropertySymbols(e);
                    r && (o = o.filter(function(r2) {
                      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
                    })), t.push.apply(t, o);
                  }
                  return t;
                }
                function producers_objectSpread(e) {
                  for (var r = 1; r < arguments.length; r++) {
                    var t = null != arguments[r] ? arguments[r] : {};
                    r % 2 ? producers_ownKeys(Object(t), true).forEach(function(r2) {
                      (0, defineProperty.A)(e, r2, t[r2]);
                    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : producers_ownKeys(Object(t)).forEach(function(r2) {
                      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
                    });
                  }
                  return e;
                }
                var producers_initialState = {};
                var producers = function producers2() {
                  var state = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : producers_initialState;
                  var action = arguments.length > 1 ? arguments[1] : void 0;
                  switch (action.type) {
                    case "SET_ROOM_STATE": {
                      var roomState = action.payload.state;
                      if (roomState === "closed") return {};
                      else return state;
                    }
                    case "ADD_PRODUCER": {
                      var producer = action.payload.producer;
                      return producers_objectSpread(producers_objectSpread({}, state), {}, (0, defineProperty.A)({}, producer.id, producer));
                    }
                    case "REMOVE_PRODUCER": {
                      var producerId = action.payload.producerId;
                      var newState = producers_objectSpread({}, state);
                      delete newState[producerId];
                      return newState;
                    }
                    case "SET_PRODUCER_PAUSED": {
                      var _producerId = action.payload.producerId;
                      var _producer = state[_producerId];
                      var newProducer = producers_objectSpread(producers_objectSpread({}, _producer), {}, {
                        paused: true
                      });
                      return producers_objectSpread(producers_objectSpread({}, state), {}, (0, defineProperty.A)({}, _producerId, newProducer));
                    }
                    case "SET_PRODUCER_RESUMED": {
                      var _producerId2 = action.payload.producerId;
                      var _producer2 = state[_producerId2];
                      var _newProducer = producers_objectSpread(producers_objectSpread({}, _producer2), {}, {
                        paused: false
                      });
                      return producers_objectSpread(producers_objectSpread({}, state), {}, (0, defineProperty.A)({}, _producerId2, _newProducer));
                    }
                    case "SET_PRODUCER_TRACK": {
                      var _action$payload = action.payload, _producerId3 = _action$payload.producerId, track = _action$payload.track;
                      var _producer3 = state[_producerId3];
                      var _newProducer2 = producers_objectSpread(producers_objectSpread({}, _producer3), {}, {
                        track
                      });
                      return producers_objectSpread(producers_objectSpread({}, state), {}, (0, defineProperty.A)({}, _producerId3, _newProducer2));
                    }
                    case "SET_PRODUCER_SCORE": {
                      var _action$payload2 = action.payload, _producerId4 = _action$payload2.producerId, score = _action$payload2.score;
                      var _producer4 = state[_producerId4];
                      if (!_producer4) return state;
                      var _newProducer3 = producers_objectSpread(producers_objectSpread({}, _producer4), {}, {
                        score
                      });
                      return producers_objectSpread(producers_objectSpread({}, state), {}, (0, defineProperty.A)({}, _producerId4, _newProducer3));
                    }
                    default: {
                      return state;
                    }
                  }
                };
                const reducers_producers = producers;
                ;
                function dataProducers_ownKeys(e, r) {
                  var t = Object.keys(e);
                  if (Object.getOwnPropertySymbols) {
                    var o = Object.getOwnPropertySymbols(e);
                    r && (o = o.filter(function(r2) {
                      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
                    })), t.push.apply(t, o);
                  }
                  return t;
                }
                function dataProducers_objectSpread(e) {
                  for (var r = 1; r < arguments.length; r++) {
                    var t = null != arguments[r] ? arguments[r] : {};
                    r % 2 ? dataProducers_ownKeys(Object(t), true).forEach(function(r2) {
                      (0, defineProperty.A)(e, r2, t[r2]);
                    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : dataProducers_ownKeys(Object(t)).forEach(function(r2) {
                      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
                    });
                  }
                  return e;
                }
                var dataProducers_initialState = {};
                var dataProducers = function dataProducers2() {
                  var state = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : dataProducers_initialState;
                  var action = arguments.length > 1 ? arguments[1] : void 0;
                  switch (action.type) {
                    case "SET_ROOM_STATE": {
                      var roomState = action.payload.state;
                      if (roomState === "closed") return {};
                      else return state;
                    }
                    case "ADD_DATA_PRODUCER": {
                      var dataProducer = action.payload.dataProducer;
                      return dataProducers_objectSpread(dataProducers_objectSpread({}, state), {}, (0, defineProperty.A)({}, dataProducer.id, dataProducer));
                    }
                    case "REMOVE_DATA_PRODUCER": {
                      var dataProducerId = action.payload.dataProducerId;
                      var newState = dataProducers_objectSpread({}, state);
                      delete newState[dataProducerId];
                      return newState;
                    }
                    default: {
                      return state;
                    }
                  }
                };
                const reducers_dataProducers = dataProducers;
                var toConsumableArray = __webpack_require__2(5458);
                ;
                function peers_ownKeys(e, r) {
                  var t = Object.keys(e);
                  if (Object.getOwnPropertySymbols) {
                    var o = Object.getOwnPropertySymbols(e);
                    r && (o = o.filter(function(r2) {
                      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
                    })), t.push.apply(t, o);
                  }
                  return t;
                }
                function peers_objectSpread(e) {
                  for (var r = 1; r < arguments.length; r++) {
                    var t = null != arguments[r] ? arguments[r] : {};
                    r % 2 ? peers_ownKeys(Object(t), true).forEach(function(r2) {
                      (0, defineProperty.A)(e, r2, t[r2]);
                    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : peers_ownKeys(Object(t)).forEach(function(r2) {
                      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
                    });
                  }
                  return e;
                }
                var peers_initialState = {};
                var peers = function peers2() {
                  var state = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : peers_initialState;
                  var action = arguments.length > 1 ? arguments[1] : void 0;
                  switch (action.type) {
                    case "SET_ROOM_STATE": {
                      var roomState = action.payload.state;
                      if (roomState === "closed") return {};
                      else return state;
                    }
                    case "ADD_PEER": {
                      var peer = action.payload.peer;
                      return peers_objectSpread(peers_objectSpread({}, state), {}, (0, defineProperty.A)({}, peer.id, peer));
                    }
                    case "REMOVE_PEER": {
                      var peerId = action.payload.peerId;
                      var newState = peers_objectSpread({}, state);
                      delete newState[peerId];
                      return newState;
                    }
                    case "SET_PEER_DISPLAY_NAME": {
                      var _action$payload = action.payload, displayName = _action$payload.displayName, _peerId = _action$payload.peerId;
                      var _peer = state[_peerId];
                      if (!_peer) throw new Error("no Peer found");
                      var newPeer = peers_objectSpread(peers_objectSpread({}, _peer), {}, {
                        displayName
                      });
                      return peers_objectSpread(peers_objectSpread({}, state), {}, (0, defineProperty.A)({}, newPeer.id, newPeer));
                    }
                    case "ADD_CONSUMER": {
                      var _action$payload2 = action.payload, consumer = _action$payload2.consumer, _peerId2 = _action$payload2.peerId;
                      var _peer2 = state[_peerId2];
                      if (!_peer2) return peers_objectSpread({}, state);
                      var newConsumers = [].concat((0, toConsumableArray.A)(_peer2.consumers), [consumer.id]);
                      var _newPeer = peers_objectSpread(peers_objectSpread({}, _peer2), {}, {
                        consumers: newConsumers
                      });
                      return peers_objectSpread(peers_objectSpread({}, state), {}, (0, defineProperty.A)({}, _newPeer.id, _newPeer));
                    }
                    case "REMOVE_CONSUMER": {
                      var _action$payload3 = action.payload, consumerId = _action$payload3.consumerId, _peerId3 = _action$payload3.peerId;
                      var _peer3 = state[_peerId3];
                      if (!_peer3) return state;
                      var idx = _peer3.consumers.indexOf(consumerId);
                      if (idx === -1) return peers_objectSpread({}, state);
                      var _newConsumers = _peer3.consumers.slice();
                      _newConsumers.splice(idx, 1);
                      var _newPeer2 = peers_objectSpread(peers_objectSpread({}, _peer3), {}, {
                        consumers: _newConsumers
                      });
                      return peers_objectSpread(peers_objectSpread({}, state), {}, (0, defineProperty.A)({}, _newPeer2.id, _newPeer2));
                    }
                    case "ADD_DATA_CONSUMER": {
                      var _action$payload4 = action.payload, dataConsumer = _action$payload4.dataConsumer, _peerId4 = _action$payload4.peerId;
                      if (!_peerId4) return state;
                      var _peer4 = state[_peerId4];
                      if (!_peer4) return peers_objectSpread({}, state);
                      var newDataConsumers = [].concat((0, toConsumableArray.A)(_peer4.dataConsumers), [dataConsumer.id]);
                      var _newPeer3 = peers_objectSpread(peers_objectSpread({}, _peer4), {}, {
                        dataConsumers: newDataConsumers
                      });
                      return peers_objectSpread(peers_objectSpread({}, state), {}, (0, defineProperty.A)({}, _newPeer3.id, _newPeer3));
                    }
                    case "REMOVE_DATA_CONSUMER": {
                      var _action$payload5 = action.payload, dataConsumerId = _action$payload5.dataConsumerId, _peerId5 = _action$payload5.peerId;
                      if (!_peerId5) return state;
                      var _peer5 = state[_peerId5];
                      if (!_peer5) return state;
                      var _idx = _peer5.dataConsumers.indexOf(dataConsumerId);
                      if (_idx === -1) {
                        return peers_objectSpread({}, state);
                      }
                      var _newDataConsumers = _peer5.dataConsumers.slice();
                      _newDataConsumers.splice(_idx, 1);
                      var _newPeer4 = peers_objectSpread(peers_objectSpread({}, _peer5), {}, {
                        dataConsumers: _newDataConsumers
                      });
                      return peers_objectSpread(peers_objectSpread({}, state), {}, (0, defineProperty.A)({}, _newPeer4.id, _newPeer4));
                    }
                    default: {
                      return state;
                    }
                  }
                };
                const reducers_peers = peers;
                ;
                function consumers_ownKeys(e, r) {
                  var t = Object.keys(e);
                  if (Object.getOwnPropertySymbols) {
                    var o = Object.getOwnPropertySymbols(e);
                    r && (o = o.filter(function(r2) {
                      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
                    })), t.push.apply(t, o);
                  }
                  return t;
                }
                function consumers_objectSpread(e) {
                  for (var r = 1; r < arguments.length; r++) {
                    var t = null != arguments[r] ? arguments[r] : {};
                    r % 2 ? consumers_ownKeys(Object(t), true).forEach(function(r2) {
                      (0, defineProperty.A)(e, r2, t[r2]);
                    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : consumers_ownKeys(Object(t)).forEach(function(r2) {
                      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
                    });
                  }
                  return e;
                }
                var consumers_initialState = {};
                var consumers = function consumers2() {
                  var state = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : consumers_initialState;
                  var action = arguments.length > 1 ? arguments[1] : void 0;
                  switch (action.type) {
                    case "SET_ROOM_STATE": {
                      var roomState = action.payload.state;
                      if (roomState === "closed") return {};
                      else return state;
                    }
                    case "ADD_CONSUMER": {
                      var consumer = action.payload.consumer;
                      return consumers_objectSpread(consumers_objectSpread({}, state), {}, (0, defineProperty.A)({}, consumer.id, consumer));
                    }
                    case "REMOVE_CONSUMER": {
                      var consumerId = action.payload.consumerId;
                      var newState = consumers_objectSpread({}, state);
                      delete newState[consumerId];
                      return newState;
                    }
                    case "SET_CONSUMER_PAUSED": {
                      var _action$payload = action.payload, _consumerId = _action$payload.consumerId, originator = _action$payload.originator;
                      var _consumer = state[_consumerId];
                      var newConsumer;
                      if (originator === "local") newConsumer = consumers_objectSpread(consumers_objectSpread({}, _consumer), {}, {
                        locallyPaused: true,
                        paused: true
                      });
                      else newConsumer = consumers_objectSpread(consumers_objectSpread({}, _consumer), {}, {
                        remotelyPaused: true,
                        paused: true
                      });
                      return consumers_objectSpread(consumers_objectSpread({}, state), {}, (0, defineProperty.A)({}, _consumerId, newConsumer));
                    }
                    case "SET_CONSUMER_RESUMED": {
                      var _action$payload2 = action.payload, _consumerId2 = _action$payload2.consumerId, _originator = _action$payload2.originator;
                      var _consumer2 = state[_consumerId2];
                      var _newConsumer;
                      if (_originator === "local") _newConsumer = consumers_objectSpread(consumers_objectSpread({}, _consumer2), {}, {
                        locallyPaused: false,
                        paused: false
                      });
                      else _newConsumer = consumers_objectSpread(consumers_objectSpread({}, _consumer2), {}, {
                        remotelyPaused: false,
                        paused: false
                      });
                      return consumers_objectSpread(consumers_objectSpread({}, state), {}, (0, defineProperty.A)({}, _consumerId2, _newConsumer));
                    }
                    case "SET_CONSUMER_CURRENT_LAYERS": {
                      var _action$payload3 = action.payload, _consumerId3 = _action$payload3.consumerId, spatialLayer = _action$payload3.spatialLayer, temporalLayer = _action$payload3.temporalLayer;
                      var _consumer3 = state[_consumerId3];
                      var _newConsumer2 = consumers_objectSpread(consumers_objectSpread({}, _consumer3), {}, {
                        currentSpatialLayer: spatialLayer,
                        currentTemporalLayer: temporalLayer
                      });
                      return consumers_objectSpread(consumers_objectSpread({}, state), {}, (0, defineProperty.A)({}, _consumerId3, _newConsumer2));
                    }
                    case "SET_CONSUMER_PREFERRED_LAYERS": {
                      var _action$payload4 = action.payload, _consumerId4 = _action$payload4.consumerId, _spatialLayer = _action$payload4.spatialLayer, _temporalLayer = _action$payload4.temporalLayer;
                      var _consumer4 = state[_consumerId4];
                      var _newConsumer3 = consumers_objectSpread(consumers_objectSpread({}, _consumer4), {}, {
                        preferredSpatialLayer: _spatialLayer,
                        preferredTemporalLayer: _temporalLayer
                      });
                      return consumers_objectSpread(consumers_objectSpread({}, state), {}, (0, defineProperty.A)({}, _consumerId4, _newConsumer3));
                    }
                    case "SET_CONSUMER_PRIORITY": {
                      var _action$payload5 = action.payload, _consumerId5 = _action$payload5.consumerId, priority = _action$payload5.priority;
                      var _consumer5 = state[_consumerId5];
                      var _newConsumer4 = consumers_objectSpread(consumers_objectSpread({}, _consumer5), {}, {
                        priority
                      });
                      return consumers_objectSpread(consumers_objectSpread({}, state), {}, (0, defineProperty.A)({}, _consumerId5, _newConsumer4));
                    }
                    case "SET_CONSUMER_TRACK": {
                      var _action$payload6 = action.payload, _consumerId6 = _action$payload6.consumerId, track = _action$payload6.track;
                      var _consumer6 = state[_consumerId6];
                      var _newConsumer5 = consumers_objectSpread(consumers_objectSpread({}, _consumer6), {}, {
                        track
                      });
                      return consumers_objectSpread(consumers_objectSpread({}, state), {}, (0, defineProperty.A)({}, _consumerId6, _newConsumer5));
                    }
                    case "SET_CONSUMER_SCORE": {
                      var _action$payload7 = action.payload, _consumerId7 = _action$payload7.consumerId, score = _action$payload7.score;
                      var _consumer7 = state[_consumerId7];
                      if (!_consumer7) return state;
                      var _newConsumer6 = consumers_objectSpread(consumers_objectSpread({}, _consumer7), {}, {
                        score
                      });
                      return consumers_objectSpread(consumers_objectSpread({}, state), {}, (0, defineProperty.A)({}, _consumerId7, _newConsumer6));
                    }
                    default: {
                      return state;
                    }
                  }
                };
                const reducers_consumers = consumers;
                ;
                function dataConsumers_ownKeys(e, r) {
                  var t = Object.keys(e);
                  if (Object.getOwnPropertySymbols) {
                    var o = Object.getOwnPropertySymbols(e);
                    r && (o = o.filter(function(r2) {
                      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
                    })), t.push.apply(t, o);
                  }
                  return t;
                }
                function dataConsumers_objectSpread(e) {
                  for (var r = 1; r < arguments.length; r++) {
                    var t = null != arguments[r] ? arguments[r] : {};
                    r % 2 ? dataConsumers_ownKeys(Object(t), true).forEach(function(r2) {
                      (0, defineProperty.A)(e, r2, t[r2]);
                    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : dataConsumers_ownKeys(Object(t)).forEach(function(r2) {
                      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
                    });
                  }
                  return e;
                }
                var dataConsumers_initialState = {};
                var dataConsumers = function dataConsumers2() {
                  var state = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : dataConsumers_initialState;
                  var action = arguments.length > 1 ? arguments[1] : void 0;
                  switch (action.type) {
                    case "SET_ROOM_STATE": {
                      var roomState = action.payload.state;
                      if (roomState === "closed") return {};
                      else return state;
                    }
                    case "ADD_DATA_CONSUMER": {
                      var dataConsumer = action.payload.dataConsumer;
                      return dataConsumers_objectSpread(dataConsumers_objectSpread({}, state), {}, (0, defineProperty.A)({}, dataConsumer.id, dataConsumer));
                    }
                    case "REMOVE_DATA_CONSUMER": {
                      var dataConsumerId = action.payload.dataConsumerId;
                      var newState = dataConsumers_objectSpread({}, state);
                      delete newState[dataConsumerId];
                      return newState;
                    }
                    default: {
                      return state;
                    }
                  }
                };
                const reducers_dataConsumers = dataConsumers;
                ;
                var notifications_initialState = [];
                var notifications = function notifications2() {
                  var state = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : notifications_initialState;
                  var action = arguments.length > 1 ? arguments[1] : void 0;
                  switch (action.type) {
                    case "ADD_NOTIFICATION": {
                      var notification = action.payload.notification;
                      return [].concat((0, toConsumableArray.A)(state), [notification]);
                    }
                    case "REMOVE_NOTIFICATION": {
                      var notificationId = action.payload.notificationId;
                      return state.filter(function(notification2) {
                        return notification2.id !== notificationId;
                      });
                    }
                    case "REMOVE_ALL_NOTIFICATIONS": {
                      return [];
                    }
                    default:
                      return state;
                  }
                };
                const reducers_notifications = notifications;
                ;
                var reducers = combineReducers({
                  room: reducers_room,
                  me: reducers_me,
                  producers: reducers_producers,
                  dataProducers: reducers_dataProducers,
                  peers: reducers_peers,
                  consumers: reducers_consumers,
                  dataConsumers: reducers_dataConsumers,
                  notifications: reducers_notifications
                });
                const redux_reducers = reducers;
                var RoomClient = __webpack_require__2(1919);
                ;
                function _objectDestructuringEmpty(t) {
                  if (null == t) throw new TypeError("Cannot destructure " + t);
                }
                var events2 = __webpack_require__2(7007);
                var slicedToArray = __webpack_require__2(296);
                ;
                var _require = __webpack_require__2(1919), store_RoomClient = _require["default"];
                var StoreState = (0, createClass.A)(function StoreState2() {
                  (0, classCallCheck.A)(this, StoreState2);
                  this.roomClient = null;
                });
                var Singleton = function() {
                  function Singleton2() {
                    (0, classCallCheck.A)(this, Singleton2);
                    if (!Singleton2.instance) Singleton2.instance = new StoreState();
                  }
                  return (0, createClass.A)(Singleton2, [{
                    key: "getInstance",
                    value: function getInstance() {
                      return Singleton2.instance;
                    }
                  }]);
                }();
                var singleton = new Singleton();
                Object.freeze(singleton);
                var Store = singleton.getInstance();
                ;
                var EV_STATE = "state";
                var Stream = function() {
                  function Stream2(producerOrConsumer) {
                    (0, classCallCheck.A)(this, Stream2);
                    (0, defineProperty.A)(this, "pausedBy", void 0);
                    this.id = producerOrConsumer.id;
                    this.kind = producerOrConsumer.track.kind;
                    this.codec = producerOrConsumer.codec;
                    this.track = producerOrConsumer.track;
                    this.producerOrConsumer = producerOrConsumer.instance;
                    if (producerOrConsumer.appData && producerOrConsumer.appData.share === true && producerOrConsumer.track.kind === "video") {
                      this.kind = "share";
                    }
                    if (producerOrConsumer.appData && producerOrConsumer.appData.share === true && producerOrConsumer.track.kind === "audio") {
                      this.kind = "shareAudio";
                    }
                    this.rtpSender = producerOrConsumer.rtpSender;
                    this.rtpReceiver = producerOrConsumer.rtpReceiver;
                    this.eventEmitter = new events2();
                  }
                  return (0, createClass.A)(Stream2, [{
                    key: "pause",
                    value: function pause() {
                      Store.roomClient._pauseConsumer(this.producerOrConsumer);
                    }
                  }, {
                    key: "resume",
                    value: function resume() {
                      Store.roomClient._resumeConsumer(this.producerOrConsumer);
                    }
                  }, {
                    key: "handleStateChanged",
                    value: function handleStateChanged(_ref) {
                      var state = _ref.state, streamId = _ref.streamId;
                      this.eventEmitter.emit(EV_STATE, {
                        state,
                        timestamp: (/* @__PURE__ */ new Date()).getTime()
                      });
                    }
                  }, {
                    key: "paused",
                    get: function get() {
                      return this.producerOrConsumer.paused;
                    }
                    /**
                    * Add event listener
                    * @param {EV_STATE} eventType
                    * @param {Function} listener Callback function
                    */
                  }, {
                    key: "on",
                    value: function on(eventType, listener) {
                      switch (eventType) {
                        case EV_STATE:
                          this.eventEmitter.on(eventType, listener);
                          break;
                        default:
                          throw new Error("Invalid event type from STREAM onn");
                      }
                    }
                    /**
                    * Add event listener
                    * @param {EV_STATE} eventType
                    * @param {Function} listener Callback function
                    */
                  }, {
                    key: "off",
                    value: function off(eventType, listener) {
                      switch (eventType) {
                        case EV_STATE:
                          this.eventEmitter.off(eventType, listener);
                          break;
                        default:
                          throw new Error("Invalid event type from STREAM off");
                      }
                    }
                  }]);
                }();
                var sdkCapabilities = __webpack_require__2(1803);
                ;
                function participant_ownKeys(e, r) {
                  var t = Object.keys(e);
                  if (Object.getOwnPropertySymbols) {
                    var o = Object.getOwnPropertySymbols(e);
                    r && (o = o.filter(function(r2) {
                      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
                    })), t.push.apply(t, o);
                  }
                  return t;
                }
                function participant_objectSpread(e) {
                  for (var r = 1; r < arguments.length; r++) {
                    var t = null != arguments[r] ? arguments[r] : {};
                    r % 2 ? participant_ownKeys(Object(t), true).forEach(function(r2) {
                      (0, defineProperty.A)(e, r2, t[r2]);
                    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : participant_ownKeys(Object(t)).forEach(function(r2) {
                      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
                    });
                  }
                  return e;
                }
                function _createForOfIteratorHelper(r, e) {
                  var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
                  if (!t) {
                    if (Array.isArray(r) || (t = _unsupportedIterableToArray2(r)) || e && r && "number" == typeof r.length) {
                      t && (r = t);
                      var _n = 0, F = function F2() {
                      };
                      return { s: F, n: function n() {
                        return _n >= r.length ? { done: true } : { done: false, value: r[_n++] };
                      }, e: function e2(r2) {
                        throw r2;
                      }, f: F };
                    }
                    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
                  }
                  var o, a = true, u = false;
                  return { s: function s() {
                    t = t.call(r);
                  }, n: function n() {
                    var r2 = t.next();
                    return a = r2.done, r2;
                  }, e: function e2(r2) {
                    u = true, o = r2;
                  }, f: function f() {
                    try {
                      a || null == t["return"] || t["return"]();
                    } finally {
                      if (u) throw o;
                    }
                  } };
                }
                function _unsupportedIterableToArray2(r, a) {
                  if (r) {
                    if ("string" == typeof r) return _arrayLikeToArray2(r, a);
                    var t = {}.toString.call(r).slice(8, -1);
                    return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray2(r, a) : void 0;
                  }
                }
                function _arrayLikeToArray2(r, a) {
                  (null == a || a > r.length) && (a = r.length);
                  for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];
                  return n;
                }
                var EV_STREAM_ENABLED = "stream-enabled";
                var EV_STREAM_DISABLED = "stream-disabled";
                var EV_MEDIA_STATUS_CHANGED = "media-status-changed";
                var EV_VIDEO_QUALITY_CHANGED = "video-quality-changed";
                var EV_STREAM_PAUSED = "stream-paused";
                var EV_STREAM_RESUMED = "stream-resumed";
                var EV_PRODUCER_ADDED = "producer-added";
                var EV_PRODUCER_REMOVED = "producer-removed";
                var EV_CONSUMER_ADDED = "consumer-added";
                var EV_CONSUMER_REMOVED = "consumer-removed";
                var EV_E2EE_STATE_CHANGE = "e2ee-state-change";
                var Participant = function() {
                  function Participant2(peer) {
                    var _this = this;
                    (0, classCallCheck.A)(this, Participant2);
                    (0, defineProperty.A)(this, "captureImage", (0, asyncToGenerator.A)(regenerator_default().mark(function _callee2() {
                      var _ref2, desrHeight, desrWidth, streams, _iterator, _step, _loop, _ret, _args3 = arguments, _t3, _t4;
                      return regenerator_default().wrap(function(_context3) {
                        while (1) switch (_context3.prev = _context3.next) {
                          case 0:
                            _ref2 = _args3.length > 0 && _args3[0] !== void 0 ? _args3[0] : {}, desrHeight = _ref2.height, desrWidth = _ref2.width;
                            _context3.prev = 1;
                            streams = (0, toConsumableArray.A)(_this.streams.values());
                            _iterator = _createForOfIteratorHelper(streams);
                            _context3.prev = 2;
                            _loop = regenerator_default().mark(function _loop2() {
                              var stream, track, video, canvas, myPromise, _t2;
                              return regenerator_default().wrap(function(_context2) {
                                while (1) switch (_context2.prev = _context2.next) {
                                  case 0:
                                    stream = _step.value;
                                    if (!(stream.kind == "video")) {
                                      _context2.next = 4;
                                      break;
                                    }
                                    _context2.prev = 1;
                                    track = new MediaStream();
                                    track.addTrack(stream.track);
                                    video = document.createElement("video");
                                    video.srcObject = track;
                                    video.playsInline = true;
                                    canvas = document.createElement("canvas");
                                    canvas.id = "canvasId";
                                    _context2.next = 2;
                                    return new Promise(function(resolve, reject) {
                                      video.addEventListener("loadeddata", (0, asyncToGenerator.A)(regenerator_default().mark(function _callee() {
                                        var videoWidth, videoHeight, ratio, x, y, url, _t;
                                        return regenerator_default().wrap(function(_context) {
                                          while (1) switch (_context.prev = _context.next) {
                                            case 0:
                                              videoWidth = video.videoWidth, videoHeight = video.videoHeight;
                                              ratio = 16 / 9;
                                              if ((desrHeight === void 0 || desrHeight === null) && (desrWidth === void 0 || desrWidth === null)) {
                                                desrHeight = videoHeight;
                                                desrWidth = videoWidth;
                                              }
                                              if (desrHeight != void 0 || desrHeight != null) {
                                                if (desrHeight <= 0 || desrHeight > videoHeight) {
                                                  desrHeight = videoHeight;
                                                }
                                              }
                                              if (desrWidth != void 0 || desrWidth != null) {
                                                if (desrWidth <= 0 || desrWidth > videoWidth) {
                                                  desrWidth = videoWidth;
                                                }
                                              }
                                              if (desrHeight === void 0 || desrHeight === null) {
                                                desrHeight = desrWidth / ratio;
                                              }
                                              if (desrWidth === void 0 || desrWidth === null) {
                                                desrWidth = desrHeight * ratio;
                                              }
                                              canvas.width = desrWidth;
                                              canvas.height = desrHeight;
                                              _context.prev = 1;
                                              _context.next = 2;
                                              return video.play();
                                            case 2:
                                              document.body.appendChild(video);
                                              x = (canvas.width - videoWidth * ratio) / 2;
                                              y = (canvas.height - videoHeight * ratio) / 2;
                                              canvas.getContext("2d").clearRect(0, 0, x / 2, y / 2);
                                              canvas.getContext("2d").drawImage(video, 0, 0);
                                              url = canvas.toDataURL("image/jpeg").split(";base64,")[1];
                                              document.body.appendChild(canvas);
                                              document.body.removeChild(canvas);
                                              document.body.removeChild(video);
                                              resolve(url);
                                              _context.next = 4;
                                              break;
                                            case 3:
                                              _context.prev = 3;
                                              _t = _context["catch"](1);
                                              reject(_t);
                                              console.log("error in video", _t);
                                            case 4:
                                            case "end":
                                              return _context.stop();
                                          }
                                        }, _callee, null, [[1, 3]]);
                                      })));
                                    });
                                  case 2:
                                    myPromise = _context2.sent;
                                    return _context2.abrupt("return", {
                                      v: myPromise
                                    });
                                  case 3:
                                    _context2.prev = 3;
                                    _t2 = _context2["catch"](1);
                                    console.error("err on image capture", _t2);
                                  case 4:
                                  case "end":
                                    return _context2.stop();
                                }
                              }, _loop2, null, [[1, 3]]);
                            });
                            _iterator.s();
                          case 3:
                            if ((_step = _iterator.n()).done) {
                              _context3.next = 6;
                              break;
                            }
                            return _context3.delegateYield(_loop(), "t0", 4);
                          case 4:
                            _ret = _context3.t0;
                            if (!_ret) {
                              _context3.next = 5;
                              break;
                            }
                            return _context3.abrupt("return", _ret.v);
                          case 5:
                            _context3.next = 3;
                            break;
                          case 6:
                            _context3.next = 8;
                            break;
                          case 7:
                            _context3.prev = 7;
                            _t3 = _context3["catch"](2);
                            _iterator.e(_t3);
                          case 8:
                            _context3.prev = 8;
                            _iterator.f();
                            return _context3.finish(8);
                          case 9:
                            throw new Error("Camera must be on to capture an image");
                          case 10:
                            _context3.prev = 10;
                            _t4 = _context3["catch"](1);
                            console.error("Error in captureImage::", _t4);
                            if (Store.roomClient._videosdkLogs) {
                              Store.roomClient._videosdkLogs.pushLogs({
                                logText: "Error on image capture",
                                logType: "ERROR",
                                attributes: {
                                  error: _t4.message
                                }
                              });
                            }
                          case 11:
                          case "end":
                            return _context3.stop();
                        }
                      }, _callee2, null, [[1, 10], [2, 7, 8, 9]]);
                    })));
                    this.id = peer.id;
                    this.displayName = peer.displayName;
                    this.streams = /* @__PURE__ */ new Map();
                    this.quality = "low";
                    this.screenShareQuality = "high";
                    this.local = peer.local || false;
                    this.pinState = {
                      cam: false,
                      share: false
                    };
                    this.webcamOn = false;
                    this.micOn = false;
                    this.mode = peer.mode;
                    this.metaData = peer.metaData;
                    this.eventEmitter = new events2.EventEmitter();
                    this.participantVideoElements = /* @__PURE__ */ new Map();
                    this.participantAudioElements = /* @__PURE__ */ new Map();
                    this.videoVisible = false;
                    this.height = null;
                    this.width = null;
                    this.resizeObserver = null;
                  }
                  return (0, createClass.A)(Participant2, [{
                    key: "_setPinState",
                    value: function _setPinState(obj) {
                      if (obj.cam != void 0) {
                        this.pinState.cam = obj.cam;
                      }
                      if (obj.share != void 0) {
                        this.pinState.share = obj.share;
                      }
                    }
                  }, {
                    key: "remove",
                    value: function remove() {
                      Store.roomClient.removePeer(this.id);
                    }
                  }, {
                    key: "enableMic",
                    value: function enableMic() {
                      Store.roomClient.enablePeerMic(this.id);
                    }
                  }, {
                    key: "disableMic",
                    value: function disableMic() {
                      Store.roomClient.disablePeerMic(this.id);
                    }
                  }, {
                    key: "enableWebcam",
                    value: function enableWebcam() {
                      Store.roomClient.enablePeerWebcam(this.id);
                    }
                  }, {
                    key: "disableWebcam",
                    value: function disableWebcam() {
                      Store.roomClient.disablePeerWebcam(this.id);
                    }
                  }, {
                    key: "getTransportStats",
                    value: function getTransportStats() {
                      return Store.roomClient.getTransportRemoteStats({
                        participantId: this.id
                      });
                    }
                  }, {
                    key: "handleStreamStateChanged",
                    value: function handleStreamStateChanged(_ref4) {
                      var state = _ref4.state, peerId = _ref4.peerId, streamId = _ref4.streamId;
                      var stream = this.streams.get(streamId);
                      if (stream == null) return;
                      if (stream.kind === "video" || stream.kind === "share") {
                        stream.handleStateChanged({
                          state,
                          streamId
                        });
                      }
                    }
                  }, {
                    key: "addStream",
                    value: function addStream(stream) {
                      if (!stream) {
                        console.warn("Attempted to add null/undefined stream");
                        return;
                      }
                      this.streams.set(stream.id, stream);
                      if (stream.kind === "video" && !this.local) {
                        Store.roomClient.setConsumerQuality(stream.id, this.quality);
                      }
                      var mediaStream = new MediaStream();
                      mediaStream.addTrack(stream.track);
                      try {
                        if (["video", "share"].includes(stream.kind)) {
                          var videoElement = this.participantVideoElements.get(stream.kind);
                          if (videoElement) {
                            var defaultStyles = {
                              display: "block",
                              objectFit: stream.kind === "share" ? "contain" : "cover",
                              width: "100%"
                            };
                            Object.assign(videoElement.style, defaultStyles);
                            videoElement.srcObject = mediaStream;
                            videoElement.play()["catch"](function(error) {
                              console.error("Failed to play ".concat(stream.kind, " stream:"), error);
                            });
                            if (stream.kind === "share" || stream.kind === "video" && this.videoVisible) {
                              stream.resume();
                            }
                          }
                        }
                        if ((stream.kind === "audio" || stream.kind === "shareAudio") && !this.local) {
                          var audioElement = this.participantAudioElements.get(stream.kind);
                          if (audioElement) {
                            audioElement.srcObject = mediaStream;
                            audioElement.play()["catch"](function(error) {
                              console.error("Failed to play ".concat(stream.kind, " audio:"), error);
                            });
                          }
                        }
                        this.eventEmitter.emit(EV_STREAM_ENABLED, stream);
                        if (stream.kind === "video" && !this.local && this.height && this.width) {
                          this.setViewPort(this.width, this.height);
                        }
                      } catch (error) {
                        console.error("Error in addStream:", error);
                      }
                    }
                  }, {
                    key: "updateStream",
                    value: function updateStream(stream) {
                      this.streams.set(stream.id, stream);
                      this.eventEmitter.emit(EV_STREAM_ENABLED, stream);
                    }
                  }, {
                    key: "deleteStream",
                    value: function deleteStream(streamId) {
                      var stream = this.streams.get(streamId);
                      if (stream == null) return;
                      this.streams["delete"](streamId);
                      var elementMappings = {
                        video: {
                          collection: this.participantVideoElements,
                          type: "video"
                        },
                        share: {
                          collection: this.participantVideoElements,
                          type: "share"
                        },
                        audio: {
                          collection: this.participantAudioElements,
                          type: "audio"
                        },
                        shareAudio: {
                          collection: this.participantAudioElements,
                          type: "shareAudio"
                        }
                      };
                      var mapping = elementMappings[stream.kind];
                      if (mapping) {
                        var element = mapping.collection.get(mapping.type);
                        if (element) {
                          element.style.display = "none";
                        }
                      }
                      this.eventEmitter.emit(EV_STREAM_DISABLED, stream);
                      return stream;
                    }
                  }, {
                    key: "streamResumed",
                    value: function streamResumed(streamId) {
                      var stream = this.streams.get(streamId);
                      if (stream == null) return;
                    }
                  }, {
                    key: "streamPaused",
                    value: function streamPaused(streamId) {
                      var stream = this.streams.get(streamId);
                      if (stream == null) return;
                    }
                  }, {
                    key: "updateParticipantMediaState",
                    value: function updateParticipantMediaState(kind, state) {
                      if (kind == "audio") {
                        this.micOn = state;
                      } else if (kind == "video") {
                        this.webcamOn = state;
                      }
                      this.eventEmitter.emit(EV_MEDIA_STATUS_CHANGED, {
                        peerId: this.id,
                        kind,
                        newStatus: state
                      });
                    }
                  }, {
                    key: "handleParticipantPause",
                    value: function handleParticipantPause(data) {
                      if (data !== null && data !== void 0 && data.consumerId) {
                        var stream = this.streams.get(data.consumerId);
                        if (stream) {
                          stream.pausedBy = "SUB_MANAGER";
                        } else {
                          console.warn("Stream with consumerId ".concat(data.consumerId, " not found."));
                        }
                      }
                      this.eventEmitter.emit(EV_STREAM_PAUSED, {
                        kind: data === null || data === void 0 ? void 0 : data.kind,
                        reason: data === null || data === void 0 ? void 0 : data.reason
                      });
                    }
                  }, {
                    key: "handleParticipantResume",
                    value: function handleParticipantResume(data) {
                      if (data !== null && data !== void 0 && data.consumerId) {
                        var stream = this.streams.get(data.consumerId);
                        if (stream) {
                          stream.pausedBy = void 0;
                        } else {
                          console.warn("Stream with consumerId ".concat(data.consumerId, " not found."));
                        }
                      }
                      this.eventEmitter.emit(EV_STREAM_RESUMED, {
                        kind: data === null || data === void 0 ? void 0 : data.kind,
                        reason: data === null || data === void 0 ? void 0 : data.reason
                      });
                    }
                  }, {
                    key: "handleE2EEStateChange",
                    value: function handleE2EEStateChange(data) {
                      data === null || data === void 0 || delete data.peerId;
                      this.eventEmitter.emit(EV_E2EE_STATE_CHANGE, data);
                    }
                  }, {
                    key: "videoQualityChanged",
                    value: function videoQualityChanged(prevQuality, currentQuality) {
                      this.eventEmitter.emit(EV_VIDEO_QUALITY_CHANGED, {
                        peerId: this.id,
                        prevQuality,
                        currentQuality
                      });
                    }
                    /**
                     *
                     * @param {"low" | "med" | 'high'} quality
                     */
                  }, {
                    key: "setQuality",
                    value: function setQuality(quality) {
                      if (this.local) return;
                      if (typeof document !== "undefined" && this.resizeObserver) {
                        var videoContainer = document.querySelector("#f-".concat(this.id));
                        if (videoContainer) {
                          this.resizeObserver.unobserve(videoContainer);
                        }
                      }
                      this.quality = quality;
                      var entries = (0, toConsumableArray.A)(this.streams.entries());
                      entries.forEach(function(entry) {
                        var stream = entry[1];
                        if (stream.kind === "video") {
                          Store.roomClient.setConsumerQuality(stream.id, quality);
                        }
                      });
                    }
                    /**
                     *
                     * @param {"low" | "med" | 'high'} quality
                     */
                  }, {
                    key: "setScreenShareQuality",
                    value: function setScreenShareQuality(quality) {
                      if (this.local) return;
                      this.screenShareQuality = quality;
                      this.streams.forEach(function(stream) {
                        if (stream.kind === "share") {
                          Store.roomClient.setConsumerScreenShareQuality(stream.id, quality);
                        }
                      });
                    }
                    /**
                     *
                     * @param {number} width
                     * @param {number} height
                     */
                  }, {
                    key: "setViewPort",
                    value: function setViewPort(width, height) {
                      var entries = (0, toConsumableArray.A)(this.streams.entries());
                      entries.forEach(function(entry) {
                        var stream = entry[1];
                        if (stream.kind === "video") {
                          Store.roomClient.setViewPort(stream.producerOrConsumer, width, height);
                        }
                      });
                    }
                    /**
                     * @param {"SHARE_AND_CAM" | "CAM" | "SHARE"} type
                     */
                  }, {
                    key: "pin",
                    value: function pin(type) {
                      switch (type) {
                        case "SHARE_AND_CAM":
                        case void 0:
                          this._setPinState({
                            cam: true,
                            share: true
                          });
                          break;
                        case "CAM":
                          this._setPinState({
                            cam: true
                          });
                          break;
                        case "SHARE":
                          this._setPinState({
                            share: true
                          });
                          break;
                        default:
                          throw new Error("Unknown pin type");
                      }
                      Store.roomClient.pinStateChange({
                        peerId: this.id,
                        state: this.pinState
                      });
                    }
                    /**
                     * @param {"SHARE_AND_CAM" | "CAM" | "SHARE"} type
                     */
                  }, {
                    key: "unpin",
                    value: function unpin(type) {
                      switch (type) {
                        case "SHARE_AND_CAM":
                        case void 0:
                          this._setPinState({
                            cam: false,
                            share: false
                          });
                          break;
                        case "CAM":
                          this._setPinState({
                            cam: false
                          });
                          break;
                        case "SHARE":
                          this._setPinState({
                            share: false
                          });
                          break;
                        default:
                          throw new Error("Unknown unpin type");
                      }
                      Store.roomClient.pinStateChange({
                        peerId: this.id,
                        state: this.pinState
                      });
                    }
                    /**
                     *@param {{meetingId: string, payload: string, token:string }} options
                     */
                  }, {
                    key: "switchTo",
                    value: function() {
                      var _switchTo = (0, asyncToGenerator.A)(regenerator_default().mark(function _callee3(_ref5) {
                        var meetingId, payload, token;
                        return regenerator_default().wrap(function(_context4) {
                          while (1) switch (_context4.prev = _context4.next) {
                            case 0:
                              meetingId = _ref5.meetingId, payload = _ref5.payload, token = _ref5.token;
                              _context4.next = 1;
                              return Store.roomClient.switchPeerRoom({
                                peerId: this.id,
                                roomId: meetingId,
                                payload,
                                token
                              });
                            case 1:
                            case "end":
                              return _context4.stop();
                          }
                        }, _callee3, this);
                      }));
                      function switchTo(_x) {
                        return _switchTo.apply(this, arguments);
                      }
                      return switchTo;
                    }()
                  }, {
                    key: "getVideoStats",
                    value: function() {
                      var _getVideoStats = (0, asyncToGenerator.A)(regenerator_default().mark(function _callee4() {
                        var entries, _iterator2, _step2, _step2$value, streamId, stream, _t5;
                        return regenerator_default().wrap(function(_context5) {
                          while (1) switch (_context5.prev = _context5.next) {
                            case 0:
                              if (!this.local) {
                                _context5.next = 2;
                                break;
                              }
                              _context5.next = 1;
                              return Store.roomClient.getVideoRemoteStats();
                            case 1:
                              return _context5.abrupt("return", _context5.sent);
                            case 2:
                              entries = (0, toConsumableArray.A)(this.streams.entries());
                              _iterator2 = _createForOfIteratorHelper(entries);
                              _context5.prev = 3;
                              _iterator2.s();
                            case 4:
                              if ((_step2 = _iterator2.n()).done) {
                                _context5.next = 7;
                                break;
                              }
                              _step2$value = (0, slicedToArray.A)(_step2.value, 2), streamId = _step2$value[0], stream = _step2$value[1];
                              if (!(stream.kind == "video")) {
                                _context5.next = 6;
                                break;
                              }
                              _context5.next = 5;
                              return Store.roomClient.getConsumerRemoteStats(streamId);
                            case 5:
                              return _context5.abrupt("return", _context5.sent);
                            case 6:
                              _context5.next = 4;
                              break;
                            case 7:
                              _context5.next = 9;
                              break;
                            case 8:
                              _context5.prev = 8;
                              _t5 = _context5["catch"](3);
                              _iterator2.e(_t5);
                            case 9:
                              _context5.prev = 9;
                              _iterator2.f();
                              return _context5.finish(9);
                            case 10:
                            case "end":
                              return _context5.stop();
                          }
                        }, _callee4, this, [[3, 8, 9, 10]]);
                      }));
                      function getVideoStats() {
                        return _getVideoStats.apply(this, arguments);
                      }
                      return getVideoStats;
                    }()
                  }, {
                    key: "getShareStats",
                    value: function() {
                      var _getShareStats = (0, asyncToGenerator.A)(regenerator_default().mark(function _callee5() {
                        var entries, _iterator3, _step3, _step3$value, streamId, stream, _t6;
                        return regenerator_default().wrap(function(_context6) {
                          while (1) switch (_context6.prev = _context6.next) {
                            case 0:
                              if (!this.local) {
                                _context6.next = 2;
                                break;
                              }
                              _context6.next = 1;
                              return Store.roomClient.getShareRemoteStats();
                            case 1:
                              return _context6.abrupt("return", _context6.sent);
                            case 2:
                              entries = (0, toConsumableArray.A)(this.streams.entries());
                              _iterator3 = _createForOfIteratorHelper(entries);
                              _context6.prev = 3;
                              _iterator3.s();
                            case 4:
                              if ((_step3 = _iterator3.n()).done) {
                                _context6.next = 7;
                                break;
                              }
                              _step3$value = (0, slicedToArray.A)(_step3.value, 2), streamId = _step3$value[0], stream = _step3$value[1];
                              if (!(stream.kind == "share")) {
                                _context6.next = 6;
                                break;
                              }
                              _context6.next = 5;
                              return Store.roomClient.getConsumerRemoteStats(streamId);
                            case 5:
                              return _context6.abrupt("return", _context6.sent);
                            case 6:
                              _context6.next = 4;
                              break;
                            case 7:
                              _context6.next = 9;
                              break;
                            case 8:
                              _context6.prev = 8;
                              _t6 = _context6["catch"](3);
                              _iterator3.e(_t6);
                            case 9:
                              _context6.prev = 9;
                              _iterator3.f();
                              return _context6.finish(9);
                            case 10:
                            case "end":
                              return _context6.stop();
                          }
                        }, _callee5, this, [[3, 8, 9, 10]]);
                      }));
                      function getShareStats() {
                        return _getShareStats.apply(this, arguments);
                      }
                      return getShareStats;
                    }()
                  }, {
                    key: "getShareAudioStats",
                    value: function() {
                      var _getShareAudioStats = (0, asyncToGenerator.A)(regenerator_default().mark(function _callee6() {
                        var entries, _iterator4, _step4, _step4$value, streamId, stream, _t7;
                        return regenerator_default().wrap(function(_context7) {
                          while (1) switch (_context7.prev = _context7.next) {
                            case 0:
                              if (!this.local) {
                                _context7.next = 2;
                                break;
                              }
                              _context7.next = 1;
                              return Store.roomClient.getShareAudioRemoteStats();
                            case 1:
                              return _context7.abrupt("return", _context7.sent);
                            case 2:
                              entries = (0, toConsumableArray.A)(this.streams.entries());
                              _iterator4 = _createForOfIteratorHelper(entries);
                              _context7.prev = 3;
                              _iterator4.s();
                            case 4:
                              if ((_step4 = _iterator4.n()).done) {
                                _context7.next = 7;
                                break;
                              }
                              _step4$value = (0, slicedToArray.A)(_step4.value, 2), streamId = _step4$value[0], stream = _step4$value[1];
                              if (!(stream.kind == "shareAudio")) {
                                _context7.next = 6;
                                break;
                              }
                              _context7.next = 5;
                              return Store.roomClient.getConsumerRemoteStats(streamId);
                            case 5:
                              return _context7.abrupt("return", _context7.sent);
                            case 6:
                              _context7.next = 4;
                              break;
                            case 7:
                              _context7.next = 9;
                              break;
                            case 8:
                              _context7.prev = 8;
                              _t7 = _context7["catch"](3);
                              _iterator4.e(_t7);
                            case 9:
                              _context7.prev = 9;
                              _iterator4.f();
                              return _context7.finish(9);
                            case 10:
                            case "end":
                              return _context7.stop();
                          }
                        }, _callee6, this, [[3, 8, 9, 10]]);
                      }));
                      function getShareAudioStats() {
                        return _getShareAudioStats.apply(this, arguments);
                      }
                      return getShareAudioStats;
                    }()
                  }, {
                    key: "getAudioStats",
                    value: function() {
                      var _getAudioStats = (0, asyncToGenerator.A)(regenerator_default().mark(function _callee7() {
                        var entries, _iterator5, _step5, _step5$value, streamId, stream, _t8;
                        return regenerator_default().wrap(function(_context8) {
                          while (1) switch (_context8.prev = _context8.next) {
                            case 0:
                              if (this.micOn) {
                                _context8.next = 1;
                                break;
                              }
                              return _context8.abrupt("return", []);
                            case 1:
                              if (!this.local) {
                                _context8.next = 3;
                                break;
                              }
                              _context8.next = 2;
                              return Store.roomClient.getAudioRemoteStats();
                            case 2:
                              return _context8.abrupt("return", _context8.sent);
                            case 3:
                              entries = (0, toConsumableArray.A)(this.streams.entries());
                              _iterator5 = _createForOfIteratorHelper(entries);
                              _context8.prev = 4;
                              _iterator5.s();
                            case 5:
                              if ((_step5 = _iterator5.n()).done) {
                                _context8.next = 8;
                                break;
                              }
                              _step5$value = (0, slicedToArray.A)(_step5.value, 2), streamId = _step5$value[0], stream = _step5$value[1];
                              if (!(stream.kind == "audio")) {
                                _context8.next = 7;
                                break;
                              }
                              _context8.next = 6;
                              return Store.roomClient.getConsumerRemoteStats(streamId);
                            case 6:
                              return _context8.abrupt("return", _context8.sent);
                            case 7:
                              _context8.next = 5;
                              break;
                            case 8:
                              _context8.next = 10;
                              break;
                            case 9:
                              _context8.prev = 9;
                              _t8 = _context8["catch"](4);
                              _iterator5.e(_t8);
                            case 10:
                              _context8.prev = 10;
                              _iterator5.f();
                              return _context8.finish(10);
                            case 11:
                            case "end":
                              return _context8.stop();
                          }
                        }, _callee7, this, [[4, 9, 10, 11]]);
                      }));
                      function getAudioStats() {
                        return _getAudioStats.apply(this, arguments);
                      }
                      return getAudioStats;
                    }()
                  }, {
                    key: "consumeMicStreams",
                    value: function consumeMicStreams() {
                      Store.roomClient.consumeMicStreams(this.id);
                    }
                  }, {
                    key: "consumeWebcamStreams",
                    value: function consumeWebcamStreams() {
                      Store.roomClient.consumeWebcamStreams(this.id);
                    }
                  }, {
                    key: "stopConsumingWebcamStreams",
                    value: function stopConsumingWebcamStreams() {
                      Store.roomClient.stopConsumingWebcamStreams(this.id);
                    }
                  }, {
                    key: "stopConsumingMicStreams",
                    value: function stopConsumingMicStreams() {
                      Store.roomClient.stopConsumingMicStreams(this.id);
                    }
                  }, {
                    key: "renderVideo",
                    value: function renderVideo(_ref6) {
                      var _this2 = this;
                      var _ref6$type = _ref6.type, type = _ref6$type === void 0 ? "video" : _ref6$type, _ref6$maxQuality = _ref6.maxQuality, maxQuality = _ref6$maxQuality === void 0 ? "auto" : _ref6$maxQuality, _ref6$videostyle = _ref6.videostyle, videostyle = _ref6$videostyle === void 0 ? {} : _ref6$videostyle, _ref6$containerStyle = _ref6.containerStyle, containerStyle = _ref6$containerStyle === void 0 ? {} : _ref6$containerStyle;
                      var videoStream;
                      for (var _i = 0, _arr = (0, toConsumableArray.A)(this.streams.values()); _i < _arr.length; _i++) {
                        var stream = _arr[_i];
                        if (stream.kind == type) {
                          videoStream = new MediaStream();
                          videoStream.addTrack(stream.track);
                        }
                      }
                      if (this.participantVideoElements.get(type)) {
                        if (videoStream) {
                          var videoElement = this.participantVideoElements.get(type);
                          if (videoElement) {
                            videoElement.srcObject = videoStream;
                            videoElement.play()["catch"](function(error) {
                              return console.error("videoElem.play() failed", error);
                            });
                          }
                        }
                        return this.participantVideoElements.get(type);
                      }
                      try {
                        var containerDiv = document.createElement("div");
                        containerDiv.classList.add("video-container", "participant-video-".concat(this.id));
                        containerDiv.setAttribute("id", "f-".concat(this.id).concat(type === "share" ? "-share" : ""));
                        containerDiv.style.setProperty("position", "relative");
                        Object.assign(containerDiv.style, containerStyle);
                        var _videoElement = document.createElement("video");
                        _videoElement.setAttribute("id", "v-".concat(this.id).concat(type === "share" ? "-share" : ""));
                        _videoElement.setAttribute("playsinline", "");
                        _videoElement.setAttribute("webkit-playsinline", "");
                        _videoElement.setAttribute("x5-playsinline", "");
                        _videoElement.playsinline = true;
                        _videoElement.muted = true;
                        _videoElement.autoplay = true;
                        _videoElement.onerror = function(err) {
                          console.log(err, "participant video error");
                        };
                        Object.assign(_videoElement.style, participant_objectSpread({
                          width: "100%",
                          height: "100%",
                          objectFit: type === "share" ? "contain" : "cover"
                        }, videostyle));
                        if (videoStream) {
                          _videoElement.srcObject = videoStream;
                          _videoElement.play().then(function(val) {
                            console.log("videoElem.play() success", val);
                          })["catch"](function(error) {
                            return console.error("videoElem.play() failed", error);
                          });
                        }
                        containerDiv.appendChild(_videoElement);
                        this.participantVideoElements.set(type, _videoElement);
                        this.videoVisible = false;
                        if (!this.local && type === "video") {
                          var throttledIntersectionCallback = (0, sdkCapabilities.sg)(function(entries) {
                            if (entries.length == 0) {
                              return;
                            }
                            var entry = entries[entries.length - 1];
                            if (entry.intersectionRatio > 0) {
                              _this2.videoVisible = true;
                              for (var _i2 = 0, _arr2 = (0, toConsumableArray.A)(_this2.streams.values()); _i2 < _arr2.length; _i2++) {
                                var _stream = _arr2[_i2];
                                if (_stream.kind == "video" && _stream.pausedBy !== "SUB_MANAGER" && _stream.paused) {
                                  _stream.resume();
                                }
                              }
                            } else {
                              _this2.videoVisible = false;
                              for (var _i3 = 0, _arr3 = (0, toConsumableArray.A)(_this2.streams.values()); _i3 < _arr3.length; _i3++) {
                                var _stream2 = _arr3[_i3];
                                if (_stream2.kind == "video") {
                                  _stream2.pause();
                                }
                              }
                            }
                          }, 500);
                          var observerOptions = {
                            root: null,
                            rootMargin: "0px",
                            threshold: 0
                          };
                          var observer = new IntersectionObserver(throttledIntersectionCallback, observerOptions);
                          observer.observe(containerDiv);
                          if (maxQuality == "auto" && type === "video") {
                            var throttledResizeCallback = (0, sdkCapabilities.sg)(function(entries) {
                              var _entries$0$contentRec = entries[0].contentRect, width = _entries$0$contentRec.width, height = _entries$0$contentRec.height;
                              if (width > 0 && height > 0) {
                                _this2.height = height;
                                _this2.width = width;
                                _this2.setViewPort(width, height);
                              }
                            }, 500);
                            var resizeObserver = new ResizeObserver(throttledResizeCallback);
                            resizeObserver.observe(containerDiv);
                            this.resizeObserver = resizeObserver;
                          }
                        }
                        if (type === "video" && maxQuality !== "auto" && !this.local) {
                          this.setQuality(maxQuality);
                        }
                        return containerDiv;
                      } catch (exce) {
                        console.log("Render video Exception", exce);
                      }
                    }
                  }, {
                    key: "renderAudio",
                    value: function renderAudio(_ref7) {
                      var _ref7$type = _ref7.type, type = _ref7$type === void 0 ? "audio" : _ref7$type;
                      if (this.local) return null;
                      try {
                        if (this.participantAudioElements.get(type)) {
                          var existingAudio = this.participantAudioElements.get(type);
                          var _audioStream = this.getAudioStream(type);
                          if (_audioStream) {
                            if (existingAudio) {
                              existingAudio.srcObject = _audioStream;
                              existingAudio.play()["catch"](function(error) {
                                return console.error("Failed to play existing audio:", error);
                              });
                            }
                          }
                          return existingAudio;
                        }
                        var audioElement = document.createElement("audio");
                        audioElement.setAttribute("id", "a-".concat(this.id, "-").concat(type));
                        audioElement.autoplay = false;
                        audioElement.playsInline = true;
                        audioElement.controls = false;
                        audioElement.style.display = "none";
                        audioElement.onerror = function(err) {
                          return console.log("Audio element error:", err);
                        };
                        var audioStream = this.getAudioStream(type);
                        if (audioStream) {
                          audioElement.srcObject = audioStream;
                          audioElement.play()["catch"](function(error) {
                            return console.error("Failed to play new audio:", error);
                          });
                        }
                        this.participantAudioElements.set(type, audioElement);
                        return audioElement;
                      } catch (error) {
                        console.error("Render audio exception:", error);
                        return null;
                      }
                    }
                    /* @internal */
                    // Helper method to get audio stream
                  }, {
                    key: "getAudioStream",
                    value: function getAudioStream() {
                      var type = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "audio";
                      var stream = (0, toConsumableArray.A)(this.streams.values()).find(function(stream2) {
                        return stream2.kind === type;
                      });
                      if (stream) {
                        var audioStream = new MediaStream();
                        audioStream.addTrack(stream.track);
                        stream.resume();
                        return audioStream;
                      }
                      return null;
                    }
                  }, {
                    key: "addProducer",
                    value: function addProducer(producer) {
                      this.eventEmitter.emit(EV_PRODUCER_ADDED, producer);
                    }
                  }, {
                    key: "removeProducer",
                    value: function removeProducer(producerId) {
                      this.eventEmitter.emit(EV_PRODUCER_REMOVED, producerId);
                    }
                  }, {
                    key: "addConsumer",
                    value: function addConsumer(consumer) {
                      this.eventEmitter.emit(EV_CONSUMER_ADDED, consumer);
                    }
                  }, {
                    key: "removeConsumer",
                    value: function removeConsumer(consumerId) {
                      this.eventEmitter.emit(EV_CONSUMER_REMOVED, consumerId);
                    }
                    /**
                     * Add event listener
                     * @param {EV_STREAM_ENABLED | EV_STREAM_DISABLED | EV_MEDIA_STATUS_CHANGED} eventType
                     * @param {Function} listener Callback function
                     */
                  }, {
                    key: "on",
                    value: function on(eventType, listener) {
                      switch (eventType) {
                        case EV_STREAM_ENABLED:
                        case EV_STREAM_DISABLED:
                        case EV_MEDIA_STATUS_CHANGED:
                        case EV_VIDEO_QUALITY_CHANGED:
                        case EV_STREAM_PAUSED:
                        case EV_STREAM_RESUMED:
                        case EV_PRODUCER_ADDED:
                        case EV_PRODUCER_REMOVED:
                        case EV_CONSUMER_ADDED:
                        case EV_CONSUMER_REMOVED:
                        case EV_E2EE_STATE_CHANGE:
                          this.eventEmitter.on(eventType, listener);
                          break;
                        default:
                          throw new Error("Invalid event type from participant onn");
                      }
                    }
                    /**
                     * Remove event listener
                     * @param {EV_STREAM_ENABLED | EV_STREAM_DISABLED | EV_MEDIA_STATUS_CHANGED} eventType
                     * @param {Function} listener Callback function
                     */
                  }, {
                    key: "off",
                    value: function off(eventType, listener) {
                      switch (eventType) {
                        case EV_STREAM_ENABLED:
                        case EV_STREAM_DISABLED:
                        case EV_MEDIA_STATUS_CHANGED:
                        case EV_VIDEO_QUALITY_CHANGED:
                        case EV_STREAM_PAUSED:
                        case EV_STREAM_RESUMED:
                        case EV_PRODUCER_ADDED:
                        case EV_PRODUCER_REMOVED:
                        case EV_CONSUMER_ADDED:
                        case EV_CONSUMER_REMOVED:
                        case EV_E2EE_STATE_CHANGE:
                          this.eventEmitter.off(eventType, listener);
                          break;
                        default:
                          throw new Error("Invalid event type from participant off");
                      }
                    }
                  }]);
                }();
                var possibleConstructorReturn = __webpack_require__2(388);
                var getPrototypeOf = __webpack_require__2(3954);
                var inherits = __webpack_require__2(5501);
                ;
                var CharacterState = {
                  CHARACTER_SPEAKING: "CHARACTER_SPEAKING",
                  CHARACTER_THINKING: "CHARACTER_THINKING",
                  CHARACTER_LISTENING: "CHARACTER_LISTENING"
                };
                var CharacterMode = {
                  TEXT: "text",
                  CO_PILOT: "co_pilot",
                  AUTO_PILOT: "auto_pilot",
                  VISION_PILOT: "vision_pilot"
                };
                var modes = __webpack_require__2(2107);
                ;
                function _callSuper(t, o, e) {
                  return o = (0, getPrototypeOf.A)(o), (0, possibleConstructorReturn.A)(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], (0, getPrototypeOf.A)(t).constructor) : o.apply(t, e));
                }
                function _isNativeReflectConstruct() {
                  try {
                    var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
                    }));
                  } catch (t2) {
                  }
                  return (_isNativeReflectConstruct = function _isNativeReflectConstruct2() {
                    return !!t;
                  })();
                }
                function _classPrivateMethodInitSpec(e, a) {
                  _checkPrivateRedeclaration(e, a), a.add(e);
                }
                function _classPrivateFieldInitSpec(e, t, a) {
                  _checkPrivateRedeclaration(e, t), t.set(e, a);
                }
                function _checkPrivateRedeclaration(e, t) {
                  if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object");
                }
                function _classPrivateFieldGet(s, a) {
                  return s.get(_assertClassBrand(s, a));
                }
                function _classPrivateFieldSet(s, a, r) {
                  return s.set(_assertClassBrand(s, a), r), r;
                }
                function _assertClassBrand(e, t, n) {
                  if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n;
                  throw new TypeError("Private element is not present on this object");
                }
                var character_EV_STREAM_ENABLED = "stream-enabled";
                var character_EV_STREAM_DISABLED = "stream-disabled";
                var EV_CHARACTER_JOINED = "character-joined";
                var EV_CHARACTER_LEFT = "character-left";
                var character_EV_MEDIA_STATUS_CHANGED = "media-status-changed";
                var character_EV_VIDEO_QUALITY_CHANGED = "video-quality-changed";
                var EV_CHARACTER_STATE_CHANGED = "character-state-changed";
                var EV_CHARACTER_MESSAGE = "character-message";
                var EV_USER_MESSAGE = "user-message";
                var EV_ON_DATA = "data";
                var EV_ON_ERROR = "error";
                var _characterRole = /* @__PURE__ */ new WeakMap();
                var _characterMode = /* @__PURE__ */ new WeakMap();
                var _knowledgeBases = /* @__PURE__ */ new WeakMap();
                var _language = /* @__PURE__ */ new WeakMap();
                var _interactionId = /* @__PURE__ */ new WeakMap();
                var _state = /* @__PURE__ */ new WeakMap();
                var _roomClient = /* @__PURE__ */ new WeakMap();
                var _Character_brand = /* @__PURE__ */ new WeakSet();
                var Character = function(_Participant) {
                  function Character2(config3) {
                    var _this;
                    (0, classCallCheck.A)(this, Character2);
                    _this = _callSuper(this, Character2, [{
                      id: config3.id,
                      displayName: config3.displayName,
                      mode: modes.nI.SEND_AND_RECV,
                      metaData: config3.metaData
                    }]);
                    _classPrivateMethodInitSpec(_this, _Character_brand);
                    _classPrivateFieldInitSpec(_this, _characterRole, void 0);
                    _classPrivateFieldInitSpec(_this, _characterMode, void 0);
                    _classPrivateFieldInitSpec(_this, _knowledgeBases, void 0);
                    _classPrivateFieldInitSpec(_this, _language, void 0);
                    _classPrivateFieldInitSpec(_this, _interactionId, void 0);
                    _classPrivateFieldInitSpec(_this, _state, void 0);
                    _classPrivateFieldInitSpec(_this, _roomClient, void 0);
                    (0, defineProperty.A)(_this, "captureImage", (0, asyncToGenerator.A)(regenerator_default().mark(function _callee() {
                      var _ref2, desrHeight, desrWidth, _args = arguments;
                      return regenerator_default().wrap(function(_context) {
                        while (1) switch (_context.prev = _context.next) {
                          case 0:
                            _ref2 = _args.length > 0 && _args[0] !== void 0 ? _args[0] : {}, desrHeight = _ref2.height, desrWidth = _ref2.width;
                            throw new Error("captureImage method is not supported on character");
                          case 1:
                          case "end":
                            return _context.stop();
                        }
                      }, _callee);
                    })));
                    _classPrivateFieldSet(_interactionId, _this, config3.interactionId || null);
                    _this.id = config3.id || null;
                    _classPrivateFieldSet(_characterRole, _this, config3.characterRole);
                    _classPrivateFieldSet(_characterMode, _this, config3.characterMode);
                    _classPrivateFieldSet(_knowledgeBases, _this, config3.knowledgeBases || []);
                    _this.displayName = config3.displayName;
                    _classPrivateFieldSet(_language, _this, config3.language);
                    _classPrivateFieldSet(_state, _this, config3.state || CharacterState.CHARACTER_LISTENING);
                    _classPrivateFieldSet(_roomClient, _this, config3.roomClient);
                    return _this;
                  }
                  (0, inherits.A)(Character2, _Participant);
                  return (0, createClass.A)(Character2, [{
                    key: "join",
                    value: function() {
                      var _join = (0, asyncToGenerator.A)(regenerator_default().mark(function _callee2() {
                        var res;
                        return regenerator_default().wrap(function(_context2) {
                          while (1) switch (_context2.prev = _context2.next) {
                            case 0:
                              _context2.next = 1;
                              return _classPrivateFieldGet(_roomClient, this).joinCharacter({
                                interactionId: _classPrivateFieldGet(_interactionId, this),
                                characterId: this.id,
                                characterRole: _classPrivateFieldGet(_characterRole, this),
                                // optional
                                displayName: this.displayName,
                                // optional
                                characterMode: _classPrivateFieldGet(_characterMode, this),
                                // optional
                                knowledgeBases: _classPrivateFieldGet(_knowledgeBases, this),
                                // optional
                                language: _classPrivateFieldGet(_language, this),
                                // optional
                                metaData: this.metaData
                              });
                            case 1:
                              res = _context2.sent;
                              if (res) {
                                this.id = res.characterId;
                                this.displayName = res.displayName;
                                _classPrivateFieldSet(_characterMode, this, res.characterMode);
                                _classPrivateFieldSet(_characterRole, this, res.characterRole);
                                _classPrivateFieldSet(_interactionId, this, res.interactionId);
                                _classPrivateFieldSet(_knowledgeBases, this, res.knowledgeBases);
                                _classPrivateFieldSet(_language, this, res.language);
                                _classPrivateFieldGet(_roomClient, this)._eventEmitter.emit("INIT_CHARACTER", this);
                              }
                            case 2:
                            case "end":
                              return _context2.stop();
                          }
                        }, _callee2, this);
                      }));
                      function join() {
                        return _join.apply(this, arguments);
                      }
                      return join;
                    }()
                  }, {
                    key: "leave",
                    value: function() {
                      var _leave = (0, asyncToGenerator.A)(regenerator_default().mark(function _callee3() {
                        return regenerator_default().wrap(function(_context3) {
                          while (1) switch (_context3.prev = _context3.next) {
                            case 0:
                              _context3.next = 1;
                              return _classPrivateFieldGet(_roomClient, this).removeCharacter();
                            case 1:
                            case "end":
                              return _context3.stop();
                          }
                        }, _callee3, this);
                      }));
                      function leave() {
                        return _leave.apply(this, arguments);
                      }
                      return leave;
                    }()
                  }, {
                    key: "remove",
                    value: function() {
                      var _remove = (0, asyncToGenerator.A)(regenerator_default().mark(function _callee4() {
                        return regenerator_default().wrap(function(_context4) {
                          while (1) switch (_context4.prev = _context4.next) {
                            case 0:
                              throw new Error("remove method is not supported on character");
                            case 1:
                            case "end":
                              return _context4.stop();
                          }
                        }, _callee4);
                      }));
                      function remove() {
                        return _remove.apply(this, arguments);
                      }
                      return remove;
                    }()
                    /**
                     * @description Send Message to Character AI
                     * @param {string} text - text to complete
                     * @returns {Promise<void>}
                     */
                  }, {
                    key: "sendMessage",
                    value: function() {
                      var _sendMessage = (0, asyncToGenerator.A)(regenerator_default().mark(function _callee5(text) {
                        return regenerator_default().wrap(function(_context5) {
                          while (1) switch (_context5.prev = _context5.next) {
                            case 0:
                              _context5.next = 1;
                              return _classPrivateFieldGet(_roomClient, this).sendCharacterMessage({
                                interactionId: _classPrivateFieldGet(_interactionId, this),
                                text
                              });
                            case 1:
                            case "end":
                              return _context5.stop();
                          }
                        }, _callee5, this);
                      }));
                      function sendMessage(_x) {
                        return _sendMessage.apply(this, arguments);
                      }
                      return sendMessage;
                    }()
                  }, {
                    key: "handleCharacterStateChanged",
                    value: function handleCharacterStateChanged(data) {
                      if (Object.keys(CharacterState).includes(data.status)) {
                        _assertClassBrand(_Character_brand, this, _updateState).call(this, data.status);
                        this.eventEmitter.emit(EV_CHARACTER_STATE_CHANGED, data);
                      }
                    }
                    /**
                     * @description character text handler
                     * @private
                     * @param {object} data - payload of character text
                     * @returns {Promise<void>}
                     */
                  }, {
                    key: "handleCharacterMessage",
                    value: function handleCharacterMessage(data) {
                      this.eventEmitter.emit(EV_CHARACTER_MESSAGE, data);
                    }
                    /**
                     * @description interrupts character
                     * @returns {Promise<void>}
                     */
                  }, {
                    key: "interrupt",
                    value: function() {
                      var _interrupt = (0, asyncToGenerator.A)(regenerator_default().mark(function _callee6() {
                        return regenerator_default().wrap(function(_context6) {
                          while (1) switch (_context6.prev = _context6.next) {
                            case 0:
                              _context6.next = 1;
                              return _classPrivateFieldGet(_roomClient, this).interruptCharacter({
                                interactionId: _classPrivateFieldGet(_interactionId, this)
                              });
                            case 1:
                            case "end":
                              return _context6.stop();
                          }
                        }, _callee6, this);
                      }));
                      function interrupt() {
                        return _interrupt.apply(this, arguments);
                      }
                      return interrupt;
                    }()
                  }, {
                    key: "handleUserMessage",
                    value: function handleUserMessage(data) {
                      this.eventEmitter.emit(EV_USER_MESSAGE, data);
                    }
                    /**
                     * @description on character data
                     * @private
                     * @param {object} data - payload of character data
                     * @returns {Promise<void>}
                     */
                  }, {
                    key: "handleCharacterData",
                    value: function handleCharacterData(config3) {
                      var topic = config3.topic, data = config3.data;
                      this.eventEmitter.emit(EV_ON_DATA, topic, data);
                    }
                  }, {
                    key: "handleCharacterError",
                    value: function handleCharacterError(config3) {
                      var data = config3.data;
                      var errorListenerCount = this.eventEmitter.listenerCount(EV_ON_ERROR);
                      if (errorListenerCount > 0) {
                        this.eventEmitter.emit(EV_ON_ERROR, data);
                      }
                    }
                  }, {
                    key: "enableMic",
                    value: function enableMic() {
                      _classPrivateFieldGet(_roomClient, this).enablePeerMic(this.id);
                    }
                  }, {
                    key: "disableMic",
                    value: function disableMic() {
                      _classPrivateFieldGet(_roomClient, this).disablePeerMic(this.id);
                    }
                  }, {
                    key: "enableWebcam",
                    value: function enableWebcam() {
                      _classPrivateFieldGet(_roomClient, this).enablePeerWebcam(this.id);
                    }
                  }, {
                    key: "disableWebcam",
                    value: function disableWebcam() {
                      _classPrivateFieldGet(_roomClient, this).disablePeerWebcam(this.id);
                    }
                  }, {
                    key: "updateStream",
                    value: function updateStream(stream) {
                      throw new Error("updateStream method is not supported on character");
                    }
                  }, {
                    key: "switchTo",
                    value: function() {
                      var _switchTo = (0, asyncToGenerator.A)(regenerator_default().mark(function _callee7(_ref3) {
                        var meetingId, payload, token;
                        return regenerator_default().wrap(function(_context7) {
                          while (1) switch (_context7.prev = _context7.next) {
                            case 0:
                              meetingId = _ref3.meetingId, payload = _ref3.payload, token = _ref3.token;
                              throw new Error("switchTo method is not supported on character");
                            case 1:
                            case "end":
                              return _context7.stop();
                          }
                        }, _callee7);
                      }));
                      function switchTo(_x2) {
                        return _switchTo.apply(this, arguments);
                      }
                      return switchTo;
                    }()
                    /**
                     * @param {"SHARE_AND_CAM" | "CAM" | "SHARE"} type
                     */
                  }, {
                    key: "pin",
                    value: function pin(type) {
                      throw new Error("pin method is not supported on character");
                    }
                    /**
                     * Add event listener
                     * @param {EV_STREAM_ENABLED | EV_STREAM_DISABLED | EV_CHARACTER_JOINED | EV_CHARACTER_LEFT | EV_MEDIA_STATUS_CHANGED | EV_VIDEO_QUALITY_CHANGED | EV_CHARACTER_STATE_CHANGED | EV_CHARACTER_MESSAGE | EV_USER_MESSAGE | EV_ON_DATA | EV_ON_ERROR} eventType
                     * @param {Function} listener Callback function
                     */
                  }, {
                    key: "on",
                    value: function on(eventType, listener) {
                      switch (eventType) {
                        case character_EV_STREAM_ENABLED:
                        case character_EV_STREAM_DISABLED:
                        case EV_CHARACTER_JOINED:
                        case EV_CHARACTER_LEFT:
                        case character_EV_MEDIA_STATUS_CHANGED:
                        case character_EV_VIDEO_QUALITY_CHANGED:
                        case EV_CHARACTER_STATE_CHANGED:
                        case EV_CHARACTER_MESSAGE:
                        case EV_USER_MESSAGE:
                        case EV_ON_DATA:
                        case EV_ON_ERROR:
                          this.eventEmitter.on(eventType, listener);
                          break;
                        default:
                          throw new Error("Invalid event type");
                      }
                    }
                    /**
                     * Remove event listener
                     * @param {EV_STREAM_ENABLED | EV_STREAM_DISABLED | EV_CHARACTER_JOINED | EV_CHARACTER_LEFT | EV_MEDIA_STATUS_CHANGED | EV_VIDEO_QUALITY_CHANGED | EV_CHARACTER_STATE_CHANGED | EV_CHARACTER_MESSAGE | EV_USER_MESSAGE | EV_ON_DATA | EV_ON_ERROR} eventType
                     * @param {Function} listener Callback function
                     */
                  }, {
                    key: "off",
                    value: function off(eventType, listener) {
                      switch (eventType) {
                        case character_EV_STREAM_ENABLED:
                        case character_EV_STREAM_DISABLED:
                        case EV_CHARACTER_JOINED:
                        case EV_CHARACTER_LEFT:
                        case character_EV_MEDIA_STATUS_CHANGED:
                        case character_EV_VIDEO_QUALITY_CHANGED:
                        case EV_CHARACTER_STATE_CHANGED:
                        case EV_CHARACTER_MESSAGE:
                        case EV_USER_MESSAGE:
                        case EV_ON_DATA:
                        case EV_ON_ERROR:
                          this.eventEmitter.off(eventType, listener);
                          break;
                        default:
                          throw new Error("Invalid event type");
                      }
                    }
                  }, {
                    key: "state",
                    get: function get() {
                      return _classPrivateFieldGet(_state, this);
                    }
                  }, {
                    key: "knowledgeBases",
                    get: function get() {
                      return _classPrivateFieldGet(_knowledgeBases, this);
                    }
                  }, {
                    key: "characterMode",
                    get: function get() {
                      return _classPrivateFieldGet(_characterMode, this);
                    }
                  }, {
                    key: "characterRole",
                    get: function get() {
                      return _classPrivateFieldGet(_characterRole, this);
                    }
                  }, {
                    key: "interactionId",
                    get: function get() {
                      return _classPrivateFieldGet(_interactionId, this);
                    }
                  }, {
                    key: "language",
                    get: function get() {
                      return _classPrivateFieldGet(_language, this);
                    }
                  }]);
                }(Participant);
                function _updateState(status) {
                  _classPrivateFieldSet(_state, this, status);
                }
                ;
                function connectionParticipant_classPrivateFieldInitSpec(e, t, a) {
                  connectionParticipant_checkPrivateRedeclaration(e, t), t.set(e, a);
                }
                function connectionParticipant_checkPrivateRedeclaration(e, t) {
                  if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object");
                }
                function connectionParticipant_classPrivateFieldGet(s, a) {
                  return s.get(connectionParticipant_assertClassBrand(s, a));
                }
                function connectionParticipant_classPrivateFieldSet(s, a, r) {
                  return s.set(connectionParticipant_assertClassBrand(s, a), r), r;
                }
                function connectionParticipant_assertClassBrand(e, t, n) {
                  if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n;
                  throw new TypeError("Private element is not present on this object");
                }
                var _connectionRoomId = /* @__PURE__ */ new WeakMap();
                var ConnectionParticipant = function() {
                  function ConnectionParticipant2(_ref, connectionRoomId) {
                    var id = _ref.id, displayName = _ref.displayName;
                    (0, classCallCheck.A)(this, ConnectionParticipant2);
                    connectionParticipant_classPrivateFieldInitSpec(this, _connectionRoomId, void 0);
                    this.id = id;
                    this.displayName = displayName;
                    connectionParticipant_classPrivateFieldSet(_connectionRoomId, this, connectionRoomId);
                  }
                  return (0, createClass.A)(ConnectionParticipant2, [{
                    key: "switchTo",
                    value: function() {
                      var _switchTo = (0, asyncToGenerator.A)(regenerator_default().mark(function _callee(_ref2) {
                        var meetingId, payload, token;
                        return regenerator_default().wrap(function(_context) {
                          while (1) switch (_context.prev = _context.next) {
                            case 0:
                              meetingId = _ref2.meetingId, payload = _ref2.payload, token = _ref2.token;
                              _context.next = 1;
                              return Store.roomClient.connectionSwitchPeerRoom({
                                roomId: meetingId,
                                connectionRoomId: connectionParticipant_classPrivateFieldGet(_connectionRoomId, this),
                                payload,
                                peerId: this.id,
                                token
                              });
                            case 1:
                            case "end":
                              return _context.stop();
                          }
                        }, _callee, this);
                      }));
                      function switchTo(_x) {
                        return _switchTo.apply(this, arguments);
                      }
                      return switchTo;
                    }()
                  }]);
                }();
                ;
                var EV_PARTICIPANT_JOINED = "participant-joined";
                var EV_PARTICIPANT_LEFT = "participant-left";
                var EV_DATA = "data";
                var ConnectionMeeting = function() {
                  function ConnectionMeeting2(roomId, peers2) {
                    var _this = this;
                    (0, classCallCheck.A)(this, ConnectionMeeting2);
                    this.eventEmitter = new events2.EventEmitter();
                    this.id = roomId;
                    this.participants = /* @__PURE__ */ new Map();
                    peers2.forEach(function(peer) {
                      _this.participants.set(peer.id, new ConnectionParticipant(peer, _this.id));
                    });
                  }
                  return (0, createClass.A)(ConnectionMeeting2, [{
                    key: "participantJoin",
                    value: function participantJoin(peer) {
                      var connectionParticipant = new ConnectionParticipant(peer, this.id);
                      this.participants.set(peer.id, connectionParticipant);
                      this.eventEmitter.emit(EV_PARTICIPANT_JOINED, connectionParticipant);
                    }
                  }, {
                    key: "participantLeft",
                    value: function participantLeft(peerId) {
                      this.participants["delete"](peerId);
                      this.eventEmitter.emit(EV_PARTICIPANT_LEFT, peerId);
                    }
                    /**
                     *
                     * @param {string} message
                     */
                  }, {
                    key: "sendChatMessage",
                    value: function sendChatMessage(message) {
                      Store.roomClient.connectionSendChatMessage({
                        roomId: this.id,
                        message
                      });
                    }
                  }, {
                    key: "sendChatMessageEvent",
                    value: function sendChatMessageEvent(_ref) {
                      var participantId = _ref.participantId, message = _ref.message;
                      this.eventEmitter.emit(EV_DATA, {
                        participantId,
                        message
                      });
                    }
                  }, {
                    key: "end",
                    value: function() {
                      var _end = (0, asyncToGenerator.A)(regenerator_default().mark(function _callee() {
                        return regenerator_default().wrap(function(_context) {
                          while (1) switch (_context.prev = _context.next) {
                            case 0:
                              _context.next = 1;
                              return Store.roomClient.connectionEndMeeting({
                                roomId: this.id
                              });
                            case 1:
                            case "end":
                              return _context.stop();
                          }
                        }, _callee, this);
                      }));
                      function end() {
                        return _end.apply(this, arguments);
                      }
                      return end;
                    }()
                    /**
                     * Add event listener
                     * @param {EV_PARTICIPANT_JOINED | EV_PARTICIPANT_LEFT | EV_DATA} eventType
                     * @param {Function} listener Callback function
                     */
                  }, {
                    key: "on",
                    value: function on(eventType, listener) {
                      switch (eventType) {
                        case EV_PARTICIPANT_JOINED:
                        case EV_PARTICIPANT_LEFT:
                        case EV_DATA:
                          this.eventEmitter.on(eventType, listener);
                          break;
                        default:
                          throw new Error("Invalid event type");
                      }
                    }
                    /**
                     * Remove event listener
                     * @param {EV_PARTICIPANT_JOINED | EV_PARTICIPANT_LEFT | EV_DATA} eventType
                     * @param {Function} listener Callback function
                     */
                  }, {
                    key: "off",
                    value: function off(eventType, listener) {
                      switch (eventType) {
                        case EV_PARTICIPANT_JOINED:
                        case EV_PARTICIPANT_LEFT:
                        case EV_DATA:
                          this.eventEmitter.off(eventType, listener);
                          break;
                        default:
                          throw new Error("Invalid event type");
                      }
                    }
                  }]);
                }();
                ;
                var Connection = function() {
                  function Connection2(_ref) {
                    var roomId = _ref.roomId, peers2 = _ref.peers, payload = _ref.payload;
                    (0, classCallCheck.A)(this, Connection2);
                    this.id = roomId;
                    this.payload = payload;
                    this.meeting = new ConnectionMeeting(roomId, peers2);
                  }
                  return (0, createClass.A)(Connection2, [{
                    key: "close",
                    value: function close() {
                      Store.roomClient.closeConnection(this.id);
                    }
                  }]);
                }();
                var LeaveReason = __webpack_require__2(1260);
                ;
                function meeting_ownKeys(e, r) {
                  var t = Object.keys(e);
                  if (Object.getOwnPropertySymbols) {
                    var o = Object.getOwnPropertySymbols(e);
                    r && (o = o.filter(function(r2) {
                      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
                    })), t.push.apply(t, o);
                  }
                  return t;
                }
                function meeting_objectSpread(e) {
                  for (var r = 1; r < arguments.length; r++) {
                    var t = null != arguments[r] ? arguments[r] : {};
                    r % 2 ? meeting_ownKeys(Object(t), true).forEach(function(r2) {
                      (0, defineProperty.A)(e, r2, t[r2]);
                    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : meeting_ownKeys(Object(t)).forEach(function(r2) {
                      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
                    });
                  }
                  return e;
                }
                function meeting_classPrivateMethodInitSpec(e, a) {
                  meeting_checkPrivateRedeclaration(e, a), a.add(e);
                }
                function meeting_classPrivateFieldInitSpec(e, t, a) {
                  meeting_checkPrivateRedeclaration(e, t), t.set(e, a);
                }
                function meeting_checkPrivateRedeclaration(e, t) {
                  if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object");
                }
                function meeting_classPrivateFieldGet(s, a) {
                  return s.get(meeting_assertClassBrand(s, a));
                }
                function meeting_classPrivateFieldSet(s, a, r) {
                  return s.set(meeting_assertClassBrand(s, a), r), r;
                }
                function meeting_assertClassBrand(e, t, n) {
                  if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n;
                  throw new TypeError("Private element is not present on this object");
                }
                var EV_ERROR = "error";
                var EV_MEETING_JOINED = "meeting-joined";
                var EV_MEETING_LEFT = "meeting-left";
                var EV_PARTICIPANT_MODE_CHANGED = "participant-mode-changed";
                var meeting_EV_PARTICIPANT_JOINED = "participant-joined";
                var meeting_EV_PARTICIPANT_LEFT = "participant-left";
                var EV_SPEAKER_CHANGED = "speaker-changed";
                var EV_PRESENTER_CHANGED = "presenter-changed";
                var EV_MAIN_PARTICIPANT_CHANGED = "main-participant-changed";
                var meeting_EV_DATA = "data";
                var EV_ENTRY_REQUESTED = "entry-requested";
                var EV_ENTRY_RESPONDED = "entry-responded";
                var EV_RECORDING_STATE_CHANGED = "recording-state-changed";
                var EV_RECORDING_STARTED = "recording-started";
                var EV_RECORDING_STOPPED = "recording-stopped";
                var EV_LIVESTREAM_STATE_CHANGED = "livestream-state-changed";
                var EV_LIVESTREAM_STARTED = "livestream-started";
                var EV_LIVESTREAM_STOPPED = "livestream-stopped";
                var EV_HLS_STATE_CHANGED = "hls-state-changed";
                var EV_HLS_STARTED = "hls-started";
                var EV_HLS_STOPPED = "hls-stopped";
                var EV_WHITEBOARD_STARTED = "whiteboard-started";
                var EV_WHITEBOARD_STOPPED = "whiteboard-stopped";
                var EV_VIDEO_STATE_CHANGED = "video-state-changed";
                var EV_VIDEO_SEEKED = "video-seeked";
                var EV_MIC_REQUESTED = "mic-requested";
                var EV_WEBCAM_REQUESTED = "webcam-requested";
                var meeting_EV_STREAM_ENABLED = "stream-enabled";
                var meeting_EV_STREAM_DISABLED = "stream-disabled";
                var EV_PIN_STATE_CHANGED = "pin-state-changed";
                var EV_CONNECTION_OPEN = "connection-open";
                var EV_CONNECTION_CLOSE = "connection-close";
                var EV_SWITCH_MEETING = "switch-meeting";
                var EV_MEETING_STATE_CHANGE = "meeting-state-changed";
                var EV_QUALITY_LIMITATION = "quality-limitation";
                var EV_ALL_STREAMS_PAUSED = "paused-all-streams";
                var EV_ALL_STREAMS_RESUMED = "resumed-all-streams";
                var EV_TRANSCRIPTION_STATE_CHANGED = "transcription-state-changed";
                var EV_TRANSCRIPTION_TEXT = "transcription-text";
                var EV_TRANSLATION_STATE_CHANGED = "translation-state-changed";
                var EV_TRANSLATION_TEXT = "translation-text";
                var EV_TRANSLATION_LANGUAGE_CHANGED = "translation-language-changed";
                var meeting_EV_CHARACTER_JOINED = "character-joined";
                var meeting_EV_CHARACTER_LEFT = "character-left";
                var EV_MEDIA_RELAY_STARTED = "media-relay-started";
                var EV_MEDIA_RELAY_STOPPED = "media-relay-stopped";
                var EV_MEDIA_RELAY_ERROR = "media-relay-error";
                var EV_MEDIA_RELAY_REQUEST_RESPONSE = "media-relay-request-response";
                var EV_MEDIA_RELAY_REQUEST_RECEIVED = "media-relay-request-received";
                var _topicEventEmitter = /* @__PURE__ */ new WeakMap();
                var _realtimeStoreEventEmitter = /* @__PURE__ */ new WeakMap();
                var _Meeting_brand = /* @__PURE__ */ new WeakSet();
                var Meeting = function() {
                  function Meeting2(meetingId, localParticipant, roomClient) {
                    var _this = this;
                    (0, classCallCheck.A)(this, Meeting2);
                    meeting_classPrivateMethodInitSpec(this, _Meeting_brand);
                    meeting_classPrivateFieldInitSpec(this, _topicEventEmitter, void 0);
                    meeting_classPrivateFieldInitSpec(this, _realtimeStoreEventEmitter, void 0);
                    (0, defineProperty.A)(this, "pubSub", {
                      /**
                       * Publish message to a topic
                       *
                       * @param {String} topic
                       * @param {String} message
                       * @param {{ persist: boolean, sendOnly: Array<String> }} options
                       * @param {object} payload
                       */
                      publish: function() {
                        var _publish = (0, asyncToGenerator.A)(regenerator_default().mark(function _callee(topic, message, options, payload) {
                          return regenerator_default().wrap(function(_context) {
                            while (1) switch (_context.prev = _context.next) {
                              case 0:
                                if (!(payload != void 0)) {
                                  _context.next = 1;
                                  break;
                                }
                                if (!((0, esm_typeof.A)(payload) != "object")) {
                                  _context.next = 1;
                                  break;
                                }
                                throw new Error('"payload" can only be object.');
                              case 1:
                                _context.next = 2;
                                return _this.roomClient.pubsubPublish(topic, message, options, payload);
                              case 2:
                              case "end":
                                return _context.stop();
                            }
                          }, _callee);
                        }));
                        function publish(_x, _x2, _x3, _x4) {
                          return _publish.apply(this, arguments);
                        }
                        return publish;
                      }(),
                      /**
                       * Subscribe to message on a topic
                       *
                       * @param {String} topic
                       * @param {Function} callback
                       */
                      subscribe: function() {
                        var _subscribe = (0, asyncToGenerator.A)(regenerator_default().mark(function _callee2(topic, callback) {
                          var messageArr;
                          return regenerator_default().wrap(function(_context2) {
                            while (1) switch (_context2.prev = _context2.next) {
                              case 0:
                                if (!meeting_classPrivateFieldGet(_topicEventEmitter, _this).listeners(topic).includes(callback)) {
                                  _context2.next = 1;
                                  break;
                                }
                                return _context2.abrupt("return");
                              case 1:
                                _context2.next = 2;
                                return _this.roomClient.pubsubSubscribe(topic);
                              case 2:
                                messageArr = _context2.sent;
                                meeting_classPrivateFieldGet(_topicEventEmitter, _this).on(topic, callback);
                                return _context2.abrupt("return", messageArr);
                              case 3:
                              case "end":
                                return _context2.stop();
                            }
                          }, _callee2);
                        }));
                        function subscribe(_x5, _x6) {
                          return _subscribe.apply(this, arguments);
                        }
                        return subscribe;
                      }(),
                      /**
                       * Unsubscribe from messages on a topic
                       *
                       * @param {String} topic
                       * @param {Function} callback
                       */
                      unsubscribe: function() {
                        var _unsubscribe = (0, asyncToGenerator.A)(regenerator_default().mark(function _callee3(topic, callback) {
                          return regenerator_default().wrap(function(_context3) {
                            while (1) switch (_context3.prev = _context3.next) {
                              case 0:
                                meeting_classPrivateFieldGet(_topicEventEmitter, _this).off(topic, callback);
                                if (!(meeting_classPrivateFieldGet(_topicEventEmitter, _this).listeners(topic).length == 0)) {
                                  _context3.next = 1;
                                  break;
                                }
                                _context3.next = 1;
                                return _this.roomClient.pubsubUnsubscribe(topic);
                              case 1:
                              case "end":
                                return _context3.stop();
                            }
                          }, _callee3);
                        }));
                        function unsubscribe(_x7, _x8) {
                          return _unsubscribe.apply(this, arguments);
                        }
                        return unsubscribe;
                      }()
                    });
                    (0, defineProperty.A)(this, "realtimeStore", {
                      /**
                       * Set or update a key-value pair in the RealtimeStore.
                       *
                       * @async
                       * @param {String} key - The key for which you want to set the value.
                       * @param {String|null} value - The value to set (string only). Pass `null` to delete the key.
                       * @returns {Promise<void>}
                       *
                       * @throws {Error} If key is invalid or missing.
                       * @throws {Error} If value is not a string or exceeds 1 KB.
                       * @throws {Error} If request fails.
                       */
                      setValue: function() {
                        var _setValue = (0, asyncToGenerator.A)(regenerator_default().mark(function _callee4(key, value) {
                          return regenerator_default().wrap(function(_context4) {
                            while (1) switch (_context4.prev = _context4.next) {
                              case 0:
                                _context4.next = 1;
                                return _this.roomClient.setValue(key, value);
                              case 1:
                                return _context4.abrupt("return", _context4.sent);
                              case 2:
                              case "end":
                                return _context4.stop();
                            }
                          }, _callee4);
                        }));
                        function setValue(_x9, _x0) {
                          return _setValue.apply(this, arguments);
                        }
                        return setValue;
                      }(),
                      /**
                       * Retrieve the value associated with a key from the RealtimeStore.
                       *
                       * @async
                       * @param {String} key - The key whose value should be retrieved.
                       * @returns {Promise<String|null>} - Returns the stored value from the RealtimeStore.
                       *
                       * @throws {Error} If key doesnt exist or request fails.
                       */
                      getValue: function() {
                        var _getValue = (0, asyncToGenerator.A)(regenerator_default().mark(function _callee5(key) {
                          return regenerator_default().wrap(function(_context5) {
                            while (1) switch (_context5.prev = _context5.next) {
                              case 0:
                                _context5.next = 1;
                                return _this.roomClient.getValue(key);
                              case 1:
                                return _context5.abrupt("return", _context5.sent);
                              case 2:
                              case "end":
                                return _context5.stop();
                            }
                          }, _callee5);
                        }));
                        function getValue(_x1) {
                          return _getValue.apply(this, arguments);
                        }
                        return getValue;
                      }(),
                      /**
                       * Observe changes for a given key in the RealtimeStore.
                       * The callback is triggered whenever the keys value changes.
                       *
                       * @async
                       * @param {String} key - The key to observe.
                       * @param {Function} callback - Function called with `(value, updatedBy)` on updates.
                       * @returns {Promise<String>} - A unique observer ID used to stop observing.
                       *
                       * @throws {Error} If key is invalid or missing.
                       * @throws {Error} If callback is not a function.
                       * @throws {Error} If subscription request fails.
                       */
                      observe: function() {
                        var _observe = (0, asyncToGenerator.A)(regenerator_default().mark(function _callee6(key, callback) {
                          var observerId;
                          return regenerator_default().wrap(function(_context6) {
                            while (1) switch (_context6.prev = _context6.next) {
                              case 0:
                                if (!(key === void 0 || key === null)) {
                                  _context6.next = 1;
                                  break;
                                }
                                throw new Error("The 'key' parameter is required.");
                              case 1:
                                if (!(typeof key !== "string")) {
                                  _context6.next = 2;
                                  break;
                                }
                                throw new TypeError("Invalid type for 'key'. Expected a string.");
                              case 2:
                                if (!meeting_classPrivateFieldGet(_realtimeStoreEventEmitter, _this).listeners(key).includes(callback)) {
                                  _context6.next = 3;
                                  break;
                                }
                                return _context6.abrupt("return");
                              case 3:
                                _context6.next = 4;
                                return _this.roomClient.observe(key);
                              case 4:
                                observerId = Math.random().toString(36).substring(2, 10);
                                _this.observers.set(observerId, {
                                  key,
                                  callback
                                });
                                meeting_classPrivateFieldGet(_realtimeStoreEventEmitter, _this).on(key, callback);
                                return _context6.abrupt("return", observerId);
                              case 5:
                              case "end":
                                return _context6.stop();
                            }
                          }, _callee6);
                        }));
                        function observe(_x10, _x11) {
                          return _observe.apply(this, arguments);
                        }
                        return observe;
                      }(),
                      /**
                       * Stop observing updates for a specific observer ID.
                       *
                       * @async
                       * @param {String} observerId - The observer ID returned by `observe()`.
                       * @returns {Promise<void>}
                       *
                       * @throws {Error} If observerId is invalid or not found.
                       * @throws {Error} If unsubscribe request fails.
                       */
                      stopObserving: function() {
                        var _stopObserving = (0, asyncToGenerator.A)(regenerator_default().mark(function _callee7(observerId) {
                          var observer, key, callback;
                          return regenerator_default().wrap(function(_context7) {
                            while (1) switch (_context7.prev = _context7.next) {
                              case 0:
                                if (!(observerId === void 0 || observerId === null)) {
                                  _context7.next = 1;
                                  break;
                                }
                                throw new Error("The 'observerId' parameter is required.");
                              case 1:
                                observer = _this.observers.get(observerId);
                                if (observer) {
                                  _context7.next = 2;
                                  break;
                                }
                                return _context7.abrupt("return");
                              case 2:
                                key = observer.key, callback = observer.callback;
                                meeting_classPrivateFieldGet(_realtimeStoreEventEmitter, _this).off(key, callback);
                                if (!(meeting_classPrivateFieldGet(_realtimeStoreEventEmitter, _this).listeners(key).length == 0)) {
                                  _context7.next = 3;
                                  break;
                                }
                                _context7.next = 3;
                                return _this.roomClient.stopObserving(key);
                              case 3:
                              case "end":
                                return _context7.stop();
                            }
                          }, _callee7);
                        }));
                        function stopObserving(_x12) {
                          return _stopObserving.apply(this, arguments);
                        }
                        return stopObserving;
                      }()
                    });
                    (0, defineProperty.A)(this, "uploadBase64File", function() {
                      var _ref2 = (0, asyncToGenerator.A)(regenerator_default().mark(function _callee8(_ref) {
                        var base64Data, token, fileName, url, requestBody, apiResponse, responseData, _t;
                        return regenerator_default().wrap(function(_context8) {
                          while (1) switch (_context8.prev = _context8.next) {
                            case 0:
                              base64Data = _ref.base64Data, token = _ref.token, fileName = _ref.fileName;
                              _context8.prev = 1;
                              if (!(!base64Data || !token || !fileName)) {
                                _context8.next = 2;
                                break;
                              }
                              throw new Error("please provide base64Data, token and fileName");
                            case 2:
                              url = "https://".concat(_this.baseUrl, "/base64-upload?roomId=").concat(_this.id);
                              requestBody = {
                                fileName,
                                base64Data
                              };
                              _context8.next = 3;
                              return fetch(url, {
                                method: "POST",
                                body: JSON.stringify(requestBody),
                                headers: {
                                  "Content-Type": "application/json",
                                  Authorization: token
                                }
                              });
                            case 3:
                              apiResponse = _context8.sent;
                              _context8.next = 4;
                              return apiResponse.json();
                            case 4:
                              responseData = _context8.sent;
                              return _context8.abrupt("return", responseData.url);
                            case 5:
                              _context8.prev = 5;
                              _t = _context8["catch"](1);
                              console.error("Error while Uploading Base64 File::", _t);
                              if (_this.roomClient._videosdkLogs) {
                                _this.roomClient._videosdkLogs.pushLogs({
                                  logText: "Error while Uploading Base64 File",
                                  logType: "ERROR",
                                  attributes: {
                                    error: _t.message
                                  }
                                });
                              }
                            case 6:
                            case "end":
                              return _context8.stop();
                          }
                        }, _callee8, null, [[1, 5]]);
                      }));
                      return function(_x13) {
                        return _ref2.apply(this, arguments);
                      };
                    }());
                    (0, defineProperty.A)(this, "fetchBase64File", function() {
                      var _ref4 = (0, asyncToGenerator.A)(regenerator_default().mark(function _callee9(_ref3) {
                        var url, token, res, binaryData, base64Data, _t2;
                        return regenerator_default().wrap(function(_context9) {
                          while (1) switch (_context9.prev = _context9.next) {
                            case 0:
                              url = _ref3.url, token = _ref3.token;
                              _context9.prev = 1;
                              if (!(!url || !token)) {
                                _context9.next = 2;
                                break;
                              }
                              throw new Error("please provide url and token");
                            case 2:
                              _context9.next = 3;
                              return fetch(url, {
                                headers: {
                                  Authorization: token
                                }
                              });
                            case 3:
                              res = _context9.sent;
                              _context9.next = 4;
                              return res.arrayBuffer();
                            case 4:
                              binaryData = _context9.sent;
                              base64Data = window.btoa(new Uint8Array(binaryData).reduce(function(data, _byte) {
                                return data + String.fromCharCode(_byte);
                              }, ""));
                              return _context9.abrupt("return", base64Data);
                            case 5:
                              _context9.prev = 5;
                              _t2 = _context9["catch"](1);
                              console.error("Error while fetching Base64 File::", _t2);
                              if (_this.roomClient._videosdkLogs) {
                                _this.roomClient._videosdkLogs.pushLogs({
                                  logText: "Error while fetching Base64 File",
                                  logType: "ERROR",
                                  attributes: {
                                    error: _t2.message
                                  }
                                });
                              }
                            case 6:
                            case "end":
                              return _context9.stop();
                          }
                        }, _callee9, null, [[1, 5]]);
                      }));
                      return function(_x14) {
                        return _ref4.apply(this, arguments);
                      };
                    }());
                    this.id = meetingId;
                    this.roomClient = roomClient;
                    this.activeSpeakerId = null;
                    this.activePresenterId = null;
                    this.mainParticipantId = null;
                    this.connections = /* @__PURE__ */ new Map();
                    this.localParticipant = localParticipant;
                    this.participants = /* @__PURE__ */ new Map();
                    this.characters = /* @__PURE__ */ new Map();
                    this.baseUrl = null;
                    this.livestreamState = "LIVESTREAM_STOPPED";
                    this.recordingState = "RECORDING_STOPPED";
                    this.hlsState = "HLS_STOPPED";
                    this.transcriptionState = "TRANSCRIPTION_STOPPED";
                    this.translationState = "TRANSLATION_STOPPED";
                    this.hlsUrls = {
                      downstreamUrl: null,
                      playbackHlsUrl: null,
                      livestreamUrl: null
                    };
                    this.messages = [];
                    this.observers = /* @__PURE__ */ new Map();
                    this.eventEmitter = new events2.EventEmitter();
                    meeting_classPrivateFieldSet(_topicEventEmitter, this, new events2.EventEmitter());
                    meeting_classPrivateFieldSet(_realtimeStoreEventEmitter, this, new events2.EventEmitter());
                    this.eventEmitter.setMaxListeners(9999);
                    meeting_classPrivateFieldGet(_topicEventEmitter, this).setMaxListeners(9999);
                    meeting_classPrivateFieldGet(_realtimeStoreEventEmitter, this).setMaxListeners(9999);
                    this.roomClient.on("ERROR", function(d) {
                      return _this.handleError(d);
                    });
                    this.roomClient.on("ADD_PEER", function(d) {
                      return _this.handlePeerAdd(d);
                    });
                    this.roomClient.on("REMOVE_PEER", function(d) {
                      return _this.handlePeerRemove(d);
                    });
                    this.roomClient.on("STREAM_STATE_CHANGED", function(d) {
                      return _this.handleStreamState(d);
                    });
                    this.roomClient.on("ADD_PRODUCER", function(d) {
                      return _this.handleProducerAdd(d);
                    });
                    this.roomClient.on("UPDATE_PRODUCER", function(d) {
                      return _this.handleUpdateProducer(d);
                    });
                    this.roomClient.on("REMOVE_PRODUCER", function(d) {
                      return _this.handleProducerRemove(d);
                    });
                    this.roomClient.on("ADD_CONSUMER", function(d) {
                      return _this.handleConsumerAdd(d);
                    });
                    this.roomClient.on("REMOVE_CONSUMER", function(d) {
                      return _this.handleConsumerRemove(d);
                    });
                    this.roomClient.on("CONSUMER_RESUMED", function(d) {
                      return _this.handleConsumerResume(d);
                    });
                    this.roomClient.on("CONSUMER_PAUSED", function(d) {
                      return _this.handleConsumerPause(d);
                    });
                    this.roomClient.on("PARTICIPANT_MEDIA_STATE_CHANGED", function(d) {
                      return _this.handleParticipantMediaStateChanged(d);
                    });
                    this.roomClient.on("DATA", function(d) {
                      return _this.handleNewChatMessage(d);
                    });
                    this.roomClient.on("SET_ROOM_ACTIVE_SPEAKER", function(d) {
                      return _this.handleSpeakerChange(d);
                    });
                    this.roomClient.on("ENTRY_REQUESTED", function(d) {
                      return _this.handleEntryRequested(d);
                    });
                    this.roomClient.on("ENTRY_RESPONDED", function(d) {
                      return _this.handleEntryResponded(d);
                    });
                    this.roomClient.on("MEETING_JOINED", function(d) {
                      return _this.handleMeetingJoined(d);
                    });
                    this.roomClient.on("MEETING_LEFT", function(d) {
                      return _this.handleMeetingLeft(d);
                    });
                    this.roomClient.on("RECORDING_STATE_CHANGED", function(d) {
                      _this.handleRecordingStateChanged(d);
                    });
                    this.roomClient.on("RECORDING_STARTED", function(d) {
                      return _this.handleRecordingStarted(d);
                    });
                    this.roomClient.on("RECORDING_STOPPED", function(d) {
                      return _this.handleRecordingStopped(d);
                    });
                    this.roomClient.on("LIVESTREAM_STATE_CHANGED", function(d) {
                      _this.handleLivestreamStateChanged(d);
                    });
                    this.roomClient.on("LIVESTREAM_STARTED", function(d) {
                      return _this.handleLivestreamStarted(d);
                    });
                    this.roomClient.on("LIVESTREAM_STOPPED", function(d) {
                      return _this.handleLivestreamStopped(d);
                    });
                    this.roomClient.on("HLS_STATE_CHANGED", function(d) {
                      _this.handleHlsStateChanged(d);
                    });
                    this.roomClient.on("HLS_STARTED", function(d) {
                      _this.handleHlsStarted(d);
                    });
                    this.roomClient.on("HLS_STOPPED", function(d) {
                      _this.handleHlsStopped(d);
                    });
                    this.roomClient.on("TRANSCRIPTION_STATE_CHANGED", function(d) {
                      _this.handleTranscriptionStateChanged(d);
                    });
                    this.roomClient.on("TRANSCRIPTION_TEXT", function(d) {
                      _this.handleTranscriptionText(d);
                    });
                    this.roomClient.on("TRANSLATION_STATE_CHANGED", function(d) {
                      _this.handleTranslationStateChanged(d);
                    });
                    this.roomClient.on("TRANSLATION_TEXT", function(d) {
                      _this.handleTranslationText(d);
                    });
                    this.roomClient.on("TRANSLATION_LANGUAGE_CHANGED", function(d) {
                      _this.handleTranslationLanguageChanged(d);
                    });
                    this.roomClient.on("SUB_MANAGER_RESUMED", function(d) {
                      _this.handleParticipantResumeBySubManager(d);
                    });
                    this.roomClient.on("SUB_MANAGER_PAUSED", function(d) {
                      _this.handleParticipantPausedBySubManager(d);
                    });
                    this.roomClient.on("WHITEBOARD_STARTED", function(d) {
                      return _this.handleWhiteboardStarted(d);
                    });
                    this.roomClient.on("WHITEBOARD_STOPPED", function(d) {
                      return _this.handleWhiteboardStopped(d);
                    });
                    this.roomClient.on("VIDEO_STATE_CHANGED", function(d) {
                      return _this.handleVideoStateChanged(d);
                    });
                    this.roomClient.on("VIDEO_SEEKED", function(d) {
                      return _this.handleVideoSeeked(d);
                    });
                    this.roomClient.on("PIN_STATE_CHANGED", function(d) {
                      _this.handlePinStateChanged(d);
                    });
                    this.roomClient.on("MIC_REQUESTED", function(d) {
                      return _this.handleMicRequested(d);
                    });
                    this.roomClient.on("WEBCAM_REQUESTED", function(d) {
                      return _this.handleWebcamRequested(d);
                    });
                    this.roomClient.on("CONNECTION_OPEN", function(d) {
                      return _this.handleConnectionOpen(d);
                    });
                    this.roomClient.on("CONNECTION_CLOSE", function(d) {
                      return _this.handleConnectionClose(d);
                    });
                    this.roomClient.on("CONNECTION_PARTICIPANT_JOIN", function(d) {
                      return _this.handleConnectionParticipantJoin(d);
                    });
                    this.roomClient.on("SWITCH_ROOM", function(d) {
                      return _this.handleSwitchMeeting(d);
                    });
                    this.roomClient.on("CONNECTION_CHAT_MESSAGE", function(d) {
                      return _this.handleConnectionChatMessage(d);
                    });
                    this.roomClient.on("CONNECTION_PARTICIPANT_LEFT", function(d) {
                      _this.handleConnectionParticipantLeft(d);
                    });
                    this.roomClient.on("PUBSUB_MESSAGE", function(d) {
                      return meeting_assertClassBrand(_Meeting_brand, _this, _handlePubsubMessage).call(_this, d);
                    });
                    this.roomClient.on("REALTIMESTORE_VALUE_CHANGED", function(d) {
                      return meeting_assertClassBrand(_Meeting_brand, _this, _handleRealtimeStoreValueChanged).call(_this, d);
                    });
                    this.roomClient.on("PEER_MODE_CHANGED", function(d) {
                      return meeting_assertClassBrand(_Meeting_brand, _this, _handlePeerModeChanged).call(_this, d);
                    });
                    this.updateMainParticipant(this.localParticipant.id);
                    this.roomClient.on("MEETING_STATE_CHANGED", function(d) {
                      return _this.handleMeetingStateChanged(d);
                    });
                    this.roomClient.on("QUALITY_LIMITATION_INTERNAL", function(d) {
                      return _this.handleQualityChanged(d);
                    });
                    this.roomClient.on("ALL_CONSUMERS_PAUSED", function(d) {
                      return _this.handleConsumersPaused(d);
                    });
                    this.roomClient.on("ALL_CONSUMERS_RESUMED", function(d) {
                      return _this.handleConsumersResumed(d);
                    });
                    this.roomClient.on("VIDEO_QUALITY_CHANGED", function(d) {
                      return _this.handleVideoQualityChanged(d);
                    });
                    this.roomClient.on("ADD_CHARACTER", function(d) {
                      return _this.handleAddCharacter(d);
                    });
                    this.roomClient.on("INIT_CHARACTER", function(d) {
                      return _this.handleInitCharacter(d);
                    });
                    this.roomClient.on("REMOVE_CHARACTER", function(d) {
                      return _this.handleRemoveCharacter(d);
                    });
                    this.roomClient.on("CHARACTER_STATE_CHANGED", function(d) {
                      return _this.handleCharacterStateChanged(d);
                    });
                    this.roomClient.on("CHARACTER_MESSAGE", function(d) {
                      return _this.handleCharacterMessage(d);
                    });
                    this.roomClient.on("USER_MESSAGE", function(d) {
                      return _this.handleUserMessage(d);
                    });
                    this.roomClient.on("CHARACTER_DATA", function(d) {
                      return _this.handleOnCharacterData(d);
                    });
                    this.roomClient.on("CHARACTER_ERROR", function(d) {
                      return _this.handleOnCharacterError(d);
                    });
                    this.roomClient.on("E2EE_STATE_CHANGE", function(d) {
                      return _this.handleE2EEStateChange(d);
                    });
                    this.roomClient.on("REMOVE_PARTICIPANTS_FOR_SWITCH_MEETING", function() {
                      return _this.handleOnRemoveCurrentMeetingParticipant();
                    });
                    this.roomClient.on("MEDIA_RELAY_STARTED", function(d) {
                      return _this.handleMediaRelayStart(d);
                    });
                    this.roomClient.on("MEDIA_RELAY_STOPPED", function(d) {
                      return _this.handleMediaRelayStop(d);
                    });
                    this.roomClient.on("MEDIA_RELAY_ERROR", function(d) {
                      return _this.handleMediaRelayError(d);
                    });
                    this.roomClient.on("MEDIA_RELAY_REQUEST_RESPONSE", function(d) {
                      return _this.handleMediaRelayRequestResponse(d);
                    });
                    this.roomClient.on("MEDIA_RELAY_REQUEST_RECEIVED", function(d) {
                      return _this.handleMediaRelayRequest(d);
                    });
                  }
                  return (0, createClass.A)(Meeting2, [{
                    key: "isE2EEEnabled",
                    get: function get() {
                      return this.roomClient.isE2EEEnabled;
                    }
                  }, {
                    key: "handleError",
                    value: function handleError(error) {
                      var errorListenerCount = this.eventEmitter.listenerCount(EV_ERROR);
                      if (errorListenerCount > 0) {
                        this.eventEmitter.emit(EV_ERROR, error);
                      }
                    }
                  }, {
                    key: "join",
                    value: function join() {
                      this.roomClient.join();
                    }
                  }, {
                    key: "changeMode",
                    value: function changeMode(mode) {
                      this.roomClient.changeMode(mode);
                    }
                  }, {
                    key: "leave",
                    value: function leave() {
                      this.roomClient.close({
                        sendLeft: true,
                        manualCalled: true
                      });
                    }
                  }, {
                    key: "end",
                    value: function end() {
                      this.roomClient.closeRoom();
                    }
                    /**
                     *
                     * @param {string} participantId
                     * @param {boolean} decision
                     */
                  }, {
                    key: "respondEntry",
                    value: function respondEntry(participantId, decision) {
                      this.roomClient.respondEntry(participantId, decision);
                    }
                    /**
                     * @returns {Map<string, Participant>}
                     */
                  }, {
                    key: "pinnedParticipants",
                    get: function get() {
                      return this.roomClient._pinnedParticipants;
                    }
                  }, {
                    key: "muteMic",
                    value: function muteMic() {
                      this.roomClient.disableMic();
                    }
                    /**
                     * @param {MediaStream | undefined} customAudioTrack?
                     */
                  }, {
                    key: "unmuteMic",
                    value: function unmuteMic() {
                      var customAudioTrack = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : void 0;
                      this.roomClient.enableMic(customAudioTrack);
                    }
                    /**
                     *
                     * @param {MediaStream | undefined} customAudioTrack?
                     * @returns
                     */
                  }, {
                    key: "publishAudio",
                    value: function() {
                      var _publishAudio = (0, asyncToGenerator.A)(regenerator_default().mark(function _callee0() {
                        var customAudioTrack, _args0 = arguments;
                        return regenerator_default().wrap(function(_context0) {
                          while (1) switch (_context0.prev = _context0.next) {
                            case 0:
                              customAudioTrack = _args0.length > 0 && _args0[0] !== void 0 ? _args0[0] : void 0;
                              _context0.next = 1;
                              return this.roomClient.enableMic(customAudioTrack);
                            case 1:
                              return _context0.abrupt("return");
                            case 2:
                            case "end":
                              return _context0.stop();
                          }
                        }, _callee0, this);
                      }));
                      function publishAudio() {
                        return _publishAudio.apply(this, arguments);
                      }
                      return publishAudio;
                    }()
                  }, {
                    key: "unpublishAudio",
                    value: function() {
                      var _unpublishAudio = (0, asyncToGenerator.A)(regenerator_default().mark(function _callee1() {
                        return regenerator_default().wrap(function(_context1) {
                          while (1) switch (_context1.prev = _context1.next) {
                            case 0:
                              _context1.next = 1;
                              return this.roomClient.disableMic();
                            case 1:
                              return _context1.abrupt("return");
                            case 2:
                            case "end":
                              return _context1.stop();
                          }
                        }, _callee1, this);
                      }));
                      function unpublishAudio() {
                        return _unpublishAudio.apply(this, arguments);
                      }
                      return unpublishAudio;
                    }()
                  }, {
                    key: "disableWebcam",
                    value: function disableWebcam() {
                      this.roomClient.disableWebcam();
                    }
                    /**
                     * @param {MediaStream | undefined} customVideoTrack?
                     */
                  }, {
                    key: "enableWebcam",
                    value: function enableWebcam() {
                      var customVideoTrack = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : void 0;
                      this.roomClient.enableWebcam(customVideoTrack);
                    }
                    /**
                     * @param {MediaStream | undefined} customVideoTrack?
                     */
                  }, {
                    key: "publishVideo",
                    value: function() {
                      var _publishVideo = (0, asyncToGenerator.A)(regenerator_default().mark(function _callee10() {
                        var customVideoTrack, _args10 = arguments;
                        return regenerator_default().wrap(function(_context10) {
                          while (1) switch (_context10.prev = _context10.next) {
                            case 0:
                              customVideoTrack = _args10.length > 0 && _args10[0] !== void 0 ? _args10[0] : void 0;
                              this.roomClient.enableWebcam(customVideoTrack);
                              return _context10.abrupt("return");
                            case 1:
                            case "end":
                              return _context10.stop();
                          }
                        }, _callee10, this);
                      }));
                      function publishVideo() {
                        return _publishVideo.apply(this, arguments);
                      }
                      return publishVideo;
                    }()
                  }, {
                    key: "unpublishVideo",
                    value: function() {
                      var _unpublishVideo = (0, asyncToGenerator.A)(regenerator_default().mark(function _callee11() {
                        return regenerator_default().wrap(function(_context11) {
                          while (1) switch (_context11.prev = _context11.next) {
                            case 0:
                              this.roomClient.disableWebcam();
                              return _context11.abrupt("return");
                            case 1:
                            case "end":
                              return _context11.stop();
                          }
                        }, _callee11, this);
                      }));
                      function unpublishVideo() {
                        return _unpublishVideo.apply(this, arguments);
                      }
                      return unpublishVideo;
                    }()
                  }, {
                    key: "disableScreenShare",
                    value: function disableScreenShare() {
                      this.roomClient.disableShare();
                    }
                    /**
                     *  @param {MediaStream | undefined}customScreenSharingTrack?
                     */
                  }, {
                    key: "enableScreenShare",
                    value: function enableScreenShare() {
                      var customScreenSharingTrack = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : void 0;
                      this.roomClient.enableShare(customScreenSharingTrack);
                    }
                    /**
                     *  @param {MediaStream | undefined}customScreenSharingTrack?
                     */
                  }, {
                    key: "pubblishScreenShare",
                    value: function pubblishScreenShare() {
                      var customScreenSharingTrack = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : void 0;
                      this.roomClient.enableShare(customScreenSharingTrack);
                    }
                  }, {
                    key: "unpublishScreenShare",
                    value: function unpublishScreenShare() {
                      this.roomClient.disableShare();
                    }
                    /**
                    * Send a message over the DataChannel with chunking.
                    *
                    * @param {string | Blob | ArrayBuffer | ArrayBufferView} payload - The message to send.
                    * @param {object} [options={}] - Additional send options.
                    * @param {("RELIABLE"|"UNRELIABLE")} [options.reliability="RELIABLE"] - Reliability mode for the message.
                    */
                  }, {
                    key: "send",
                    value: function() {
                      var _send = (0, asyncToGenerator.A)(regenerator_default().mark(function _callee12(payload, options) {
                        return regenerator_default().wrap(function(_context12) {
                          while (1) switch (_context12.prev = _context12.next) {
                            case 0:
                              _context12.next = 1;
                              return this.roomClient.send(payload, options);
                            case 1:
                              return _context12.abrupt("return", _context12.sent);
                            case 2:
                            case "end":
                              return _context12.stop();
                          }
                        }, _callee12, this);
                      }));
                      function send(_x15, _x16) {
                        return _send.apply(this, arguments);
                      }
                      return send;
                    }()
                  }, {
                    key: "pauseAllStreams",
                    value: function pauseAllStreams(kind) {
                      this.roomClient.pauseAllConsumers(kind);
                    }
                    /**
                     * @param {string} kind?
                     */
                  }, {
                    key: "resumeAllStreams",
                    value: function resumeAllStreams(kind) {
                      this.roomClient.resumeAllConsumers(kind);
                    }
                    /**
                     * @param {string} webhookUrl?
                     * @param {string} awsDirPath?
                     * @param {{layout: { type: "GRID" | "SPOTLIGHT" | "SIDEBAR" , priority: "SPEAKER" | "PIN", gridSize: number}}} config?
                     * @param {{enabled: boolean , summary: { enabled: boolean, prompt: string | undefined } | undefined}} transcription?
                     */
                  }, {
                    key: "startRecording",
                    value: function startRecording(webhookUrl, awsDirPath, config3, transcription) {
                      this.roomClient.startRecording(webhookUrl, awsDirPath, config3, transcription);
                    }
                  }, {
                    key: "stopRecording",
                    value: function stopRecording() {
                      this.roomClient.stopRecording();
                    }
                    /**
                     * @param {any} config?
                     */
                  }, {
                    key: "startTranscription",
                    value: function startTranscription(config3) {
                      this.roomClient.startTranscription(config3);
                    }
                  }, {
                    key: "stopTranscription",
                    value: function stopTranscription() {
                      this.roomClient.stopTranscription();
                    }
                    /**
                     * @param {any} config?
                     */
                  }, {
                    key: "startTranslation",
                    value: function() {
                      var _startTranslation = (0, asyncToGenerator.A)(regenerator_default().mark(function _callee13(config3) {
                        return regenerator_default().wrap(function(_context13) {
                          while (1) switch (_context13.prev = _context13.next) {
                            case 0:
                              return _context13.abrupt("return", this.roomClient.startTranslation(config3));
                            case 1:
                            case "end":
                              return _context13.stop();
                          }
                        }, _callee13, this);
                      }));
                      function startTranslation(_x17) {
                        return _startTranslation.apply(this, arguments);
                      }
                      return startTranslation;
                    }()
                  }, {
                    key: "changeTranslationLanguage",
                    value: function() {
                      var _changeTranslationLanguage = (0, asyncToGenerator.A)(regenerator_default().mark(function _callee14(language) {
                        return regenerator_default().wrap(function(_context14) {
                          while (1) switch (_context14.prev = _context14.next) {
                            case 0:
                              return _context14.abrupt("return", this.roomClient.changeTranslationLanguage(language));
                            case 1:
                            case "end":
                              return _context14.stop();
                          }
                        }, _callee14, this);
                      }));
                      function changeTranslationLanguage(_x18) {
                        return _changeTranslationLanguage.apply(this, arguments);
                      }
                      return changeTranslationLanguage;
                    }()
                  }, {
                    key: "stopTranslation",
                    value: function() {
                      var _stopTranslation = (0, asyncToGenerator.A)(regenerator_default().mark(function _callee15() {
                        return regenerator_default().wrap(function(_context15) {
                          while (1) switch (_context15.prev = _context15.next) {
                            case 0:
                              return _context15.abrupt("return", this.roomClient.stopTranslation());
                            case 1:
                            case "end":
                              return _context15.stop();
                          }
                        }, _callee15, this);
                      }));
                      function stopTranslation() {
                        return _stopTranslation.apply(this, arguments);
                      }
                      return stopTranslation;
                    }()
                    /**
                     * @param {{layout: { type: "GRID" | "SPOTLIGHT" | "SIDEBAR" , priority: "SPEAKER" | "PIN", gridSize: number}}} config?
                     * @param {Array<{url : string, streamKey: string}>} outputs
                     */
                  }, {
                    key: "startLivestream",
                    value: function startLivestream(outputs, config3) {
                      this.roomClient.startLivestream(outputs, config3);
                    }
                  }, {
                    key: "stopLivestream",
                    value: function stopLivestream() {
                      this.roomClient.stopLivestream();
                    }
                    /**
                     * @param {{layout: { type: "GRID" | "SPOTLIGHT" | "SIDEBAR" , priority: "SPEAKER" | "PIN", gridSize: number}}} config?
                     * @param {{enabled: boolean , summary: { enabled: boolean, prompt: string | undefined } | undefined}} transcription?
                     */
                  }, {
                    key: "startHls",
                    value: function() {
                      var _startHls = (0, asyncToGenerator.A)(regenerator_default().mark(function _callee16(config3, transcription) {
                        return regenerator_default().wrap(function(_context16) {
                          while (1) switch (_context16.prev = _context16.next) {
                            case 0:
                              _context16.next = 1;
                              return this.roomClient.startHls(config3, transcription);
                            case 1:
                            case "end":
                              return _context16.stop();
                          }
                        }, _callee16, this);
                      }));
                      function startHls(_x19, _x20) {
                        return _startHls.apply(this, arguments);
                      }
                      return startHls;
                    }()
                  }, {
                    key: "stopHls",
                    value: function stopHls() {
                      this.roomClient.stopHls();
                    }
                  }, {
                    key: "createCharacter",
                    value: function createCharacter(config3) {
                      if (!config3.interactionId && !config3.id) {
                        throw new Error("InteractionId or id is required");
                      }
                      return new Character(meeting_objectSpread(meeting_objectSpread({}, config3), {}, {
                        roomClient: this.roomClient
                      }));
                    }
                  }, {
                    key: "getMics",
                    value: function() {
                      var _getMics = (0, asyncToGenerator.A)(regenerator_default().mark(function _callee17() {
                        return regenerator_default().wrap(function(_context17) {
                          while (1) switch (_context17.prev = _context17.next) {
                            case 0:
                              _context17.next = 1;
                              return this.roomClient.getMics();
                            case 1:
                              return _context17.abrupt("return", _context17.sent);
                            case 2:
                            case "end":
                              return _context17.stop();
                          }
                        }, _callee17, this);
                      }));
                      function getMics() {
                        return _getMics.apply(this, arguments);
                      }
                      return getMics;
                    }()
                  }, {
                    key: "getWebcams",
                    value: function() {
                      var _getWebcams = (0, asyncToGenerator.A)(regenerator_default().mark(function _callee18() {
                        return regenerator_default().wrap(function(_context18) {
                          while (1) switch (_context18.prev = _context18.next) {
                            case 0:
                              _context18.next = 1;
                              return this.roomClient.getWebcams();
                            case 1:
                              return _context18.abrupt("return", _context18.sent);
                            case 2:
                            case "end":
                              return _context18.stop();
                          }
                        }, _callee18, this);
                      }));
                      function getWebcams() {
                        return _getWebcams.apply(this, arguments);
                      }
                      return getWebcams;
                    }()
                    /**
                     *
                     * @param {string | MediaStream } object
                     */
                  }, {
                    key: "changeMic",
                    value: function changeMic(object) {
                      this.roomClient.changeMic(object);
                    }
                    /**
                     *
                     * @param {string | MediaStream } object
                     */
                  }, {
                    key: "changeWebcam",
                    value: function changeWebcam(object) {
                      this.roomClient.changeWebcam(object);
                    }
                    /**
                     *
                     * @param { MediaStream } stream
                     */
                  }, {
                    key: "replaceWebcamStream",
                    value: function replaceWebcamStream(stream) {
                      this.roomClient.replaceWebcamStream(stream);
                    }
                    /**
                     *
                     * @param {"low" | "med" | "high"} quality
                     */
                  }, {
                    key: "setWebcamQuality",
                    value: function setWebcamQuality(quality) {
                      this.roomClient.setWebcamQuality(quality);
                    }
                  }, {
                    key: "startWhiteboard",
                    value: function startWhiteboard() {
                      this.roomClient.startWhiteboard();
                    }
                  }, {
                    key: "stopWhiteboard",
                    value: function stopWhiteboard() {
                      this.roomClient.stopWhiteboard();
                    }
                    /**
                     *
                     * @param {{link: string}} options
                     */
                  }, {
                    key: "startVideo",
                    value: function startVideo(_ref5) {
                      var link = _ref5.link;
                      this.roomClient.startVideo({
                        link
                      });
                    }
                  }, {
                    key: "stopVideo",
                    value: function stopVideo() {
                      this.roomClient.stopVideo();
                    }
                  }, {
                    key: "resumeVideo",
                    value: function resumeVideo() {
                      this.roomClient.resumeVideo();
                    }
                  }, {
                    key: "refreshConnection",
                    value: function refreshConnection() {
                      this.roomClient.restartIce();
                    }
                    /**
                     *
                     * @param {{currentTime: number}} options
                     */
                  }, {
                    key: "pauseVideo",
                    value: function pauseVideo(_ref6) {
                      var currentTime = _ref6.currentTime;
                      this.roomClient.pauseVideo(currentTime);
                    }
                    /**
                     *
                     * @param {{currentTime: number}} options
                     */
                  }, {
                    key: "seekVideo",
                    value: function seekVideo(_ref7) {
                      var currentTime = _ref7.currentTime;
                      this.roomClient.seekVideo(currentTime);
                    }
                  }, {
                    key: "handlePeerAdd",
                    value: function handlePeerAdd(_ref8) {
                      var peer = _ref8.peer;
                      var participant = new Participant(peer);
                      this.participants.set(participant.id, participant);
                      this.eventEmitter.emit(meeting_EV_PARTICIPANT_JOINED, participant);
                      if (this.participants.size === 1) {
                        this.updateMainParticipant(participant.id);
                      }
                    }
                  }, {
                    key: "handleStreamState",
                    value: function handleStreamState(_ref9) {
                      var state = _ref9.state, peerId = _ref9.peerId, streamId = _ref9.streamId;
                      var participant = this.participants.get(peerId);
                      if (participant == null) return;
                      participant.handleStreamStateChanged({
                        state,
                        peerId,
                        streamId
                      });
                    }
                  }, {
                    key: "handlePeerRemove",
                    value: function handlePeerRemove(_ref0) {
                      var peerId = _ref0.peerId, reason = _ref0.reason;
                      var defaultReason = {
                        code: LeaveReason.t.UNKNOWN.code,
                        message: LeaveReason.t.UNKNOWN.message
                      };
                      var participant = this.participants.get(peerId);
                      if (participant == null) return;
                      this.participants["delete"](peerId);
                      this.eventEmitter.emit(meeting_EV_PARTICIPANT_LEFT, participant, reason || defaultReason);
                      if (this.activePresenterId === participant.id) {
                        this.activePresenterId = null;
                        this.eventEmitter.emit(EV_PRESENTER_CHANGED, this.activePresenterId);
                      }
                      if (this.mainParticipantId === participant.id) {
                        if (this.participants.size > 0) {
                          this.updateMainParticipant(this.participants.entries().next().value[1].id);
                        } else {
                          this.updateMainParticipant(this.localParticipant.id);
                        }
                      }
                    }
                  }, {
                    key: "handleProducerAdd",
                    value: function handleProducerAdd(_ref1) {
                      var producer = _ref1.producer;
                      var producerInfo = {
                        id: producer.id,
                        rtpSender: producer.rtpSender
                      };
                      this.localParticipant.addProducer(producerInfo);
                      var stream = new Stream(producer);
                      this.localParticipant.addStream(stream);
                      if (stream.kind === "share") {
                        this.activePresenterId = this.localParticipant.id;
                        this.eventEmitter.emit(EV_PRESENTER_CHANGED, this.activePresenterId);
                        this.updateMainParticipant(this.localParticipant.id);
                      }
                    }
                  }, {
                    key: "handleUpdateProducer",
                    value: function handleUpdateProducer(_ref10) {
                      var producer = _ref10.producer;
                      var stream = new Stream(producer);
                      this.localParticipant.updateStream(stream);
                    }
                  }, {
                    key: "handleProducerRemove",
                    value: function handleProducerRemove(_ref11) {
                      var producerId = _ref11.producerId;
                      this.localParticipant.removeProducer(producerId);
                      var stream = this.localParticipant.deleteStream(producerId);
                      if (stream && stream.kind === "share") {
                        this.activePresenterId = null;
                        this.eventEmitter.emit(EV_PRESENTER_CHANGED, this.activePresenterId);
                        var nextParticipant = this.participants.size > 0 ? this.participants.entries().next().value[1].id : null;
                        this.updateMainParticipant(this.activeSpeakerId || nextParticipant || this.localParticipant.id);
                      }
                    }
                  }, {
                    key: "handleConsumerAdd",
                    value: function handleConsumerAdd(_ref12) {
                      var consumer = _ref12.consumer, peerId = _ref12.peerId;
                      var participant = this.participants.get(peerId) || this.characters.get(peerId);
                      if (participant) {
                        var consumerInfo = {
                          id: consumer.id,
                          rtpReceiver: consumer.rtpReceiver
                        };
                        participant.addConsumer(consumerInfo);
                        var stream = new Stream(consumer);
                        participant.addStream(stream);
                        this.eventEmitter.emit(meeting_EV_STREAM_ENABLED, stream);
                        if (stream.kind === "share") {
                          this.activePresenterId = participant.id;
                          this.eventEmitter.emit(EV_PRESENTER_CHANGED, this.activePresenterId);
                          this.updateMainParticipant(participant.id);
                        }
                      }
                    }
                  }, {
                    key: "handleConsumerResume",
                    value: function handleConsumerResume(_ref13) {
                      var consumerId = _ref13.consumerId, peerId = _ref13.peerId;
                      var participant = this.participants.get(peerId);
                      if (participant) {
                        participant.streamResumed(consumerId);
                      }
                    }
                  }, {
                    key: "handleConsumerPause",
                    value: function handleConsumerPause(_ref14) {
                      var consumerId = _ref14.consumerId, peerId = _ref14.peerId;
                      var participant = this.participants.get(peerId);
                      if (participant) {
                        participant.streamPaused(consumerId);
                      }
                    }
                  }, {
                    key: "handleConsumerRemove",
                    value: function handleConsumerRemove(_ref15) {
                      var consumerId = _ref15.consumerId, peerId = _ref15.peerId;
                      var participant = this.participants.get(peerId) || this.characters.get(peerId);
                      if (participant == null) return;
                      if (participant) {
                        participant.removeConsumer(consumerId);
                        var stream = participant.deleteStream(consumerId);
                        this.eventEmitter.emit(meeting_EV_STREAM_DISABLED, stream);
                        if (stream && stream.kind === "share") {
                          this.activePresenterId = null;
                          this.eventEmitter.emit(EV_PRESENTER_CHANGED, this.activePresenterId);
                          var nextParticipant = this.participants.size > 0 ? this.participants.entries().next().value[1].id : null;
                          this.updateMainParticipant(this.activeSpeakerId || nextParticipant || this.localParticipant.id);
                        }
                      }
                    }
                  }, {
                    key: "handleParticipantMediaStateChanged",
                    value: function handleParticipantMediaStateChanged(_ref16) {
                      var peerId = _ref16.peerId, kind = _ref16.kind, newState = _ref16.newState;
                      var participant = this.participants.get(peerId) || this.characters.get(peerId);
                      if (this.localParticipant.id == peerId) {
                        participant = this.localParticipant;
                      }
                      if (!participant) return;
                      if (participant) {
                        if (kind == "audio") {
                          participant.micOn = newState;
                        } else if (kind == "video") {
                          participant.webcamOn = newState;
                        }
                        participant.updateParticipantMediaState(kind, newState);
                      }
                    }
                  }, {
                    key: "handleParticipantPausedBySubManager",
                    value: function handleParticipantPausedBySubManager(data) {
                      var participant = this.participants.get(data.peerId);
                      if (!participant) return;
                      if (participant) {
                        participant.handleParticipantPause(data);
                      }
                    }
                  }, {
                    key: "handleParticipantResumeBySubManager",
                    value: function handleParticipantResumeBySubManager(data) {
                      var participant = this.participants.get(data.peerId);
                      if (!participant) return;
                      if (participant) {
                        participant.handleParticipantResume(data);
                      }
                    }
                  }, {
                    key: "handleSpeakerChange",
                    value: function handleSpeakerChange(_ref17) {
                      var peerId = _ref17.peerId;
                      if (this.activeSpeakerId !== peerId) {
                        this.activeSpeakerId = peerId;
                        this.eventEmitter.emit(EV_SPEAKER_CHANGED, peerId);
                        if (peerId && peerId !== this.localParticipant.id && this.activePresenterId !== this.mainParticipantId && peerId !== this.mainParticipantId) {
                          this.updateMainParticipant(peerId);
                        }
                      }
                    }
                  }, {
                    key: "handleNewChatMessage",
                    value: function handleNewChatMessage(_ref18) {
                      var payload = _ref18.payload, from = _ref18.from, reliability = _ref18.reliability, timestamp = _ref18.timestamp;
                      var message = {
                        from,
                        payload,
                        timestamp,
                        reliability
                      };
                      this.messages.push(message);
                      this.eventEmitter.emit(meeting_EV_DATA, message);
                    }
                  }, {
                    key: "updateMainParticipant",
                    value: function updateMainParticipant(participantId) {
                      this.mainParticipantId = participantId;
                      var participant = null;
                      if (participantId === this.localParticipant.id) {
                        participant = this.localParticipant;
                      } else {
                        participant = this.participants.get(this.mainParticipantId);
                      }
                      this.eventEmitter.emit(EV_MAIN_PARTICIPANT_CHANGED, participant);
                    }
                  }, {
                    key: "handleEntryRequested",
                    value: function handleEntryRequested(_ref19) {
                      var _this2 = this;
                      var id = _ref19.id, name = _ref19.name;
                      this.eventEmitter.emit(EV_ENTRY_REQUESTED, {
                        participantId: id,
                        name,
                        allow: function allow() {
                          _this2.roomClient.respondEntry(id, "allowed");
                        },
                        deny: function deny() {
                          _this2.roomClient.respondEntry(id, "denied");
                        }
                      });
                    }
                  }, {
                    key: "handleEntryResponded",
                    value: function handleEntryResponded(_ref20) {
                      var id = _ref20.id, decision = _ref20.decision;
                      this.eventEmitter.emit(EV_ENTRY_RESPONDED, id, decision);
                    }
                  }, {
                    key: "handleMeetingJoined",
                    value: function handleMeetingJoined(_ref21) {
                      var peers2 = _ref21.peers, poll = _ref21.poll, messages = _ref21.messages, baseUrl = _ref21.baseUrl, switchRoomId = _ref21.switchRoomId;
                      if (typeof switchRoomId === "string") {
                        this.id = switchRoomId;
                      }
                      this.baseUrl = baseUrl;
                      if (messages.length > 0) this.messages = messages;
                      this.eventEmitter.emit(EV_MEETING_JOINED, {
                        switchRoomId: switchRoomId || null,
                        peers: peers2,
                        poll,
                        messages
                      });
                    }
                  }, {
                    key: "handleMeetingLeft",
                    value: function handleMeetingLeft(d) {
                      this.eventEmitter.emit(EV_MEETING_LEFT, d);
                    }
                  }, {
                    key: "handleRecordingStateChanged",
                    value: function handleRecordingStateChanged(d) {
                      this.recordingState = d.status;
                      this.eventEmitter.emit(EV_RECORDING_STATE_CHANGED, d);
                    }
                  }, {
                    key: "handleLivestreamStateChanged",
                    value: function handleLivestreamStateChanged(d) {
                      this.livestreamState = d.status;
                      this.eventEmitter.emit(EV_LIVESTREAM_STATE_CHANGED, d);
                    }
                  }, {
                    key: "handleHlsStateChanged",
                    value: function handleHlsStateChanged(d) {
                      this.hlsState = d.status;
                      if (d.status == "HLS_PLAYABLE") {
                        this.hlsUrls = {
                          downstreamUrl: d.downstreamUrl,
                          playbackHlsUrl: d.playbackHlsUrl,
                          livestreamUrl: d.livestreamUrl
                        };
                      } else if (d.status == "HLS_STOPPED") {
                        this.hlsUrls = {
                          downstreamUrl: null,
                          playbackHlsUrl: null,
                          livestreamUrl: null
                        };
                      }
                      this.eventEmitter.emit(EV_HLS_STATE_CHANGED, d);
                    }
                  }, {
                    key: "handleTranscriptionStateChanged",
                    value: function handleTranscriptionStateChanged(d) {
                      this.transcriptionState = d.status;
                      this.eventEmitter.emit(EV_TRANSCRIPTION_STATE_CHANGED, d);
                    }
                  }, {
                    key: "handleTranscriptionText",
                    value: function handleTranscriptionText(d) {
                      this.eventEmitter.emit(EV_TRANSCRIPTION_TEXT, d);
                    }
                  }, {
                    key: "handleTranslationText",
                    value: function handleTranslationText(d) {
                      this.eventEmitter.emit(EV_TRANSLATION_TEXT, d);
                    }
                  }, {
                    key: "handleTranslationStateChanged",
                    value: function handleTranslationStateChanged(d) {
                      this.translationState = d.status;
                      this.eventEmitter.emit(EV_TRANSLATION_STATE_CHANGED, d);
                    }
                  }, {
                    key: "handleTranslationLanguageChanged",
                    value: function handleTranslationLanguageChanged(d) {
                      this.eventEmitter.emit(EV_TRANSLATION_LANGUAGE_CHANGED, d);
                    }
                  }, {
                    key: "handleRecordingStarted",
                    value: function handleRecordingStarted() {
                      this.eventEmitter.emit(EV_RECORDING_STARTED);
                    }
                  }, {
                    key: "handleRecordingStopped",
                    value: function handleRecordingStopped() {
                      this.eventEmitter.emit(EV_RECORDING_STOPPED);
                    }
                  }, {
                    key: "handleLivestreamStarted",
                    value: function handleLivestreamStarted() {
                      this.eventEmitter.emit(EV_LIVESTREAM_STARTED);
                    }
                  }, {
                    key: "handleLivestreamStopped",
                    value: function handleLivestreamStopped() {
                      this.eventEmitter.emit(EV_LIVESTREAM_STOPPED);
                    }
                  }, {
                    key: "handleHlsStarted",
                    value: function handleHlsStarted(d) {
                      this.eventEmitter.emit(EV_HLS_STARTED, d);
                    }
                  }, {
                    key: "handleHlsStopped",
                    value: function handleHlsStopped() {
                      this.eventEmitter.emit(EV_HLS_STOPPED);
                    }
                  }, {
                    key: "handleWhiteboardStarted",
                    value: function handleWhiteboardStarted(data) {
                      this.eventEmitter.emit(EV_WHITEBOARD_STARTED, data);
                    }
                  }, {
                    key: "handleWhiteboardStopped",
                    value: function handleWhiteboardStopped(_ref22) {
                      _objectDestructuringEmpty(_ref22);
                      this.eventEmitter.emit(EV_WHITEBOARD_STOPPED);
                    }
                  }, {
                    key: "handleAddCharacter",
                    value: function handleAddCharacter(config3) {
                      var _this$characters$get;
                      var id = config3.id;
                      var character = (_this$characters$get = this.characters.get(id)) !== null && _this$characters$get !== void 0 ? _this$characters$get : new Character(meeting_objectSpread(meeting_objectSpread({}, config3), {}, {
                        state: CharacterState.CHARACTER_LISTENING,
                        roomClient: this.roomClient
                      }));
                      this.characters.set(id, character);
                      this.eventEmitter.emit(meeting_EV_CHARACTER_JOINED, character);
                      character.eventEmitter.emit(meeting_EV_CHARACTER_JOINED);
                    }
                  }, {
                    key: "handleInitCharacter",
                    value: function handleInitCharacter(character) {
                      this.characters.set(character.id, character);
                    }
                  }, {
                    key: "handleRemoveCharacter",
                    value: function handleRemoveCharacter(config3) {
                      var id = config3.id;
                      if (this.characters.has(id)) {
                        var character = this.characters.get(id);
                        this.eventEmitter.emit(meeting_EV_CHARACTER_LEFT, character);
                        character.eventEmitter.emit(meeting_EV_CHARACTER_LEFT);
                        this.characters["delete"](id);
                      }
                    }
                  }, {
                    key: "handleCharacterStateChanged",
                    value: function handleCharacterStateChanged(config3) {
                      var id = config3.id;
                      if (this.characters.has(id)) {
                        var character = this.characters.get(id);
                        character.handleCharacterStateChanged(config3);
                      }
                    }
                  }, {
                    key: "handleCharacterMessage",
                    value: function handleCharacterMessage(config3) {
                      var id = config3.id;
                      if (this.characters.has(id)) {
                        var character = this.characters.get(id);
                        character.handleCharacterMessage(config3);
                      }
                    }
                  }, {
                    key: "handleUserMessage",
                    value: function handleUserMessage(config3) {
                      var id = config3.id;
                      if (this.characters.has(id)) {
                        var character = this.characters.get(id);
                        character.handleUserMessage(config3);
                      }
                    }
                  }, {
                    key: "handleOnCharacterData",
                    value: function handleOnCharacterData(config3) {
                      var id = config3.id;
                      if (this.characters.has(id)) {
                        var character = this.characters.get(id);
                        character.handleCharacterData(config3);
                      }
                    }
                  }, {
                    key: "handleOnCharacterError",
                    value: function handleOnCharacterError(config3) {
                      var id = config3.id;
                      if (this.characters.has(id)) {
                        var character = this.characters.get(id);
                        character.handleCharacterError(config3);
                      }
                    }
                  }, {
                    key: "handleOnRemoveCurrentMeetingParticipant",
                    value: function handleOnRemoveCurrentMeetingParticipant() {
                      var _this3 = this;
                      (0, toConsumableArray.A)(this.participants.keys()).forEach(function(peerId) {
                        if (peerId !== _this3.localParticipant.id) {
                          _this3.handlePeerRemove({
                            peerId
                          });
                        }
                      });
                    }
                  }, {
                    key: "handleVideoStateChanged",
                    value: function handleVideoStateChanged(data) {
                      this.eventEmitter.emit(EV_VIDEO_STATE_CHANGED, data);
                    }
                  }, {
                    key: "handleVideoSeeked",
                    value: function handleVideoSeeked(_ref23) {
                      var currentTime = _ref23.currentTime;
                      this.eventEmitter.emit(EV_VIDEO_SEEKED, {
                        currentTime
                      });
                    }
                  }, {
                    key: "handlePinStateChanged",
                    value: function handlePinStateChanged(_ref24) {
                      var peerId = _ref24.peerId, state = _ref24.state, pinnedBy = _ref24.pinnedBy;
                      this.eventEmitter.emit(EV_PIN_STATE_CHANGED, {
                        participantId: peerId,
                        state,
                        pinnedBy
                      });
                    }
                  }, {
                    key: "handleMeetingStateChanged",
                    value: function handleMeetingStateChanged(_ref25) {
                      var state = _ref25.state;
                      this.eventEmitter.emit(EV_MEETING_STATE_CHANGE, {
                        state
                      });
                    }
                  }, {
                    key: "handleQualityChanged",
                    value: function handleQualityChanged(_ref26) {
                      var type = _ref26.type, state = _ref26.state, timestamp = _ref26.timestamp;
                      this.eventEmitter.emit(EV_QUALITY_LIMITATION, {
                        type,
                        state,
                        timestamp
                      });
                    }
                  }, {
                    key: "handleConsumersPaused",
                    value: function handleConsumersPaused(_ref27) {
                      var kind = _ref27.kind;
                      this.eventEmitter.emit(EV_ALL_STREAMS_PAUSED, {
                        kind
                      });
                    }
                  }, {
                    key: "handleConsumersResumed",
                    value: function handleConsumersResumed(_ref28) {
                      var kind = _ref28.kind;
                      this.eventEmitter.emit(EV_ALL_STREAMS_RESUMED, {
                        kind
                      });
                    }
                  }, {
                    key: "handleVideoQualityChanged",
                    value: function handleVideoQualityChanged(_ref29) {
                      var peerId = _ref29.peerId, prevQuality = _ref29.prevQuality, currentQuality = _ref29.currentQuality;
                      var participant = this.participants.get(peerId) || this.characters.get(peerId);
                      if (!participant) return;
                      if (participant) {
                        participant.videoQualityChanged(prevQuality, currentQuality);
                      }
                    }
                  }, {
                    key: "handleMicRequested",
                    value: function handleMicRequested(_ref30) {
                      var _this4 = this;
                      var peerId = _ref30.peerId;
                      this.eventEmitter.emit(EV_MIC_REQUESTED, {
                        participantId: peerId,
                        accept: function accept() {
                          return _this4.unmuteMic();
                        },
                        reject: function reject() {
                        }
                      });
                    }
                  }, {
                    key: "handleWebcamRequested",
                    value: function handleWebcamRequested(_ref31) {
                      var _this5 = this;
                      var peerId = _ref31.peerId;
                      this.eventEmitter.emit(EV_WEBCAM_REQUESTED, {
                        participantId: peerId,
                        accept: function accept() {
                          return _this5.enableWebcam();
                        },
                        reject: function reject() {
                        }
                      });
                    }
                  }, {
                    key: "handleConnectionParticipantJoin",
                    value: function handleConnectionParticipantJoin(_ref32) {
                      var roomId = _ref32.roomId, peer = _ref32.peer;
                      var connection = this.connections.get(roomId);
                      if (connection == null) return;
                      connection.meeting.participantJoin(peer);
                    }
                  }, {
                    key: "handleConnectionParticipantLeft",
                    value: function handleConnectionParticipantLeft(_ref33) {
                      var roomId = _ref33.roomId, peerId = _ref33.peerId;
                      var connection = this.connections.get(roomId);
                      if (connection == null) return;
                      connection.meeting.participantLeft(peerId);
                    }
                  }, {
                    key: "handleConnectionOpen",
                    value: function handleConnectionOpen(_ref34) {
                      var peers2 = _ref34.peers, roomId = _ref34.roomId, payload = _ref34.payload;
                      var connection = new Connection({
                        roomId,
                        peers: peers2,
                        payload
                      });
                      this.connections.set(connection.id, connection);
                      this.eventEmitter.emit(EV_CONNECTION_OPEN, connection);
                    }
                  }, {
                    key: "handleConnectionClose",
                    value: function handleConnectionClose(_ref35) {
                      var roomId = _ref35.roomId;
                      var connection = this.connections.get(roomId);
                      if (connection == null) return;
                      this.connections["delete"](roomId);
                      this.eventEmitter.emit(EV_CONNECTION_CLOSE, roomId);
                    }
                  }, {
                    key: "handleMediaRelayError",
                    value: function handleMediaRelayError(_ref36) {
                      var meetingId = _ref36.meetingId, error = _ref36.error;
                      this.eventEmitter.emit(EV_MEDIA_RELAY_ERROR, {
                        meetingId,
                        error
                      });
                    }
                  }, {
                    key: "handleMediaRelayRequest",
                    value: function handleMediaRelayRequest(_ref37) {
                      var _this6 = this;
                      var peerId = _ref37.peerId, meetingId = _ref37.meetingId, displayName = _ref37.displayName;
                      this.eventEmitter.emit(EV_MEDIA_RELAY_REQUEST_RECEIVED, {
                        participantId: peerId,
                        meetingId,
                        displayName,
                        accept: function accept() {
                          return _this6.roomClient.handleRelayRequestResponse({
                            decision: "allowed",
                            meetingId,
                            peerId
                          });
                        },
                        reject: function reject() {
                          return _this6.roomClient.handleRelayRequestResponse({
                            decision: "denied",
                            meetingId,
                            peerId
                          });
                        }
                      });
                    }
                  }, {
                    key: "handleMediaRelayRequestResponse",
                    value: function handleMediaRelayRequestResponse(_ref38) {
                      var decision = _ref38.decision, decidedBy = _ref38.decidedBy, meetingId = _ref38.meetingId;
                      this.eventEmitter.emit(EV_MEDIA_RELAY_REQUEST_RESPONSE, {
                        decision,
                        decidedBy,
                        meetingId
                      });
                    }
                  }, {
                    key: "handleMediaRelayStart",
                    value: function handleMediaRelayStart(_ref39) {
                      var meetingId = _ref39.meetingId;
                      this.eventEmitter.emit(EV_MEDIA_RELAY_STARTED, {
                        meetingId
                      });
                    }
                  }, {
                    key: "handleMediaRelayStop",
                    value: function handleMediaRelayStop(_ref40) {
                      var meetingId = _ref40.meetingId, reason = _ref40.reason;
                      this.eventEmitter.emit(EV_MEDIA_RELAY_STOPPED, {
                        meetingId,
                        reason
                      });
                    }
                  }, {
                    key: "requestMediaRelay",
                    value: function() {
                      var _requestMediaRelay = (0, asyncToGenerator.A)(regenerator_default().mark(function _callee19(_ref41) {
                        var destinationMeetingId, token, kinds;
                        return regenerator_default().wrap(function(_context19) {
                          while (1) switch (_context19.prev = _context19.next) {
                            case 0:
                              destinationMeetingId = _ref41.destinationMeetingId, token = _ref41.token, kinds = _ref41.kinds;
                              if (destinationMeetingId) {
                                _context19.next = 1;
                                break;
                              }
                              throw new Error("Parameter destinationMeetingId is required when calling requestMediaRelay.");
                            case 1:
                              _context19.next = 2;
                              return this.roomClient.requestMediaRelay(destinationMeetingId, token, kinds);
                            case 2:
                            case "end":
                              return _context19.stop();
                          }
                        }, _callee19, this);
                      }));
                      function requestMediaRelay(_x21) {
                        return _requestMediaRelay.apply(this, arguments);
                      }
                      return requestMediaRelay;
                    }()
                  }, {
                    key: "stopMediaRelay",
                    value: function() {
                      var _stopMediaRelay = (0, asyncToGenerator.A)(regenerator_default().mark(function _callee20(destinationMeetingId) {
                        return regenerator_default().wrap(function(_context20) {
                          while (1) switch (_context20.prev = _context20.next) {
                            case 0:
                              if (destinationMeetingId) {
                                _context20.next = 1;
                                break;
                              }
                              throw new Error("Parameter destinationMeetingId is required when calling stopMediaRelay.");
                            case 1:
                              _context20.next = 2;
                              return this.roomClient.stopMediaRelay(destinationMeetingId);
                            case 2:
                            case "end":
                              return _context20.stop();
                          }
                        }, _callee20, this);
                      }));
                      function stopMediaRelay(_x22) {
                        return _stopMediaRelay.apply(this, arguments);
                      }
                      return stopMediaRelay;
                    }()
                    // async enableRelayMedia(meetingId, kind) {
                    //   await this.roomClient.enableRelayMedia(meetingId, kind);
                    // }
                    // async disableRelayMedia(meetingId, kind) {
                    //   await this.roomClient.disableRelayMedia(meetingId, kind);
                    // }
                  }, {
                    key: "enableAdaptiveSubscription",
                    value: function() {
                      var _enableAdaptiveSubscription = (0, asyncToGenerator.A)(regenerator_default().mark(function _callee21() {
                        return regenerator_default().wrap(function(_context21) {
                          while (1) switch (_context21.prev = _context21.next) {
                            case 0:
                              _context21.next = 1;
                              return this.roomClient.enableAdaptiveSubscription();
                            case 1:
                            case "end":
                              return _context21.stop();
                          }
                        }, _callee21, this);
                      }));
                      function enableAdaptiveSubscription() {
                        return _enableAdaptiveSubscription.apply(this, arguments);
                      }
                      return enableAdaptiveSubscription;
                    }()
                  }, {
                    key: "disableAdaptiveSubscription",
                    value: function() {
                      var _disableAdaptiveSubscription = (0, asyncToGenerator.A)(regenerator_default().mark(function _callee22() {
                        return regenerator_default().wrap(function(_context22) {
                          while (1) switch (_context22.prev = _context22.next) {
                            case 0:
                              _context22.next = 1;
                              return this.roomClient.disableAdaptiveSubscription();
                            case 1:
                            case "end":
                              return _context22.stop();
                          }
                        }, _callee22, this);
                      }));
                      function disableAdaptiveSubscription() {
                        return _disableAdaptiveSubscription.apply(this, arguments);
                      }
                      return disableAdaptiveSubscription;
                    }()
                  }, {
                    key: "enableE2EE",
                    value: function() {
                      var _enableE2EE = (0, asyncToGenerator.A)(regenerator_default().mark(function _callee23() {
                        return regenerator_default().wrap(function(_context23) {
                          while (1) switch (_context23.prev = _context23.next) {
                            case 0:
                              _context23.next = 1;
                              return this.roomClient.toggleE2EEEnabled(true);
                            case 1:
                            case "end":
                              return _context23.stop();
                          }
                        }, _callee23, this);
                      }));
                      function enableE2EE() {
                        return _enableE2EE.apply(this, arguments);
                      }
                      return enableE2EE;
                    }()
                  }, {
                    key: "disableE2EE",
                    value: function() {
                      var _disableE2EE = (0, asyncToGenerator.A)(regenerator_default().mark(function _callee24() {
                        return regenerator_default().wrap(function(_context24) {
                          while (1) switch (_context24.prev = _context24.next) {
                            case 0:
                              _context24.next = 1;
                              return this.roomClient.toggleE2EEEnabled(false);
                            case 1:
                            case "end":
                              return _context24.stop();
                          }
                        }, _callee24, this);
                      }));
                      function disableE2EE() {
                        return _disableE2EE.apply(this, arguments);
                      }
                      return disableE2EE;
                    }()
                  }, {
                    key: "handleSwitchMeeting",
                    value: function handleSwitchMeeting(d) {
                      var roomId = d.roomId, token = d.token, payload = d.payload, peerId = d.peerId, connectionPeerId = d.connectionPeerId, connectionRoomId = d.connectionRoomId;
                      var data = peerId ? {
                        meetingId: roomId,
                        payload,
                        token,
                        participantId: peerId
                      } : {
                        meetingId: roomId,
                        payload,
                        token,
                        connectionParticipantId: connectionPeerId,
                        connectionMeetingId: connectionRoomId
                      };
                      this.eventEmitter.emit(EV_SWITCH_MEETING, data);
                    }
                  }, {
                    key: "handleConnectionChatMessage",
                    value: function handleConnectionChatMessage(_ref42) {
                      var roomId = _ref42.roomId, peerId = _ref42.peerId, message = _ref42.message;
                      var connection = this.connections.get(roomId);
                      if (connection == null) return;
                      connection.meeting.sendChatMessageEvent({
                        participantId: peerId,
                        message
                      });
                    }
                  }, {
                    key: "handleE2EEStateChange",
                    value: function handleE2EEStateChange(data) {
                      var peerId = data.peerId;
                      var participant = this.localParticipant.id == peerId ? this.localParticipant : this.participants.get(peerId) || this.characters.get(peerId);
                      if (!participant) return;
                      if (participant) {
                        participant.handleE2EEStateChange(data);
                      }
                    }
                    // OPEN CONNECTION FUNCTION
                    /**
                     *
                     * @param {{meetingId: string, payload: string}} options
                     */
                  }, {
                    key: "connectTo",
                    value: function() {
                      var _connectTo = (0, asyncToGenerator.A)(regenerator_default().mark(function _callee25(_ref43) {
                        var meetingId, payload;
                        return regenerator_default().wrap(function(_context25) {
                          while (1) switch (_context25.prev = _context25.next) {
                            case 0:
                              meetingId = _ref43.meetingId, payload = _ref43.payload;
                              _context25.next = 1;
                              return this.roomClient.openConnection({
                                roomId: meetingId,
                                payload
                              });
                            case 1:
                            case "end":
                              return _context25.stop();
                          }
                        }, _callee25, this);
                      }));
                      function connectTo(_x23) {
                        return _connectTo.apply(this, arguments);
                      }
                      return connectTo;
                    }()
                  }, {
                    key: "switchTo",
                    value: function switchTo(_ref44) {
                      var meetingId = _ref44.meetingId, token = _ref44.token;
                      if (!meetingId || typeof meetingId !== "string" || meetingId.trim() === "") {
                        throw new Error("Invalid meetingId: must be a non-empty string");
                      }
                      this.roomClient.switchTo({
                        meetingId,
                        token,
                        participantId: this.localParticipant.id
                      });
                    }
                  }, {
                    key: "selectedCameraDevice",
                    get: (
                      /**
                       *
                       * @returns {InputDeviceInfo}
                       */
                      function get() {
                        var _this$roomClient$_web;
                        return (_this$roomClient$_web = this.roomClient._webcam) === null || _this$roomClient$_web === void 0 ? void 0 : _this$roomClient$_web.device;
                      }
                    )
                    /**
                     *
                     * @returns {InputDeviceInfo}
                     */
                  }, {
                    key: "selectedMicrophoneDevice",
                    get: function get() {
                      var _this$roomClient$_mic;
                      return (_this$roomClient$_mic = this.roomClient._mic) === null || _this$roomClient$_mic === void 0 ? void 0 : _this$roomClient$_mic.device;
                    }
                    /**
                     * Add event listener
                     * @param { EV_PARTICIPANT_JOINED | EV_PARTICIPANT_LEFT | EV_SPEAKER_CHANGED | EV_PRESENTER_CHANGED | EV_MAIN_PARTICIPANT_CHANGED | EV_ENTRY_REQUESTED | EV_ENTRY_RESPONDED |       EV_RECORDING_STARTED | EV_RECORDING_STOPPED |      EV_LIVESTREAM_STARTED | EV_LIVESTREAM_STOPPED |       EV_HLS_STARTED | EV_HLS_STOPPED |       EV_STREAM_ENABLED | EV_STREAM_DISABLED |       EV_WHITEBOARD_STARTED | EV_WHITEBOARD_STOPPED |       EV_MEETING_JOINED | EV_MEETING_LEFT |      EV_VIDEO_STATE_CHANGED | EV_VIDEO_SEEKED |       EV_MIC_REQUESTED | EV_WEBCAM_REQUESTED |      EV_PIN_STATE_CHANGED | EV_CONNECTION_OPEN | EV_CONNECTION_CLOSE |    EV_SWITCH_MEETING | EV_ALL_STREAMS_PAUSED | EV_ALL_STREAMS_RESUMED | EV_DATA } eventType
                     * @param {Function} listener Callback function
                     */
                  }, {
                    key: "on",
                    value: function on(eventType, listener) {
                      switch (eventType) {
                        case meeting_EV_PARTICIPANT_JOINED:
                        case meeting_EV_PARTICIPANT_LEFT:
                        case EV_SPEAKER_CHANGED:
                        case EV_PRESENTER_CHANGED:
                        case EV_MAIN_PARTICIPANT_CHANGED:
                        case meeting_EV_DATA:
                        case EV_ENTRY_REQUESTED:
                        case EV_ENTRY_RESPONDED:
                        case EV_RECORDING_STATE_CHANGED:
                        case EV_RECORDING_STARTED:
                        case EV_RECORDING_STOPPED:
                        case EV_LIVESTREAM_STATE_CHANGED:
                        case EV_LIVESTREAM_STARTED:
                        case EV_LIVESTREAM_STOPPED:
                        case EV_HLS_STARTED:
                        case EV_HLS_STOPPED:
                        case EV_HLS_STATE_CHANGED:
                        case EV_TRANSCRIPTION_STATE_CHANGED:
                        case EV_TRANSCRIPTION_TEXT:
                        case EV_TRANSLATION_STATE_CHANGED:
                        case EV_TRANSLATION_TEXT:
                        case EV_TRANSLATION_LANGUAGE_CHANGED:
                        case meeting_EV_STREAM_ENABLED:
                        case meeting_EV_STREAM_DISABLED:
                        case EV_WHITEBOARD_STARTED:
                        case EV_WHITEBOARD_STOPPED:
                        case meeting_EV_CHARACTER_JOINED:
                        case meeting_EV_CHARACTER_LEFT:
                        case EV_MEETING_JOINED:
                        case EV_MEETING_LEFT:
                        case EV_VIDEO_STATE_CHANGED:
                        case EV_VIDEO_SEEKED:
                        case EV_MIC_REQUESTED:
                        case EV_WEBCAM_REQUESTED:
                        case EV_PIN_STATE_CHANGED:
                        case EV_CONNECTION_OPEN:
                        case EV_CONNECTION_CLOSE:
                        case EV_SWITCH_MEETING:
                        case EV_MEETING_STATE_CHANGE:
                        case EV_PARTICIPANT_MODE_CHANGED:
                        case EV_ALL_STREAMS_PAUSED:
                        case EV_ALL_STREAMS_RESUMED:
                        case EV_MEDIA_RELAY_STARTED:
                        case EV_MEDIA_RELAY_STOPPED:
                        case EV_MEDIA_RELAY_ERROR:
                        case EV_MEDIA_RELAY_REQUEST_RECEIVED:
                        case EV_MEDIA_RELAY_REQUEST_RESPONSE:
                        case EV_ERROR:
                        case EV_QUALITY_LIMITATION:
                          this.eventEmitter.on(eventType, listener);
                          break;
                        default:
                          throw new Error("Invalid event type " + eventType);
                      }
                    }
                    /**
                     * Remove event listener
                     * @param { EV_PARTICIPANT_JOINED | EV_PARTICIPANT_LEFT | EV_SPEAKER_CHANGED | EV_PRESENTER_CHANGED | EV_MAIN_PARTICIPANT_CHANGED | EV_ENTRY_REQUESTED | EV_ENTRY_RESPONDED |       EV_RECORDING_STARTED | EV_RECORDING_STOPPED |      EV_LIVESTREAM_STARTED | EV_LIVESTREAM_STOPPED |       EV_HLS_STARTED | EV_HLS_STOPPED |       EV_STREAM_ENABLED | EV_STREAM_DISABLED |       EV_WHITEBOARD_STARTED | EV_WHITEBOARD_STOPPED |       EV_MEETING_JOINED | EV_MEETING_LEFT |      EV_VIDEO_STATE_CHANGED | EV_VIDEO_SEEKED |       EV_MIC_REQUESTED | EV_WEBCAM_REQUESTED |      EV_PIN_STATE_CHANGED | EV_CONNECTION_OPEN | EV_CONNECTION_CLOSE |    EV_SWITCH_MEETING | EV_ALL_STREAMS_PAUSED | EV_ALL_STREAMS_RESUMED | EV_DATA } eventType
                     * @param {Function} listener Callback function
                     */
                  }, {
                    key: "off",
                    value: function off(eventType, listener) {
                      switch (eventType) {
                        case meeting_EV_PARTICIPANT_JOINED:
                        case meeting_EV_PARTICIPANT_LEFT:
                        case EV_SPEAKER_CHANGED:
                        case EV_PRESENTER_CHANGED:
                        case EV_MAIN_PARTICIPANT_CHANGED:
                        case meeting_EV_DATA:
                        case EV_ENTRY_REQUESTED:
                        case EV_ENTRY_RESPONDED:
                        case EV_RECORDING_STATE_CHANGED:
                        case EV_RECORDING_STARTED:
                        case EV_RECORDING_STOPPED:
                        case EV_LIVESTREAM_STATE_CHANGED:
                        case EV_LIVESTREAM_STARTED:
                        case EV_LIVESTREAM_STOPPED:
                        case EV_HLS_STATE_CHANGED:
                        case EV_HLS_STARTED:
                        case EV_HLS_STOPPED:
                        case EV_TRANSCRIPTION_STATE_CHANGED:
                        case EV_TRANSCRIPTION_TEXT:
                        case EV_TRANSLATION_STATE_CHANGED:
                        case EV_TRANSLATION_TEXT:
                        case EV_TRANSLATION_LANGUAGE_CHANGED:
                        case meeting_EV_STREAM_ENABLED:
                        case meeting_EV_STREAM_DISABLED:
                        case EV_WHITEBOARD_STARTED:
                        case EV_WHITEBOARD_STOPPED:
                        case meeting_EV_CHARACTER_JOINED:
                        case meeting_EV_CHARACTER_LEFT:
                        case EV_MEETING_JOINED:
                        case EV_MEETING_LEFT:
                        case EV_VIDEO_STATE_CHANGED:
                        case EV_VIDEO_SEEKED:
                        case EV_MIC_REQUESTED:
                        case EV_WEBCAM_REQUESTED:
                        case EV_PIN_STATE_CHANGED:
                        case EV_CONNECTION_OPEN:
                        case EV_CONNECTION_CLOSE:
                        case EV_SWITCH_MEETING:
                        case EV_MEETING_STATE_CHANGE:
                        case EV_ERROR:
                        case EV_MEDIA_RELAY_STARTED:
                        case EV_MEDIA_RELAY_STOPPED:
                        case EV_MEDIA_RELAY_ERROR:
                        case EV_MEDIA_RELAY_REQUEST_RECEIVED:
                        case EV_MEDIA_RELAY_REQUEST_RESPONSE:
                        case EV_PARTICIPANT_MODE_CHANGED:
                        case EV_ALL_STREAMS_PAUSED:
                        case EV_ALL_STREAMS_RESUMED:
                        case EV_QUALITY_LIMITATION:
                          this.eventEmitter.off(eventType, listener);
                          break;
                        default:
                          throw new Error("Invalid event type.");
                      }
                    }
                  }]);
                }();
                function _handlePubsubMessage(data) {
                  var topic = data.topic, message = data.message, senderId = data.senderId, timestamp = data.timestamp, senderName = data.senderName, id = data.id, payload = data.payload;
                  if (!topic || !message) return;
                  meeting_classPrivateFieldGet(_topicEventEmitter, this).emit(topic, {
                    message,
                    senderId,
                    timestamp,
                    topic,
                    senderName,
                    id,
                    payload
                  });
                }
                function _handleRealtimeStoreValueChanged(data) {
                  var key = data.key, value = data.value, updatedBy = data.updatedBy;
                  if (!key) return;
                  meeting_classPrivateFieldGet(_realtimeStoreEventEmitter, this).emit(key, {
                    value,
                    updatedBy
                  });
                }
                function _handlePeerModeChanged(_ref45) {
                  var peerId = _ref45.peerId, mode = _ref45.mode;
                  if (peerId === this.localParticipant.id) {
                    this.localParticipant.mode = mode;
                  } else {
                    this.participants.get(peerId).mode = mode;
                  }
                  if (this.activePresenterId === this.localParticipant.id && !(0, modes.kR)(mode)) {
                    this.activePresenterId = null;
                    this.eventEmitter.emit(EV_PRESENTER_CHANGED, this.activePresenterId);
                  }
                  this.eventEmitter.emit(EV_PARTICIPANT_MODE_CHANGED, {
                    participantId: peerId,
                    mode
                  });
                }
                var errors = __webpack_require__2(7080);
                ;
                var recordingEvents = {
                  RECORDING_STARTING: "RECORDING_STARTING",
                  RECORDING_STARTED: "RECORDING_STARTED",
                  RECORDING_STOPPING: "RECORDING_STOPPING",
                  RECORDING_STOPPED: "RECORDING_STOPPED"
                };
                ;
                var livestreamEvents = {
                  LIVESTREAM_STARTING: "LIVESTREAM_STARTING",
                  LIVESTREAM_STARTED: "LIVESTREAM_STARTED",
                  LIVESTREAM_STOPPING: "LIVESTREAM_STOPPING",
                  LIVESTREAM_STOPPED: "LIVESTREAM_STOPPED"
                };
                var hlsEvents = __webpack_require__2(5071);
                ;
                var transcriptionEvents = {
                  TRANSCRIPTION_STARTING: "TRANSCRIPTION_STARTING",
                  TRANSCRIPTION_STARTED: "TRANSCRIPTION_STARTED",
                  TRANSCRIPTION_STOPPING: "TRANSCRIPTION_STOPPING",
                  TRANSCRIPTION_STOPPED: "TRANSCRIPTION_STOPPED"
                };
                ;
                var translationEvents = {
                  TRANSLATION_STARTING: "TRANSLATION_STARTING",
                  TRANSLATION_STARTED: "TRANSLATION_STARTED",
                  TRANSLATION_STOPPING: "TRANSLATION_STOPPING",
                  TRANSLATION_STOPPED: "TRANSLATION_STOPPED"
                };
                var media = __webpack_require__2(4973);
                var config2 = __webpack_require__2(9027);
                ;
                function DeviceInfo_callSuper(t, o, e) {
                  return o = (0, getPrototypeOf.A)(o), (0, possibleConstructorReturn.A)(t, DeviceInfo_isNativeReflectConstruct() ? Reflect.construct(o, e || [], (0, getPrototypeOf.A)(t).constructor) : o.apply(t, e));
                }
                function DeviceInfo_isNativeReflectConstruct() {
                  try {
                    var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
                    }));
                  } catch (t2) {
                  }
                  return (DeviceInfo_isNativeReflectConstruct = function _isNativeReflectConstruct2() {
                    return !!t;
                  })();
                }
                var MediaDeviceInfo = (0, createClass.A)(function MediaDeviceInfo2(deviceId, groupId, kind, label) {
                  (0, classCallCheck.A)(this, MediaDeviceInfo2);
                  this.deviceId = deviceId;
                  this.groupId = groupId;
                  this.kind = kind;
                  this.label = label;
                });
                var DeviceInfo2 = function(_MediaDeviceInfo) {
                  function DeviceInfo3(deviceId, groupId, kind, label) {
                    (0, classCallCheck.A)(this, DeviceInfo3);
                    return DeviceInfo_callSuper(this, DeviceInfo3, [deviceId, groupId, kind, label]);
                  }
                  (0, inherits.A)(DeviceInfo3, _MediaDeviceInfo);
                  return (0, createClass.A)(DeviceInfo3);
                }(MediaDeviceInfo);
                var CameraDeviceInfo2 = function(_DeviceInfo) {
                  function CameraDeviceInfo3(deviceId, groupId, kind, label) {
                    (0, classCallCheck.A)(this, CameraDeviceInfo3);
                    return DeviceInfo_callSuper(this, CameraDeviceInfo3, [deviceId, groupId, kind, label]);
                  }
                  (0, inherits.A)(CameraDeviceInfo3, _DeviceInfo);
                  return (0, createClass.A)(CameraDeviceInfo3);
                }(DeviceInfo2);
                var MicrophoneDeviceInfo2 = function(_DeviceInfo2) {
                  function MicrophoneDeviceInfo3(deviceId, groupId, kind, label) {
                    (0, classCallCheck.A)(this, MicrophoneDeviceInfo3);
                    return DeviceInfo_callSuper(this, MicrophoneDeviceInfo3, [deviceId, groupId, kind, label]);
                  }
                  (0, inherits.A)(MicrophoneDeviceInfo3, _DeviceInfo2);
                  return (0, createClass.A)(MicrophoneDeviceInfo3);
                }(DeviceInfo2);
                var PlaybackDeviceInfo = function(_DeviceInfo3) {
                  function PlaybackDeviceInfo2(deviceId, groupId, kind, label) {
                    (0, classCallCheck.A)(this, PlaybackDeviceInfo2);
                    return DeviceInfo_callSuper(this, PlaybackDeviceInfo2, [deviceId, groupId, kind, label]);
                  }
                  (0, inherits.A)(PlaybackDeviceInfo2, _DeviceInfo3);
                  return (0, createClass.A)(PlaybackDeviceInfo2);
                }(DeviceInfo2);
                ;
                var Permission = {
                  AUDIO: "audio",
                  VIDEO: "video",
                  AUDIO_AND_VIDEO: "audio_video"
                };
                var fetch_npm_browserify = __webpack_require__2(328);
                var lodash_memoize = __webpack_require__2(7654);
                ;
                function ascending(a, b) {
                  return a == null || b == null ? NaN : a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
                }
                ;
                function descending(a, b) {
                  return a == null || b == null ? NaN : b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;
                }
                ;
                function bisector(f) {
                  let compare1, compare2, delta;
                  if (f.length !== 2) {
                    compare1 = ascending;
                    compare2 = (d, x) => ascending(f(d), x);
                    delta = (d, x) => f(d) - x;
                  } else {
                    compare1 = f === ascending || f === descending ? f : zero;
                    compare2 = f;
                    delta = f;
                  }
                  function left(a, x, lo = 0, hi = a.length) {
                    if (lo < hi) {
                      if (compare1(x, x) !== 0) return hi;
                      do {
                        const mid = lo + hi >>> 1;
                        if (compare2(a[mid], x) < 0) lo = mid + 1;
                        else hi = mid;
                      } while (lo < hi);
                    }
                    return lo;
                  }
                  function right(a, x, lo = 0, hi = a.length) {
                    if (lo < hi) {
                      if (compare1(x, x) !== 0) return hi;
                      do {
                        const mid = lo + hi >>> 1;
                        if (compare2(a[mid], x) <= 0) lo = mid + 1;
                        else hi = mid;
                      } while (lo < hi);
                    }
                    return lo;
                  }
                  function center(a, x, lo = 0, hi = a.length) {
                    const i = left(a, x, lo, hi - 1);
                    return i > lo && delta(a[i - 1], x) > -delta(a[i], x) ? i - 1 : i;
                  }
                  return { left, center, right };
                }
                function zero() {
                  return 0;
                }
                ;
                function number(x) {
                  return x === null ? NaN : +x;
                }
                function* numbers(values, valueof) {
                  if (valueof === void 0) {
                    for (let value of values) {
                      if (value != null && (value = +value) >= value) {
                        yield value;
                      }
                    }
                  } else {
                    let index = -1;
                    for (let value of values) {
                      if ((value = valueof(value, ++index, values)) != null && (value = +value) >= value) {
                        yield value;
                      }
                    }
                  }
                }
                ;
                const ascendingBisect = bisector(ascending);
                const bisectRight = ascendingBisect.right;
                const bisectLeft = ascendingBisect.left;
                const bisectCenter = bisector(number).center;
                const bisect = bisectRight;
                ;
                function initRange(domain, range) {
                  switch (arguments.length) {
                    case 0:
                      break;
                    case 1:
                      this.range(domain);
                      break;
                    default:
                      this.range(range).domain(domain);
                      break;
                  }
                  return this;
                }
                function initInterpolator(domain, interpolator) {
                  switch (arguments.length) {
                    case 0:
                      break;
                    case 1: {
                      if (typeof domain === "function") this.interpolator(domain);
                      else this.range(domain);
                      break;
                    }
                    default: {
                      this.domain(domain);
                      if (typeof interpolator === "function") this.interpolator(interpolator);
                      else this.range(interpolator);
                      break;
                    }
                  }
                  return this;
                }
                ;
                function threshold() {
                  var domain = [0.5], range = [0, 1], unknown, n = 1;
                  function scale(x) {
                    return x != null && x <= x ? range[bisect(domain, x, 0, n)] : unknown;
                  }
                  scale.domain = function(_) {
                    return arguments.length ? (domain = Array.from(_), n = Math.min(domain.length, range.length - 1), scale) : domain.slice();
                  };
                  scale.range = function(_) {
                    return arguments.length ? (range = Array.from(_), n = Math.min(domain.length, range.length - 1), scale) : range.slice();
                  };
                  scale.invertExtent = function(y) {
                    var i = range.indexOf(y);
                    return [domain[i - 1], domain[i]];
                  };
                  scale.unknown = function(_) {
                    return arguments.length ? (unknown = _, scale) : unknown;
                  };
                  scale.copy = function() {
                    return threshold().domain(domain).range(range).unknown(unknown);
                  };
                  return initRange.apply(scale, arguments);
                }
                ;
                function speedtest_arrayLikeToArray(r, a) {
                  (null == a || a > r.length) && (a = r.length);
                  for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];
                  return n;
                }
                function _arrayWithHoles(r) {
                  if (Array.isArray(r)) return r;
                }
                function _arrayWithoutHoles(r) {
                  if (Array.isArray(r)) return speedtest_arrayLikeToArray(r);
                }
                function speedtest_assertClassBrand(e, t, n) {
                  if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n;
                  throw new TypeError("Private element is not present on this object");
                }
                function _assertThisInitialized(e) {
                  if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                  return e;
                }
                function speedtest_callSuper(t, o, e) {
                  return o = _getPrototypeOf(o), _possibleConstructorReturn(t, speedtest_isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e));
                }
                function speedtest_checkPrivateRedeclaration(e, t) {
                  if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object");
                }
                function _classCallCheck(a, n) {
                  if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
                }
                function _classPrivateFieldGet2(s, a) {
                  return s.get(speedtest_assertClassBrand(s, a));
                }
                function speedtest_classPrivateFieldInitSpec(e, t, a) {
                  speedtest_checkPrivateRedeclaration(e, t), t.set(e, a);
                }
                function _classPrivateFieldSet2(s, a, r) {
                  return s.set(speedtest_assertClassBrand(s, a), r), r;
                }
                function speedtest_classPrivateMethodInitSpec(e, a) {
                  speedtest_checkPrivateRedeclaration(e, a), a.add(e);
                }
                function _defineProperties(e, r) {
                  for (var t = 0; t < r.length; t++) {
                    var o = r[t];
                    o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(e, _toPropertyKey(o.key), o);
                  }
                }
                function _createClass(e, r, t) {
                  return r && _defineProperties(e.prototype, r), Object.defineProperty(e, "prototype", {
                    writable: false
                  }), e;
                }
                function _defineProperty(e, r, t) {
                  return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, {
                    value: t,
                    enumerable: true,
                    configurable: true,
                    writable: true
                  }) : e[r] = t, e;
                }
                function _get() {
                  return _get = "undefined" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function(e, t, r) {
                    var p = _superPropBase(e, t);
                    if (p) {
                      var n = Object.getOwnPropertyDescriptor(p, t);
                      return n.get ? n.get.call(arguments.length < 3 ? e : r) : n.value;
                    }
                  }, _get.apply(null, arguments);
                }
                function _getPrototypeOf(t) {
                  return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t2) {
                    return t2.__proto__ || Object.getPrototypeOf(t2);
                  }, _getPrototypeOf(t);
                }
                function _inherits(t, e) {
                  if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
                  t.prototype = Object.create(e && e.prototype, {
                    constructor: {
                      value: t,
                      writable: true,
                      configurable: true
                    }
                  }), Object.defineProperty(t, "prototype", {
                    writable: false
                  }), e && _setPrototypeOf(t, e);
                }
                function speedtest_isNativeReflectConstruct() {
                  try {
                    var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
                    }));
                  } catch (t2) {
                  }
                  return (speedtest_isNativeReflectConstruct = function() {
                    return !!t;
                  })();
                }
                function _iterableToArray(r) {
                  if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r);
                }
                function _iterableToArrayLimit(r, l) {
                  var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
                  if (null != t) {
                    var e, n, i, u, a = [], f = true, o = false;
                    try {
                      if (i = (t = t.call(r)).next, 0 === l) {
                        if (Object(t) !== t) return;
                        f = false;
                      } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = true) ;
                    } catch (r2) {
                      o = true, n = r2;
                    } finally {
                      try {
                        if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return;
                      } finally {
                        if (o) throw n;
                      }
                    }
                    return a;
                  }
                }
                function _nonIterableRest() {
                  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
                }
                function _nonIterableSpread() {
                  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
                }
                function speedtest_ownKeys(e, r) {
                  var t = Object.keys(e);
                  if (Object.getOwnPropertySymbols) {
                    var o = Object.getOwnPropertySymbols(e);
                    r && (o = o.filter(function(r2) {
                      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
                    })), t.push.apply(t, o);
                  }
                  return t;
                }
                function speedtest_objectSpread2(e) {
                  for (var r = 1; r < arguments.length; r++) {
                    var t = null != arguments[r] ? arguments[r] : {};
                    r % 2 ? speedtest_ownKeys(Object(t), true).forEach(function(r2) {
                      _defineProperty(e, r2, t[r2]);
                    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : speedtest_ownKeys(Object(t)).forEach(function(r2) {
                      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
                    });
                  }
                  return e;
                }
                function _objectWithoutProperties(e, t) {
                  if (null == e) return {};
                  var o, r, i = _objectWithoutPropertiesLoose2(e, t);
                  if (Object.getOwnPropertySymbols) {
                    var n = Object.getOwnPropertySymbols(e);
                    for (r = 0; r < n.length; r++) o = n[r], -1 === t.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]);
                  }
                  return i;
                }
                function _objectWithoutPropertiesLoose2(r, e) {
                  if (null == r) return {};
                  var t = {};
                  for (var n in r) if ({}.hasOwnProperty.call(r, n)) {
                    if (-1 !== e.indexOf(n)) continue;
                    t[n] = r[n];
                  }
                  return t;
                }
                function _possibleConstructorReturn(t, e) {
                  if (e && ("object" == typeof e || "function" == typeof e)) return e;
                  if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
                  return _assertThisInitialized(t);
                }
                function set(e, r, t, o) {
                  return set = "undefined" != typeof Reflect && Reflect.set ? Reflect.set : function(e2, r2, t2, o2) {
                    var f, i = _superPropBase(e2, r2);
                    if (i) {
                      if ((f = Object.getOwnPropertyDescriptor(i, r2)).set) return f.set.call(o2, t2), true;
                      if (!f.writable) return false;
                    }
                    if (f = Object.getOwnPropertyDescriptor(o2, r2)) {
                      if (!f.writable) return false;
                      f.value = t2, Object.defineProperty(o2, r2, f);
                    } else _defineProperty(o2, r2, t2);
                    return true;
                  }, set(e, r, t, o);
                }
                function _set(e, r, t, o, f) {
                  if (!set(e, r, t, o || e) && f) throw new TypeError("failed to set property");
                  return t;
                }
                function _setPrototypeOf(t, e) {
                  return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t2, e2) {
                    return t2.__proto__ = e2, t2;
                  }, _setPrototypeOf(t, e);
                }
                function _slicedToArray(r, e) {
                  return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || speedtest_unsupportedIterableToArray(r, e) || _nonIterableRest();
                }
                function _superPropBase(t, o) {
                  for (; !{}.hasOwnProperty.call(t, o) && null !== (t = _getPrototypeOf(t)); ) ;
                  return t;
                }
                function _superPropGet(t, o, e, r) {
                  var p = _get(_getPrototypeOf(t.prototype), o, e);
                  return 2 & r && "function" == typeof p ? function(t2) {
                    return p.apply(e, t2);
                  } : p;
                }
                function _superPropSet(t, e, o, r, p, f) {
                  return _set(_getPrototypeOf(t.prototype), e, o, r, p);
                }
                function _toConsumableArray(r) {
                  return _arrayWithoutHoles(r) || _iterableToArray(r) || speedtest_unsupportedIterableToArray(r) || _nonIterableSpread();
                }
                function _toPrimitive(t, r) {
                  if ("object" != typeof t || !t) return t;
                  var e = t[Symbol.toPrimitive];
                  if (void 0 !== e) {
                    var i = e.call(t, r);
                    if ("object" != typeof i) return i;
                    throw new TypeError("@@toPrimitive must return a primitive value.");
                  }
                  return String(t);
                }
                function _toPropertyKey(t) {
                  var i = _toPrimitive(t, "string");
                  return "symbol" == typeof i ? i : i + "";
                }
                function speedtest_unsupportedIterableToArray(r, a) {
                  if (r) {
                    if ("string" == typeof r) return speedtest_arrayLikeToArray(r, a);
                    var t = {}.toString.call(r).slice(8, -1);
                    return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? speedtest_arrayLikeToArray(r, a) : void 0;
                  }
                }
                var REL_API_URL = "https://speed.cloudflare.com";
                var defaultConfig = {
                  // Engine
                  autoStart: true,
                  // APIs
                  downloadApiUrl: "".concat(REL_API_URL, "/__down"),
                  uploadApiUrl: "".concat(REL_API_URL, "/__up"),
                  logMeasurementApiUrl: null,
                  logAimApiUrl: "https://aim.cloudflare.com/__log",
                  turnServerUri: "turn.speed.cloudflare.com:50000",
                  turnServerCredsApiUrl: "".concat(REL_API_URL, "/turn-creds"),
                  turnServerUser: null,
                  turnServerPass: null,
                  rpkiInvalidHost: "invalid.rpki.cloudflare.com",
                  cfTraceUrl: "".concat(REL_API_URL, "/cdn-cgi/trace"),
                  includeCredentials: false,
                  sessionId: void 0,
                  // Measurements
                  measurements: [
                    {
                      type: "latency",
                      numPackets: 1
                    },
                    // initial ttfb estimation
                    {
                      type: "download",
                      bytes: 1e5,
                      count: 1,
                      bypassMinDuration: true
                    },
                    // initial download estimation
                    {
                      type: "latency",
                      numPackets: 20
                    },
                    {
                      type: "download",
                      bytes: 1e5,
                      count: 9
                    },
                    {
                      type: "download",
                      bytes: 1e6,
                      count: 8
                    },
                    {
                      type: "upload",
                      bytes: 1e5,
                      count: 8
                    },
                    {
                      type: "packetLoss",
                      numPackets: 1e3,
                      batchSize: 10,
                      batchWaitTime: 10,
                      // ms (in between batches)
                      responsesWaitTime: 3e3
                      // ms (silent time after last sent msg)
                    },
                    {
                      type: "upload",
                      bytes: 1e6,
                      count: 6
                    },
                    {
                      type: "download",
                      bytes: 1e7,
                      count: 6
                    },
                    {
                      type: "upload",
                      bytes: 1e7,
                      count: 4
                    },
                    {
                      type: "download",
                      bytes: 25e6,
                      count: 4
                    },
                    {
                      type: "upload",
                      bytes: 25e6,
                      count: 4
                    },
                    {
                      type: "download",
                      bytes: 1e8,
                      count: 3
                    },
                    {
                      type: "upload",
                      bytes: 5e7,
                      count: 3
                    },
                    {
                      type: "download",
                      bytes: 25e7,
                      count: 2
                    }
                  ],
                  measureDownloadLoadedLatency: true,
                  measureUploadLoadedLatency: true,
                  loadedLatencyThrottle: 400,
                  // ms in between loaded latency requests
                  bandwidthFinishRequestDuration: 1e3,
                  // download/upload duration (ms) to reach for stopping further measurements
                  estimatedServerTime: 10,
                  // ms to discount from latency calculation (if not present in response headers)
                  // Result interpretation
                  latencyPercentile: 0.5,
                  // Percentile used to calculate latency from a set of measurements
                  bandwidthPercentile: 0.9,
                  // Percentile used to calculate bandwidth from a set of measurements
                  bandwidthMinRequestDuration: 10,
                  // minimum duration (ms) to consider a measurement good enough to use in bandwidth calculation
                  loadedRequestMinDuration: 250,
                  // minimum duration (ms) of a request to consider it to be loading the connection
                  loadedLatencyMaxPoints: 20
                  // number of data points to keep for loaded latency
                };
                var internalConfig = {
                  // AIM
                  aimMeasurementScoring: {
                    packetLoss: threshold([0.01, 0.05, 0.25, 0.5], [10, 5, 0, -10, -20]),
                    latency: threshold([10, 20, 50, 100, 500], [20, 10, 5, 0, -10, -20]),
                    loadedLatencyIncrease: threshold([10, 20, 50, 100, 500], [20, 10, 5, 0, -10, -20]),
                    jitter: threshold([10, 20, 100, 500], [10, 5, 0, -10, -20]),
                    download: threshold([1e6, 1e7, 5e7, 1e8], [0, 5, 10, 20, 30]),
                    upload: threshold([1e6, 1e7, 5e7, 1e8], [0, 5, 10, 20, 30])
                  },
                  aimExperiencesDefs: {
                    streaming: {
                      input: ["latency", "packetLoss", "download", "loadedLatencyIncrease"],
                      pointThresholds: [15, 20, 40, 60]
                    },
                    gaming: {
                      input: ["latency", "packetLoss", "loadedLatencyIncrease"],
                      pointThresholds: [5, 15, 25, 30]
                    },
                    rtc: {
                      input: ["latency", "jitter", "packetLoss", "loadedLatencyIncrease"],
                      pointThresholds: [5, 15, 25, 40]
                    }
                  }
                };
                var MAX_RETRIES = 20;
                var ESTIMATED_HEADER_FRACTION = 5e-3;
                var cfGetServerTime = function cfGetServerTime2(r) {
                  var serverTiming = r.headers.get("server-timing");
                  if (serverTiming) {
                    var re = serverTiming.match(/dur=([0-9.]+)/);
                    if (re) return +re[1];
                  }
                };
                var getTtfb = function getTtfb2(perf) {
                  return perf.responseStart - perf.requestStart;
                };
                var gePayloadDownload = function gePayloadDownload2(perf) {
                  return perf.responseEnd - perf.responseStart;
                };
                var calcDownloadDuration = function calcDownloadDuration2(_ref) {
                  var ping = _ref.ping, payloadDownloadTime = _ref.payloadDownloadTime;
                  return ping + payloadDownloadTime;
                };
                var calcUploadDuration = function calcUploadDuration2(_ref2) {
                  var ttfb = _ref2.ttfb;
                  return ttfb;
                };
                var calcDownloadSpeed = function calcDownloadSpeed2(_ref3, numBytes) {
                  var duration = _ref3.duration, transferSize = _ref3.transferSize;
                  var bits = 8 * (transferSize || +numBytes * (1 + ESTIMATED_HEADER_FRACTION));
                  var secs = duration / 1e3;
                  return !secs ? void 0 : bits / secs;
                };
                var calcUploadSpeed = function calcUploadSpeed2(_ref4, numBytes) {
                  var duration = _ref4.duration;
                  var bits = 8 * numBytes * (1 + ESTIMATED_HEADER_FRACTION);
                  var secs = duration / 1e3;
                  return !secs ? void 0 : bits / secs;
                };
                var genContent = lodash_memoize(function(numBytes) {
                  return "0".repeat(numBytes);
                });
                var _qsParams = /* @__PURE__ */ new WeakMap();
                var _fetchOptions = /* @__PURE__ */ new WeakMap();
                var _responseHook = /* @__PURE__ */ new WeakMap();
                var _onRunningChange = /* @__PURE__ */ new WeakMap();
                var _onNewMeasurementStarted = /* @__PURE__ */ new WeakMap();
                var _onMeasurementResult = /* @__PURE__ */ new WeakMap();
                var _onFinished$1 = /* @__PURE__ */ new WeakMap();
                var _onConnectionError$1 = /* @__PURE__ */ new WeakMap();
                var _measurements = /* @__PURE__ */ new WeakMap();
                var _downloadApi = /* @__PURE__ */ new WeakMap();
                var _uploadApi = /* @__PURE__ */ new WeakMap();
                var _running$2 = /* @__PURE__ */ new WeakMap();
                var _finished$1 = /* @__PURE__ */ new WeakMap();
                var _results$1 = /* @__PURE__ */ new WeakMap();
                var _measIdx = /* @__PURE__ */ new WeakMap();
                var _counter = /* @__PURE__ */ new WeakMap();
                var _retries = /* @__PURE__ */ new WeakMap();
                var _minDuration = /* @__PURE__ */ new WeakMap();
                var _throttleMs = /* @__PURE__ */ new WeakMap();
                var _estimatedServerTime = /* @__PURE__ */ new WeakMap();
                var _currentFetchPromise = /* @__PURE__ */ new WeakMap();
                var _currentNextMsmTimeoutId = /* @__PURE__ */ new WeakMap();
                var _BandwidthMeasurementEngine_brand = /* @__PURE__ */ new WeakSet();
                var BandwidthMeasurementEngine = function() {
                  function BandwidthMeasurementEngine2(_measurements2) {
                    var _ref5 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, downloadApiUrl = _ref5.downloadApiUrl, uploadApiUrl = _ref5.uploadApiUrl, _ref5$throttleMs = _ref5.throttleMs, throttleMs = _ref5$throttleMs === void 0 ? 0 : _ref5$throttleMs, _ref5$estimatedServer = _ref5.estimatedServerTime, estimatedServerTime = _ref5$estimatedServer === void 0 ? 0 : _ref5$estimatedServer;
                    _classCallCheck(this, BandwidthMeasurementEngine2);
                    speedtest_classPrivateMethodInitSpec(this, _BandwidthMeasurementEngine_brand);
                    speedtest_classPrivateFieldInitSpec(this, _qsParams, {});
                    speedtest_classPrivateFieldInitSpec(this, _fetchOptions, {});
                    _defineProperty(this, "finishRequestDuration", 1e3);
                    _defineProperty(this, "getServerTime", cfGetServerTime);
                    speedtest_classPrivateFieldInitSpec(this, _responseHook, function(r) {
                      return r;
                    });
                    speedtest_classPrivateFieldInitSpec(this, _onRunningChange, function() {
                    });
                    speedtest_classPrivateFieldInitSpec(this, _onNewMeasurementStarted, function() {
                    });
                    speedtest_classPrivateFieldInitSpec(this, _onMeasurementResult, function() {
                    });
                    speedtest_classPrivateFieldInitSpec(this, _onFinished$1, function() {
                    });
                    speedtest_classPrivateFieldInitSpec(this, _onConnectionError$1, function() {
                    });
                    speedtest_classPrivateFieldInitSpec(this, _measurements, void 0);
                    speedtest_classPrivateFieldInitSpec(this, _downloadApi, void 0);
                    speedtest_classPrivateFieldInitSpec(this, _uploadApi, void 0);
                    speedtest_classPrivateFieldInitSpec(this, _running$2, false);
                    speedtest_classPrivateFieldInitSpec(this, _finished$1, {
                      down: false,
                      up: false
                    });
                    speedtest_classPrivateFieldInitSpec(this, _results$1, {
                      down: {},
                      up: {}
                    });
                    speedtest_classPrivateFieldInitSpec(this, _measIdx, 0);
                    speedtest_classPrivateFieldInitSpec(this, _counter, 0);
                    speedtest_classPrivateFieldInitSpec(this, _retries, 0);
                    speedtest_classPrivateFieldInitSpec(this, _minDuration, -Infinity);
                    speedtest_classPrivateFieldInitSpec(this, _throttleMs, 0);
                    speedtest_classPrivateFieldInitSpec(this, _estimatedServerTime, 0);
                    speedtest_classPrivateFieldInitSpec(this, _currentFetchPromise, void 0);
                    speedtest_classPrivateFieldInitSpec(this, _currentNextMsmTimeoutId, void 0);
                    if (!_measurements2) throw new Error("Missing measurements argument");
                    if (!downloadApiUrl) throw new Error("Missing downloadApiUrl argument");
                    if (!uploadApiUrl) throw new Error("Missing uploadApiUrl argument");
                    _classPrivateFieldSet2(_measurements, this, _measurements2);
                    _classPrivateFieldSet2(_downloadApi, this, downloadApiUrl);
                    _classPrivateFieldSet2(_uploadApi, this, uploadApiUrl);
                    _classPrivateFieldSet2(_throttleMs, this, throttleMs);
                    _classPrivateFieldSet2(_estimatedServerTime, this, Math.max(0, estimatedServerTime));
                  }
                  return _createClass(BandwidthMeasurementEngine2, [{
                    key: "results",
                    get: function get() {
                      return _classPrivateFieldGet2(_results$1, this);
                    }
                  }, {
                    key: "qsParams",
                    get: (
                      // additional query string params to include in the requests
                      function get() {
                        return _classPrivateFieldGet2(_qsParams, this);
                      }
                    ),
                    set: function set2(v) {
                      _classPrivateFieldSet2(_qsParams, this, v);
                    }
                  }, {
                    key: "fetchOptions",
                    get: (
                      // additional options included in the requests
                      function get() {
                        return _classPrivateFieldGet2(_fetchOptions, this);
                      }
                    ),
                    set: function set2(v) {
                      _classPrivateFieldSet2(_fetchOptions, this, v);
                    }
                  }, {
                    key: "responseHook",
                    set: (
                      // pipe-through of response objects
                      function set2(f) {
                        _classPrivateFieldSet2(_responseHook, this, f);
                      }
                    )
                  }, {
                    key: "onRunningChange",
                    set: (
                      // callback invoked when engine starts/stops
                      function set2(f) {
                        _classPrivateFieldSet2(_onRunningChange, this, f);
                      }
                    )
                  }, {
                    key: "onNewMeasurementStarted",
                    set: (
                      // callback invoked when a new item in the measurement list is started
                      function set2(f) {
                        _classPrivateFieldSet2(_onNewMeasurementStarted, this, f);
                      }
                    )
                  }, {
                    key: "onMeasurementResult",
                    set: (
                      // callback invoked when a new measurement result arrives
                      function set2(f) {
                        _classPrivateFieldSet2(_onMeasurementResult, this, f);
                      }
                    )
                  }, {
                    key: "onFinished",
                    set: (
                      // callback invoked when all the measurements are finished
                      function set2(f) {
                        _classPrivateFieldSet2(_onFinished$1, this, f);
                      }
                    )
                  }, {
                    key: "onConnectionError",
                    set: (
                      // Invoked when unable to get a response from the API
                      function set2(f) {
                        _classPrivateFieldSet2(_onConnectionError$1, this, f);
                      }
                    )
                    // Public methods
                  }, {
                    key: "pause",
                    value: function pause() {
                      clearTimeout(_classPrivateFieldGet2(_currentNextMsmTimeoutId, this));
                      speedtest_assertClassBrand(_BandwidthMeasurementEngine_brand, this, _cancelCurrentMeasurement).call(this);
                      speedtest_assertClassBrand(_BandwidthMeasurementEngine_brand, this, _setRunning$2).call(this, false);
                    }
                  }, {
                    key: "play",
                    value: function play() {
                      if (!_classPrivateFieldGet2(_running$2, this)) {
                        speedtest_assertClassBrand(_BandwidthMeasurementEngine_brand, this, _setRunning$2).call(this, true);
                        speedtest_assertClassBrand(_BandwidthMeasurementEngine_brand, this, _nextMeasurement).call(this);
                      }
                    }
                  }]);
                }();
                function _setRunning$2(running) {
                  var _this = this;
                  if (running !== _classPrivateFieldGet2(_running$2, this)) {
                    _classPrivateFieldSet2(_running$2, this, running);
                    setTimeout(function() {
                      return _classPrivateFieldGet2(_onRunningChange, _this).call(_this, _classPrivateFieldGet2(_running$2, _this));
                    });
                  }
                }
                function _saveMeasurementResults(measIdx, measTiming) {
                  var _this2 = this;
                  var _classPrivateFieldGet2$1 = _classPrivateFieldGet2(_measurements, this)[measIdx], bytes = _classPrivateFieldGet2$1.bytes, dir = _classPrivateFieldGet2$1.dir;
                  var results = _classPrivateFieldGet2(_results$1, this);
                  var bytesResult = results[dir].hasOwnProperty(bytes) ? results[dir][bytes] : {
                    timings: [],
                    // count all measurements with same bytes and direction
                    numMeasurements: _classPrivateFieldGet2(_measurements, this).filter(function(_ref6) {
                      var b = _ref6.bytes, d = _ref6.dir;
                      return bytes === b && dir === d;
                    }).map(function(m) {
                      return m.count;
                    }).reduce(function(agg, cnt) {
                      return agg + cnt;
                    }, 0)
                  };
                  !!measTiming && bytesResult.timings.push(measTiming);
                  bytesResult.timings = bytesResult.timings.slice(-bytesResult.numMeasurements);
                  results[dir][bytes] = bytesResult;
                  if (measTiming) {
                    setTimeout(function() {
                      _classPrivateFieldGet2(_onMeasurementResult, _this2).call(_this2, speedtest_objectSpread2({
                        type: dir,
                        bytes
                      }, measTiming), results);
                    });
                  } else {
                    _classPrivateFieldGet2(_onNewMeasurementStarted, this).call(this, _classPrivateFieldGet2(_measurements, this)[measIdx], results);
                  }
                }
                function _nextMeasurement() {
                  var _this3 = this;
                  var measurements = _classPrivateFieldGet2(_measurements, this);
                  var meas = measurements[_classPrivateFieldGet2(_measIdx, this)];
                  if (_classPrivateFieldGet2(_counter, this) >= meas.count) {
                    var finished = _classPrivateFieldGet2(_finished$1, this);
                    if (_classPrivateFieldGet2(_minDuration, this) > this.finishRequestDuration && !meas.bypassMinDuration) {
                      var _dir = meas.dir;
                      _classPrivateFieldGet2(_finished$1, this)[_dir] = true;
                      Object.values(_classPrivateFieldGet2(_finished$1, this)).every(function(finished2) {
                        return finished2;
                      }) && _classPrivateFieldGet2(_onFinished$1, this).call(this, _classPrivateFieldGet2(_results$1, this));
                    }
                    _classPrivateFieldSet2(_counter, this, 0);
                    _classPrivateFieldSet2(_minDuration, this, -Infinity);
                    performance.clearResourceTimings();
                    do {
                      _classPrivateFieldSet2(_measIdx, this, _classPrivateFieldGet2(_measIdx, this) + 1);
                    } while (_classPrivateFieldGet2(_measIdx, this) < measurements.length && finished[measurements[_classPrivateFieldGet2(_measIdx, this)].dir]);
                    if (_classPrivateFieldGet2(_measIdx, this) >= measurements.length) {
                      _classPrivateFieldSet2(_finished$1, this, {
                        down: true,
                        up: true
                      });
                      speedtest_assertClassBrand(_BandwidthMeasurementEngine_brand, this, _setRunning$2).call(this, false);
                      _classPrivateFieldGet2(_onFinished$1, this).call(this, _classPrivateFieldGet2(_results$1, this));
                      return;
                    }
                    meas = measurements[_classPrivateFieldGet2(_measIdx, this)];
                  }
                  var measIdx = _classPrivateFieldGet2(_measIdx, this);
                  if (_classPrivateFieldGet2(_counter, this) === 0) {
                    speedtest_assertClassBrand(_BandwidthMeasurementEngine_brand, this, _saveMeasurementResults).call(this, measIdx);
                  }
                  var _meas = meas, numBytes = _meas.bytes, dir = _meas.dir;
                  var isDown = dir === "down";
                  var apiUrl = isDown ? _classPrivateFieldGet2(_downloadApi, this) : _classPrivateFieldGet2(_uploadApi, this);
                  var qsParams = Object.assign({}, _classPrivateFieldGet2(_qsParams, this));
                  isDown && (qsParams.bytes = "".concat(numBytes));
                  var url = "".concat(
                    apiUrl.startsWith("http") || apiUrl.startsWith("//") ? "" : window.location.origin
                    // use abs to match perf timing urls
                  ).concat(apiUrl, "?").concat(Object.entries(qsParams).map(function(_ref7) {
                    var _ref8 = _slicedToArray(_ref7, 2), k = _ref8[0], v = _ref8[1];
                    return "".concat(k, "=").concat(v);
                  }).join("&"));
                  var fetchOpt = Object.assign({}, isDown ? {} : {
                    method: "POST",
                    body: genContent(numBytes)
                  }, _classPrivateFieldGet2(_fetchOptions, this));
                  var serverTime;
                  var curPromise = _classPrivateFieldSet2(_currentFetchPromise, this, fetch(url, fetchOpt).then(function(r) {
                    if (r.ok) return r;
                    throw Error(r.statusText);
                  }).then(function(r) {
                    _this3.getServerTime && (serverTime = _this3.getServerTime(r));
                    return r;
                  }).then(function(r) {
                    return r.text().then(function(body) {
                      _classPrivateFieldGet2(_responseHook, _this3) && _classPrivateFieldGet2(_responseHook, _this3).call(_this3, {
                        url,
                        headers: r.headers,
                        body
                      });
                      return body;
                    });
                  }).then(function(_, reject) {
                    if (curPromise._cancel) {
                      reject("cancelled");
                      return;
                    }
                    var perf = performance.getEntriesByName(url).slice(-1)[0];
                    var timing = {
                      transferSize: perf.transferSize,
                      ttfb: getTtfb(perf),
                      payloadDownloadTime: gePayloadDownload(perf),
                      serverTime: serverTime || -1,
                      measTime: /* @__PURE__ */ new Date()
                    };
                    timing.ping = Math.max(0.01, timing.ttfb - (serverTime || _classPrivateFieldGet2(_estimatedServerTime, _this3)));
                    timing.duration = (isDown ? calcDownloadDuration : calcUploadDuration)(timing);
                    timing.bps = (isDown ? calcDownloadSpeed : calcUploadSpeed)(timing, numBytes);
                    if (isDown && numBytes) {
                      var reqSize = +numBytes;
                      if (timing.transferSize && (timing.transferSize < reqSize || timing.transferSize / reqSize > 1.05)) {
                        console.warn("Requested ".concat(reqSize, "B but received ").concat(timing.transferSize, "B (").concat(Math.round(timing.transferSize / reqSize * 1e4) / 100, "%)."));
                      }
                    }
                    speedtest_assertClassBrand(_BandwidthMeasurementEngine_brand, _this3, _saveMeasurementResults).call(_this3, measIdx, timing);
                    var requestDuration = timing.duration;
                    _classPrivateFieldSet2(_minDuration, _this3, _classPrivateFieldGet2(_minDuration, _this3) < 0 ? requestDuration : Math.min(_classPrivateFieldGet2(_minDuration, _this3), requestDuration));
                    _classPrivateFieldSet2(_counter, _this3, _classPrivateFieldGet2(_counter, _this3) + 1);
                    _classPrivateFieldSet2(_retries, _this3, 0);
                    if (_classPrivateFieldGet2(_throttleMs, _this3)) {
                      _classPrivateFieldSet2(_currentNextMsmTimeoutId, _this3, setTimeout(function() {
                        return speedtest_assertClassBrand(_BandwidthMeasurementEngine_brand, _this3, _nextMeasurement).call(_this3);
                      }, _classPrivateFieldGet2(_throttleMs, _this3)));
                    } else {
                      speedtest_assertClassBrand(_BandwidthMeasurementEngine_brand, _this3, _nextMeasurement).call(_this3);
                    }
                  })["catch"](function(error) {
                    var _this$retries, _this$retries2;
                    if (curPromise._cancel) return;
                    console.warn("Error fetching ".concat(url, ": ").concat(error));
                    if ((_classPrivateFieldSet2(_retries, _this3, (_this$retries = _classPrivateFieldGet2(_retries, _this3), _this$retries2 = _this$retries++, _this$retries)), _this$retries2) < MAX_RETRIES) {
                      speedtest_assertClassBrand(_BandwidthMeasurementEngine_brand, _this3, _nextMeasurement).call(_this3);
                    } else {
                      _classPrivateFieldSet2(_retries, _this3, 0);
                      speedtest_assertClassBrand(_BandwidthMeasurementEngine_brand, _this3, _setRunning$2).call(_this3, false);
                      _classPrivateFieldGet2(_onConnectionError$1, _this3).call(_this3, "Connection failed to ".concat(url, ". Gave up after ").concat(MAX_RETRIES, " retries."));
                    }
                  }));
                }
                function _cancelCurrentMeasurement() {
                  var curPromise = _classPrivateFieldGet2(_currentFetchPromise, this);
                  curPromise && (curPromise._cancel = true);
                }
                var _excluded$5 = ["measureParallelLatency", "parallelLatencyThrottleMs", "downloadApiUrl", "uploadApiUrl", "estimatedServerTime"];
                var _latencyEngine = /* @__PURE__ */ new WeakMap();
                var _latencyTimeout = /* @__PURE__ */ new WeakMap();
                var _BandwidthWithParallelLatencyEngine_brand = /* @__PURE__ */ new WeakSet();
                var BandwidthWithParallelLatencyEngine = function(_BandwidthEngine) {
                  function BandwidthWithParallelLatencyEngine2(measurements) {
                    var _this;
                    var _ref = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, _ref$measureParallelL = _ref.measureParallelLatency, measureParallelLatency = _ref$measureParallelL === void 0 ? false : _ref$measureParallelL, _ref$parallelLatencyT = _ref.parallelLatencyThrottleMs, parallelLatencyThrottleMs = _ref$parallelLatencyT === void 0 ? 100 : _ref$parallelLatencyT, downloadApiUrl = _ref.downloadApiUrl, uploadApiUrl = _ref.uploadApiUrl, _ref$estimatedServerT = _ref.estimatedServerTime, estimatedServerTime = _ref$estimatedServerT === void 0 ? 0 : _ref$estimatedServerT, ptProps = _objectWithoutProperties(_ref, _excluded$5);
                    _classCallCheck(this, BandwidthWithParallelLatencyEngine2);
                    _this = speedtest_callSuper(this, BandwidthWithParallelLatencyEngine2, [measurements, speedtest_objectSpread2({
                      downloadApiUrl,
                      uploadApiUrl,
                      estimatedServerTime
                    }, ptProps)]);
                    speedtest_classPrivateMethodInitSpec(_this, _BandwidthWithParallelLatencyEngine_brand);
                    speedtest_classPrivateFieldInitSpec(_this, _latencyEngine, void 0);
                    speedtest_classPrivateFieldInitSpec(_this, _latencyTimeout, void 0);
                    if (measureParallelLatency) {
                      _classPrivateFieldSet2(_latencyEngine, _this, new BandwidthMeasurementEngine([{
                        dir: "down",
                        bytes: 0,
                        count: Infinity,
                        bypassMinDuration: true
                      }], {
                        downloadApiUrl,
                        uploadApiUrl,
                        estimatedServerTime,
                        throttleMs: parallelLatencyThrottleMs
                      }));
                      _classPrivateFieldGet2(_latencyEngine, _this).qsParams = {
                        during: "".concat(measurements[0].dir, "load")
                      };
                      _superPropSet(BandwidthWithParallelLatencyEngine2, "onRunningChange", speedtest_assertClassBrand(_BandwidthWithParallelLatencyEngine_brand, _this, _setLatencyRunning), _this, 1);
                      _superPropSet(BandwidthWithParallelLatencyEngine2, "onConnectionError", function() {
                        return _classPrivateFieldGet2(_latencyEngine, _this).pause();
                      }, _this, 1);
                    }
                    return _this;
                  }
                  _inherits(BandwidthWithParallelLatencyEngine2, _BandwidthEngine);
                  return _createClass(BandwidthWithParallelLatencyEngine2, [{
                    key: "latencyResults",
                    get: function get() {
                      return _classPrivateFieldGet2(_latencyEngine, this) && _classPrivateFieldGet2(_latencyEngine, this).results.down[0].timings;
                    }
                    // callback invoked when a new parallel latency result arrives
                  }, {
                    key: "onParallelLatencyResult",
                    set: function set2(f) {
                      _classPrivateFieldGet2(_latencyEngine, this) && (_classPrivateFieldGet2(_latencyEngine, this).onMeasurementResult = function(res) {
                        return f(res);
                      });
                    }
                    // Overridden attributes
                  }, {
                    key: "fetchOptions",
                    get: function get() {
                      return _superPropGet(BandwidthWithParallelLatencyEngine2, "fetchOptions", this, 1);
                    },
                    set: function set2(fetchOptions) {
                      _superPropSet(BandwidthWithParallelLatencyEngine2, "fetchOptions", fetchOptions, this, 1);
                      _classPrivateFieldGet2(_latencyEngine, this) && (_classPrivateFieldGet2(_latencyEngine, this).fetchOptions = fetchOptions);
                    }
                  }, {
                    key: "onRunningChange",
                    set: function set2(onRunningChange) {
                      var _this2 = this;
                      _superPropSet(BandwidthWithParallelLatencyEngine2, "onRunningChange", function(running) {
                        speedtest_assertClassBrand(_BandwidthWithParallelLatencyEngine_brand, _this2, _setLatencyRunning).call(_this2, running);
                        onRunningChange(running);
                      }, this, 1);
                    }
                  }, {
                    key: "onConnectionError",
                    set: function set2(onConnectionError) {
                      var _this3 = this;
                      _superPropSet(BandwidthWithParallelLatencyEngine2, "onConnectionError", function() {
                        _classPrivateFieldGet2(_latencyEngine, _this3) && _classPrivateFieldGet2(_latencyEngine, _this3).pause();
                        onConnectionError.apply(void 0, arguments);
                      }, this, 1);
                    }
                  }]);
                }(BandwidthMeasurementEngine);
                function _setLatencyRunning(running) {
                  var _this4 = this;
                  if (_classPrivateFieldGet2(_latencyEngine, this)) {
                    if (!running) {
                      clearTimeout(_classPrivateFieldGet2(_latencyTimeout, this));
                      _classPrivateFieldGet2(_latencyEngine, this).pause();
                    } else {
                      _classPrivateFieldSet2(_latencyTimeout, this, setTimeout(function() {
                        return _classPrivateFieldGet2(_latencyEngine, _this4).play();
                      }, 20));
                    }
                  }
                }
                var _excluded$4 = ["measurementId", "logApiUrl", "sessionId"];
                var _measurementId$1 = /* @__PURE__ */ new WeakMap();
                var _token = /* @__PURE__ */ new WeakMap();
                var _requestTime = /* @__PURE__ */ new WeakMap();
                var _logApiUrl = /* @__PURE__ */ new WeakMap();
                var _sessionId$1 = /* @__PURE__ */ new WeakMap();
                var _LoggingBandwidthEngine_brand = /* @__PURE__ */ new WeakSet();
                var LoggingBandwidthEngine = function(_BandwidthEngine) {
                  function LoggingBandwidthEngine2(measurements) {
                    var _this;
                    var _ref = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, measurementId = _ref.measurementId, logApiUrl = _ref.logApiUrl, sessionId = _ref.sessionId, ptProps = _objectWithoutProperties(_ref, _excluded$4);
                    _classCallCheck(this, LoggingBandwidthEngine2);
                    _this = speedtest_callSuper(this, LoggingBandwidthEngine2, [measurements, ptProps]);
                    speedtest_classPrivateMethodInitSpec(_this, _LoggingBandwidthEngine_brand);
                    speedtest_classPrivateFieldInitSpec(_this, _measurementId$1, void 0);
                    speedtest_classPrivateFieldInitSpec(_this, _token, void 0);
                    speedtest_classPrivateFieldInitSpec(_this, _requestTime, void 0);
                    speedtest_classPrivateFieldInitSpec(_this, _logApiUrl, void 0);
                    speedtest_classPrivateFieldInitSpec(_this, _sessionId$1, void 0);
                    _classPrivateFieldSet2(_measurementId$1, _this, measurementId);
                    _classPrivateFieldSet2(_logApiUrl, _this, logApiUrl);
                    _classPrivateFieldSet2(_sessionId$1, _this, sessionId);
                    _superPropSet(LoggingBandwidthEngine2, "qsParams", logApiUrl ? {
                      measId: _classPrivateFieldGet2(_measurementId$1, _this)
                    } : {}, _this, 1);
                    _superPropSet(LoggingBandwidthEngine2, "responseHook", function(r) {
                      return speedtest_assertClassBrand(_LoggingBandwidthEngine_brand, _this, _loggingResponseHook).call(_this, r);
                    }, _this, 1);
                    _superPropSet(LoggingBandwidthEngine2, "onMeasurementResult", function(meas) {
                      return speedtest_assertClassBrand(_LoggingBandwidthEngine_brand, _this, _logMeasurement).call(_this, meas);
                    }, _this, 1);
                    return _this;
                  }
                  _inherits(LoggingBandwidthEngine2, _BandwidthEngine);
                  return _createClass(LoggingBandwidthEngine2, [{
                    key: "qsParams",
                    set: function set2(qsParams) {
                      _superPropSet(LoggingBandwidthEngine2, "qsParams", _classPrivateFieldGet2(_logApiUrl, this) ? speedtest_objectSpread2({
                        measId: _classPrivateFieldGet2(_measurementId$1, this)
                      }, qsParams) : qsParams, this, 1);
                    }
                  }, {
                    key: "responseHook",
                    set: function set2(responseHook) {
                      var _this2 = this;
                      _superPropSet(LoggingBandwidthEngine2, "responseHook", function(r) {
                        responseHook(r);
                        speedtest_assertClassBrand(_LoggingBandwidthEngine_brand, _this2, _loggingResponseHook).call(_this2, r);
                      }, this, 1);
                    }
                  }, {
                    key: "onMeasurementResult",
                    set: function set2(onMeasurementResult) {
                      var _this3 = this;
                      _superPropSet(LoggingBandwidthEngine2, "onMeasurementResult", function(meas) {
                        for (var _len = arguments.length, restArgs = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                          restArgs[_key - 1] = arguments[_key];
                        }
                        onMeasurementResult.apply(void 0, [meas].concat(restArgs));
                        speedtest_assertClassBrand(_LoggingBandwidthEngine_brand, _this3, _logMeasurement).call(_this3, meas);
                      }, this, 1);
                    }
                  }]);
                }(BandwidthWithParallelLatencyEngine);
                function _loggingResponseHook(r) {
                  if (!_classPrivateFieldGet2(_logApiUrl, this)) return;
                  _classPrivateFieldSet2(_requestTime, this, +r.headers.get("cf-meta-request-time"));
                  _classPrivateFieldSet2(_token, this, r.body.slice(-300).split("___").pop());
                }
                function _logMeasurement(measData) {
                  if (!_classPrivateFieldGet2(_logApiUrl, this)) return;
                  var logData = {
                    type: measData.type,
                    bytes: measData.bytes,
                    ping: Math.round(measData.ping),
                    // round to ms
                    ttfb: Math.round(measData.ttfb),
                    // round to ms
                    payloadDownloadTime: Math.round(measData.payloadDownloadTime),
                    duration: Math.round(measData.duration),
                    transferSize: Math.round(measData.transferSize),
                    serverTime: Math.round(measData.serverTime),
                    token: _classPrivateFieldGet2(_token, this),
                    requestTime: _classPrivateFieldGet2(_requestTime, this),
                    measId: _classPrivateFieldGet2(_measurementId$1, this),
                    sessionId: _classPrivateFieldGet2(_sessionId$1, this)
                  };
                  _classPrivateFieldSet2(_token, this, null);
                  _classPrivateFieldSet2(_requestTime, this, null);
                  fetch(_classPrivateFieldGet2(_logApiUrl, this), speedtest_objectSpread2({
                    method: "POST",
                    body: JSON.stringify(logData)
                  }, this.fetchOptions));
                }
                var _running$1 = /* @__PURE__ */ new WeakMap();
                var _currentPromise = /* @__PURE__ */ new WeakMap();
                var _promiseFn = /* @__PURE__ */ new WeakMap();
                var _PromiseEngine_brand = /* @__PURE__ */ new WeakSet();
                var PromiseEngine = function() {
                  function PromiseEngine2(promiseFn) {
                    _classCallCheck(this, PromiseEngine2);
                    speedtest_classPrivateMethodInitSpec(this, _PromiseEngine_brand);
                    speedtest_classPrivateFieldInitSpec(this, _running$1, false);
                    speedtest_classPrivateFieldInitSpec(this, _currentPromise, void 0);
                    speedtest_classPrivateFieldInitSpec(this, _promiseFn, void 0);
                    if (!promiseFn) throw new Error("Missing operation to perform");
                    _classPrivateFieldSet2(_promiseFn, this, promiseFn);
                    this.play();
                  }
                  return _createClass(PromiseEngine2, [{
                    key: "pause",
                    value: function pause() {
                      speedtest_assertClassBrand(_PromiseEngine_brand, this, _cancelCurrent).call(this);
                      speedtest_assertClassBrand(_PromiseEngine_brand, this, _setRunning$1).call(this, false);
                    }
                  }, {
                    key: "stop",
                    value: function stop() {
                      this.pause();
                    }
                  }, {
                    key: "play",
                    value: function play() {
                      if (!_classPrivateFieldGet2(_running$1, this)) {
                        speedtest_assertClassBrand(_PromiseEngine_brand, this, _setRunning$1).call(this, true);
                        speedtest_assertClassBrand(_PromiseEngine_brand, this, _next$1).call(this);
                      }
                    }
                  }]);
                }();
                function _setRunning$1(running) {
                  if (running !== _classPrivateFieldGet2(_running$1, this)) {
                    _classPrivateFieldSet2(_running$1, this, running);
                  }
                }
                function _next$1() {
                  var _this2 = this;
                  var curPromise = _classPrivateFieldSet2(_currentPromise, this, _classPrivateFieldGet2(_promiseFn, this).call(this).then(function() {
                    !curPromise._cancel && speedtest_assertClassBrand(_PromiseEngine_brand, _this2, _next$1).call(_this2);
                  }));
                }
                function _cancelCurrent() {
                  var curPromise = _classPrivateFieldGet2(_currentPromise, this);
                  curPromise && (curPromise._cancel = true);
                }
                var _engines = /* @__PURE__ */ new WeakMap();
                var LoadNetworkEngine = function() {
                  function LoadNetworkEngine2() {
                    var _this = this;
                    var _ref = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, download = _ref.download, upload = _ref.upload;
                    _classCallCheck(this, LoadNetworkEngine2);
                    _defineProperty(this, "qsParams", {});
                    _defineProperty(this, "fetchOptions", {});
                    speedtest_classPrivateFieldInitSpec(this, _engines, []);
                    if (!download && !upload) throw new Error("Missing at least one of download/upload config");
                    [[download, "download"], [upload, "upload"]].filter(function(_ref2) {
                      var _ref3 = _slicedToArray(_ref2, 1), cfg = _ref3[0];
                      return cfg;
                    }).forEach(function(_ref4) {
                      var _ref5 = _slicedToArray(_ref4, 2), cfg = _ref5[0], type = _ref5[1];
                      var apiUrl = cfg.apiUrl, chunkSize = cfg.chunkSize;
                      if (!apiUrl) throw new Error("Missing ".concat(type, " apiUrl argument"));
                      if (!chunkSize) throw new Error("Missing ".concat(type, " chunkSize argument"));
                    });
                    var getLoadEngine = function getLoadEngine2(_ref6) {
                      var apiUrl = _ref6.apiUrl, _ref6$qsParams = _ref6.qsParams, qsParams = _ref6$qsParams === void 0 ? {} : _ref6$qsParams, _ref6$fetchOptions = _ref6.fetchOptions, fetchOptions = _ref6$fetchOptions === void 0 ? {} : _ref6$fetchOptions;
                      return new PromiseEngine(function() {
                        var fetchQsParams = Object.assign({}, qsParams, _this.qsParams);
                        var url = "".concat(
                          apiUrl.startsWith("http") || apiUrl.startsWith("//") ? "" : window.location.origin
                          // use abs to match perf timing urls
                        ).concat(apiUrl, "?").concat(Object.entries(fetchQsParams).map(function(_ref7) {
                          var _ref8 = _slicedToArray(_ref7, 2), k = _ref8[0], v = _ref8[1];
                          return "".concat(k, "=").concat(v);
                        }).join("&"));
                        var fetchOpt = Object.assign({}, fetchOptions, _this.fetchOptions);
                        return fetch(url, fetchOpt).then(function(r) {
                          if (r.ok) return r;
                          throw Error(r.statusText);
                        }).then(function(r) {
                          return r.text();
                        });
                      });
                    };
                    download && _classPrivateFieldGet2(_engines, this).push(getLoadEngine({
                      apiUrl: download.apiUrl,
                      qsParams: {
                        bytes: "".concat(download.chunkSize)
                      }
                    }));
                    upload && _classPrivateFieldGet2(_engines, this).push(getLoadEngine({
                      apiUrl: upload.apiUrl,
                      fetchOptions: {
                        method: "POST",
                        body: "0".repeat(upload.chunkSize)
                      }
                    }));
                  }
                  return _createClass(LoadNetworkEngine2, [{
                    key: "pause",
                    value: (
                      // additional options included in the requests
                      // Public methods
                      function pause() {
                        _classPrivateFieldGet2(_engines, this).forEach(function(engine) {
                          return engine.pause();
                        });
                      }
                    )
                  }, {
                    key: "stop",
                    value: function stop() {
                      this.pause();
                    }
                  }, {
                    key: "play",
                    value: function play() {
                      _classPrivateFieldGet2(_engines, this).forEach(function(engine) {
                        return engine.play();
                      });
                    }
                  }]);
                }();
                var _excluded$3 = ["iceServers", "acceptIceCandidate", "dataChannelCfg"];
                var _established = /* @__PURE__ */ new WeakMap();
                var _sender = /* @__PURE__ */ new WeakMap();
                var _receiver = /* @__PURE__ */ new WeakMap();
                var _senderDc = /* @__PURE__ */ new WeakMap();
                var _receiverDc = /* @__PURE__ */ new WeakMap();
                var SelfWebRtcDataConnection = function() {
                  function SelfWebRtcDataConnection2() {
                    var _this = this;
                    var _ref = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, _ref$iceServers = _ref.iceServers, iceServers = _ref$iceServers === void 0 ? [] : _ref$iceServers, _ref$acceptIceCandida = _ref.acceptIceCandidate, acceptIceCandidate = _ref$acceptIceCandida === void 0 ? function(candidate) {
                      var protocol = candidate.protocol || "";
                      if (!protocol && candidate.candidate) {
                        var sdpAttrs = candidate.candidate.split(" ");
                        sdpAttrs.length >= 3 && (protocol = sdpAttrs[2]);
                      }
                      return protocol.toLowerCase() === "udp";
                    } : _ref$acceptIceCandida, _ref$dataChannelCfg = _ref.dataChannelCfg, dataChannelCfg = _ref$dataChannelCfg === void 0 ? {
                      ordered: false,
                      maxRetransmits: 0
                    } : _ref$dataChannelCfg, rtcPeerConnectionCfg = _objectWithoutProperties(_ref, _excluded$3);
                    _classCallCheck(this, SelfWebRtcDataConnection2);
                    _defineProperty(this, "onOpen", function() {
                    });
                    _defineProperty(this, "onClose", function() {
                    });
                    _defineProperty(this, "onMessageReceived", function() {
                    });
                    speedtest_classPrivateFieldInitSpec(this, _established, false);
                    speedtest_classPrivateFieldInitSpec(this, _sender, void 0);
                    speedtest_classPrivateFieldInitSpec(this, _receiver, void 0);
                    speedtest_classPrivateFieldInitSpec(this, _senderDc, void 0);
                    speedtest_classPrivateFieldInitSpec(this, _receiverDc, void 0);
                    var sender = new RTCPeerConnection(speedtest_objectSpread2({
                      iceServers
                    }, rtcPeerConnectionCfg));
                    var receiver = new RTCPeerConnection(speedtest_objectSpread2({
                      iceServers
                    }, rtcPeerConnectionCfg));
                    var senderDc = sender.createDataChannel("channel", dataChannelCfg);
                    senderDc.onopen = function() {
                      _classPrivateFieldSet2(_established, _this, true);
                      _this.onOpen();
                    };
                    senderDc.onclose = function() {
                      return _this.close();
                    };
                    receiver.ondatachannel = function(e) {
                      var dc = e.channel;
                      dc.onclose = function() {
                        return _this.close();
                      };
                      dc.onmessage = function(msg) {
                        return _this.onMessageReceived(msg.data);
                      };
                      _classPrivateFieldSet2(_receiverDc, _this, dc);
                    };
                    sender.onicecandidate = function(e) {
                      e.candidate && acceptIceCandidate(e.candidate) && receiver.addIceCandidate(e.candidate);
                    };
                    receiver.onicecandidate = function(e) {
                      e.candidate && acceptIceCandidate(e.candidate) && sender.addIceCandidate(e.candidate);
                    };
                    sender.createOffer().then(function(offer) {
                      return sender.setLocalDescription(offer);
                    }).then(function() {
                      return receiver.setRemoteDescription(sender.localDescription);
                    }).then(function() {
                      return receiver.createAnswer();
                    }).then(function(answer) {
                      return receiver.setLocalDescription(answer);
                    }).then(function() {
                      return sender.setRemoteDescription(receiver.localDescription);
                    });
                    _classPrivateFieldSet2(_sender, this, sender);
                    _classPrivateFieldSet2(_receiver, this, receiver);
                    _classPrivateFieldSet2(_senderDc, this, senderDc);
                    _classPrivateFieldSet2(_established, this, false);
                  }
                  return _createClass(SelfWebRtcDataConnection2, [{
                    key: "send",
                    value: (
                      // callback invoked when a new message is received from the TURN server
                      // Public methods
                      function send(msg) {
                        return _classPrivateFieldGet2(_senderDc, this).send(msg);
                      }
                    )
                  }, {
                    key: "close",
                    value: function close() {
                      _classPrivateFieldGet2(_sender, this) && _classPrivateFieldGet2(_sender, this).close();
                      _classPrivateFieldGet2(_receiver, this) && _classPrivateFieldGet2(_receiver, this).close();
                      _classPrivateFieldGet2(_senderDc, this) && _classPrivateFieldGet2(_senderDc, this).close();
                      _classPrivateFieldGet2(_receiverDc, this) && _classPrivateFieldGet2(_receiverDc, this).close();
                      _classPrivateFieldGet2(_established, this) && this.onClose();
                      _classPrivateFieldSet2(_established, this, false);
                      return this;
                    }
                  }]);
                }();
                var _onCredentialsFailure = /* @__PURE__ */ new WeakMap();
                var _onConnectionError = /* @__PURE__ */ new WeakMap();
                var _onFinished = /* @__PURE__ */ new WeakMap();
                var _msgTracker = /* @__PURE__ */ new WeakMap();
                var _webRtcConnection = /* @__PURE__ */ new WeakMap();
                var _numMsgs = /* @__PURE__ */ new WeakMap();
                var PacketLossEngine = function() {
                  function PacketLossEngine2() {
                    var _this = this;
                    var _ref = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, turnServerUri = _ref.turnServerUri, turnServerCredsApi = _ref.turnServerCredsApi, _ref$turnServerCredsA = _ref.turnServerCredsApiParser, turnServerCredsApiParser = _ref$turnServerCredsA === void 0 ? function(_ref2) {
                      var username = _ref2.username, credential = _ref2.credential, server = _ref2.server;
                      return {
                        turnServerUser: username,
                        turnServerPass: credential,
                        turnServerUri: server
                      };
                    } : _ref$turnServerCredsA, _ref$turnServerCredsA2 = _ref.turnServerCredsApiIncludeCredentials, turnServerCredsApiIncludeCredentials = _ref$turnServerCredsA2 === void 0 ? false : _ref$turnServerCredsA2, turnServerUser = _ref.turnServerUser, turnServerPass = _ref.turnServerPass, _ref$numMsgs = _ref.numMsgs, numMsgs = _ref$numMsgs === void 0 ? 100 : _ref$numMsgs, _ref$batchSize = _ref.batchSize, batchSize = _ref$batchSize === void 0 ? 10 : _ref$batchSize, _ref$batchWaitTime = _ref.batchWaitTime, batchWaitTime = _ref$batchWaitTime === void 0 ? 10 : _ref$batchWaitTime, _ref$responsesWaitTim = _ref.responsesWaitTime, responsesWaitTime = _ref$responsesWaitTim === void 0 ? 5e3 : _ref$responsesWaitTim, _ref$connectionTimeou = _ref.connectionTimeout, connectionTimeout = _ref$connectionTimeou === void 0 ? 5e3 : _ref$connectionTimeou;
                    _classCallCheck(this, PacketLossEngine2);
                    speedtest_classPrivateFieldInitSpec(this, _onCredentialsFailure, function() {
                    });
                    speedtest_classPrivateFieldInitSpec(this, _onConnectionError, function() {
                    });
                    speedtest_classPrivateFieldInitSpec(this, _onFinished, function() {
                    });
                    _defineProperty(this, "onMsgSent", function() {
                    });
                    _defineProperty(this, "onAllMsgsSent", function() {
                    });
                    _defineProperty(this, "onMsgReceived", function() {
                    });
                    speedtest_classPrivateFieldInitSpec(this, _msgTracker, {});
                    speedtest_classPrivateFieldInitSpec(this, _webRtcConnection, void 0);
                    speedtest_classPrivateFieldInitSpec(this, _numMsgs, void 0);
                    if (!turnServerUri && !turnServerCredsApi) throw new Error("Missing turnServerCredsApi or turnServerUri argument");
                    if ((!turnServerUser || !turnServerPass) && !turnServerCredsApi) throw new Error("Missing either turnServerCredsApi or turnServerUser+turnServerPass arguments");
                    _classPrivateFieldSet2(_numMsgs, this, numMsgs);
                    (!turnServerUser || !turnServerPass ? (
                      // Get TURN credentials from API endpoint if not statically supplied
                      fetch(turnServerCredsApi, {
                        credentials: turnServerCredsApiIncludeCredentials ? "include" : void 0
                      }).then(function(r) {
                        return r.json();
                      }).then(function(d) {
                        if (d.error) throw d.error;
                        return d;
                      }).then(turnServerCredsApiParser)
                    ) : Promise.resolve({
                      turnServerUser,
                      turnServerPass
                    }))["catch"](function(e) {
                      return _classPrivateFieldGet2(_onCredentialsFailure, _this).call(_this, e);
                    }).then(function(_ref3) {
                      var turnServerUser2 = _ref3.turnServerUser, turnServerPass2 = _ref3.turnServerPass, credsApiTurnServerUri = _ref3.turnServerUri;
                      var c = _classPrivateFieldSet2(_webRtcConnection, _this, new SelfWebRtcDataConnection({
                        iceServers: [{
                          urls: "turn:".concat(credsApiTurnServerUri || turnServerUri, "?transport=udp"),
                          username: turnServerUser2,
                          credential: turnServerPass2
                        }],
                        iceTransportPolicy: "relay"
                      }));
                      var connectionSuccess = false;
                      setTimeout(function() {
                        if (!connectionSuccess) {
                          c.close();
                          _classPrivateFieldGet2(_onConnectionError, _this).call(_this, "ICE connection timeout!");
                        }
                      }, connectionTimeout);
                      var msgTracker = _classPrivateFieldGet2(_msgTracker, _this);
                      c.onOpen = function() {
                        connectionSuccess = true;
                        var self2 = _this;
                        (function sendNum(n) {
                          if (n <= numMsgs) {
                            var i = n;
                            while (i <= Math.min(numMsgs, n + batchSize - 1)) {
                              msgTracker[i] = false;
                              c.send(i);
                              self2.onMsgSent(i);
                              i++;
                            }
                            setTimeout(function() {
                              return sendNum(i);
                            }, batchWaitTime);
                          } else {
                            self2.onAllMsgsSent(Object.keys(msgTracker).length);
                            var finishFn = function finishFn2() {
                              c.close();
                              _classPrivateFieldGet2(_onFinished, self2).call(self2, self2.results);
                            };
                            var finishTimeout = setTimeout(finishFn, responsesWaitTime);
                            var missingMsgs = Object.values(_classPrivateFieldGet2(_msgTracker, self2)).filter(function(recv) {
                              return !recv;
                            }).length;
                            c.onMessageReceived = function(msg) {
                              clearTimeout(finishTimeout);
                              msgTracker[msg] = true;
                              self2.onMsgReceived(msg);
                              missingMsgs--;
                              if (missingMsgs <= 0 && Object.values(_classPrivateFieldGet2(_msgTracker, self2)).every(function(recv) {
                                return recv;
                              })) {
                                finishFn();
                              } else {
                                finishTimeout = setTimeout(finishFn, responsesWaitTime);
                              }
                            };
                          }
                        })(1);
                      };
                      c.onMessageReceived = function(msg) {
                        msgTracker[msg] = true;
                        _this.onMsgReceived(msg);
                      };
                    })["catch"](function(e) {
                      return _classPrivateFieldGet2(_onConnectionError, _this).call(_this, e.toString());
                    });
                  }
                  return _createClass(PacketLossEngine2, [{
                    key: "onCredentialsFailure",
                    set: (
                      // Invoked when unable to fetch TURN server credentials
                      function set2(f) {
                        _classPrivateFieldSet2(_onCredentialsFailure, this, f);
                      }
                    )
                  }, {
                    key: "onConnectionError",
                    set: (
                      // Invoked when unable to establish a connection with TURN server
                      function set2(f) {
                        _classPrivateFieldSet2(_onConnectionError, this, f);
                      }
                    )
                  }, {
                    key: "onFinished",
                    set: (
                      // Invoked when the packet loss measurement is complete
                      function set2(f) {
                        _classPrivateFieldSet2(_onFinished, this, f);
                      }
                    )
                  }, {
                    key: "results",
                    get: (
                      // Invoked when receiving a new message from the TURN server
                      function get() {
                        var totalMessages = _classPrivateFieldGet2(_numMsgs, this);
                        var numMessagesSent = Object.keys(_classPrivateFieldGet2(_msgTracker, this)).length;
                        var lostMessages = Object.entries(_classPrivateFieldGet2(_msgTracker, this)).filter(function(_ref4) {
                          var _ref5 = _slicedToArray(_ref4, 2), recv = _ref5[1];
                          return !recv;
                        }).map(function(_ref6) {
                          var _ref7 = _slicedToArray(_ref6, 1), n = _ref7[0];
                          return +n;
                        });
                        var packetLoss = lostMessages.length / numMessagesSent;
                        return {
                          totalMessages,
                          numMessagesSent,
                          packetLoss,
                          lostMessages
                        };
                      }
                    )
                  }]);
                }();
                var _excluded$2 = ["downloadChunkSize", "uploadChunkSize", "downloadApiUrl", "uploadApiUrl"];
                var _loadEngine = /* @__PURE__ */ new WeakMap();
                var PacketLossUnderLoadEngine = function(_PacketLossEngine) {
                  function PacketLossUnderLoadEngine2() {
                    var _this;
                    var _ref = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, downloadChunkSize = _ref.downloadChunkSize, uploadChunkSize = _ref.uploadChunkSize, downloadApiUrl = _ref.downloadApiUrl, uploadApiUrl = _ref.uploadApiUrl, ptProps = _objectWithoutProperties(_ref, _excluded$2);
                    _classCallCheck(this, PacketLossUnderLoadEngine2);
                    _this = speedtest_callSuper(this, PacketLossUnderLoadEngine2, [ptProps]);
                    speedtest_classPrivateFieldInitSpec(_this, _loadEngine, void 0);
                    if (downloadChunkSize || uploadChunkSize) {
                      _classPrivateFieldSet2(_loadEngine, _this, new LoadNetworkEngine({
                        download: downloadChunkSize ? {
                          apiUrl: downloadApiUrl,
                          chunkSize: downloadChunkSize
                        } : null,
                        upload: uploadChunkSize ? {
                          apiUrl: uploadApiUrl,
                          chunkSize: uploadChunkSize
                        } : null
                      }));
                      _superPropSet(PacketLossUnderLoadEngine2, "onCredentialsFailure", _superPropSet(PacketLossUnderLoadEngine2, "onConnectionError", _superPropSet(PacketLossUnderLoadEngine2, "onFinished", function() {
                        return _classPrivateFieldGet2(_loadEngine, _this).stop();
                      }, _this, 1, 1), _this, 1, 1), _this, 1);
                    }
                    return _this;
                  }
                  _inherits(PacketLossUnderLoadEngine2, _PacketLossEngine);
                  return _createClass(PacketLossUnderLoadEngine2, [{
                    key: "qsParams",
                    set: function set2(qsParams) {
                      _classPrivateFieldGet2(_loadEngine, this) && (_classPrivateFieldGet2(_loadEngine, this).qsParams = qsParams);
                    }
                  }, {
                    key: "fetchOptions",
                    set: function set2(fetchOptions) {
                      _classPrivateFieldGet2(_loadEngine, this) && (_classPrivateFieldGet2(_loadEngine, this).fetchOptions = fetchOptions);
                    }
                  }, {
                    key: "onCredentialsFailure",
                    set: function set2(onCredentialsFailure) {
                      var _this2 = this;
                      _superPropSet(PacketLossUnderLoadEngine2, "onCredentialsFailure", function() {
                        onCredentialsFailure.apply(void 0, arguments);
                        _classPrivateFieldGet2(_loadEngine, _this2) && _classPrivateFieldGet2(_loadEngine, _this2).stop();
                      }, this, 1);
                    }
                  }, {
                    key: "onConnectionError",
                    set: function set2(onConnectionError) {
                      var _this3 = this;
                      _superPropSet(PacketLossUnderLoadEngine2, "onConnectionError", function() {
                        onConnectionError.apply(void 0, arguments);
                        _classPrivateFieldGet2(_loadEngine, _this3) && _classPrivateFieldGet2(_loadEngine, _this3).stop();
                      }, this, 1);
                    }
                  }, {
                    key: "onFinished",
                    set: function set2(onFinished) {
                      var _this4 = this;
                      _superPropSet(PacketLossUnderLoadEngine2, "onFinished", function() {
                        onFinished.apply(void 0, arguments);
                        _classPrivateFieldGet2(_loadEngine, _this4) && _classPrivateFieldGet2(_loadEngine, _this4).stop();
                      }, this, 1);
                    }
                  }]);
                }(PacketLossEngine);
                var _excluded$1 = ["reachable"];
                var ReachabilityEngine = _createClass(function ReachabilityEngine2(targetUrl) {
                  var _this = this;
                  var _ref = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, _ref$timeout = _ref.timeout, timeout = _ref$timeout === void 0 ? -1 : _ref$timeout, _ref$fetchOptions = _ref.fetchOptions, fetchOptions = _ref$fetchOptions === void 0 ? {} : _ref$fetchOptions;
                  _classCallCheck(this, ReachabilityEngine2);
                  _defineProperty(this, "onFinished", function() {
                  });
                  var finished = false;
                  var finish = function finish2(_ref2) {
                    var reachable = _ref2.reachable, rest = _objectWithoutProperties(_ref2, _excluded$1);
                    if (finished) return;
                    finished = true;
                    _this.onFinished(speedtest_objectSpread2({
                      targetUrl,
                      reachable
                    }, rest));
                  };
                  fetch(targetUrl, fetchOptions).then(function(response) {
                    finish({
                      reachable: true,
                      response
                    });
                  })["catch"](function(error) {
                    finish({
                      reachable: false,
                      error
                    });
                  });
                  timeout > 0 && setTimeout(function() {
                    return finish({
                      reachable: false,
                      error: "Request timeout"
                    });
                  }, timeout);
                });
                var sum = function sum2(vals) {
                  return vals.reduce(function(agg, val) {
                    return agg + val;
                  }, 0);
                };
                var percentile = function percentile2(vals) {
                  var perc = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0.5;
                  if (!vals.length) return 0;
                  var sortedVals = vals.slice().sort(function(a, b) {
                    return a - b;
                  });
                  var idx = (vals.length - 1) * perc;
                  var rem = idx % 1;
                  if (rem === 0) return sortedVals[Math.round(idx)];
                  var edges = [Math.floor, Math.ceil].map(function(rndFn) {
                    return sortedVals[rndFn(idx)];
                  });
                  return edges[0] + (edges[1] - edges[0]) * rem;
                };
                var _config$3 = /* @__PURE__ */ new WeakMap();
                var _extractLoadedLatencies = /* @__PURE__ */ new WeakMap();
                var MeasurementCalculations = function() {
                  function MeasurementCalculations2(config3) {
                    var _this = this;
                    _classCallCheck(this, MeasurementCalculations2);
                    _defineProperty(this, "getLatencyPoints", function(latencyResults) {
                      return latencyResults.timings.map(function(d) {
                        return d.ping;
                      });
                    });
                    _defineProperty(this, "getLatency", function(latencyResults) {
                      return percentile(_this.getLatencyPoints(latencyResults), _classPrivateFieldGet2(_config$3, _this).latencyPercentile);
                    });
                    _defineProperty(this, "getBandwidthPoints", function(bandwidthResults) {
                      return Object.entries(bandwidthResults).map(function(_ref) {
                        var _ref2 = _slicedToArray(_ref, 2), bytes = _ref2[0], timings = _ref2[1].timings;
                        return timings.map(function(_ref3) {
                          var bps = _ref3.bps, duration = _ref3.duration, ping = _ref3.ping, measTime = _ref3.measTime, serverTime = _ref3.serverTime, transferSize = _ref3.transferSize;
                          return {
                            bytes: +bytes,
                            bps,
                            duration,
                            ping,
                            measTime,
                            serverTime,
                            transferSize
                          };
                        });
                      }).flat();
                    });
                    _defineProperty(this, "getBandwidth", function(bandwidthResults) {
                      return percentile(_this.getBandwidthPoints(bandwidthResults).filter(function(d) {
                        return d.duration >= _classPrivateFieldGet2(_config$3, _this).bandwidthMinRequestDuration;
                      }).map(function(d) {
                        return d.bps;
                      }).filter(function(bps) {
                        return bps;
                      }), _classPrivateFieldGet2(_config$3, _this).bandwidthPercentile);
                    });
                    _defineProperty(this, "getLoadedLatency", function(loadedResults) {
                      return _this.getLatency({
                        timings: _classPrivateFieldGet2(_extractLoadedLatencies, _this).call(_this, loadedResults)
                      });
                    });
                    _defineProperty(this, "getLoadedJitter", function(loadedResults) {
                      return _this.getJitter({
                        timings: _classPrivateFieldGet2(_extractLoadedLatencies, _this).call(_this, loadedResults)
                      });
                    });
                    _defineProperty(this, "getLoadedLatencyPoints", function(loadedResults) {
                      return _this.getLatencyPoints({
                        timings: _classPrivateFieldGet2(_extractLoadedLatencies, _this).call(_this, loadedResults)
                      });
                    });
                    _defineProperty(this, "getPacketLoss", function(plResults) {
                      return plResults.packetLoss;
                    });
                    _defineProperty(this, "getPacketLossDetails", function(plResults) {
                      return plResults;
                    });
                    _defineProperty(this, "getReachability", function(reachabilityResults) {
                      return !!reachabilityResults.reachable;
                    });
                    _defineProperty(this, "getReachabilityDetails", function(d) {
                      return {
                        host: d.host,
                        reachable: d.reachable
                      };
                    });
                    speedtest_classPrivateFieldInitSpec(this, _config$3, void 0);
                    speedtest_classPrivateFieldInitSpec(this, _extractLoadedLatencies, function(loadedResults) {
                      return Object.values(loadedResults).filter(
                        // keep only file sizes that saturated the connection
                        function(d) {
                          return d.timings.length && Math.min.apply(Math, _toConsumableArray(d.timings.map(function(d2) {
                            return d2.duration;
                          }))) >= _classPrivateFieldGet2(_config$3, _this).loadedRequestMinDuration;
                        }
                      ).map(function(d) {
                        return d.sideLatency || [];
                      }).flat().slice(-_classPrivateFieldGet2(_config$3, _this).loadedLatencyMaxPoints);
                    });
                    _classPrivateFieldSet2(_config$3, this, config3);
                  }
                  return _createClass(MeasurementCalculations2, [{
                    key: "getJitter",
                    value: function getJitter(latencyResults) {
                      var pings = this.getLatencyPoints(latencyResults);
                      return pings.length < 2 ? null : pings.reduce(function(_ref4, latency) {
                        var _ref4$sumDeltas = _ref4.sumDeltas, sumDeltas = _ref4$sumDeltas === void 0 ? 0 : _ref4$sumDeltas, prevLatency = _ref4.prevLatency;
                        return {
                          sumDeltas: sumDeltas + (prevLatency !== void 0 ? Math.abs(prevLatency - latency) : 0),
                          prevLatency: latency
                        };
                      }, {}).sumDeltas / (pings.length - 1);
                    }
                    // last measurements are most accurate
                  }]);
                }();
                var classificationNames = ["bad", "poor", "average", "good", "great"];
                var customResultTypes = {
                  loadedLatencyIncrease: function loadedLatencyIncrease(measurements) {
                    return measurements.latency && (measurements.downLoadedLatency || measurements.upLoadedLatency) ? Math.max(measurements.downLoadedLatency, measurements.upLoadedLatency) - measurements.latency : void 0;
                  }
                };
                var defaultPoints = {
                  packetLoss: 0
                };
                var _config$2 = /* @__PURE__ */ new WeakMap();
                var ScoresCalculations = function() {
                  function ScoresCalculations2(config3) {
                    _classCallCheck(this, ScoresCalculations2);
                    speedtest_classPrivateFieldInitSpec(this, _config$2, void 0);
                    _classPrivateFieldSet2(_config$2, this, config3);
                  }
                  return _createClass(ScoresCalculations2, [{
                    key: "getScores",
                    value: function getScores(measurements) {
                      var scores = Object.assign.apply(Object, _toConsumableArray(Object.entries(_classPrivateFieldGet2(_config$2, this).aimMeasurementScoring).map(function(_ref) {
                        var _ref2 = _slicedToArray(_ref, 2), type = _ref2[0], fn = _ref2[1];
                        var val = customResultTypes.hasOwnProperty(type) ? customResultTypes[type](measurements) : measurements[type];
                        return val === void 0 ? defaultPoints.hasOwnProperty(type) ? _defineProperty({}, type, defaultPoints[type]) : {} : _defineProperty({}, type, val === void 0 ? 0 : +fn(val));
                      })));
                      return Object.assign.apply(Object, [{}].concat(_toConsumableArray(Object.entries(_classPrivateFieldGet2(_config$2, this).aimExperiencesDefs).filter(function(_ref5) {
                        var _ref6 = _slicedToArray(_ref5, 2), input = _ref6[1].input;
                        return input.every(function(k) {
                          return scores.hasOwnProperty(k);
                        });
                      }).map(function(_ref7) {
                        var _ref8 = _slicedToArray(_ref7, 2), k = _ref8[0], _ref8$ = _ref8[1], input = _ref8$.input, pointThresholds = _ref8$.pointThresholds;
                        var sumPoints = Math.max(0, sum(input.map(function(k2) {
                          return scores[k2];
                        })));
                        var classificationIdx = threshold(pointThresholds, [0, 1, 2, 3, 4])(sumPoints);
                        var classificationName = classificationNames[classificationIdx];
                        return _defineProperty({}, k, {
                          points: sumPoints,
                          classificationIdx,
                          classificationName
                        });
                      }))));
                    }
                  }]);
                }();
                var _config$1 = /* @__PURE__ */ new WeakMap();
                var _measCalc = /* @__PURE__ */ new WeakMap();
                var _scoresCalc = /* @__PURE__ */ new WeakMap();
                var _calcGetter = /* @__PURE__ */ new WeakMap();
                var _getV4Reachability = /* @__PURE__ */ new WeakMap();
                var _getV4ReachabilityDetails = /* @__PURE__ */ new WeakMap();
                var _getV6Reachability = /* @__PURE__ */ new WeakMap();
                var _getV6ReachabilityDetails = /* @__PURE__ */ new WeakMap();
                var Results = function() {
                  function Results2(config3) {
                    var _this = this;
                    _classCallCheck(this, Results2);
                    _defineProperty(this, "raw", void 0);
                    _defineProperty(this, "getUnloadedLatency", function() {
                      return _classPrivateFieldGet2(_calcGetter, _this).call(_this, "getLatency", "latency");
                    });
                    _defineProperty(this, "getUnloadedJitter", function() {
                      return _classPrivateFieldGet2(_calcGetter, _this).call(_this, "getJitter", "latency");
                    });
                    _defineProperty(this, "getUnloadedLatencyPoints", function() {
                      return _classPrivateFieldGet2(_calcGetter, _this).call(_this, "getLatencyPoints", "latency", []);
                    });
                    _defineProperty(this, "getDownLoadedLatency", function() {
                      return _classPrivateFieldGet2(_calcGetter, _this).call(_this, "getLoadedLatency", "download");
                    });
                    _defineProperty(this, "getDownLoadedJitter", function() {
                      return _classPrivateFieldGet2(_calcGetter, _this).call(_this, "getLoadedJitter", "download");
                    });
                    _defineProperty(this, "getDownLoadedLatencyPoints", function() {
                      return _classPrivateFieldGet2(_calcGetter, _this).call(_this, "getLoadedLatencyPoints", "download", []);
                    });
                    _defineProperty(this, "getUpLoadedLatency", function() {
                      return _classPrivateFieldGet2(_calcGetter, _this).call(_this, "getLoadedLatency", "upload");
                    });
                    _defineProperty(this, "getUpLoadedJitter", function() {
                      return _classPrivateFieldGet2(_calcGetter, _this).call(_this, "getLoadedJitter", "upload");
                    });
                    _defineProperty(this, "getUpLoadedLatencyPoints", function() {
                      return _classPrivateFieldGet2(_calcGetter, _this).call(_this, "getLoadedLatencyPoints", "upload", []);
                    });
                    _defineProperty(this, "getDownloadBandwidth", function() {
                      return _classPrivateFieldGet2(_calcGetter, _this).call(_this, "getBandwidth", "download");
                    });
                    _defineProperty(this, "getDownloadBandwidthPoints", function() {
                      return _classPrivateFieldGet2(_calcGetter, _this).call(_this, "getBandwidthPoints", "download", []);
                    });
                    _defineProperty(this, "getUploadBandwidth", function() {
                      return _classPrivateFieldGet2(_calcGetter, _this).call(_this, "getBandwidth", "upload");
                    });
                    _defineProperty(this, "getUploadBandwidthPoints", function() {
                      return _classPrivateFieldGet2(_calcGetter, _this).call(_this, "getBandwidthPoints", "upload", []);
                    });
                    _defineProperty(this, "getPacketLoss", function() {
                      return _classPrivateFieldGet2(_calcGetter, _this).call(_this, "getPacketLoss", "packetLoss");
                    });
                    _defineProperty(this, "getPacketLossDetails", function() {
                      return _classPrivateFieldGet2(_calcGetter, _this).call(_this, "getPacketLossDetails", "packetLoss", void 0, true);
                    });
                    _defineProperty(this, "getScores", function() {
                      return _classPrivateFieldGet2(_scoresCalc, _this).getScores(_this.getSummary());
                    });
                    speedtest_classPrivateFieldInitSpec(this, _config$1, void 0);
                    speedtest_classPrivateFieldInitSpec(this, _measCalc, void 0);
                    speedtest_classPrivateFieldInitSpec(this, _scoresCalc, void 0);
                    speedtest_classPrivateFieldInitSpec(this, _calcGetter, function(calcFn, resKey) {
                      var defaultVal = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : void 0;
                      var surfaceError = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
                      return !_this.raw.hasOwnProperty(resKey) || !_this.raw[resKey].started ? defaultVal : surfaceError && _this.raw[resKey].error ? {
                        error: _this.raw[resKey].error
                      } : _classPrivateFieldGet2(_measCalc, _this)[calcFn](_this.raw[resKey].results);
                    });
                    speedtest_classPrivateFieldInitSpec(this, _getV4Reachability, function() {
                      return _classPrivateFieldGet2(_calcGetter, _this).call(_this, "getReachability", "v4Reachability");
                    });
                    speedtest_classPrivateFieldInitSpec(this, _getV4ReachabilityDetails, function() {
                      return _classPrivateFieldGet2(_calcGetter, _this).call(_this, "getReachabilityDetails", "v4Reachability");
                    });
                    speedtest_classPrivateFieldInitSpec(this, _getV6Reachability, function() {
                      return _classPrivateFieldGet2(_calcGetter, _this).call(_this, "getReachability", "v6Reachability");
                    });
                    speedtest_classPrivateFieldInitSpec(this, _getV6ReachabilityDetails, function() {
                      return _classPrivateFieldGet2(_calcGetter, _this).call(_this, "getReachabilityDetails", "v6Reachability");
                    });
                    _classPrivateFieldSet2(_config$1, this, config3);
                    this.clear();
                    _classPrivateFieldSet2(_measCalc, this, new MeasurementCalculations(_classPrivateFieldGet2(_config$1, this)));
                    _classPrivateFieldSet2(_scoresCalc, this, new ScoresCalculations(_classPrivateFieldGet2(_config$1, this)));
                  }
                  return _createClass(Results2, [{
                    key: "isFinished",
                    get: function get() {
                      return Object.values(this.raw).every(function(d) {
                        return d.finished;
                      });
                    }
                    // Public methods
                  }, {
                    key: "clear",
                    value: function clear() {
                      this.raw = Object.assign.apply(Object, [{}].concat(_toConsumableArray(_toConsumableArray(new Set(_classPrivateFieldGet2(_config$1, this).measurements.map(function(m) {
                        return m.type;
                      }))).map(function(m) {
                        return _defineProperty({}, m, {
                          started: false,
                          finished: false,
                          results: {}
                        });
                      }))));
                    }
                  }, {
                    key: "getSummary",
                    value: function getSummary() {
                      var items = {
                        download: this.getDownloadBandwidth,
                        upload: this.getUploadBandwidth,
                        latency: this.getUnloadedLatency,
                        jitter: this.getUnloadedJitter,
                        downLoadedLatency: this.getDownLoadedLatency,
                        downLoadedJitter: this.getDownLoadedJitter,
                        upLoadedLatency: this.getUpLoadedLatency,
                        upLoadedJitter: this.getUpLoadedJitter,
                        packetLoss: this.getPacketLoss,
                        v4Reachability: _classPrivateFieldGet2(_getV4Reachability, this),
                        v6Reachability: _classPrivateFieldGet2(_getV6Reachability, this)
                      };
                      return Object.assign.apply(Object, _toConsumableArray(Object.entries(items).map(function(_ref2) {
                        var _ref3 = _slicedToArray(_ref2, 2), key = _ref3[0], fn = _ref3[1];
                        var val = fn();
                        return val === void 0 ? {} : _defineProperty({}, key, val);
                      })));
                    }
                  }]);
                }();
                var round = function round2(num) {
                  var decimals = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
                  return !num ? num : Math.round(num * Math.pow(10, decimals)) / Math.pow(10, decimals);
                };
                var latencyPointsParser = function latencyPointsParser2(durations) {
                  return durations.map(function(d) {
                    return round(d, 2);
                  });
                };
                var bpsPointsParser = function bpsPointsParser2(pnts) {
                  return pnts.map(function(d) {
                    return {
                      bytes: +d.bytes,
                      bps: round(d.bps)
                    };
                  });
                };
                var packetLossParser = function packetLossParser2(d) {
                  return d.error ? void 0 : {
                    numMessages: d.numMessagesSent,
                    lossRatio: round(d.packetLoss, 4)
                  };
                };
                var resultsParsers = {
                  latencyMs: ["getUnloadedLatencyPoints", latencyPointsParser],
                  download: ["getDownloadBandwidthPoints", bpsPointsParser],
                  upload: ["getUploadBandwidthPoints", bpsPointsParser],
                  downLoadedLatencyMs: ["getDownLoadedLatencyPoints", latencyPointsParser],
                  upLoadedLatencyMs: ["getUpLoadedLatencyPoints", latencyPointsParser],
                  packetLoss: ["getPacketLossDetails", packetLossParser]
                  // v4Reachability: ['getV4ReachabilityDetails'],
                  // v6Reachability: ['getV6ReachabilityDetails']
                };
                var scoreParser = function scoreParser2(d) {
                  return {
                    points: d.points,
                    classification: d.classificationName
                  };
                };
                var logAimResults = function logAimResults2(results, _ref) {
                  var apiUrl = _ref.apiUrl, sessionId = _ref.sessionId;
                  var logData = {
                    sessionId
                  };
                  Object.entries(resultsParsers).forEach(function(_ref2) {
                    var _ref3 = _slicedToArray(_ref2, 2), logK = _ref3[0], _ref3$ = _slicedToArray(_ref3[1], 2), fn = _ref3$[0], _ref3$$ = _ref3$[1], parser = _ref3$$ === void 0 ? function(d) {
                      return d;
                    } : _ref3$$;
                    var val = results[fn]();
                    val && (logData[logK] = parser(val));
                  });
                  var scores = results.getScores();
                  scores && (logData.scores = Object.assign.apply(Object, [{}].concat(_toConsumableArray(Object.entries(scores).map(function(_ref4) {
                    var _ref5 = _slicedToArray(_ref4, 2), k = _ref5[0], score = _ref5[1];
                    return _defineProperty({}, k, scoreParser(score));
                  })))));
                  fetch(apiUrl, {
                    method: "POST",
                    body: JSON.stringify(logData)
                  });
                };
                var _excluded2 = ["type"], _excluded22 = ["numPackets"], _excluded3 = ["bytes"];
                var DEFAULT_OPTIMAL_DOWNLOAD_SIZE = 1e6;
                var DEFAULT_OPTIMAL_UPLOAD_SIZE = 1e6;
                var OPTIMAL_SIZE_RATIO = 0.5;
                var pausableTypes = ["latency", "latencyUnderLoad", "download", "upload"];
                var genMeasId = function genMeasId2() {
                  return "".concat(Math.round(Math.random() * 1e16));
                };
                var _onFinish = /* @__PURE__ */ new WeakMap();
                var _onError = /* @__PURE__ */ new WeakMap();
                var _config = /* @__PURE__ */ new WeakMap();
                var _results = /* @__PURE__ */ new WeakMap();
                var _measurementId = /* @__PURE__ */ new WeakMap();
                var _curMsmIdx = /* @__PURE__ */ new WeakMap();
                var _curEngine = /* @__PURE__ */ new WeakMap();
                var _optimalDownloadChunkSize = /* @__PURE__ */ new WeakMap();
                var _optimalUploadChunkSize = /* @__PURE__ */ new WeakMap();
                var _running = /* @__PURE__ */ new WeakMap();
                var _finished = /* @__PURE__ */ new WeakMap();
                var _MeasurementEngine_brand = /* @__PURE__ */ new WeakSet();
                var MeasurementEngine = function() {
                  function MeasurementEngine2() {
                    var userConfig = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
                    _classCallCheck(this, MeasurementEngine2);
                    speedtest_classPrivateMethodInitSpec(this, _MeasurementEngine_brand);
                    _defineProperty(this, "onRunningChange", function() {
                    });
                    _defineProperty(this, "onResultsChange", function() {
                    });
                    speedtest_classPrivateFieldInitSpec(this, _onFinish, function() {
                    });
                    speedtest_classPrivateFieldInitSpec(this, _onError, function() {
                    });
                    speedtest_classPrivateFieldInitSpec(this, _config, void 0);
                    speedtest_classPrivateFieldInitSpec(this, _results, void 0);
                    speedtest_classPrivateFieldInitSpec(this, _measurementId, genMeasId());
                    speedtest_classPrivateFieldInitSpec(this, _curMsmIdx, -1);
                    speedtest_classPrivateFieldInitSpec(this, _curEngine, void 0);
                    speedtest_classPrivateFieldInitSpec(this, _optimalDownloadChunkSize, DEFAULT_OPTIMAL_DOWNLOAD_SIZE);
                    speedtest_classPrivateFieldInitSpec(this, _optimalUploadChunkSize, DEFAULT_OPTIMAL_UPLOAD_SIZE);
                    speedtest_classPrivateFieldInitSpec(this, _running, false);
                    speedtest_classPrivateFieldInitSpec(this, _finished, false);
                    _classPrivateFieldSet2(_config, this, Object.assign({}, defaultConfig, userConfig, internalConfig));
                    _classPrivateFieldSet2(_results, this, new Results(_classPrivateFieldGet2(_config, this)));
                    _classPrivateFieldGet2(_config, this).autoStart && this.play();
                  }
                  return _createClass(MeasurementEngine2, [{
                    key: "results",
                    get: function get() {
                      return _classPrivateFieldGet2(_results, this);
                    }
                  }, {
                    key: "isRunning",
                    get: function get() {
                      return _classPrivateFieldGet2(_running, this);
                    }
                  }, {
                    key: "isFinished",
                    get: function get() {
                      return _classPrivateFieldGet2(_finished, this);
                    }
                  }, {
                    key: "onFinish",
                    set: (
                      // callback invoked when all the measurements are finished
                      function set2(f) {
                        _classPrivateFieldSet2(_onFinish, this, f);
                      }
                    )
                  }, {
                    key: "onError",
                    set: (
                      // callback invoked if an error occurs during measurement
                      function set2(f) {
                        _classPrivateFieldSet2(_onError, this, f);
                      }
                    )
                    // Public methods
                  }, {
                    key: "pause",
                    value: function pause() {
                      pausableTypes.includes(speedtest_assertClassBrand(_MeasurementEngine_brand, this, _curType).call(this)) && _classPrivateFieldGet2(_curEngine, this).pause();
                      speedtest_assertClassBrand(_MeasurementEngine_brand, this, _setRunning).call(this, false);
                    }
                  }, {
                    key: "play",
                    value: function play() {
                      if (!_classPrivateFieldGet2(_running, this)) {
                        speedtest_assertClassBrand(_MeasurementEngine_brand, this, _setRunning).call(this, true);
                        speedtest_assertClassBrand(_MeasurementEngine_brand, this, _next).call(this);
                      }
                    }
                  }, {
                    key: "restart",
                    value: function restart() {
                      speedtest_assertClassBrand(_MeasurementEngine_brand, this, _clear).call(this);
                      this.play();
                    }
                  }]);
                }();
                function _setRunning(running) {
                  if (running !== _classPrivateFieldGet2(_running, this)) {
                    _classPrivateFieldSet2(_running, this, running);
                    this.onRunningChange(_classPrivateFieldGet2(_running, this));
                  }
                }
                function _setFinished(finished) {
                  var _this3 = this;
                  if (finished !== _classPrivateFieldGet2(_finished, this)) {
                    _classPrivateFieldSet2(_finished, this, finished);
                    finished && setTimeout(function() {
                      return _classPrivateFieldGet2(_onFinish, _this3).call(_this3, _this3.results);
                    });
                  }
                }
                function _curType() {
                  return _classPrivateFieldGet2(_curMsmIdx, this) < 0 || _classPrivateFieldGet2(_curMsmIdx, this) >= _classPrivateFieldGet2(_config, this).measurements.length ? null : _classPrivateFieldGet2(_config, this).measurements[_classPrivateFieldGet2(_curMsmIdx, this)].type;
                }
                function _curTypeResults() {
                  return _classPrivateFieldGet2(_results, this).raw[speedtest_assertClassBrand(_MeasurementEngine_brand, this, _curType).call(this)] || void 0;
                }
                function _clear() {
                  speedtest_assertClassBrand(_MeasurementEngine_brand, this, _destroyCurEngine).call(this);
                  _classPrivateFieldSet2(_measurementId, this, genMeasId());
                  _classPrivateFieldSet2(_curMsmIdx, this, -1);
                  _classPrivateFieldSet2(_curEngine, this, void 0);
                  speedtest_assertClassBrand(_MeasurementEngine_brand, this, _setRunning).call(this, false);
                  speedtest_assertClassBrand(_MeasurementEngine_brand, this, _setFinished).call(this, false);
                  _classPrivateFieldGet2(_results, this).clear();
                }
                function _destroyCurEngine() {
                  var engine = _classPrivateFieldGet2(_curEngine, this);
                  if (!engine) return;
                  engine.onFinished = engine.onConnectionError = engine.onFail = engine.onMsgReceived = engine.onCredentialsFailure = engine.onMeasurementResult = function() {
                  };
                  pausableTypes.includes(speedtest_assertClassBrand(_MeasurementEngine_brand, this, _curType).call(this)) && engine.pause();
                }
                function _next() {
                  var _this4 = this;
                  var _this$curMsmIdx;
                  if (pausableTypes.includes(speedtest_assertClassBrand(_MeasurementEngine_brand, this, _curType).call(this)) && speedtest_assertClassBrand(_MeasurementEngine_brand, this, _curTypeResults).call(this) && speedtest_assertClassBrand(_MeasurementEngine_brand, this, _curTypeResults).call(this).started && !speedtest_assertClassBrand(_MeasurementEngine_brand, this, _curTypeResults).call(this).finished && !speedtest_assertClassBrand(_MeasurementEngine_brand, this, _curTypeResults).call(this).finishedCurrentRound && !speedtest_assertClassBrand(_MeasurementEngine_brand, this, _curTypeResults).call(this).error) {
                    _classPrivateFieldGet2(_curEngine, this).play();
                    return;
                  }
                  _classPrivateFieldSet2(_curMsmIdx, this, (_this$curMsmIdx = _classPrivateFieldGet2(_curMsmIdx, this), _this$curMsmIdx++, _this$curMsmIdx));
                  if (_classPrivateFieldGet2(_curMsmIdx, this) >= _classPrivateFieldGet2(_config, this).measurements.length) {
                    speedtest_assertClassBrand(_MeasurementEngine_brand, this, _setRunning).call(this, false);
                    speedtest_assertClassBrand(_MeasurementEngine_brand, this, _setFinished).call(this, true);
                    return;
                  }
                  var _classPrivateFieldGet2$1 = _classPrivateFieldGet2(_config, this).measurements[_classPrivateFieldGet2(_curMsmIdx, this)], type = _classPrivateFieldGet2$1.type, msmConfig = _objectWithoutProperties(_classPrivateFieldGet2$1, _excluded2);
                  var msmResults = speedtest_assertClassBrand(_MeasurementEngine_brand, this, _curTypeResults).call(this);
                  var _classPrivateFieldGet3 = _classPrivateFieldGet2(_config, this), downloadApiUrl = _classPrivateFieldGet3.downloadApiUrl, uploadApiUrl = _classPrivateFieldGet3.uploadApiUrl, estimatedServerTime = _classPrivateFieldGet3.estimatedServerTime;
                  var engine;
                  switch (type) {
                    case "v4Reachability":
                    case "v6Reachability":
                      engine = new ReachabilityEngine("https://".concat(msmConfig.host), {
                        fetchOptions: {
                          method: "GET",
                          mode: "no-cors"
                        }
                      });
                      engine.onFinished = function(result) {
                        msmResults.finished = true;
                        msmResults.results = speedtest_objectSpread2({
                          host: msmConfig.host
                        }, result);
                        _this4.onResultsChange({
                          type
                        });
                        speedtest_assertClassBrand(_MeasurementEngine_brand, _this4, _next).call(_this4);
                      };
                      break;
                    case "rpki":
                      engine = new ReachabilityEngine("https://".concat(_classPrivateFieldGet2(_config, this).rpkiInvalidHost), {
                        timeout: 5e3
                      });
                      engine.onFinished = function(result) {
                        (result.response ? result.response.json() : Promise.resolve()).then(function(response) {
                          msmResults.finished = true;
                          msmResults.results = speedtest_objectSpread2({
                            host: _classPrivateFieldGet2(_config, _this4).rpkiInvalidHost,
                            filteringInvalids: !result.reachable
                          }, response ? {
                            asn: response.asn,
                            name: response.name
                          } : {});
                          _this4.onResultsChange({
                            type
                          });
                          speedtest_assertClassBrand(_MeasurementEngine_brand, _this4, _next).call(_this4);
                        });
                      };
                      break;
                    case "nxdomain":
                      engine = new ReachabilityEngine("https://".concat(msmConfig.nxhost), {
                        fetchOptions: {
                          mode: "no-cors"
                        }
                      });
                      engine.onFinished = function(result) {
                        msmResults.finished = true;
                        msmResults.results = {
                          host: msmConfig.nxhost,
                          reachable: result.reachable
                        };
                        _this4.onResultsChange({
                          type
                        });
                        speedtest_assertClassBrand(_MeasurementEngine_brand, _this4, _next).call(_this4);
                      };
                      break;
                    case "packetLoss":
                    case "packetLossUnderLoad":
                      {
                        msmResults.finished = false;
                        var numMsgs = msmConfig.numPackets, ptCfg = _objectWithoutProperties(msmConfig, _excluded22);
                        var _classPrivateFieldGet4 = _classPrivateFieldGet2(_config, this), turnServerUri = _classPrivateFieldGet4.turnServerUri, turnServerCredsApi = _classPrivateFieldGet4.turnServerCredsApiUrl, turnServerUser = _classPrivateFieldGet4.turnServerUser, turnServerPass = _classPrivateFieldGet4.turnServerPass, includeCredentials = _classPrivateFieldGet4.includeCredentials;
                        engine = new PacketLossUnderLoadEngine(speedtest_objectSpread2({
                          turnServerUri,
                          turnServerCredsApi,
                          turnServerCredsApiIncludeCredentials: includeCredentials,
                          turnServerUser,
                          turnServerPass,
                          numMsgs,
                          // if under load
                          downloadChunkSize: msmConfig.loadDown ? _classPrivateFieldGet2(_optimalDownloadChunkSize, this) : void 0,
                          uploadChunkSize: msmConfig.loadUp ? _classPrivateFieldGet2(_optimalUploadChunkSize, this) : void 0,
                          downloadApiUrl,
                          uploadApiUrl
                        }, ptCfg));
                      }
                      engine.onMsgReceived = function() {
                        msmResults.results = Object.assign({}, engine.results);
                        _this4.onResultsChange({
                          type
                        });
                      };
                      engine.onFinished = function() {
                        msmResults.finished = true;
                        _this4.onResultsChange({
                          type
                        });
                        speedtest_assertClassBrand(_MeasurementEngine_brand, _this4, _next).call(_this4);
                      };
                      engine.onConnectionError = function(e) {
                        msmResults.error = e;
                        _this4.onResultsChange({
                          type
                        });
                        _classPrivateFieldGet2(_onError, _this4).call(_this4, "Connection error while measuring packet loss: ".concat(e));
                        speedtest_assertClassBrand(_MeasurementEngine_brand, _this4, _next).call(_this4);
                      };
                      engine.onCredentialsFailure = function() {
                        msmResults.error = "unable to get turn server credentials";
                        _this4.onResultsChange({
                          type
                        });
                        _classPrivateFieldGet2(_onError, _this4).call(_this4, "Error while measuring packet loss: unable to get turn server credentials.");
                        speedtest_assertClassBrand(_MeasurementEngine_brand, _this4, _next).call(_this4);
                      };
                      break;
                    case "latency":
                    case "latencyUnderLoad":
                      msmResults.finished = false;
                      engine = new LoggingBandwidthEngine([{
                        dir: "down",
                        bytes: 0,
                        count: msmConfig.numPackets,
                        bypassMinDuration: true
                      }], {
                        downloadApiUrl,
                        uploadApiUrl,
                        estimatedServerTime,
                        logApiUrl: _classPrivateFieldGet2(_config, this).logMeasurementApiUrl,
                        measurementId: _classPrivateFieldGet2(_measurementId, this),
                        sessionId: _classPrivateFieldGet2(_config, this).sessionId,
                        // if under load
                        downloadChunkSize: msmConfig.loadDown ? _classPrivateFieldGet2(_optimalDownloadChunkSize, this) : void 0,
                        uploadChunkSize: msmConfig.loadUp ? _classPrivateFieldGet2(_optimalUploadChunkSize, this) : void 0
                      });
                      engine.fetchOptions = {
                        credentials: _classPrivateFieldGet2(_config, this).includeCredentials ? "include" : void 0
                      };
                      engine.onMeasurementResult = engine.onNewMeasurementStarted = function(meas, results) {
                        msmResults.results = Object.assign({}, results.down[0]);
                        _this4.onResultsChange({
                          type
                        });
                      };
                      engine.onFinished = function() {
                        msmResults.finished = true;
                        _this4.onResultsChange({
                          type
                        });
                        _classPrivateFieldGet2(_running, _this4) && speedtest_assertClassBrand(_MeasurementEngine_brand, _this4, _next).call(_this4);
                      };
                      engine.onConnectionError = function(e) {
                        msmResults.error = e;
                        _this4.onResultsChange({
                          type
                        });
                        _classPrivateFieldGet2(_onError, _this4).call(_this4, "Connection error while measuring latency: ".concat(e));
                        speedtest_assertClassBrand(_MeasurementEngine_brand, _this4, _next).call(_this4);
                      };
                      engine.play();
                      break;
                    case "download":
                    case "upload":
                      if (msmResults.finished || msmResults.error) {
                        speedtest_assertClassBrand(_MeasurementEngine_brand, this, _next).call(this);
                      } else {
                        delete msmResults.finishedCurrentRound;
                        var measureParallelLatency = _classPrivateFieldGet2(_config, this)["measure".concat(type === "download" ? "Down" : "Up", "loadLoadedLatency")];
                        engine = new LoggingBandwidthEngine([speedtest_objectSpread2({
                          dir: type === "download" ? "down" : "up"
                        }, msmConfig)], {
                          downloadApiUrl,
                          uploadApiUrl,
                          estimatedServerTime,
                          logApiUrl: _classPrivateFieldGet2(_config, this).logMeasurementApiUrl,
                          measurementId: _classPrivateFieldGet2(_measurementId, this),
                          measureParallelLatency,
                          parallelLatencyThrottleMs: _classPrivateFieldGet2(_config, this).loadedLatencyThrottle,
                          sessionId: _classPrivateFieldGet2(_config, this).sessionId
                        });
                        engine.fetchOptions = {
                          credentials: _classPrivateFieldGet2(_config, this).includeCredentials ? "include" : void 0
                        };
                        engine.finishRequestDuration = _classPrivateFieldGet2(_config, this).bandwidthFinishRequestDuration;
                        engine.onNewMeasurementStarted = function(_ref) {
                          var count = _ref.count, bytes = _ref.bytes;
                          var res = msmResults.results = Object.assign({}, msmResults.results);
                          !res.hasOwnProperty(bytes) && (res[bytes] = {
                            timings: [],
                            numMeasurements: 0,
                            sideLatency: measureParallelLatency ? [] : void 0
                          });
                          if (res[bytes].numMeasurements - res[bytes].timings.length !== count) {
                            res[bytes].numMeasurements += count;
                            _this4.onResultsChange({
                              type
                            });
                          }
                        };
                        engine.onMeasurementResult = function(_ref2) {
                          var bytes = _ref2.bytes, timing = _objectWithoutProperties(_ref2, _excluded3);
                          msmResults.results[bytes].timings.push(timing);
                          msmResults.results = Object.assign({}, msmResults.results);
                          _this4.onResultsChange({
                            type
                          });
                        };
                        engine.onParallelLatencyResult = function(res) {
                          msmResults.results[msmConfig.bytes].sideLatency.push(res);
                          msmResults.results = Object.assign({}, msmResults.results);
                          _this4.onResultsChange({
                            type
                          });
                        };
                        engine.onFinished = function(results) {
                          var isLastMsmOfType = !_classPrivateFieldGet2(_config, _this4).measurements.slice(_classPrivateFieldGet2(_curMsmIdx, _this4) + 1).map(function(d) {
                            return d.type;
                          }).includes(type);
                          var minDuration = Math.min.apply(Math, _toConsumableArray(Object.values(type === "download" ? results.down : results.up).slice(-1)[0].timings.map(function(d) {
                            return d.duration;
                          })));
                          var reachedEndOfMsmType = isLastMsmOfType || !msmConfig.bypassMinDuration && minDuration > _classPrivateFieldGet2(_config, _this4).bandwidthFinishRequestDuration;
                          if (!reachedEndOfMsmType) {
                            msmResults.finishedCurrentRound = true;
                          } else {
                            msmResults.finished = true;
                            _this4.onResultsChange({
                              type
                            });
                            var largestSize = Object.keys(msmResults.results).map(function(n) {
                              return +n;
                            }).sort(function(a, b) {
                              return b - a;
                            })[0];
                            var optimalSize = largestSize * OPTIMAL_SIZE_RATIO;
                            type === "download" && _classPrivateFieldSet2(_optimalDownloadChunkSize, _this4, optimalSize);
                            type === "upload" && _classPrivateFieldSet2(_optimalUploadChunkSize, _this4, optimalSize);
                          }
                          _classPrivateFieldGet2(_running, _this4) && speedtest_assertClassBrand(_MeasurementEngine_brand, _this4, _next).call(_this4);
                        };
                        engine.onConnectionError = function(e) {
                          msmResults.error = e;
                          _this4.onResultsChange({
                            type
                          });
                          _classPrivateFieldGet2(_onError, _this4).call(_this4, "Connection error while measuring ".concat(type, ": ").concat(e));
                          speedtest_assertClassBrand(_MeasurementEngine_brand, _this4, _next).call(_this4);
                        };
                        engine.play();
                      }
                      break;
                  }
                  _classPrivateFieldSet2(_curEngine, this, engine);
                  msmResults.started = true;
                  this.onResultsChange({
                    type
                  });
                }
                var _logAimApiUrl = /* @__PURE__ */ new WeakMap();
                var _sessionId = /* @__PURE__ */ new WeakMap();
                var _logFinalResults = /* @__PURE__ */ new WeakMap();
                var LoggingMeasurementEngine = function(_MeasurementEngine2) {
                  function LoggingMeasurementEngine2(userConfig) {
                    var _this;
                    _classCallCheck(this, LoggingMeasurementEngine2);
                    for (var _len = arguments.length, pt = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                      pt[_key - 1] = arguments[_key];
                    }
                    _this = speedtest_callSuper(this, LoggingMeasurementEngine2, [userConfig].concat(pt));
                    speedtest_classPrivateFieldInitSpec(_this, _logAimApiUrl, void 0);
                    speedtest_classPrivateFieldInitSpec(_this, _sessionId, void 0);
                    speedtest_classPrivateFieldInitSpec(_this, _logFinalResults, function(results) {
                      _classPrivateFieldGet2(_logAimApiUrl, _this) && logAimResults(results, {
                        apiUrl: _classPrivateFieldGet2(_logAimApiUrl, _this),
                        sessionId: _classPrivateFieldGet2(_sessionId, _this)
                      });
                    });
                    _superPropSet(LoggingMeasurementEngine2, "onFinish", _classPrivateFieldGet2(_logFinalResults, _this), _this, 1);
                    var config3 = Object.assign({}, defaultConfig, userConfig, internalConfig);
                    _classPrivateFieldSet2(_logAimApiUrl, _this, config3.logAimApiUrl);
                    _classPrivateFieldSet2(_sessionId, _this, config3.sessionId);
                    return _this;
                  }
                  _inherits(LoggingMeasurementEngine2, _MeasurementEngine2);
                  return _createClass(LoggingMeasurementEngine2, [{
                    key: "onFinish",
                    set: function set2(onFinish) {
                      var _this2 = this;
                      _superPropSet(LoggingMeasurementEngine2, "onFinish", function(results) {
                        onFinish(results);
                        _classPrivateFieldGet2(_logFinalResults, _this2).call(_this2, results);
                      }, this, 1);
                    }
                  }]);
                }(MeasurementEngine);
                var KeyProvider = __webpack_require__2(9633);
                var reliabilityModes = __webpack_require__2(2067);
                ;
                function src_createForOfIteratorHelper(r, e) {
                  var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
                  if (!t) {
                    if (Array.isArray(r) || (t = src_unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) {
                      t && (r = t);
                      var _n = 0, F = function F2() {
                      };
                      return { s: F, n: function n() {
                        return _n >= r.length ? { done: true } : { done: false, value: r[_n++] };
                      }, e: function e2(r2) {
                        throw r2;
                      }, f: F };
                    }
                    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
                  }
                  var o, a = true, u = false;
                  return { s: function s() {
                    t = t.call(r);
                  }, n: function n() {
                    var r2 = t.next();
                    return a = r2.done, r2;
                  }, e: function e2(r2) {
                    u = true, o = r2;
                  }, f: function f() {
                    try {
                      a || null == t["return"] || t["return"]();
                    } finally {
                      if (u) throw o;
                    }
                  } };
                }
                function src_unsupportedIterableToArray(r, a) {
                  if (r) {
                    if ("string" == typeof r) return src_arrayLikeToArray(r, a);
                    var t = {}.toString.call(r).slice(8, -1);
                    return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? src_arrayLikeToArray(r, a) : void 0;
                  }
                }
                function src_arrayLikeToArray(r, a) {
                  (null == a || a > r.length) && (a = r.length);
                  for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];
                  return n;
                }
                var reduxMiddlewares = [es];
                var deviceChangeEventRegistered = false;
                var VideoSDK2 = function() {
                  function VideoSDK3() {
                    (0, classCallCheck.A)(this, VideoSDK3);
                    (0, defineProperty.A)(this, "keyProvider", null);
                  }
                  return (0, createClass.A)(VideoSDK3, null, [{
                    key: "setKeyProvider",
                    value: (
                      /**
                       * @param {ExternalE2EEKeyProvider} keyProvider
                       */
                      function setKeyProvider(keyProvider) {
                        this.keyProvider = keyProvider;
                      }
                    )
                    /**
                     * @returns {ExternalE2EEKeyProvider}
                     */
                  }, {
                    key: "getKeyProvider",
                    value: function getKeyProvider() {
                      return this.keyProvider;
                    }
                    /**
                     * Configure SDK with apiKey.
                     * @param {string} apiKey
                     */
                  }, {
                    key: "config",
                    value: function config3(apiKey) {
                      if (!apiKey) {
                        throw new Error("'token' is empty, please provide it in config");
                      }
                      this.apiKey = apiKey;
                      var store = createStore(redux_reducers, void 0, applyMiddleware.apply(void 0, reduxMiddlewares));
                      window.STORE = store;
                      RoomClient["default"].init({
                        store
                      });
                    }
                    /**
                     *
                     * @returns {Promise<Array<CameraDeviceInfo>>}
                     */
                  }, {
                    key: "getCameras",
                    value: function() {
                      var _getCameras = (0, asyncToGenerator.A)(regenerator_default().mark(function _callee2() {
                        var isFirefox, cameras, devices, message, _t;
                        return regenerator_default().wrap(function(_context2) {
                          while (1) switch (_context2.prev = _context2.next) {
                            case 0:
                              _context2.prev = 0;
                              if (navigator.userAgent) {
                                isFirefox = navigator.userAgent.includes("Firefox");
                              }
                              cameras = [];
                              if (!isFirefox) {
                                _context2.next = 2;
                                break;
                              }
                              _context2.next = 1;
                              return new Promise(function(resolve, reject) {
                                navigator.mediaDevices.getUserMedia({
                                  audio: false,
                                  video: true
                                }).then(function() {
                                  var _ref = (0, asyncToGenerator.A)(regenerator_default().mark(function _callee(stream) {
                                    var devices2;
                                    return regenerator_default().wrap(function(_context) {
                                      while (1) switch (_context.prev = _context.next) {
                                        case 0:
                                          _context.next = 1;
                                          return navigator.mediaDevices.enumerateDevices();
                                        case 1:
                                          devices2 = _context.sent;
                                          cameras = devices2.filter(function(device) {
                                            return device.kind === "videoinput";
                                          }).map(function(device) {
                                            return new CameraDeviceInfo2(device.deviceId, device.groupId, device.kind, device.label);
                                          });
                                          resolve(cameras);
                                          stream.getTracks().forEach(function(track) {
                                            return track.stop();
                                          });
                                        case 2:
                                        case "end":
                                          return _context.stop();
                                      }
                                    }, _callee);
                                  }));
                                  return function(_x) {
                                    return _ref.apply(this, arguments);
                                  };
                                }())["catch"](function(error) {
                                  console.error("Error in getCameras()", error);
                                  reject(error);
                                });
                              });
                            case 1:
                              _context2.next = 4;
                              break;
                            case 2:
                              _context2.next = 3;
                              return navigator.mediaDevices.enumerateDevices();
                            case 3:
                              devices = _context2.sent;
                              cameras = devices.filter(function(device) {
                                return device.kind === "videoinput";
                              }).map(function(device) {
                                return new CameraDeviceInfo2(device.deviceId, device.groupId, device.kind, device.label);
                              });
                            case 4:
                              return _context2.abrupt("return", cameras);
                            case 5:
                              _context2.prev = 5;
                              _t = _context2["catch"](0);
                              message = _t.message;
                              if (_t instanceof TypeError && _t.name === "TypeError") {
                                message = errors.q.ERROR_CAMERA_ACCESS_UNAVAILABLE.message;
                              }
                              console.error("An error occurred in getCameras(), ".concat(message));
                            case 6:
                            case "end":
                              return _context2.stop();
                          }
                        }, _callee2, null, [[0, 5]]);
                      }));
                      function getCameras() {
                        return _getCameras.apply(this, arguments);
                      }
                      return getCameras;
                    }()
                  }, {
                    key: "getMicrophones",
                    value: function() {
                      var _getMicrophones = (0, asyncToGenerator.A)(regenerator_default().mark(function _callee4() {
                        var isFirefox, microphones, devices, message, _t2;
                        return regenerator_default().wrap(function(_context4) {
                          while (1) switch (_context4.prev = _context4.next) {
                            case 0:
                              _context4.prev = 0;
                              if (navigator.userAgent) {
                                isFirefox = navigator.userAgent.includes("Firefox");
                              }
                              microphones = [];
                              if (!isFirefox) {
                                _context4.next = 2;
                                break;
                              }
                              _context4.next = 1;
                              return new Promise(function(resolve, reject) {
                                navigator.mediaDevices.getUserMedia({
                                  audio: true,
                                  video: false
                                }).then(function() {
                                  var _ref2 = (0, asyncToGenerator.A)(regenerator_default().mark(function _callee3(stream) {
                                    var devices2;
                                    return regenerator_default().wrap(function(_context3) {
                                      while (1) switch (_context3.prev = _context3.next) {
                                        case 0:
                                          _context3.next = 1;
                                          return navigator.mediaDevices.enumerateDevices();
                                        case 1:
                                          devices2 = _context3.sent;
                                          microphones = devices2.filter(function(device) {
                                            return device.kind === "audioinput";
                                          }).map(function(device) {
                                            return new MicrophoneDeviceInfo2(device.deviceId, device.groupId, device.kind, device.label);
                                          });
                                          resolve(microphones);
                                          stream.getTracks().forEach(function(track) {
                                            return track.stop();
                                          });
                                        case 2:
                                        case "end":
                                          return _context3.stop();
                                      }
                                    }, _callee3);
                                  }));
                                  return function(_x2) {
                                    return _ref2.apply(this, arguments);
                                  };
                                }())["catch"](function(error) {
                                  console.error("Error in getMicrophones()", error);
                                  reject(error);
                                });
                              });
                            case 1:
                              _context4.next = 4;
                              break;
                            case 2:
                              _context4.next = 3;
                              return navigator.mediaDevices.enumerateDevices();
                            case 3:
                              devices = _context4.sent;
                              microphones = devices.filter(function(device) {
                                return device.kind === "audioinput";
                              }).map(function(device) {
                                return new MicrophoneDeviceInfo2(device.deviceId, device.groupId, device.kind, device.label);
                              });
                            case 4:
                              return _context4.abrupt("return", microphones);
                            case 5:
                              _context4.prev = 5;
                              _t2 = _context4["catch"](0);
                              message = _t2.message;
                              if (_t2 instanceof TypeError && _t2.name === "TypeError") {
                                message = errors.q.ERROR_MICROPHONE_ACCESS_UNAVAILABLE.message;
                              }
                              console.error("An error occurred in getMicrophones(), ".concat(message));
                            case 6:
                            case "end":
                              return _context4.stop();
                          }
                        }, _callee4, null, [[0, 5]]);
                      }));
                      function getMicrophones() {
                        return _getMicrophones.apply(this, arguments);
                      }
                      return getMicrophones;
                    }()
                  }, {
                    key: "getPlaybackDevices",
                    value: function() {
                      var _getPlaybackDevices = (0, asyncToGenerator.A)(regenerator_default().mark(function _callee6() {
                        var isFirefox, playbackDevices, devices, message, _t3;
                        return regenerator_default().wrap(function(_context6) {
                          while (1) switch (_context6.prev = _context6.next) {
                            case 0:
                              _context6.prev = 0;
                              if (navigator.userAgent) {
                                isFirefox = navigator.userAgent.includes("Firefox");
                              }
                              playbackDevices = [];
                              if (!isFirefox) {
                                _context6.next = 2;
                                break;
                              }
                              _context6.next = 1;
                              return new Promise(function(resolve, reject) {
                                navigator.mediaDevices.getUserMedia({
                                  audio: true,
                                  video: false
                                }).then(function() {
                                  var _ref3 = (0, asyncToGenerator.A)(regenerator_default().mark(function _callee5(stream) {
                                    var devices2;
                                    return regenerator_default().wrap(function(_context5) {
                                      while (1) switch (_context5.prev = _context5.next) {
                                        case 0:
                                          _context5.next = 1;
                                          return navigator.mediaDevices.enumerateDevices();
                                        case 1:
                                          devices2 = _context5.sent;
                                          playbackDevices = devices2.filter(function(device) {
                                            return device.kind === "audiooutput";
                                          }).map(function(device) {
                                            return new PlaybackDeviceInfo(device.deviceId, device.groupId, device.kind, device.label);
                                          });
                                          resolve(playbackDevices);
                                          stream.getTracks().forEach(function(track) {
                                            return track.stop();
                                          });
                                        case 2:
                                        case "end":
                                          return _context5.stop();
                                      }
                                    }, _callee5);
                                  }));
                                  return function(_x3) {
                                    return _ref3.apply(this, arguments);
                                  };
                                }())["catch"](function(error) {
                                  console.error("Error in getPlaybackDevices()", error);
                                  reject(error);
                                });
                              });
                            case 1:
                              _context6.next = 4;
                              break;
                            case 2:
                              _context6.next = 3;
                              return navigator.mediaDevices.enumerateDevices();
                            case 3:
                              devices = _context6.sent;
                              playbackDevices = devices.filter(function(device) {
                                return device.kind === "audiooutput";
                              }).map(function(device) {
                                return new PlaybackDeviceInfo(device.deviceId, device.groupId, device.kind, device.label);
                              });
                            case 4:
                              return _context6.abrupt("return", playbackDevices);
                            case 5:
                              _context6.prev = 5;
                              _t3 = _context6["catch"](0);
                              message = _t3.message;
                              if (_t3 instanceof TypeError && _t3.name === "TypeError") {
                                message = "Playback device access unavailable: Please ensure your device is compatible and that you're on a secure website (https://)";
                              }
                              console.error("An error occurred in getPlaybackDevices(), ".concat(message));
                            case 6:
                            case "end":
                              return _context6.stop();
                          }
                        }, _callee6, null, [[0, 5]]);
                      }));
                      function getPlaybackDevices() {
                        return _getPlaybackDevices.apply(this, arguments);
                      }
                      return getPlaybackDevices;
                    }()
                  }, {
                    key: "getDevices",
                    value: function() {
                      var _getDevices = (0, asyncToGenerator.A)(regenerator_default().mark(function _callee7() {
                        var devices, mediaDevices, _iterator, _step, device, message, _t4;
                        return regenerator_default().wrap(function(_context7) {
                          while (1) switch (_context7.prev = _context7.next) {
                            case 0:
                              _context7.prev = 0;
                              _context7.next = 1;
                              return navigator.mediaDevices.enumerateDevices();
                            case 1:
                              devices = _context7.sent;
                              mediaDevices = [];
                              _iterator = src_createForOfIteratorHelper(devices);
                              try {
                                for (_iterator.s(); !(_step = _iterator.n()).done; ) {
                                  device = _step.value;
                                  mediaDevices.push(new DeviceInfo2(device.deviceId, device.groupId, device.kind, device.label));
                                }
                              } catch (err) {
                                _iterator.e(err);
                              } finally {
                                _iterator.f();
                              }
                              return _context7.abrupt("return", mediaDevices);
                            case 2:
                              _context7.prev = 2;
                              _t4 = _context7["catch"](0);
                              message = _t4.message;
                              if (_t4 instanceof TypeError) {
                                if (_t4.name === "TypeError") {
                                  message = "Could not access devices : Please ensure your devices is compatible and that you're on a secure website (https://)";
                                } else {
                                  message = _t4.message;
                                }
                              }
                              console.error("An error occurred in getDevices(), ".concat(message));
                            case 3:
                            case "end":
                              return _context7.stop();
                          }
                        }, _callee7, null, [[0, 2]]);
                      }));
                      function getDevices() {
                        return _getDevices.apply(this, arguments);
                      }
                      return getDevices;
                    }()
                  }, {
                    key: "on",
                    value: function on(eventType, listener) {
                      switch (eventType) {
                        case "device-changed":
                          this.addDeviceChangeEvent();
                          this.eventEmitter.on(eventType, listener);
                          break;
                        default:
                          throw new Error("Unsupported event type");
                      }
                    }
                  }, {
                    key: "addDeviceChangeEvent",
                    value: function addDeviceChangeEvent() {
                      var _this = this;
                      if (!deviceChangeEventRegistered) {
                        this.getDevices().then(function(devices) {
                          _this.devices = devices;
                        });
                        try {
                          navigator.mediaDevices.addEventListener("devicechange", function() {
                            var _ref4 = (0, asyncToGenerator.A)(regenerator_default().mark(function _callee8(e) {
                              var oldList, newDevices, _iterator2, _step2, _loop, _t5;
                              return regenerator_default().wrap(function(_context9) {
                                while (1) switch (_context9.prev = _context9.next) {
                                  case 0:
                                    oldList = _this.devices;
                                    _context9.next = 1;
                                    return _this.getDevices();
                                  case 1:
                                    _this.devices = _context9.sent;
                                    newDevices = new Array();
                                    _iterator2 = src_createForOfIteratorHelper(_this.devices);
                                    _context9.prev = 2;
                                    _loop = regenerator_default().mark(function _loop2() {
                                      var device, oldDevice;
                                      return regenerator_default().wrap(function(_context8) {
                                        while (1) switch (_context8.prev = _context8.next) {
                                          case 0:
                                            device = _step2.value;
                                            oldDevice = oldList.filter(function(old) {
                                              return old.deviceId == device.deviceId && old.kind == device.kind;
                                            });
                                            if (oldDevice.length == 0) {
                                              newDevices.push(device);
                                            } else {
                                              oldList = oldList.filter(function(old) {
                                                return !(old.deviceId == device.deviceId && old.kind == device.kind);
                                              });
                                            }
                                          case 1:
                                          case "end":
                                            return _context8.stop();
                                        }
                                      }, _loop2);
                                    });
                                    _iterator2.s();
                                  case 3:
                                    if ((_step2 = _iterator2.n()).done) {
                                      _context9.next = 5;
                                      break;
                                    }
                                    return _context9.delegateYield(_loop(), "t0", 4);
                                  case 4:
                                    _context9.next = 3;
                                    break;
                                  case 5:
                                    _context9.next = 7;
                                    break;
                                  case 6:
                                    _context9.prev = 6;
                                    _t5 = _context9["catch"](2);
                                    _iterator2.e(_t5);
                                  case 7:
                                    _context9.prev = 7;
                                    _iterator2.f();
                                    return _context9.finish(7);
                                  case 8:
                                    if (newDevices.length != 0) {
                                      _this.eventEmitter.emit("device-changed", {
                                        devices: _this.devices
                                      });
                                    }
                                    if (oldList.length != 0) {
                                      _this.eventEmitter.emit("device-changed", {
                                        devices: _this.devices
                                      });
                                    }
                                  case 9:
                                  case "end":
                                    return _context9.stop();
                                }
                              }, _callee8, null, [[2, 6, 7, 8]]);
                            }));
                            return function(_x4) {
                              return _ref4.apply(this, arguments);
                            };
                          }());
                          deviceChangeEventRegistered = true;
                        } catch (error) {
                          var message = error.message;
                          if (error instanceof TypeError) {
                            if (error.name === "TypeError") {
                              message = "Could not access devices : Please ensure your devices is compatible and that you're on a secure website (https://)";
                            } else {
                              message = error.message;
                            }
                          }
                          console.error("An error occurred in device-change event, ".concat(message));
                        }
                      }
                    }
                    /**
                     * Remove event listener
                     * @param { "device-changed" } eventType
                     * @param {Function} listener Callback function
                     */
                  }, {
                    key: "off",
                    value: function off(eventType, listener) {
                      switch (eventType) {
                        case "device-changed":
                          this.eventEmitter.off(eventType, listener);
                          break;
                        default:
                          throw new Error("Unsupported event type");
                      }
                    }
                    /**
                     *
                     * @param {Permission} permissions
                     * @returns {Promise<Map<string, boolean>>}
                     */
                  }, {
                    key: "checkPermissions",
                    value: function() {
                      var _checkPermissions = (0, asyncToGenerator.A)(regenerator_default().mark(function _callee9(permissions) {
                        var permissionMap, allowed, res, _allowed, _res, _t6, _t7;
                        return regenerator_default().wrap(function(_context0) {
                          while (1) switch (_context0.prev = _context0.next) {
                            case 0:
                              if (!permissions) {
                                permissions = Permission.AUDIO_AND_VIDEO;
                              }
                              permissionMap = /* @__PURE__ */ new Map();
                              if (!(permissions.includes(Permission.AUDIO) || permissions.includes(Permission.AUDIO_AND_VIDEO))) {
                                _context0.next = 5;
                                break;
                              }
                              allowed = true;
                              _context0.prev = 1;
                              _context0.next = 2;
                              return navigator.permissions.query({
                                name: "microphone"
                              });
                            case 2:
                              res = _context0.sent;
                              if (res.state == "prompt" || res.state == "denied") allowed = false;
                              _context0.next = 4;
                              break;
                            case 3:
                              _context0.prev = 3;
                              _t6 = _context0["catch"](1);
                              throw Error("Browser does not support microphone permission check");
                            case 4:
                              permissionMap.set(Permission.AUDIO, allowed);
                            case 5:
                              if (!(permissions.includes(Permission.VIDEO) || permissions.includes(Permission.AUDIO_AND_VIDEO))) {
                                _context0.next = 10;
                                break;
                              }
                              _allowed = true;
                              _context0.prev = 6;
                              _context0.next = 7;
                              return navigator.permissions.query({
                                name: "camera"
                              });
                            case 7:
                              _res = _context0.sent;
                              if (_res.state == "prompt" || _res.state == "denied") _allowed = false;
                              _context0.next = 9;
                              break;
                            case 8:
                              _context0.prev = 8;
                              _t7 = _context0["catch"](6);
                              throw Error("Browser does not support camera permission check");
                            case 9:
                              permissionMap.set(Permission.VIDEO, _allowed);
                            case 10:
                              return _context0.abrupt("return", permissionMap);
                            case 11:
                            case "end":
                              return _context0.stop();
                          }
                        }, _callee9, null, [[1, 3], [6, 8]]);
                      }));
                      function checkPermissions(_x5) {
                        return _checkPermissions.apply(this, arguments);
                      }
                      return checkPermissions;
                    }()
                  }, {
                    key: "requestPermission",
                    value: function() {
                      var _requestPermission = (0, asyncToGenerator.A)(regenerator_default().mark(function _callee0(permissions) {
                        var permissionMap, mediaStream, constraints, permissionGranted, message, videoMediaStream, _constraints, _permissionGranted, _message, audioMediaStream, _constraints2, _permissionGranted2, _message2, _t8, _t9, _t0, _t1, _t10, _t11;
                        return regenerator_default().wrap(function(_context1) {
                          while (1) switch (_context1.prev = _context1.next) {
                            case 0:
                              if (!permissions) {
                                permissions = Permission.AUDIO_AND_VIDEO;
                              }
                              permissionMap = /* @__PURE__ */ new Map();
                              if (!permissions.includes(Permission.AUDIO_AND_VIDEO)) {
                                _context1.next = 12;
                                break;
                              }
                              constraints = {
                                audio: true,
                                video: true
                              };
                              permissionGranted = true;
                              _context1.prev = 1;
                              _context1.next = 2;
                              return navigator.mediaDevices.getUserMedia(constraints);
                            case 2:
                              mediaStream = _context1.sent;
                              _context1.next = 11;
                              break;
                            case 3:
                              _context1.prev = 3;
                              _t8 = _context1["catch"](1);
                              if (!(_t8 instanceof DOMException)) {
                                _context1.next = 9;
                                break;
                              }
                              _t9 = _t8.name;
                              _context1.next = _t9 === "NotAllowedError" ? 4 : _t9 === "NotReadableError" ? 5 : _t9 === "NotFoundError" ? 6 : 7;
                              break;
                            case 4:
                              if (_t8.message === "Permission denied by system") {
                                message = errors.q.ERROR_CAMERA_PERMISSION_DENIED_BY_OS.message;
                              }
                              return _context1.abrupt("continue", 8);
                            case 5:
                              message = handleNotReadableError(_t8, "video");
                              return _context1.abrupt("continue", 8);
                            case 6:
                              message = errors.q.ERROR_CAMERA_NOT_FOUND.message;
                              if (navigator && navigator.userAgent) {
                                if (navigator.userAgent.indexOf("Firefox") != -1) {
                                  message = errors.q.ERROR_CAMERA_PERMISSION_DENIED_BY_OS.message;
                                }
                              }
                              return _context1.abrupt("continue", 8);
                            case 7:
                              message = _t8.message;
                            case 8:
                              _context1.next = 10;
                              break;
                            case 9:
                              if (_t8 instanceof TypeError) {
                                if (_t8.name === "TypeError") {
                                  message = errors.q.ERROR_CAMERA_ACCESS_UNAVAILABLE.message;
                                } else {
                                  message = _t8.message;
                                }
                              } else {
                                message = _t8.message;
                              }
                            case 10:
                              permissionGranted = false;
                              if (message) console.error("An error occurred in request permission, ".concat(message));
                            case 11:
                              if (mediaStream) {
                                setTimeout(function() {
                                  mediaStream.getTracks().forEach(function(track) {
                                    track.stop();
                                  });
                                }, 100);
                              }
                              permissionMap.set(Permission.AUDIO_AND_VIDEO, permissionGranted);
                            case 12:
                              if (!permissions.includes(Permission.VIDEO)) {
                                _context1.next = 24;
                                break;
                              }
                              _constraints = {
                                audio: false,
                                video: true
                              };
                              _permissionGranted = true;
                              _context1.prev = 13;
                              _context1.next = 14;
                              return navigator.mediaDevices.getUserMedia(_constraints);
                            case 14:
                              videoMediaStream = _context1.sent;
                              _context1.next = 23;
                              break;
                            case 15:
                              _context1.prev = 15;
                              _t0 = _context1["catch"](13);
                              if (!(_t0 instanceof DOMException)) {
                                _context1.next = 21;
                                break;
                              }
                              _t1 = _t0.name;
                              _context1.next = _t1 === "NotAllowedError" ? 16 : _t1 === "NotReadableError" ? 17 : _t1 === "NotFoundError" ? 18 : 19;
                              break;
                            case 16:
                              if (_t0.message === "Permission denied by system") {
                                _message = errors.q.ERROR_CAMERA_PERMISSION_DENIED_BY_OS.message;
                              }
                              return _context1.abrupt("continue", 20);
                            case 17:
                              _message = handleNotReadableError(_t0, "video");
                              return _context1.abrupt("continue", 20);
                            case 18:
                              _message = errors.q.ERROR_CAMERA_NOT_FOUND.message;
                              if (navigator && navigator.userAgent) {
                                if (navigator.userAgent.indexOf("Firefox") != -1) {
                                  _message = errors.q.ERROR_CAMERA_PERMISSION_DENIED_BY_OS.message;
                                }
                              }
                              return _context1.abrupt("continue", 20);
                            case 19:
                              _message = _t0.message;
                            case 20:
                              _context1.next = 22;
                              break;
                            case 21:
                              if (_t0 instanceof TypeError) {
                                if (_t0.name === "TypeError") {
                                  _message = errors.q.ERROR_CAMERA_ACCESS_UNAVAILABLE.message;
                                } else {
                                  _message = _t0.message;
                                }
                              } else {
                                _message = _t0.message;
                              }
                            case 22:
                              _permissionGranted = false;
                              if (_message) console.error("An error occurred in request permission, ".concat(_message));
                            case 23:
                              if (videoMediaStream) {
                                videoMediaStream.getTracks().forEach(function(track) {
                                  track.stop();
                                });
                              }
                              permissionMap.set(Permission.VIDEO, _permissionGranted);
                            case 24:
                              if (!permissions.includes(Permission.AUDIO)) {
                                _context1.next = 36;
                                break;
                              }
                              _constraints2 = {
                                audio: true,
                                video: false
                              };
                              _permissionGranted2 = true;
                              _context1.prev = 25;
                              _context1.next = 26;
                              return navigator.mediaDevices.getUserMedia(_constraints2);
                            case 26:
                              audioMediaStream = _context1.sent;
                              _context1.next = 35;
                              break;
                            case 27:
                              _context1.prev = 27;
                              _t10 = _context1["catch"](25);
                              if (!(_t10 instanceof DOMException)) {
                                _context1.next = 33;
                                break;
                              }
                              _t11 = _t10.name;
                              _context1.next = _t11 === "NotAllowedError" ? 28 : _t11 === "NotReadableError" ? 29 : _t11 === "NotFoundError" ? 30 : 31;
                              break;
                            case 28:
                              if (_t10.message === "Permission denied by system") {
                                _message2 = errors.q.ERROR_MICROPHONE_PERMISSION_DENIED_BY_OS.message;
                              }
                              return _context1.abrupt("continue", 32);
                            case 29:
                              _message2 = handleNotReadableError(_t10, "audio");
                              return _context1.abrupt("continue", 32);
                            case 30:
                              _message2 = errors.q.ERROR_MICROPHONE_NOT_FOUND.message;
                              if (navigator && navigator.userAgent) {
                                if (navigator.userAgent.indexOf("Firefox") != -1) {
                                  _message2 = errors.q.ERROR_MICROPHONE_PERMISSION_DENIED_BY_OS.message;
                                }
                              }
                              return _context1.abrupt("continue", 32);
                            case 31:
                              _message2 = _t10.message;
                            case 32:
                              _context1.next = 34;
                              break;
                            case 33:
                              if (_t10 instanceof TypeError) {
                                if (_t10.name === "TypeError") {
                                  _message2 = errors.q.ERROR_MICROPHONE_ACCESS_UNAVAILABLE.message;
                                } else {
                                  _message2 = _t10.message;
                                }
                              } else {
                                _message2 = _t10.message;
                              }
                            case 34:
                              _permissionGranted2 = false;
                              if (_message2) console.error("An error occurred in request permission, ".concat(_message2));
                            case 35:
                              if (audioMediaStream) {
                                audioMediaStream.getTracks().forEach(function(track) {
                                  track.stop();
                                });
                              }
                              permissionMap.set(Permission.AUDIO, _permissionGranted2);
                            case 36:
                              return _context1.abrupt("return", permissionMap);
                            case 37:
                            case "end":
                              return _context1.stop();
                          }
                        }, _callee0, null, [[1, 3], [13, 15], [25, 27]]);
                      }));
                      function requestPermission(_x6) {
                        return _requestPermission.apply(this, arguments);
                      }
                      return requestPermission;
                    }()
                  }, {
                    key: "isInt",
                    value: function isInt(x) {
                      return typeof x === "number" && x % 1 == 0;
                    }
                    /** @deprecated */
                    /**
                     * @param {{
                     * timeoutDuration ?: number | undefined,
                     * }}
                     * @returns {Promise<{downloadSpeed: number,uploadSpeed: number}> }
                     */
                  }, {
                    key: "getNetworkStats",
                    value: function() {
                      var _getNetworkStats = (0, asyncToGenerator.A)(regenerator_default().mark(function _callee1() {
                        var _ref5, timeoutDuration, _ref5$baseUrl, baseUrl, timeoutPromise, statsPromise, _args10 = arguments;
                        return regenerator_default().wrap(function(_context10) {
                          while (1) switch (_context10.prev = _context10.next) {
                            case 0:
                              _ref5 = _args10.length > 0 && _args10[0] !== void 0 ? _args10[0] : {}, timeoutDuration = _ref5.timeoutDuration, _ref5$baseUrl = _ref5.baseUrl, baseUrl = _ref5$baseUrl === void 0 ? "api.videosdk.live" : _ref5$baseUrl;
                              if (!timeoutDuration || !this.isInt(timeoutDuration)) {
                                timeoutDuration = 6e4;
                              }
                              timeoutPromise = new Promise(function(resolve, reject) {
                                setTimeout(function() {
                                  reject("Not able to get NetworkStats due to timeout");
                                }, timeoutDuration);
                              });
                              statsPromise = new Promise(function(resolve, reject) {
                                if (!navigator.onLine) {
                                  reject("Not able to get NetworkStats due to no Network");
                                  return;
                                }
                                var speedTest = new LoggingMeasurementEngine({
                                  measureDownloadLoadedLatency: false,
                                  measureUploadLoadedLatency: false,
                                  measurements: [{
                                    type: "upload",
                                    bytes: 3e6,
                                    count: 1,
                                    bypassMinDuration: true
                                  }, {
                                    type: "download",
                                    bytes: 3e6,
                                    count: 1,
                                    bypassMinDuration: true
                                  }],
                                  uploadApiUrl: "https://".concat(baseUrl, "/test-upload-speed"),
                                  downloadApiUrl: "https://".concat(baseUrl, "/test-download-speed")
                                });
                                if (!speedTest.isRunning) {
                                  reject("Not able to get NetworkStats");
                                  return;
                                }
                                speedTest.onFinish = function(results) {
                                  resolve({
                                    downloadSpeed: parseFloat(Number(results.getDownloadBandwidth() / 1048576).toFixed(2)),
                                    uploadSpeed: parseFloat(Number(results.getUploadBandwidth() / 1048576).toFixed(2))
                                  });
                                };
                                speedTest.onError = function(e) {
                                  reject("Not able to get NetworkStats");
                                  return;
                                };
                              });
                              return _context10.abrupt("return", Promise.race([statsPromise, timeoutPromise]));
                            case 1:
                            case "end":
                              return _context10.stop();
                          }
                        }, _callee1, this);
                      }));
                      function getNetworkStats3() {
                        return _getNetworkStats.apply(this, arguments);
                      }
                      return getNetworkStats3;
                    }()
                  }, {
                    key: "checkConnection",
                    value: function() {
                      var _checkConnection = (0, asyncToGenerator.A)(regenerator_default().mark(function _callee10() {
                        var _ref6, timeoutDuration, _ref6$baseUrl, baseUrl, timeoutPromise, connectionPromise, _args11 = arguments;
                        return regenerator_default().wrap(function(_context11) {
                          while (1) switch (_context11.prev = _context11.next) {
                            case 0:
                              _ref6 = _args11.length > 0 && _args11[0] !== void 0 ? _args11[0] : {}, timeoutDuration = _ref6.timeoutDuration, _ref6$baseUrl = _ref6.baseUrl, baseUrl = _ref6$baseUrl === void 0 ? "api.videosdk.live" : _ref6$baseUrl;
                              if (!timeoutDuration || !this.isInt(timeoutDuration)) {
                                timeoutDuration = 6e4;
                              }
                              timeoutPromise = new Promise(function(resolve, reject) {
                                setTimeout(function() {
                                  reject("TimeoutError: NetworkStats timeout");
                                }, timeoutDuration);
                              });
                              connectionPromise = new Promise(function(resolve, reject) {
                                if (!navigator.onLine) {
                                  reject("NetworkError: Offline");
                                  return;
                                }
                                fetch("https://".concat(baseUrl, "/ping")).then(function(response) {
                                  response.text().then(function(text) {
                                    if (text == "pong") {
                                      resolve("Connection established");
                                    } else {
                                      reject("ConnectionError: Server unreachable");
                                    }
                                  });
                                })["catch"](function(error) {
                                  reject("ConnectionError: Server unreachable");
                                });
                              });
                              return _context11.abrupt("return", Promise.race([connectionPromise, timeoutPromise]));
                            case 1:
                            case "end":
                              return _context11.stop();
                          }
                        }, _callee10, this);
                      }));
                      function checkConnection() {
                        return _checkConnection.apply(this, arguments);
                      }
                      return checkConnection;
                    }()
                  }, {
                    key: "analytics",
                    value: function analytics(params) {
                      var _parsedUserAgent;
                      var _userAgent, parsedUserAgent;
                      if (!params && navigator && navigator.userAgent) {
                        _userAgent = navigator.userAgent;
                        parsedUserAgent = es5_default().parse(_userAgent);
                        delete parsedUserAgent.engine;
                      }
                      try {
                        var _params;
                        if (!((_params = params) !== null && _params !== void 0 && _params.browserUserAgent)) {
                          _userAgent = navigator.userAgent;
                          parsedUserAgent = es5_default().parse(_userAgent);
                          delete parsedUserAgent.engine;
                        }
                      } catch (error) {
                      }
                      if (params && params.rawUserAgent) {
                        _userAgent = params.rawUserAgent;
                        parsedUserAgent = es5_default().parse(_userAgent);
                        delete parsedUserAgent.engine;
                      }
                      if (!params) params = {};
                      var deviceInfo = {};
                      deviceInfo.sdkType = params.sdkType || "javascript";
                      deviceInfo.sdkVersion = params.sdkVersion || "0.3.12";
                      deviceInfo.platform = params.platform || ((_parsedUserAgent = parsedUserAgent) === null || _parsedUserAgent === void 0 || (_parsedUserAgent = _parsedUserAgent.platform) === null || _parsedUserAgent === void 0 ? void 0 : _parsedUserAgent.type) || "";
                      if (params.browserUserAgent == "null") {
                        deviceInfo.browserUserAgent = void 0;
                      } else {
                        deviceInfo.browserUserAgent = parsedUserAgent;
                      }
                      if (params.deviceUserAgent) {
                        deviceInfo.deviceUserAgent = params.deviceUserAgent;
                      }
                      this._deviceInfo = deviceInfo;
                    }
                    /**
                     * Initialize meeting and local video stream.
                     * @param {{
                     *  meetingId: string,
                     *  autoConsume?: boolean,
                     *  preferredProtocol?: "UDP_ONLY" | "UDP_OVER_TCP" | "TCP_ONLY",
                     *  participantId?:string,
                     *  name:string,
                     *  micEnabled:boolean,
                     *  webcamEnabled:boolean,
                     *  chatEnabled?: boolean,
                     *  maxResolution?:"hd" | "sd",
                     *  customCameraVideoTrack?: MediaStream | undefined
                     *  customMicrophoneAudioTrack?: MediaStream | undefined,
                     *  useSpartialLayerAnalytics?: boolean
                     *  mode?: SEND_AND_RECV | SIGNALLING_ONLY | RECV_ONLY,
                     *  multiStream?: boolean,
                     *  metaData?: object | undefined,
                     *  defaultCamera?: 'front' | 'back',
                     *  debugMode: boolean
                     * }}
                     * @returns {Meeting}
                     */
                  }, {
                    key: "initMeeting",
                    value: function initMeeting(_ref7) {
                      var _preferredProtocol;
                      var meetingId = _ref7.meetingId, _ref7$customCameraVid = _ref7.customCameraVideoTrack, customCameraVideoTrack = _ref7$customCameraVid === void 0 ? void 0 : _ref7$customCameraVid, _ref7$customMicrophon = _ref7.customMicrophoneAudioTrack, customMicrophoneAudioTrack = _ref7$customMicrophon === void 0 ? void 0 : _ref7$customMicrophon, _ref7$autoConsume = _ref7.autoConsume, autoConsume = _ref7$autoConsume === void 0 ? true : _ref7$autoConsume, preferredProtocol = _ref7.preferredProtocol, mode = _ref7.mode, _ref7$multiStream = _ref7.multiStream, multiStream = _ref7$multiStream === void 0 ? true : _ref7$multiStream, participantId = _ref7.participantId, name = _ref7.name, translationLanguage = _ref7.translationLanguage, speakingLanguage = _ref7.speakingLanguage, micEnabled = _ref7.micEnabled, webcamEnabled = _ref7.webcamEnabled, maxResolution = _ref7.maxResolution, metaData = _ref7.metaData, chatEnabled = _ref7.chatEnabled, useSpartialLayerAnalytics = _ref7.useSpartialLayerAnalytics, signalingBaseUrl = _ref7.signalingBaseUrl, defaultCamera = _ref7.defaultCamera, _ref7$debugMode = _ref7.debugMode, debugMode = _ref7$debugMode === void 0 ? true : _ref7$debugMode;
                      if (!meetingId) {
                        throw new Error("'meetingId' is empty, please verify it or generate new meetingId using the API.");
                      }
                      var peerId = participantId ? participantId.toString() : random_string_default()({
                        length: 8
                      }).toLowerCase();
                      var displayName = name || random_string_default()({
                        length: 6
                      }).toLowerCase();
                      if (!this._deviceInfo) {
                        this.analytics();
                      }
                      if (typeof preferredProtocol !== "string") {
                        preferredProtocol = "UDP_OVER_TCP";
                      }
                      switch ((_preferredProtocol = preferredProtocol) === null || _preferredProtocol === void 0 ? void 0 : _preferredProtocol.toUpperCase()) {
                        case "UDP_ONLY":
                        case "UDP_OVER_TCP":
                        case "TCP_ONLY":
                          preferredProtocol = preferredProtocol.toUpperCase();
                          break;
                        default:
                          preferredProtocol = "UDP_OVER_TCP";
                          break;
                      }
                      if (!mode) {
                        mode = modes.nI.SEND_AND_RECV;
                      }
                      if (mode !== modes.nI.SEND_AND_RECV && mode !== modes.nI.SIGNALLING_ONLY && mode !== modes.nI.RECV_ONLY && mode !== modes.nI.VIEWER && mode !== modes.nI.CONFERENCE) {
                        throw new Error('"mode" can only be either '.concat(modes.nI.SEND_AND_RECV, " or ").concat(modes.nI.SIGNALLING_ONLY, " or ").concat(modes.nI.RECV_ONLY, " "));
                      }
                      if (metaData != void 0) {
                        if ((0, esm_typeof.A)(metaData) != "object") {
                          throw new Error('"metaData" can only be object.');
                        }
                      }
                      var isReactNative = this._deviceInfo.sdkType === "react-native";
                      var defaultCameraIndex = isReactNative ? defaultCamera ? defaultCamera === "front" ? 1 : 0 : customCameraVideoTrack ? customCameraVideoTrack.getVideoTracks()[0].getConstraints().facingMode === "user" ? 1 : 0 : isReactNative ? 1 : 0 : 0;
                      var roomClient = new RoomClient["default"]({
                        roomId: meetingId,
                        peerId,
                        secret: this.apiKey,
                        device: "unknown",
                        displayName,
                        translationLanguage,
                        speakingLanguage,
                        mode,
                        useSimulcast: multiStream,
                        produce: true,
                        consume: true,
                        datachannel: chatEnabled !== false,
                        micEnabled: micEnabled !== false,
                        webcamEnabled: webcamEnabled !== false,
                        maxResolution: maxResolution || "hd",
                        useSpartialLayerAnalytics,
                        //useSpartialLayerAnalytics: true,
                        _deviceInfo: this._deviceInfo,
                        customCameraVideoTrack,
                        customMicrophoneAudioTrack,
                        autoConsume,
                        preferredProtocol,
                        signalingBaseUrl,
                        metaData,
                        defaultCameraIndex,
                        defaultCamera,
                        debugMode,
                        keyProvider: this.keyProvider
                      });
                      Store.roomClient = roomClient;
                      var localParticipant = new Participant({
                        id: peerId,
                        displayName,
                        local: true,
                        mode,
                        metaData
                      });
                      return new Meeting(meetingId, localParticipant, roomClient);
                    }
                    /**
                     *
                     * For media API refer this doc
                     * https://www.w3.org/TR/mediacapture-streams/#def-constraint-sampleRate
                     */
                    /**
                     * @param {{
                     *  cameraId?: string | undefined,
                     *  encoderConfig?: "h90p_w160p" | "h180p_w320p" | "h216p_w384p"
                     *     | "h360p_w640p" | "h360p_w640p_150kbps" | h540p_w960p" | "h540p_w960p_500kbps" | "h720p_w1280p" | "h1080p_w1920p"
                     *     | "h1440p_w2560p" | "h2160p_w3840p" | "h120p_w160p" | "h180p_w240p"
                     *     | "h240p_w320p" | "h360p_w480p" | "h480p_w640p" | "h540p_w720p"
                     *     | "h720p_w960p" | "h1080p_w1440p" | "h1440p_w1920p" | undefined,
                     *  facingMode?: "front" | "environment" | undefined,
                     *  optimizationMode?: "text"| "motion" | "detail" | undefined
                     *  multiStream?: boolean
                     * }}
                     */
                  }, {
                    key: "createCameraVideoTrack",
                    value: function() {
                      var _createCameraVideoTrack = (0, asyncToGenerator.A)(regenerator_default().mark(function _callee11(_ref8) {
                        var _ref8$cameraId, cameraId, _ref8$encoderConfig, encoderConfig, _ref8$facingMode, facingMode, _ref8$optimizationMod, optimizationMode, _ref8$multiStream, multiStream, cameras, isCamera, foundCamera, videoProfile, cameraConstraints, mediaStream, message, sdkError, _t12, _t13;
                        return regenerator_default().wrap(function(_context12) {
                          while (1) switch (_context12.prev = _context12.next) {
                            case 0:
                              _ref8$cameraId = _ref8.cameraId, cameraId = _ref8$cameraId === void 0 ? void 0 : _ref8$cameraId, _ref8$encoderConfig = _ref8.encoderConfig, encoderConfig = _ref8$encoderConfig === void 0 ? void 0 : _ref8$encoderConfig, _ref8$facingMode = _ref8.facingMode, facingMode = _ref8$facingMode === void 0 ? void 0 : _ref8$facingMode, _ref8$optimizationMod = _ref8.optimizationMode, optimizationMode = _ref8$optimizationMod === void 0 ? void 0 : _ref8$optimizationMod, _ref8$multiStream = _ref8.multiStream, multiStream = _ref8$multiStream === void 0 ? true : _ref8$multiStream;
                              if (!cameraId) {
                                _context12.next = 2;
                                break;
                              }
                              _context12.next = 1;
                              return this.getCameras();
                            case 1:
                              cameras = _context12.sent;
                              if (cameras) {
                                isCamera = cameras.some(function(element) {
                                  return element.deviceId;
                                });
                                if (isCamera) {
                                  foundCamera = cameras.some(function(element) {
                                    return element.deviceId === cameraId;
                                  });
                                  if (!foundCamera) {
                                    console.error("No camera device found for the given cameraId, please check the passed cameraId. The default camera will be used instead.");
                                  }
                                }
                              }
                            case 2:
                              _context12.prev = 2;
                              videoProfile = encoderConfig ? config2.$.videoProfiles[encoderConfig] : config2.$.videoProfiles.h360p_w640p;
                              cameraConstraints = {
                                video: {
                                  // deviceId: {
                                  //   exact: cameraId ? cameraId : undefined
                                  // },
                                  deviceId: cameraId ? {
                                    exact: cameraId
                                  } : void 0,
                                  facingMode: facingMode ? facingMode : void 0,
                                  width: videoProfile.width,
                                  height: videoProfile.height,
                                  // aspectRatio: config.aspectRatios[videoProfile.aspectRatio].value,
                                  frameRate: videoProfile.frameRate
                                }
                              };
                              _context12.next = 3;
                              return (0, media.lp)(cameraConstraints);
                            case 3:
                              mediaStream = _context12.sent;
                              if (optimizationMode) {
                                mediaStream.contentHint = optimizationMode;
                              }
                              mediaStream.encoderConfig = encoderConfig ? encoderConfig : "h360p_w640p";
                              mediaStream.contentHint = optimizationMode ? optimizationMode : "";
                              mediaStream.multiStream = multiStream;
                              mediaStream.cameraId = cameraId;
                              return _context12.abrupt("return", mediaStream);
                            case 4:
                              _context12.prev = 4;
                              _t12 = _context12["catch"](2);
                              if (!(_t12.name === "SecurityError")) {
                                _context12.next = 5;
                                break;
                              }
                              message = errors.q.ERROR_RN_CAMERA_ACCESS_DENIED_OR_DISMISSED.message;
                              _context12.next = 13;
                              break;
                            case 5:
                              if (!(_t12.name === "DOMException")) {
                                _context12.next = 6;
                                break;
                              }
                              message = errors.q.ERROR_RN_CAMERA_NOT_FOUND.message;
                              _context12.next = 13;
                              break;
                            case 6:
                              if (!(_t12 instanceof DOMException)) {
                                _context12.next = 12;
                                break;
                              }
                              _t13 = _t12.name;
                              _context12.next = _t13 === "NotAllowedError" ? 7 : _t13 === "NotReadableError" ? 8 : _t13 === "NotFoundError" ? 9 : 10;
                              break;
                            case 7:
                              message = handleNotAllowedError(_t12, "video");
                              return _context12.abrupt("continue", 11);
                            case 8:
                              message = handleNotReadableError(_t12, "video");
                              return _context12.abrupt("continue", 11);
                            case 9:
                              message = errors.q.ERROR_CAMERA_NOT_FOUND.message;
                              if (navigator && navigator.userAgent) {
                                if (navigator.userAgent.indexOf("Firefox") != -1) {
                                  message = errors.q.ERROR_CAMERA_PERMISSION_DENIED_BY_OS.message;
                                }
                              }
                              return _context12.abrupt("continue", 11);
                            case 10:
                              message = _t12.message;
                              return _context12.abrupt("continue", 11);
                            case 11:
                              _context12.next = 13;
                              break;
                            case 12:
                              if (_t12.message == "getUserMedia is not implemented in this browser") {
                                sdkError = errors.q.ERROR_CAMERA_ACCESS_UNAVAILABLE;
                                message = sdkError.message;
                              } else {
                                message = _t12.message;
                              }
                            case 13:
                              console.error("An error occurred in creating video track, ".concat(message));
                              return _context12.abrupt("return", null);
                            case 14:
                            case "end":
                              return _context12.stop();
                          }
                        }, _callee11, this, [[2, 4]]);
                      }));
                      function createCameraVideoTrack3(_x7) {
                        return _createCameraVideoTrack.apply(this, arguments);
                      }
                      return createCameraVideoTrack3;
                    }()
                  }, {
                    key: "createScreenShareVideoTrack",
                    value: function() {
                      var _createScreenShareVideoTrack = (0, asyncToGenerator.A)(regenerator_default().mark(function _callee12(_ref9) {
                        var _ref9$encoderConfig, encoderConfig, _ref9$optimizationMod, optimizationMode, _ref9$withAudio, withAudio, _ref9$multiStream, multiStream, screenProfile, screenConstraints, screenStream;
                        return regenerator_default().wrap(function(_context13) {
                          while (1) switch (_context13.prev = _context13.next) {
                            case 0:
                              _ref9$encoderConfig = _ref9.encoderConfig, encoderConfig = _ref9$encoderConfig === void 0 ? void 0 : _ref9$encoderConfig, _ref9$optimizationMod = _ref9.optimizationMode, optimizationMode = _ref9$optimizationMod === void 0 ? void 0 : _ref9$optimizationMod, _ref9$withAudio = _ref9.withAudio, withAudio = _ref9$withAudio === void 0 ? "enable" : _ref9$withAudio, _ref9$multiStream = _ref9.multiStream, multiStream = _ref9$multiStream === void 0 ? false : _ref9$multiStream;
                              screenProfile = encoderConfig ? config2.$.screenShareProfiles[encoderConfig] : config2.$.screenShareProfiles.h720p_15fps;
                              screenConstraints = {
                                audio: withAudio === "enable",
                                video: {
                                  width: screenProfile.resolution.width,
                                  height: screenProfile.resolution.height,
                                  frameRate: screenProfile.frameRate
                                }
                              };
                              _context13.next = 1;
                              return (0, media.Zu)(screenConstraints);
                            case 1:
                              screenStream = _context13.sent;
                              if (optimizationMode) {
                                screenStream.contentHint = optimizationMode;
                              }
                              screenStream.multiStream = multiStream;
                              return _context13.abrupt("return", screenStream);
                            case 2:
                            case "end":
                              return _context13.stop();
                          }
                        }, _callee12);
                      }));
                      function createScreenShareVideoTrack3(_x8) {
                        return _createScreenShareVideoTrack.apply(this, arguments);
                      }
                      return createScreenShareVideoTrack3;
                    }()
                  }, {
                    key: "createMicrophoneAudioTrack",
                    value: function() {
                      var _createMicrophoneAudioTrack = (0, asyncToGenerator.A)(regenerator_default().mark(function _callee13(_ref0) {
                        var _ref0$noiseConfig, noiseConfig, _ref0$encoderConfig, encoderConfig, _ref0$microphoneId, microphoneId, microphones, foundMicrophone, audioProfile, microphoneConstraints, audioStream, message, sdkError, _t14, _t15;
                        return regenerator_default().wrap(function(_context14) {
                          while (1) switch (_context14.prev = _context14.next) {
                            case 0:
                              _ref0$noiseConfig = _ref0.noiseConfig, noiseConfig = _ref0$noiseConfig === void 0 ? void 0 : _ref0$noiseConfig, _ref0$encoderConfig = _ref0.encoderConfig, encoderConfig = _ref0$encoderConfig === void 0 ? void 0 : _ref0$encoderConfig, _ref0$microphoneId = _ref0.microphoneId, microphoneId = _ref0$microphoneId === void 0 ? void 0 : _ref0$microphoneId;
                              if (!microphoneId) {
                                _context14.next = 2;
                                break;
                              }
                              _context14.next = 1;
                              return this.getMicrophones();
                            case 1:
                              microphones = _context14.sent;
                              if (microphones) {
                                if (microphones.some(function(element) {
                                  return element.deviceId;
                                })) {
                                  foundMicrophone = microphones.some(function(element) {
                                    return element.deviceId === microphoneId;
                                  });
                                  if (!foundMicrophone) {
                                    console.error("No microphone device found for the given microphoneId, please check the passed microphoneId. The default microphone will be used instead.");
                                  }
                                }
                              }
                            case 2:
                              _context14.prev = 2;
                              audioProfile = encoderConfig ? config2.$.audioProfiles[encoderConfig] : config2.$.audioProfiles.speech_standard;
                              microphoneConstraints = {
                                audio: {
                                  // deviceId: { exact: microphoneId ? microphoneId : undefined },
                                  deviceId: microphoneId ? {
                                    exact: microphoneId
                                  } : void 0,
                                  sampleRate: audioProfile.sampleRate,
                                  echoCancellation: noiseConfig ? noiseConfig && noiseConfig.acousticEchoCancellation : audioProfile.echoCancellation,
                                  autoGainControl: noiseConfig ? noiseConfig && noiseConfig.autoGainControl : audioProfile.autoGainControl,
                                  noiseSuppression: noiseConfig ? noiseConfig && noiseConfig.noiseSuppression : audioProfile.noiseSuppression,
                                  channelCount: audioProfile.channelCount
                                }
                              };
                              _context14.next = 3;
                              return (0, media.lp)(microphoneConstraints);
                            case 3:
                              audioStream = _context14.sent;
                              audioStream.encoderConfig = encoderConfig ? encoderConfig : "speech_standard";
                              audioStream.microphoneId = microphoneId;
                              return _context14.abrupt("return", audioStream);
                            case 4:
                              _context14.prev = 4;
                              _t14 = _context14["catch"](2);
                              if (!(_t14.name === "SecurityError")) {
                                _context14.next = 5;
                                break;
                              }
                              message = errors.q.ERROR_RN_MIC_ACCESS_DENIED_OR_DISMISSED.message;
                              _context14.next = 13;
                              break;
                            case 5:
                              if (!(_t14.name === "DOMException")) {
                                _context14.next = 6;
                                break;
                              }
                              message = errors.q.ERROR_RN_MIC_NOT_FOUND.message;
                              _context14.next = 13;
                              break;
                            case 6:
                              if (!(_t14 instanceof DOMException)) {
                                _context14.next = 12;
                                break;
                              }
                              _t15 = _t14.name;
                              _context14.next = _t15 === "NotAllowedError" ? 7 : _t15 === "NotReadableError" ? 8 : _t15 === "NotFoundError" ? 9 : 10;
                              break;
                            case 7:
                              message = handleNotAllowedError(_t14, "audio");
                              return _context14.abrupt("continue", 11);
                            case 8:
                              message = handleNotReadableError(_t14, "audio");
                              return _context14.abrupt("continue", 11);
                            case 9:
                              message = errors.q.ERROR_MICROPHONE_NOT_FOUND.message;
                              if (navigator && navigator.userAgent) {
                                if (navigator.userAgent.indexOf("Firefox") != -1) {
                                  message = errors.q.ERROR_MICROPHONE_PERMISSION_DENIED_BY_OS.message;
                                }
                              }
                              return _context14.abrupt("continue", 11);
                            case 10:
                              message = _t14.message;
                              return _context14.abrupt("continue", 11);
                            case 11:
                              _context14.next = 13;
                              break;
                            case 12:
                              if (_t14.message == "getUserMedia is not implemented in this browser") {
                                sdkError = errors.q.ERROR_MICROPHONE_ACCESS_UNAVAILABLE;
                                message = sdkError.message;
                              } else {
                                message = _t14.message;
                              }
                            case 13:
                              console.error("An error occurred in creating audio track, ".concat(message));
                              return _context14.abrupt("return", null);
                            case 14:
                            case "end":
                              return _context14.stop();
                          }
                        }, _callee13, this, [[2, 4]]);
                      }));
                      function createMicrophoneAudioTrack3(_x9) {
                        return _createMicrophoneAudioTrack.apply(this, arguments);
                      }
                      return createMicrophoneAudioTrack3;
                    }()
                  }]);
                }();
                (0, defineProperty.A)(VideoSDK2, "devices", []);
                (0, defineProperty.A)(VideoSDK2, "eventEmitter", new events2());
                (0, defineProperty.A)(VideoSDK2, "Constants", {
                  errors: errors.s,
                  recordingEvents,
                  livestreamEvents,
                  characterState: CharacterState,
                  characterMode: CharacterMode,
                  hlsEvents: hlsEvents.V,
                  transcriptionEvents,
                  translationEvents,
                  modes: modes.nI,
                  permission: Permission,
                  reliabilityMode: reliabilityModes.y,
                  leaveReason: LeaveReason.E
                });
                function handleNotAllowedError(error, mediaType) {
                  var err = {};
                  if (error.message === "Permission denied" || error.message === "Permission dismissed") {
                    err = mediaType === "video" ? errors.q.ERROR_CAMERA_ACCESS_DENIED_OR_DISMISSED : errors.q.ERROR_MICROPHONE_ACCESS_DENIED_OR_DISMISSED;
                  } else if (error.message.includes("The request is not allowed by the user agent")) {
                    err = mediaType === "video" ? errors.q.ERROR_CAMERA_PERMISSION_OR_AUTOPLAY_ISSUE : errors.q.ERROR_MICROPHONE_ACCESS_DENIED_OR_DISMISSED;
                  } else if (error.message === "Permission denied by system") {
                    err = mediaType === "video" ? errors.q.ERROR_CAMERA_PERMISSION_DENIED_BY_OS : errors.q.ERROR_MICROPHONE_PERMISSION_DENIED_BY_OS;
                  } else {
                    err = mediaType === "video" ? errors.q.ERROR_GET_VIDEO_MEDIA_PERMISSION_DENIED : errors.q.ERROR_GET_AUDIO_MEDIA_PERMISSION_DENIED;
                  }
                  return err.message;
                }
                function handleNotReadableError(error, mediaType) {
                  var err = {};
                  if (error.message === "Device in use") {
                    err = mediaType === "video" ? errors.q.ERROR_CAMERA_IN_USE : errors.q.ERROR_MICROPHONE_IN_USE;
                  } else {
                    err = mediaType === "video" ? errors.q.ERROR_VIDEO_SOURCE_INITIATION_FAILED : errors.q.ERROR_MICROPHONE_IN_USE;
                  }
                  return err.message;
                }
                var ZujoSDK = VideoSDK2;
              }
            ),
            /***/
            3128: (
              /***/
              function(module2, exports2, __webpack_require__2) {
                ;
                (function(root, factory, undef) {
                  if (true) {
                    module2.exports = exports2 = factory(__webpack_require__2(9021), __webpack_require__2(754), __webpack_require__2(4636), __webpack_require__2(9506), __webpack_require__2(7165));
                  } else {
                  }
                })(this, function(CryptoJS) {
                  (function() {
                    var C = CryptoJS;
                    var C_lib = C.lib;
                    var BlockCipher = C_lib.BlockCipher;
                    var C_algo = C.algo;
                    const N = 16;
                    const ORIG_P = [
                      608135816,
                      2242054355,
                      320440878,
                      57701188,
                      2752067618,
                      698298832,
                      137296536,
                      3964562569,
                      1160258022,
                      953160567,
                      3193202383,
                      887688300,
                      3232508343,
                      3380367581,
                      1065670069,
                      3041331479,
                      2450970073,
                      2306472731
                    ];
                    const ORIG_S = [
                      [
                        3509652390,
                        2564797868,
                        805139163,
                        3491422135,
                        3101798381,
                        1780907670,
                        3128725573,
                        4046225305,
                        614570311,
                        3012652279,
                        134345442,
                        2240740374,
                        1667834072,
                        1901547113,
                        2757295779,
                        4103290238,
                        227898511,
                        1921955416,
                        1904987480,
                        2182433518,
                        2069144605,
                        3260701109,
                        2620446009,
                        720527379,
                        3318853667,
                        677414384,
                        3393288472,
                        3101374703,
                        2390351024,
                        1614419982,
                        1822297739,
                        2954791486,
                        3608508353,
                        3174124327,
                        2024746970,
                        1432378464,
                        3864339955,
                        2857741204,
                        1464375394,
                        1676153920,
                        1439316330,
                        715854006,
                        3033291828,
                        289532110,
                        2706671279,
                        2087905683,
                        3018724369,
                        1668267050,
                        732546397,
                        1947742710,
                        3462151702,
                        2609353502,
                        2950085171,
                        1814351708,
                        2050118529,
                        680887927,
                        999245976,
                        1800124847,
                        3300911131,
                        1713906067,
                        1641548236,
                        4213287313,
                        1216130144,
                        1575780402,
                        4018429277,
                        3917837745,
                        3693486850,
                        3949271944,
                        596196993,
                        3549867205,
                        258830323,
                        2213823033,
                        772490370,
                        2760122372,
                        1774776394,
                        2652871518,
                        566650946,
                        4142492826,
                        1728879713,
                        2882767088,
                        1783734482,
                        3629395816,
                        2517608232,
                        2874225571,
                        1861159788,
                        326777828,
                        3124490320,
                        2130389656,
                        2716951837,
                        967770486,
                        1724537150,
                        2185432712,
                        2364442137,
                        1164943284,
                        2105845187,
                        998989502,
                        3765401048,
                        2244026483,
                        1075463327,
                        1455516326,
                        1322494562,
                        910128902,
                        469688178,
                        1117454909,
                        936433444,
                        3490320968,
                        3675253459,
                        1240580251,
                        122909385,
                        2157517691,
                        634681816,
                        4142456567,
                        3825094682,
                        3061402683,
                        2540495037,
                        79693498,
                        3249098678,
                        1084186820,
                        1583128258,
                        426386531,
                        1761308591,
                        1047286709,
                        322548459,
                        995290223,
                        1845252383,
                        2603652396,
                        3431023940,
                        2942221577,
                        3202600964,
                        3727903485,
                        1712269319,
                        422464435,
                        3234572375,
                        1170764815,
                        3523960633,
                        3117677531,
                        1434042557,
                        442511882,
                        3600875718,
                        1076654713,
                        1738483198,
                        4213154764,
                        2393238008,
                        3677496056,
                        1014306527,
                        4251020053,
                        793779912,
                        2902807211,
                        842905082,
                        4246964064,
                        1395751752,
                        1040244610,
                        2656851899,
                        3396308128,
                        445077038,
                        3742853595,
                        3577915638,
                        679411651,
                        2892444358,
                        2354009459,
                        1767581616,
                        3150600392,
                        3791627101,
                        3102740896,
                        284835224,
                        4246832056,
                        1258075500,
                        768725851,
                        2589189241,
                        3069724005,
                        3532540348,
                        1274779536,
                        3789419226,
                        2764799539,
                        1660621633,
                        3471099624,
                        4011903706,
                        913787905,
                        3497959166,
                        737222580,
                        2514213453,
                        2928710040,
                        3937242737,
                        1804850592,
                        3499020752,
                        2949064160,
                        2386320175,
                        2390070455,
                        2415321851,
                        4061277028,
                        2290661394,
                        2416832540,
                        1336762016,
                        1754252060,
                        3520065937,
                        3014181293,
                        791618072,
                        3188594551,
                        3933548030,
                        2332172193,
                        3852520463,
                        3043980520,
                        413987798,
                        3465142937,
                        3030929376,
                        4245938359,
                        2093235073,
                        3534596313,
                        375366246,
                        2157278981,
                        2479649556,
                        555357303,
                        3870105701,
                        2008414854,
                        3344188149,
                        4221384143,
                        3956125452,
                        2067696032,
                        3594591187,
                        2921233993,
                        2428461,
                        544322398,
                        577241275,
                        1471733935,
                        610547355,
                        4027169054,
                        1432588573,
                        1507829418,
                        2025931657,
                        3646575487,
                        545086370,
                        48609733,
                        2200306550,
                        1653985193,
                        298326376,
                        1316178497,
                        3007786442,
                        2064951626,
                        458293330,
                        2589141269,
                        3591329599,
                        3164325604,
                        727753846,
                        2179363840,
                        146436021,
                        1461446943,
                        4069977195,
                        705550613,
                        3059967265,
                        3887724982,
                        4281599278,
                        3313849956,
                        1404054877,
                        2845806497,
                        146425753,
                        1854211946
                      ],
                      [
                        1266315497,
                        3048417604,
                        3681880366,
                        3289982499,
                        290971e4,
                        1235738493,
                        2632868024,
                        2414719590,
                        3970600049,
                        1771706367,
                        1449415276,
                        3266420449,
                        422970021,
                        1963543593,
                        2690192192,
                        3826793022,
                        1062508698,
                        1531092325,
                        1804592342,
                        2583117782,
                        2714934279,
                        4024971509,
                        1294809318,
                        4028980673,
                        1289560198,
                        2221992742,
                        1669523910,
                        35572830,
                        157838143,
                        1052438473,
                        1016535060,
                        1802137761,
                        1753167236,
                        1386275462,
                        3080475397,
                        2857371447,
                        1040679964,
                        2145300060,
                        2390574316,
                        1461121720,
                        2956646967,
                        4031777805,
                        4028374788,
                        33600511,
                        2920084762,
                        1018524850,
                        629373528,
                        3691585981,
                        3515945977,
                        2091462646,
                        2486323059,
                        586499841,
                        988145025,
                        935516892,
                        3367335476,
                        2599673255,
                        2839830854,
                        265290510,
                        3972581182,
                        2759138881,
                        3795373465,
                        1005194799,
                        847297441,
                        406762289,
                        1314163512,
                        1332590856,
                        1866599683,
                        4127851711,
                        750260880,
                        613907577,
                        1450815602,
                        3165620655,
                        3734664991,
                        3650291728,
                        3012275730,
                        3704569646,
                        1427272223,
                        778793252,
                        1343938022,
                        2676280711,
                        2052605720,
                        1946737175,
                        3164576444,
                        3914038668,
                        3967478842,
                        3682934266,
                        1661551462,
                        3294938066,
                        4011595847,
                        840292616,
                        3712170807,
                        616741398,
                        312560963,
                        711312465,
                        1351876610,
                        322626781,
                        1910503582,
                        271666773,
                        2175563734,
                        1594956187,
                        70604529,
                        3617834859,
                        1007753275,
                        1495573769,
                        4069517037,
                        2549218298,
                        2663038764,
                        504708206,
                        2263041392,
                        3941167025,
                        2249088522,
                        1514023603,
                        1998579484,
                        1312622330,
                        694541497,
                        2582060303,
                        2151582166,
                        1382467621,
                        776784248,
                        2618340202,
                        3323268794,
                        2497899128,
                        2784771155,
                        503983604,
                        4076293799,
                        907881277,
                        423175695,
                        432175456,
                        1378068232,
                        4145222326,
                        3954048622,
                        3938656102,
                        3820766613,
                        2793130115,
                        2977904593,
                        26017576,
                        3274890735,
                        3194772133,
                        1700274565,
                        1756076034,
                        4006520079,
                        3677328699,
                        720338349,
                        1533947780,
                        354530856,
                        688349552,
                        3973924725,
                        1637815568,
                        332179504,
                        3949051286,
                        53804574,
                        2852348879,
                        3044236432,
                        1282449977,
                        3583942155,
                        3416972820,
                        4006381244,
                        1617046695,
                        2628476075,
                        3002303598,
                        1686838959,
                        431878346,
                        2686675385,
                        1700445008,
                        1080580658,
                        1009431731,
                        832498133,
                        3223435511,
                        2605976345,
                        2271191193,
                        2516031870,
                        1648197032,
                        4164389018,
                        2548247927,
                        300782431,
                        375919233,
                        238389289,
                        3353747414,
                        2531188641,
                        2019080857,
                        1475708069,
                        455242339,
                        2609103871,
                        448939670,
                        3451063019,
                        1395535956,
                        2413381860,
                        1841049896,
                        1491858159,
                        885456874,
                        4264095073,
                        4001119347,
                        1565136089,
                        3898914787,
                        1108368660,
                        540939232,
                        1173283510,
                        2745871338,
                        3681308437,
                        4207628240,
                        3343053890,
                        4016749493,
                        1699691293,
                        1103962373,
                        3625875870,
                        2256883143,
                        3830138730,
                        1031889488,
                        3479347698,
                        1535977030,
                        4236805024,
                        3251091107,
                        2132092099,
                        1774941330,
                        1199868427,
                        1452454533,
                        157007616,
                        2904115357,
                        342012276,
                        595725824,
                        1480756522,
                        206960106,
                        497939518,
                        591360097,
                        863170706,
                        2375253569,
                        3596610801,
                        1814182875,
                        2094937945,
                        3421402208,
                        1082520231,
                        3463918190,
                        2785509508,
                        435703966,
                        3908032597,
                        1641649973,
                        2842273706,
                        3305899714,
                        1510255612,
                        2148256476,
                        2655287854,
                        3276092548,
                        4258621189,
                        236887753,
                        3681803219,
                        274041037,
                        1734335097,
                        3815195456,
                        3317970021,
                        1899903192,
                        1026095262,
                        4050517792,
                        356393447,
                        2410691914,
                        3873677099,
                        3682840055
                      ],
                      [
                        3913112168,
                        2491498743,
                        4132185628,
                        2489919796,
                        1091903735,
                        1979897079,
                        3170134830,
                        3567386728,
                        3557303409,
                        857797738,
                        1136121015,
                        1342202287,
                        507115054,
                        2535736646,
                        337727348,
                        3213592640,
                        1301675037,
                        2528481711,
                        1895095763,
                        1721773893,
                        3216771564,
                        62756741,
                        2142006736,
                        835421444,
                        2531993523,
                        1442658625,
                        3659876326,
                        2882144922,
                        676362277,
                        1392781812,
                        170690266,
                        3921047035,
                        1759253602,
                        3611846912,
                        1745797284,
                        664899054,
                        1329594018,
                        3901205900,
                        3045908486,
                        2062866102,
                        2865634940,
                        3543621612,
                        3464012697,
                        1080764994,
                        553557557,
                        3656615353,
                        3996768171,
                        991055499,
                        499776247,
                        1265440854,
                        648242737,
                        3940784050,
                        980351604,
                        3713745714,
                        1749149687,
                        3396870395,
                        4211799374,
                        3640570775,
                        1161844396,
                        3125318951,
                        1431517754,
                        545492359,
                        4268468663,
                        3499529547,
                        1437099964,
                        2702547544,
                        3433638243,
                        2581715763,
                        2787789398,
                        1060185593,
                        1593081372,
                        2418618748,
                        4260947970,
                        69676912,
                        2159744348,
                        86519011,
                        2512459080,
                        3838209314,
                        1220612927,
                        3339683548,
                        133810670,
                        1090789135,
                        1078426020,
                        1569222167,
                        845107691,
                        3583754449,
                        4072456591,
                        1091646820,
                        628848692,
                        1613405280,
                        3757631651,
                        526609435,
                        236106946,
                        48312990,
                        2942717905,
                        3402727701,
                        1797494240,
                        859738849,
                        992217954,
                        4005476642,
                        2243076622,
                        3870952857,
                        3732016268,
                        765654824,
                        3490871365,
                        2511836413,
                        1685915746,
                        3888969200,
                        1414112111,
                        2273134842,
                        3281911079,
                        4080962846,
                        172450625,
                        2569994100,
                        980381355,
                        4109958455,
                        2819808352,
                        2716589560,
                        2568741196,
                        3681446669,
                        3329971472,
                        1835478071,
                        660984891,
                        3704678404,
                        4045999559,
                        3422617507,
                        3040415634,
                        1762651403,
                        1719377915,
                        3470491036,
                        2693910283,
                        3642056355,
                        3138596744,
                        1364962596,
                        2073328063,
                        1983633131,
                        926494387,
                        3423689081,
                        2150032023,
                        4096667949,
                        1749200295,
                        3328846651,
                        309677260,
                        2016342300,
                        1779581495,
                        3079819751,
                        111262694,
                        1274766160,
                        443224088,
                        298511866,
                        1025883608,
                        3806446537,
                        1145181785,
                        168956806,
                        3641502830,
                        3584813610,
                        1689216846,
                        3666258015,
                        3200248200,
                        1692713982,
                        2646376535,
                        4042768518,
                        1618508792,
                        1610833997,
                        3523052358,
                        4130873264,
                        2001055236,
                        3610705100,
                        2202168115,
                        4028541809,
                        2961195399,
                        1006657119,
                        2006996926,
                        3186142756,
                        1430667929,
                        3210227297,
                        1314452623,
                        4074634658,
                        4101304120,
                        2273951170,
                        1399257539,
                        3367210612,
                        3027628629,
                        1190975929,
                        2062231137,
                        2333990788,
                        2221543033,
                        2438960610,
                        1181637006,
                        548689776,
                        2362791313,
                        3372408396,
                        3104550113,
                        3145860560,
                        296247880,
                        1970579870,
                        3078560182,
                        3769228297,
                        1714227617,
                        3291629107,
                        3898220290,
                        166772364,
                        1251581989,
                        493813264,
                        448347421,
                        195405023,
                        2709975567,
                        677966185,
                        3703036547,
                        1463355134,
                        2715995803,
                        1338867538,
                        1343315457,
                        2802222074,
                        2684532164,
                        233230375,
                        2599980071,
                        2000651841,
                        3277868038,
                        1638401717,
                        4028070440,
                        3237316320,
                        6314154,
                        819756386,
                        300326615,
                        590932579,
                        1405279636,
                        3267499572,
                        3150704214,
                        2428286686,
                        3959192993,
                        3461946742,
                        1862657033,
                        1266418056,
                        963775037,
                        2089974820,
                        2263052895,
                        1917689273,
                        448879540,
                        3550394620,
                        3981727096,
                        150775221,
                        3627908307,
                        1303187396,
                        508620638,
                        2975983352,
                        2726630617,
                        1817252668,
                        1876281319,
                        1457606340,
                        908771278,
                        3720792119,
                        3617206836,
                        2455994898,
                        1729034894,
                        1080033504
                      ],
                      [
                        976866871,
                        3556439503,
                        2881648439,
                        1522871579,
                        1555064734,
                        1336096578,
                        3548522304,
                        2579274686,
                        3574697629,
                        3205460757,
                        3593280638,
                        3338716283,
                        3079412587,
                        564236357,
                        2993598910,
                        1781952180,
                        1464380207,
                        3163844217,
                        3332601554,
                        1699332808,
                        1393555694,
                        1183702653,
                        3581086237,
                        1288719814,
                        691649499,
                        2847557200,
                        2895455976,
                        3193889540,
                        2717570544,
                        1781354906,
                        1676643554,
                        2592534050,
                        3230253752,
                        1126444790,
                        2770207658,
                        2633158820,
                        2210423226,
                        2615765581,
                        2414155088,
                        3127139286,
                        673620729,
                        2805611233,
                        1269405062,
                        4015350505,
                        3341807571,
                        4149409754,
                        1057255273,
                        2012875353,
                        2162469141,
                        2276492801,
                        2601117357,
                        993977747,
                        3918593370,
                        2654263191,
                        753973209,
                        36408145,
                        2530585658,
                        25011837,
                        3520020182,
                        2088578344,
                        530523599,
                        2918365339,
                        1524020338,
                        1518925132,
                        3760827505,
                        3759777254,
                        1202760957,
                        3985898139,
                        3906192525,
                        674977740,
                        4174734889,
                        2031300136,
                        2019492241,
                        3983892565,
                        4153806404,
                        3822280332,
                        352677332,
                        2297720250,
                        60907813,
                        90501309,
                        3286998549,
                        1016092578,
                        2535922412,
                        2839152426,
                        457141659,
                        509813237,
                        4120667899,
                        652014361,
                        1966332200,
                        2975202805,
                        55981186,
                        2327461051,
                        676427537,
                        3255491064,
                        2882294119,
                        3433927263,
                        1307055953,
                        942726286,
                        933058658,
                        2468411793,
                        3933900994,
                        4215176142,
                        1361170020,
                        2001714738,
                        2830558078,
                        3274259782,
                        1222529897,
                        1679025792,
                        2729314320,
                        3714953764,
                        1770335741,
                        151462246,
                        3013232138,
                        1682292957,
                        1483529935,
                        471910574,
                        1539241949,
                        458788160,
                        3436315007,
                        1807016891,
                        3718408830,
                        978976581,
                        1043663428,
                        3165965781,
                        1927990952,
                        4200891579,
                        2372276910,
                        3208408903,
                        3533431907,
                        1412390302,
                        2931980059,
                        4132332400,
                        1947078029,
                        3881505623,
                        4168226417,
                        2941484381,
                        1077988104,
                        1320477388,
                        886195818,
                        18198404,
                        3786409e3,
                        2509781533,
                        112762804,
                        3463356488,
                        1866414978,
                        891333506,
                        18488651,
                        661792760,
                        1628790961,
                        3885187036,
                        3141171499,
                        876946877,
                        2693282273,
                        1372485963,
                        791857591,
                        2686433993,
                        3759982718,
                        3167212022,
                        3472953795,
                        2716379847,
                        445679433,
                        3561995674,
                        3504004811,
                        3574258232,
                        54117162,
                        3331405415,
                        2381918588,
                        3769707343,
                        4154350007,
                        1140177722,
                        4074052095,
                        668550556,
                        3214352940,
                        367459370,
                        261225585,
                        2610173221,
                        4209349473,
                        3468074219,
                        3265815641,
                        314222801,
                        3066103646,
                        3808782860,
                        282218597,
                        3406013506,
                        3773591054,
                        379116347,
                        1285071038,
                        846784868,
                        2669647154,
                        3771962079,
                        3550491691,
                        2305946142,
                        453669953,
                        1268987020,
                        3317592352,
                        3279303384,
                        3744833421,
                        2610507566,
                        3859509063,
                        266596637,
                        3847019092,
                        517658769,
                        3462560207,
                        3443424879,
                        370717030,
                        4247526661,
                        2224018117,
                        4143653529,
                        4112773975,
                        2788324899,
                        2477274417,
                        1456262402,
                        2901442914,
                        1517677493,
                        1846949527,
                        2295493580,
                        3734397586,
                        2176403920,
                        1280348187,
                        1908823572,
                        3871786941,
                        846861322,
                        1172426758,
                        3287448474,
                        3383383037,
                        1655181056,
                        3139813346,
                        901632758,
                        1897031941,
                        2986607138,
                        3066810236,
                        3447102507,
                        1393639104,
                        373351379,
                        950779232,
                        625454576,
                        3124240540,
                        4148612726,
                        2007998917,
                        544563296,
                        2244738638,
                        2330496472,
                        2058025392,
                        1291430526,
                        424198748,
                        50039436,
                        29584100,
                        3605783033,
                        2429876329,
                        2791104160,
                        1057563949,
                        3255363231,
                        3075367218,
                        3463963227,
                        1469046755,
                        985887462
                      ]
                    ];
                    var BLOWFISH_CTX = {
                      pbox: [],
                      sbox: []
                    };
                    function F(ctx, x) {
                      let a = x >> 24 & 255;
                      let b = x >> 16 & 255;
                      let c = x >> 8 & 255;
                      let d = x & 255;
                      let y = ctx.sbox[0][a] + ctx.sbox[1][b];
                      y = y ^ ctx.sbox[2][c];
                      y = y + ctx.sbox[3][d];
                      return y;
                    }
                    function BlowFish_Encrypt(ctx, left, right) {
                      let Xl = left;
                      let Xr = right;
                      let temp;
                      for (let i = 0; i < N; ++i) {
                        Xl = Xl ^ ctx.pbox[i];
                        Xr = F(ctx, Xl) ^ Xr;
                        temp = Xl;
                        Xl = Xr;
                        Xr = temp;
                      }
                      temp = Xl;
                      Xl = Xr;
                      Xr = temp;
                      Xr = Xr ^ ctx.pbox[N];
                      Xl = Xl ^ ctx.pbox[N + 1];
                      return { left: Xl, right: Xr };
                    }
                    function BlowFish_Decrypt(ctx, left, right) {
                      let Xl = left;
                      let Xr = right;
                      let temp;
                      for (let i = N + 1; i > 1; --i) {
                        Xl = Xl ^ ctx.pbox[i];
                        Xr = F(ctx, Xl) ^ Xr;
                        temp = Xl;
                        Xl = Xr;
                        Xr = temp;
                      }
                      temp = Xl;
                      Xl = Xr;
                      Xr = temp;
                      Xr = Xr ^ ctx.pbox[1];
                      Xl = Xl ^ ctx.pbox[0];
                      return { left: Xl, right: Xr };
                    }
                    function BlowFishInit(ctx, key, keysize) {
                      for (let Row = 0; Row < 4; Row++) {
                        ctx.sbox[Row] = [];
                        for (let Col = 0; Col < 256; Col++) {
                          ctx.sbox[Row][Col] = ORIG_S[Row][Col];
                        }
                      }
                      let keyIndex = 0;
                      for (let index = 0; index < N + 2; index++) {
                        ctx.pbox[index] = ORIG_P[index] ^ key[keyIndex];
                        keyIndex++;
                        if (keyIndex >= keysize) {
                          keyIndex = 0;
                        }
                      }
                      let Data1 = 0;
                      let Data2 = 0;
                      let res = 0;
                      for (let i = 0; i < N + 2; i += 2) {
                        res = BlowFish_Encrypt(ctx, Data1, Data2);
                        Data1 = res.left;
                        Data2 = res.right;
                        ctx.pbox[i] = Data1;
                        ctx.pbox[i + 1] = Data2;
                      }
                      for (let i = 0; i < 4; i++) {
                        for (let j = 0; j < 256; j += 2) {
                          res = BlowFish_Encrypt(ctx, Data1, Data2);
                          Data1 = res.left;
                          Data2 = res.right;
                          ctx.sbox[i][j] = Data1;
                          ctx.sbox[i][j + 1] = Data2;
                        }
                      }
                      return true;
                    }
                    var Blowfish = C_algo.Blowfish = BlockCipher.extend({
                      _doReset: function() {
                        if (this._keyPriorReset === this._key) {
                          return;
                        }
                        var key = this._keyPriorReset = this._key;
                        var keyWords = key.words;
                        var keySize = key.sigBytes / 4;
                        BlowFishInit(BLOWFISH_CTX, keyWords, keySize);
                      },
                      encryptBlock: function(M, offset) {
                        var res = BlowFish_Encrypt(BLOWFISH_CTX, M[offset], M[offset + 1]);
                        M[offset] = res.left;
                        M[offset + 1] = res.right;
                      },
                      decryptBlock: function(M, offset) {
                        var res = BlowFish_Decrypt(BLOWFISH_CTX, M[offset], M[offset + 1]);
                        M[offset] = res.left;
                        M[offset + 1] = res.right;
                      },
                      blockSize: 64 / 32,
                      keySize: 128 / 32,
                      ivSize: 64 / 32
                    });
                    C.Blowfish = BlockCipher._createHelper(Blowfish);
                  })();
                  return CryptoJS.Blowfish;
                });
              }
            ),
            /***/
            3145: (
              /***/
              (__unused_webpack___webpack_module__, __webpack_exports__2, __webpack_require__2) => {
                "use strict";
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  A: () => (
                    /* binding */
                    _arrayLikeToArray2
                  )
                  /* harmony export */
                });
                function _arrayLikeToArray2(r, a) {
                  (null == a || a > r.length) && (a = r.length);
                  for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];
                  return n;
                }
              }
            ),
            /***/
            3200: (
              /***/
              (__unused_webpack_module, exports2, __webpack_require__2) => {
                "use strict";
                Object.defineProperty(exports2, "__esModule", { value: true });
                exports2.ProfileLevelId = exports2.Level = exports2.Profile = void 0;
                exports2.parseProfileLevelId = parseProfileLevelId;
                exports2.profileLevelIdToString = profileLevelIdToString;
                exports2.profileToString = profileToString;
                exports2.levelToString = levelToString;
                exports2.parseSdpProfileLevelId = parseSdpProfileLevelId;
                exports2.isSameProfile = isSameProfile;
                exports2.isSameProfileAndLevel = isSameProfileAndLevel;
                exports2.generateProfileLevelIdStringForAnswer = generateProfileLevelIdStringForAnswer;
                exports2.supportedLevel = supportedLevel;
                const Logger_1 = __webpack_require__2(3582);
                const logger = new Logger_1.Logger();
                var Profile;
                (function(Profile2) {
                  Profile2[Profile2["ConstrainedBaseline"] = 1] = "ConstrainedBaseline";
                  Profile2[Profile2["Baseline"] = 2] = "Baseline";
                  Profile2[Profile2["Main"] = 3] = "Main";
                  Profile2[Profile2["ConstrainedHigh"] = 4] = "ConstrainedHigh";
                  Profile2[Profile2["High"] = 5] = "High";
                  Profile2[Profile2["PredictiveHigh444"] = 6] = "PredictiveHigh444";
                })(Profile || (exports2.Profile = Profile = {}));
                var Level;
                (function(Level2) {
                  Level2[Level2["L1_b"] = 0] = "L1_b";
                  Level2[Level2["L1"] = 10] = "L1";
                  Level2[Level2["L1_1"] = 11] = "L1_1";
                  Level2[Level2["L1_2"] = 12] = "L1_2";
                  Level2[Level2["L1_3"] = 13] = "L1_3";
                  Level2[Level2["L2"] = 20] = "L2";
                  Level2[Level2["L2_1"] = 21] = "L2_1";
                  Level2[Level2["L2_2"] = 22] = "L2_2";
                  Level2[Level2["L3"] = 30] = "L3";
                  Level2[Level2["L3_1"] = 31] = "L3_1";
                  Level2[Level2["L3_2"] = 32] = "L3_2";
                  Level2[Level2["L4"] = 40] = "L4";
                  Level2[Level2["L4_1"] = 41] = "L4_1";
                  Level2[Level2["L4_2"] = 42] = "L4_2";
                  Level2[Level2["L5"] = 50] = "L5";
                  Level2[Level2["L5_1"] = 51] = "L5_1";
                  Level2[Level2["L5_2"] = 52] = "L5_2";
                })(Level || (exports2.Level = Level = {}));
                class ProfileLevelId {
                  constructor(profile, level) {
                    __publicField(this, "profile");
                    __publicField(this, "level");
                    this.profile = profile;
                    this.level = level;
                  }
                }
                exports2.ProfileLevelId = ProfileLevelId;
                const DefaultProfileLevelId = new ProfileLevelId(Profile.ConstrainedBaseline, Level.L3_1);
                class BitPattern {
                  constructor(str) {
                    __publicField(this, "mask");
                    __publicField(this, "masked_value");
                    this.mask = ~byteMaskString("x", str);
                    this.masked_value = byteMaskString("1", str);
                  }
                  isMatch(value) {
                    return this.masked_value === (value & this.mask);
                  }
                }
                class ProfilePattern {
                  constructor(profile_idc, profile_iop, profile) {
                    __publicField(this, "profile_idc");
                    __publicField(this, "profile_iop");
                    __publicField(this, "profile");
                    this.profile_idc = profile_idc;
                    this.profile_iop = profile_iop;
                    this.profile = profile;
                  }
                }
                const ProfilePatterns = [
                  new ProfilePattern(66, new BitPattern("x1xx0000"), Profile.ConstrainedBaseline),
                  new ProfilePattern(77, new BitPattern("1xxx0000"), Profile.ConstrainedBaseline),
                  new ProfilePattern(88, new BitPattern("11xx0000"), Profile.ConstrainedBaseline),
                  new ProfilePattern(66, new BitPattern("x0xx0000"), Profile.Baseline),
                  new ProfilePattern(88, new BitPattern("10xx0000"), Profile.Baseline),
                  new ProfilePattern(77, new BitPattern("0x0x0000"), Profile.Main),
                  new ProfilePattern(100, new BitPattern("00000000"), Profile.High),
                  new ProfilePattern(100, new BitPattern("00001100"), Profile.ConstrainedHigh),
                  new ProfilePattern(244, new BitPattern("00000000"), Profile.PredictiveHigh444)
                ];
                const LevelConstraints = [
                  {
                    max_macroblocks_per_second: 1485,
                    max_macroblock_frame_size: 99,
                    level: Level.L1
                  },
                  {
                    max_macroblocks_per_second: 1485,
                    max_macroblock_frame_size: 99,
                    level: Level.L1_b
                  },
                  {
                    max_macroblocks_per_second: 3e3,
                    max_macroblock_frame_size: 396,
                    level: Level.L1_1
                  },
                  {
                    max_macroblocks_per_second: 6e3,
                    max_macroblock_frame_size: 396,
                    level: Level.L1_2
                  },
                  {
                    max_macroblocks_per_second: 11880,
                    max_macroblock_frame_size: 396,
                    level: Level.L1_3
                  },
                  {
                    max_macroblocks_per_second: 11880,
                    max_macroblock_frame_size: 396,
                    level: Level.L2
                  },
                  {
                    max_macroblocks_per_second: 19800,
                    max_macroblock_frame_size: 792,
                    level: Level.L2_1
                  },
                  {
                    max_macroblocks_per_second: 20250,
                    max_macroblock_frame_size: 1620,
                    level: Level.L2_2
                  },
                  {
                    max_macroblocks_per_second: 40500,
                    max_macroblock_frame_size: 1620,
                    level: Level.L3
                  },
                  {
                    max_macroblocks_per_second: 108e3,
                    max_macroblock_frame_size: 3600,
                    level: Level.L3_1
                  },
                  {
                    max_macroblocks_per_second: 216e3,
                    max_macroblock_frame_size: 5120,
                    level: Level.L3_2
                  },
                  {
                    max_macroblocks_per_second: 245760,
                    max_macroblock_frame_size: 8192,
                    level: Level.L4
                  },
                  {
                    max_macroblocks_per_second: 245760,
                    max_macroblock_frame_size: 8192,
                    level: Level.L4_1
                  },
                  {
                    max_macroblocks_per_second: 522240,
                    max_macroblock_frame_size: 8704,
                    level: Level.L4_2
                  },
                  {
                    max_macroblocks_per_second: 589824,
                    max_macroblock_frame_size: 22080,
                    level: Level.L5
                  },
                  {
                    max_macroblocks_per_second: 983040,
                    max_macroblock_frame_size: 36864,
                    level: Level.L5_1
                  },
                  {
                    max_macroblocks_per_second: 2073600,
                    max_macroblock_frame_size: 36864,
                    level: Level.L5_2
                  }
                ];
                function parseProfileLevelId(str) {
                  const ConstraintSet3Flag = 16;
                  if (typeof str !== "string" || str.length !== 6) {
                    return void 0;
                  }
                  const profile_level_id_numeric = parseInt(str, 16);
                  if (profile_level_id_numeric === 0) {
                    return void 0;
                  }
                  const level_idc = profile_level_id_numeric & 255;
                  const profile_iop = profile_level_id_numeric >> 8 & 255;
                  const profile_idc = profile_level_id_numeric >> 16 & 255;
                  let level;
                  switch (level_idc) {
                    case Level.L1_1: {
                      level = (profile_iop & ConstraintSet3Flag) !== 0 ? Level.L1_b : Level.L1_1;
                      break;
                    }
                    case Level.L1:
                    case Level.L1_2:
                    case Level.L1_3:
                    case Level.L2:
                    case Level.L2_1:
                    case Level.L2_2:
                    case Level.L3:
                    case Level.L3_1:
                    case Level.L3_2:
                    case Level.L4:
                    case Level.L4_1:
                    case Level.L4_2:
                    case Level.L5:
                    case Level.L5_1:
                    case Level.L5_2: {
                      level = level_idc;
                      break;
                    }
                    default: {
                      logger.warn(`parseProfileLevelId() | unrecognized level_idc [str:${str}, level_idc:${level_idc}]`);
                      return void 0;
                    }
                  }
                  for (const pattern of ProfilePatterns) {
                    if (profile_idc === pattern.profile_idc && pattern.profile_iop.isMatch(profile_iop)) {
                      logger.debug(`parseProfileLevelId() | result [str:${str}, profile:${pattern.profile}, level:${level}]`);
                      return new ProfileLevelId(pattern.profile, level);
                    }
                  }
                  logger.warn(`parseProfileLevelId() | unrecognized profile_idc/profile_iop combination [str:${str}, profile_idc:${profile_idc}, profile_iop:${profile_iop}]`);
                  return void 0;
                }
                function profileLevelIdToString(profile_level_id) {
                  if (profile_level_id.level == Level.L1_b) {
                    switch (profile_level_id.profile) {
                      case Profile.ConstrainedBaseline: {
                        return "42f00b";
                      }
                      case Profile.Baseline: {
                        return "42100b";
                      }
                      case Profile.Main: {
                        return "4d100b";
                      }
                      default: {
                        logger.warn(`profileLevelIdToString() | Level 1_b not is allowed for profile ${profile_level_id.profile}`);
                        return void 0;
                      }
                    }
                  }
                  let profile_idc_iop_string;
                  switch (profile_level_id.profile) {
                    case Profile.ConstrainedBaseline: {
                      profile_idc_iop_string = "42e0";
                      break;
                    }
                    case Profile.Baseline: {
                      profile_idc_iop_string = "4200";
                      break;
                    }
                    case Profile.Main: {
                      profile_idc_iop_string = "4d00";
                      break;
                    }
                    case Profile.ConstrainedHigh: {
                      profile_idc_iop_string = "640c";
                      break;
                    }
                    case Profile.High: {
                      profile_idc_iop_string = "6400";
                      break;
                    }
                    case Profile.PredictiveHigh444: {
                      profile_idc_iop_string = "f400";
                      break;
                    }
                    default: {
                      logger.warn(`profileLevelIdToString() | unrecognized profile ${profile_level_id.profile}`);
                      return void 0;
                    }
                  }
                  let levelStr = profile_level_id.level.toString(16);
                  if (levelStr.length === 1) {
                    levelStr = `0${levelStr}`;
                  }
                  return `${profile_idc_iop_string}${levelStr}`;
                }
                function profileToString(profile) {
                  switch (profile) {
                    case Profile.ConstrainedBaseline: {
                      return "ConstrainedBaseline";
                    }
                    case Profile.Baseline: {
                      return "Baseline";
                    }
                    case Profile.Main: {
                      return "Main";
                    }
                    case Profile.ConstrainedHigh: {
                      return "ConstrainedHigh";
                    }
                    case Profile.High: {
                      return "High";
                    }
                    case Profile.PredictiveHigh444: {
                      return "PredictiveHigh444";
                    }
                    default: {
                      logger.warn(`profileToString() | unrecognized profile ${profile}`);
                      return void 0;
                    }
                  }
                }
                function levelToString(level) {
                  switch (level) {
                    case Level.L1_b: {
                      return "1b";
                    }
                    case Level.L1: {
                      return "1";
                    }
                    case Level.L1_1: {
                      return "1.1";
                    }
                    case Level.L1_2: {
                      return "1.2";
                    }
                    case Level.L1_3: {
                      return "1.3";
                    }
                    case Level.L2: {
                      return "2";
                    }
                    case Level.L2_1: {
                      return "2.1";
                    }
                    case Level.L2_2: {
                      return "2.2";
                    }
                    case Level.L3: {
                      return "3";
                    }
                    case Level.L3_1: {
                      return "3.1";
                    }
                    case Level.L3_2: {
                      return "3.2";
                    }
                    case Level.L4: {
                      return "4";
                    }
                    case Level.L4_1: {
                      return "4.1";
                    }
                    case Level.L4_2: {
                      return "4.2";
                    }
                    case Level.L5: {
                      return "5";
                    }
                    case Level.L5_1: {
                      return "5.1";
                    }
                    case Level.L5_2: {
                      return "5.2";
                    }
                    default: {
                      logger.warn(`levelToString() | unrecognized level ${level}`);
                      return void 0;
                    }
                  }
                }
                function parseSdpProfileLevelId(params = {}) {
                  const profile_level_id = params["profile-level-id"];
                  return profile_level_id ? parseProfileLevelId(profile_level_id) : DefaultProfileLevelId;
                }
                function isSameProfile(params1 = {}, params2 = {}) {
                  const profile_level_id_1 = parseSdpProfileLevelId(params1);
                  const profile_level_id_2 = parseSdpProfileLevelId(params2);
                  return Boolean(profile_level_id_1 && profile_level_id_2 && profile_level_id_1.profile === profile_level_id_2.profile);
                }
                function isSameProfileAndLevel(params1 = {}, params2 = {}) {
                  const profile_level_id_1 = parseSdpProfileLevelId(params1);
                  const profile_level_id_2 = parseSdpProfileLevelId(params2);
                  return Boolean(profile_level_id_1 && profile_level_id_2 && profile_level_id_1.profile === profile_level_id_2.profile && profile_level_id_1.level == profile_level_id_2.level);
                }
                function generateProfileLevelIdStringForAnswer(local_supported_params = {}, remote_offered_params = {}) {
                  if (!local_supported_params["profile-level-id"] && !remote_offered_params["profile-level-id"]) {
                    logger.warn("generateProfileLevelIdStringForAnswer() | profile-level-id missing in local and remote params");
                    return void 0;
                  }
                  const local_profile_level_id = parseSdpProfileLevelId(local_supported_params);
                  const remote_profile_level_id = parseSdpProfileLevelId(remote_offered_params);
                  if (!local_profile_level_id) {
                    throw new TypeError("invalid local_profile_level_id");
                  }
                  if (!remote_profile_level_id) {
                    throw new TypeError("invalid remote_profile_level_id");
                  }
                  if (local_profile_level_id.profile !== remote_profile_level_id.profile) {
                    throw new TypeError("H264 Profile mismatch");
                  }
                  const level_asymmetry_allowed = isLevelAsymmetryAllowed(local_supported_params) && isLevelAsymmetryAllowed(remote_offered_params);
                  const local_level = local_profile_level_id.level;
                  const remote_level = remote_profile_level_id.level;
                  const min_level = minLevel(local_level, remote_level);
                  const answer_level = level_asymmetry_allowed ? local_level : min_level;
                  logger.debug(`generateProfileLevelIdStringForAnswer() | result [profile:${local_profile_level_id.profile}, level:${answer_level}]`);
                  return profileLevelIdToString(new ProfileLevelId(local_profile_level_id.profile, answer_level));
                }
                function supportedLevel(max_frame_pixel_count, max_fps) {
                  const PixelsPerMacroblock = 16 * 16;
                  for (let i = LevelConstraints.length - 1; i >= 0; --i) {
                    const level_constraint = LevelConstraints[i];
                    if (level_constraint.max_macroblock_frame_size * PixelsPerMacroblock <= max_frame_pixel_count && level_constraint.max_macroblocks_per_second <= max_fps * level_constraint.max_macroblock_frame_size) {
                      logger.debug(`supportedLevel() | result [max_frame_pixel_count:${max_frame_pixel_count}, max_fps:${max_fps}, level:${level_constraint.level}]`);
                      return level_constraint.level;
                    }
                  }
                  logger.warn(`supportedLevel() | no level supported [max_frame_pixel_count:${max_frame_pixel_count}, max_fps:${max_fps}]`);
                  return void 0;
                }
                function byteMaskString(c, str) {
                  return Number(str[0] === c) << 7 | Number(str[1] === c) << 6 | Number(str[2] === c) << 5 | Number(str[3] === c) << 4 | Number(str[4] === c) << 3 | Number(str[5] === c) << 2 | Number(str[6] === c) << 1 | Number(str[7] === c) << 0;
                }
                function isLessLevel(a, b) {
                  if (a === Level.L1_b) {
                    return b !== Level.L1 && b !== Level.L1_b;
                  }
                  if (b === Level.L1_b) {
                    return a !== Level.L1;
                  }
                  return a < b;
                }
                function minLevel(a, b) {
                  return isLessLevel(a, b) ? a : b;
                }
                function isLevelAsymmetryAllowed(params = {}) {
                  const level_asymmetry_allowed = params["level-asymmetry-allowed"];
                  return level_asymmetry_allowed === true || level_asymmetry_allowed === 1 || level_asymmetry_allowed === "1";
                }
              }
            ),
            /***/
            3240: (
              /***/
              function(module2, exports2, __webpack_require__2) {
                ;
                (function(root, factory) {
                  if (true) {
                    module2.exports = exports2 = factory(__webpack_require__2(9021));
                  } else {
                  }
                })(this, function(CryptoJS) {
                  (function(undefined2) {
                    var C = CryptoJS;
                    var C_lib = C.lib;
                    var Base = C_lib.Base;
                    var X32WordArray = C_lib.WordArray;
                    var C_x64 = C.x64 = {};
                    var X64Word = C_x64.Word = Base.extend({
                      /**
                       * Initializes a newly created 64-bit word.
                       *
                       * @param {number} high The high 32 bits.
                       * @param {number} low The low 32 bits.
                       *
                       * @example
                       *
                       *     var x64Word = CryptoJS.x64.Word.create(0x00010203, 0x04050607);
                       */
                      init: function(high, low) {
                        this.high = high;
                        this.low = low;
                      }
                      /**
                       * Bitwise NOTs this word.
                       *
                       * @return {X64Word} A new x64-Word object after negating.
                       *
                       * @example
                       *
                       *     var negated = x64Word.not();
                       */
                      // not: function () {
                      // var high = ~this.high;
                      // var low = ~this.low;
                      // return X64Word.create(high, low);
                      // },
                      /**
                       * Bitwise ANDs this word with the passed word.
                       *
                       * @param {X64Word} word The x64-Word to AND with this word.
                       *
                       * @return {X64Word} A new x64-Word object after ANDing.
                       *
                       * @example
                       *
                       *     var anded = x64Word.and(anotherX64Word);
                       */
                      // and: function (word) {
                      // var high = this.high & word.high;
                      // var low = this.low & word.low;
                      // return X64Word.create(high, low);
                      // },
                      /**
                       * Bitwise ORs this word with the passed word.
                       *
                       * @param {X64Word} word The x64-Word to OR with this word.
                       *
                       * @return {X64Word} A new x64-Word object after ORing.
                       *
                       * @example
                       *
                       *     var ored = x64Word.or(anotherX64Word);
                       */
                      // or: function (word) {
                      // var high = this.high | word.high;
                      // var low = this.low | word.low;
                      // return X64Word.create(high, low);
                      // },
                      /**
                       * Bitwise XORs this word with the passed word.
                       *
                       * @param {X64Word} word The x64-Word to XOR with this word.
                       *
                       * @return {X64Word} A new x64-Word object after XORing.
                       *
                       * @example
                       *
                       *     var xored = x64Word.xor(anotherX64Word);
                       */
                      // xor: function (word) {
                      // var high = this.high ^ word.high;
                      // var low = this.low ^ word.low;
                      // return X64Word.create(high, low);
                      // },
                      /**
                       * Shifts this word n bits to the left.
                       *
                       * @param {number} n The number of bits to shift.
                       *
                       * @return {X64Word} A new x64-Word object after shifting.
                       *
                       * @example
                       *
                       *     var shifted = x64Word.shiftL(25);
                       */
                      // shiftL: function (n) {
                      // if (n < 32) {
                      // var high = (this.high << n) | (this.low >>> (32 - n));
                      // var low = this.low << n;
                      // } else {
                      // var high = this.low << (n - 32);
                      // var low = 0;
                      // }
                      // return X64Word.create(high, low);
                      // },
                      /**
                       * Shifts this word n bits to the right.
                       *
                       * @param {number} n The number of bits to shift.
                       *
                       * @return {X64Word} A new x64-Word object after shifting.
                       *
                       * @example
                       *
                       *     var shifted = x64Word.shiftR(7);
                       */
                      // shiftR: function (n) {
                      // if (n < 32) {
                      // var low = (this.low >>> n) | (this.high << (32 - n));
                      // var high = this.high >>> n;
                      // } else {
                      // var low = this.high >>> (n - 32);
                      // var high = 0;
                      // }
                      // return X64Word.create(high, low);
                      // },
                      /**
                       * Rotates this word n bits to the left.
                       *
                       * @param {number} n The number of bits to rotate.
                       *
                       * @return {X64Word} A new x64-Word object after rotating.
                       *
                       * @example
                       *
                       *     var rotated = x64Word.rotL(25);
                       */
                      // rotL: function (n) {
                      // return this.shiftL(n).or(this.shiftR(64 - n));
                      // },
                      /**
                       * Rotates this word n bits to the right.
                       *
                       * @param {number} n The number of bits to rotate.
                       *
                       * @return {X64Word} A new x64-Word object after rotating.
                       *
                       * @example
                       *
                       *     var rotated = x64Word.rotR(7);
                       */
                      // rotR: function (n) {
                      // return this.shiftR(n).or(this.shiftL(64 - n));
                      // },
                      /**
                       * Adds this word with the passed word.
                       *
                       * @param {X64Word} word The x64-Word to add with this word.
                       *
                       * @return {X64Word} A new x64-Word object after adding.
                       *
                       * @example
                       *
                       *     var added = x64Word.add(anotherX64Word);
                       */
                      // add: function (word) {
                      // var low = (this.low + word.low) | 0;
                      // var carry = (low >>> 0) < (this.low >>> 0) ? 1 : 0;
                      // var high = (this.high + word.high + carry) | 0;
                      // return X64Word.create(high, low);
                      // }
                    });
                    var X64WordArray = C_x64.WordArray = Base.extend({
                      /**
                       * Initializes a newly created word array.
                       *
                       * @param {Array} words (Optional) An array of CryptoJS.x64.Word objects.
                       * @param {number} sigBytes (Optional) The number of significant bytes in the words.
                       *
                       * @example
                       *
                       *     var wordArray = CryptoJS.x64.WordArray.create();
                       *
                       *     var wordArray = CryptoJS.x64.WordArray.create([
                       *         CryptoJS.x64.Word.create(0x00010203, 0x04050607),
                       *         CryptoJS.x64.Word.create(0x18191a1b, 0x1c1d1e1f)
                       *     ]);
                       *
                       *     var wordArray = CryptoJS.x64.WordArray.create([
                       *         CryptoJS.x64.Word.create(0x00010203, 0x04050607),
                       *         CryptoJS.x64.Word.create(0x18191a1b, 0x1c1d1e1f)
                       *     ], 10);
                       */
                      init: function(words, sigBytes) {
                        words = this.words = words || [];
                        if (sigBytes != undefined2) {
                          this.sigBytes = sigBytes;
                        } else {
                          this.sigBytes = words.length * 8;
                        }
                      },
                      /**
                       * Converts this 64-bit word array to a 32-bit word array.
                       *
                       * @return {CryptoJS.lib.WordArray} This word array's data as a 32-bit word array.
                       *
                       * @example
                       *
                       *     var x32WordArray = x64WordArray.toX32();
                       */
                      toX32: function() {
                        var x64Words = this.words;
                        var x64WordsLength = x64Words.length;
                        var x32Words = [];
                        for (var i = 0; i < x64WordsLength; i++) {
                          var x64Word = x64Words[i];
                          x32Words.push(x64Word.high);
                          x32Words.push(x64Word.low);
                        }
                        return X32WordArray.create(x32Words, this.sigBytes);
                      },
                      /**
                       * Creates a copy of this word array.
                       *
                       * @return {X64WordArray} The clone.
                       *
                       * @example
                       *
                       *     var clone = x64WordArray.clone();
                       */
                      clone: function() {
                        var clone = Base.clone.call(this);
                        var words = clone.words = this.words.slice(0);
                        var wordsLength = words.length;
                        for (var i = 0; i < wordsLength; i++) {
                          words[i] = words[i].clone();
                        }
                        return clone;
                      }
                    });
                  })();
                  return CryptoJS;
                });
              }
            ),
            /***/
            3303: (
              /***/
              (__unused_webpack_module, exports2) => {
                "use strict";
                Object.defineProperty(exports2, "__esModule", { value: true });
                exports2.parse = parse;
                const ScalabilityModeRegex = new RegExp("^[LS]([1-9]\\d{0,1})T([1-9]\\d{0,1})");
                function parse(scalabilityMode) {
                  const match = ScalabilityModeRegex.exec(scalabilityMode ?? "");
                  if (match) {
                    return {
                      spatialLayers: Number(match[1]),
                      temporalLayers: Number(match[2])
                    };
                  } else {
                    return {
                      spatialLayers: 1,
                      temporalLayers: 1
                    };
                  }
                }
              }
            ),
            /***/
            3471: (
              /***/
              (__unused_webpack_module, exports2, __webpack_require__2) => {
                "use strict";
                Object.defineProperty(exports2, "__esModule", { value: true });
                exports2.OfferMediaSection = exports2.AnswerMediaSection = exports2.MediaSection = void 0;
                const sdpTransform = __webpack_require__2(7363);
                const utils = __webpack_require__2(1765);
                class MediaSection {
                  constructor({ iceParameters, iceCandidates, dtlsParameters }) {
                    // SDP media object.
                    __publicField(this, "_mediaObject");
                    this._mediaObject = {
                      type: "",
                      port: 0,
                      protocol: "",
                      payloads: "",
                      rtp: [],
                      fmtp: []
                    };
                    if (iceParameters) {
                      this.setIceParameters(iceParameters);
                    }
                    if (iceCandidates) {
                      this._mediaObject.candidates = [];
                      for (const candidate of iceCandidates) {
                        const candidateObject = {
                          foundation: candidate.foundation,
                          // mediasoup does mandates rtcp-mux so candidates component is always
                          // RTP (1).
                          component: 1,
                          // Be ready for new candidate.address field in mediasoup server side
                          // field and keep backward compatibility with deprecated candidate.ip.
                          ip: candidate.address ?? candidate.ip,
                          port: candidate.port,
                          priority: candidate.priority,
                          transport: candidate.protocol,
                          type: candidate.type
                        };
                        if (candidate.tcpType) {
                          candidateObject.tcptype = candidate.tcpType;
                        }
                        this._mediaObject.candidates.push(candidateObject);
                      }
                      this._mediaObject.endOfCandidates = "end-of-candidates";
                      this._mediaObject.iceOptions = "renomination";
                    }
                    if (dtlsParameters) {
                      this.setDtlsRole(dtlsParameters.role);
                    }
                  }
                  get mid() {
                    return String(this._mediaObject.mid);
                  }
                  get closed() {
                    return this._mediaObject.port === 0;
                  }
                  getObject() {
                    return this._mediaObject;
                  }
                  setIceParameters(iceParameters) {
                    this._mediaObject.iceUfrag = iceParameters.usernameFragment;
                    this._mediaObject.icePwd = iceParameters.password;
                  }
                  pause() {
                    this._mediaObject.direction = "inactive";
                  }
                  disable() {
                    this.pause();
                    delete this._mediaObject.ext;
                    delete this._mediaObject.ssrcs;
                    delete this._mediaObject.ssrcGroups;
                    delete this._mediaObject.simulcast;
                    delete this._mediaObject.simulcast_03;
                    delete this._mediaObject.rids;
                    delete this._mediaObject.extmapAllowMixed;
                  }
                  close() {
                    this.disable();
                    this._mediaObject.port = 0;
                  }
                }
                exports2.MediaSection = MediaSection;
                class AnswerMediaSection extends MediaSection {
                  constructor({ iceParameters, iceCandidates, dtlsParameters, sctpParameters, plainRtpParameters, offerMediaObject, offerRtpParameters, answerRtpParameters, codecOptions }) {
                    super({ iceParameters, iceCandidates, dtlsParameters });
                    this._mediaObject.mid = String(offerMediaObject.mid);
                    this._mediaObject.type = offerMediaObject.type;
                    this._mediaObject.protocol = offerMediaObject.protocol;
                    if (!plainRtpParameters) {
                      this._mediaObject.connection = { ip: "127.0.0.1", version: 4 };
                      this._mediaObject.port = 7;
                    } else {
                      this._mediaObject.connection = {
                        ip: plainRtpParameters.ip,
                        version: plainRtpParameters.ipVersion
                      };
                      this._mediaObject.port = plainRtpParameters.port;
                    }
                    switch (offerMediaObject.type) {
                      case "audio":
                      case "video": {
                        this._mediaObject.direction = "recvonly";
                        this._mediaObject.rtp = [];
                        this._mediaObject.rtcpFb = [];
                        this._mediaObject.fmtp = [];
                        for (const codec of answerRtpParameters.codecs) {
                          const rtp = {
                            payload: codec.payloadType,
                            codec: getCodecName(codec),
                            rate: codec.clockRate
                          };
                          if (codec.channels > 1) {
                            rtp.encoding = codec.channels;
                          }
                          this._mediaObject.rtp.push(rtp);
                          const codecParameters = utils.clone(codec.parameters) ?? {};
                          let codecRtcpFeedback = utils.clone(codec.rtcpFeedback) ?? [];
                          if (codecOptions) {
                            const { opusStereo, opusFec, opusDtx, opusMaxPlaybackRate, opusMaxAverageBitrate, opusPtime, opusNack, videoGoogleStartBitrate, videoGoogleMaxBitrate, videoGoogleMinBitrate } = codecOptions;
                            const offerCodec = offerRtpParameters.codecs.find((c) => c.payloadType === codec.payloadType);
                            switch (codec.mimeType.toLowerCase()) {
                              case "audio/opus":
                              case "audio/multiopus": {
                                if (opusStereo !== void 0) {
                                  offerCodec.parameters["sprop-stereo"] = opusStereo ? 1 : 0;
                                  codecParameters["stereo"] = opusStereo ? 1 : 0;
                                }
                                if (opusFec !== void 0) {
                                  offerCodec.parameters["useinbandfec"] = opusFec ? 1 : 0;
                                  codecParameters["useinbandfec"] = opusFec ? 1 : 0;
                                }
                                if (opusDtx !== void 0) {
                                  offerCodec.parameters["usedtx"] = opusDtx ? 1 : 0;
                                  codecParameters["usedtx"] = opusDtx ? 1 : 0;
                                }
                                if (opusMaxPlaybackRate !== void 0) {
                                  codecParameters["maxplaybackrate"] = opusMaxPlaybackRate;
                                }
                                if (opusMaxAverageBitrate !== void 0) {
                                  codecParameters["maxaveragebitrate"] = opusMaxAverageBitrate;
                                }
                                if (opusPtime !== void 0) {
                                  offerCodec.parameters["ptime"] = opusPtime;
                                  codecParameters["ptime"] = opusPtime;
                                }
                                if (!opusNack) {
                                  offerCodec.rtcpFeedback = offerCodec.rtcpFeedback.filter((fb) => fb.type !== "nack" || fb.parameter);
                                  codecRtcpFeedback = codecRtcpFeedback.filter((fb) => fb.type !== "nack" || fb.parameter);
                                }
                                break;
                              }
                              case "video/vp8":
                              case "video/vp9":
                              case "video/h264":
                              case "video/h265":
                              case "video/av1": {
                                if (videoGoogleStartBitrate !== void 0) {
                                  codecParameters["x-google-start-bitrate"] = videoGoogleStartBitrate;
                                }
                                if (videoGoogleMaxBitrate !== void 0) {
                                  codecParameters["x-google-max-bitrate"] = videoGoogleMaxBitrate;
                                }
                                if (videoGoogleMinBitrate !== void 0) {
                                  codecParameters["x-google-min-bitrate"] = videoGoogleMinBitrate;
                                }
                                break;
                              }
                            }
                          }
                          const fmtp = {
                            payload: codec.payloadType,
                            config: ""
                          };
                          for (const key of Object.keys(codecParameters)) {
                            if (fmtp.config) {
                              fmtp.config += ";";
                            }
                            fmtp.config += `${key}=${codecParameters[key]}`;
                          }
                          if (fmtp.config) {
                            this._mediaObject.fmtp.push(fmtp);
                          }
                          for (const fb of codecRtcpFeedback) {
                            this._mediaObject.rtcpFb.push({
                              payload: codec.payloadType,
                              type: fb.type,
                              subtype: fb.parameter
                            });
                          }
                        }
                        this._mediaObject.payloads = answerRtpParameters.codecs.map((codec) => codec.payloadType).join(" ");
                        this._mediaObject.ext = [];
                        for (const ext of answerRtpParameters.headerExtensions) {
                          const found = (offerMediaObject.ext ?? []).some((localExt) => localExt.uri === ext.uri);
                          if (!found) {
                            continue;
                          }
                          this._mediaObject.ext.push({
                            uri: ext.uri,
                            value: ext.id
                          });
                        }
                        if (offerMediaObject.extmapAllowMixed === "extmap-allow-mixed") {
                          this._mediaObject.extmapAllowMixed = "extmap-allow-mixed";
                        }
                        if (offerMediaObject.simulcast) {
                          this._mediaObject.simulcast = {
                            dir1: "recv",
                            list1: offerMediaObject.simulcast.list1
                          };
                          this._mediaObject.rids = [];
                          for (const rid of offerMediaObject.rids ?? []) {
                            if (rid.direction !== "send") {
                              continue;
                            }
                            this._mediaObject.rids.push({
                              id: rid.id,
                              direction: "recv"
                            });
                          }
                        } else if (offerMediaObject.simulcast_03) {
                          this._mediaObject.simulcast_03 = {
                            value: offerMediaObject.simulcast_03.value.replace(/send/g, "recv")
                          };
                          this._mediaObject.rids = [];
                          for (const rid of offerMediaObject.rids ?? []) {
                            if (rid.direction !== "send") {
                              continue;
                            }
                            this._mediaObject.rids.push({
                              id: rid.id,
                              direction: "recv"
                            });
                          }
                        }
                        this._mediaObject.rtcpMux = "rtcp-mux";
                        this._mediaObject.rtcpRsize = "rtcp-rsize";
                        break;
                      }
                      case "application": {
                        if (typeof offerMediaObject.sctpPort === "number") {
                          this._mediaObject.payloads = "webrtc-datachannel";
                          this._mediaObject.sctpPort = sctpParameters.port;
                          this._mediaObject.maxMessageSize = sctpParameters.maxMessageSize;
                        } else if (offerMediaObject.sctpmap) {
                          this._mediaObject.payloads = String(sctpParameters.port);
                          this._mediaObject.sctpmap = {
                            app: "webrtc-datachannel",
                            sctpmapNumber: sctpParameters.port,
                            maxMessageSize: sctpParameters.maxMessageSize
                          };
                        }
                        break;
                      }
                    }
                  }
                  setDtlsRole(role) {
                    switch (role) {
                      case "client": {
                        this._mediaObject.setup = "active";
                        break;
                      }
                      case "server": {
                        this._mediaObject.setup = "passive";
                        break;
                      }
                      case "auto": {
                        this._mediaObject.setup = "actpass";
                        break;
                      }
                    }
                  }
                  resume() {
                    this._mediaObject.direction = "recvonly";
                  }
                  muxSimulcastStreams(encodings) {
                    var _a, _b;
                    if (!((_a = this._mediaObject.simulcast) == null ? void 0 : _a.list1)) {
                      return;
                    }
                    const layers = {};
                    for (const encoding of encodings) {
                      if (encoding.rid) {
                        layers[encoding.rid] = encoding;
                      }
                    }
                    const raw = this._mediaObject.simulcast.list1;
                    const simulcastStreams = sdpTransform.parseSimulcastStreamList(raw);
                    for (const simulcastStream of simulcastStreams) {
                      for (const simulcastFormat of simulcastStream) {
                        simulcastFormat.paused = !((_b = layers[simulcastFormat.scid]) == null ? void 0 : _b.active);
                      }
                    }
                    this._mediaObject.simulcast.list1 = simulcastStreams.map((simulcastFormats) => simulcastFormats.map((f) => `${f.paused ? "~" : ""}${f.scid}`).join(",")).join(";");
                  }
                }
                exports2.AnswerMediaSection = AnswerMediaSection;
                class OfferMediaSection extends MediaSection {
                  constructor({ iceParameters, iceCandidates, dtlsParameters, sctpParameters, plainRtpParameters, mid, kind, offerRtpParameters, streamId, trackId }) {
                    var _a;
                    super({ iceParameters, iceCandidates, dtlsParameters });
                    this._mediaObject.mid = String(mid);
                    this._mediaObject.type = kind;
                    if (!plainRtpParameters) {
                      this._mediaObject.connection = { ip: "127.0.0.1", version: 4 };
                      if (!sctpParameters) {
                        this._mediaObject.protocol = "UDP/TLS/RTP/SAVPF";
                      } else {
                        this._mediaObject.protocol = "UDP/DTLS/SCTP";
                      }
                      this._mediaObject.port = 7;
                    } else {
                      this._mediaObject.connection = {
                        ip: plainRtpParameters.ip,
                        version: plainRtpParameters.ipVersion
                      };
                      this._mediaObject.protocol = "RTP/AVP";
                      this._mediaObject.port = plainRtpParameters.port;
                    }
                    this._mediaObject.extmapAllowMixed = "extmap-allow-mixed";
                    switch (kind) {
                      case "audio":
                      case "video": {
                        this._mediaObject.direction = "sendonly";
                        this._mediaObject.rtp = [];
                        this._mediaObject.rtcpFb = [];
                        this._mediaObject.fmtp = [];
                        this._mediaObject.msid = `${streamId ?? "-"} ${trackId}`;
                        for (const codec of offerRtpParameters.codecs) {
                          const rtp = {
                            payload: codec.payloadType,
                            codec: getCodecName(codec),
                            rate: codec.clockRate
                          };
                          if (codec.channels > 1) {
                            rtp.encoding = codec.channels;
                          }
                          this._mediaObject.rtp.push(rtp);
                          const fmtp = {
                            payload: codec.payloadType,
                            config: ""
                          };
                          for (const key of Object.keys(codec.parameters ?? {})) {
                            if (fmtp.config) {
                              fmtp.config += ";";
                            }
                            fmtp.config += `${key}=${codec.parameters[key]}`;
                          }
                          if (fmtp.config) {
                            this._mediaObject.fmtp.push(fmtp);
                          }
                          for (const fb of codec.rtcpFeedback) {
                            this._mediaObject.rtcpFb.push({
                              payload: codec.payloadType,
                              type: fb.type,
                              subtype: fb.parameter
                            });
                          }
                        }
                        this._mediaObject.payloads = offerRtpParameters.codecs.map((codec) => codec.payloadType).join(" ");
                        this._mediaObject.ext = [];
                        for (const ext of offerRtpParameters.headerExtensions) {
                          this._mediaObject.ext.push({
                            uri: ext.uri,
                            value: ext.id
                          });
                        }
                        this._mediaObject.rtcpMux = "rtcp-mux";
                        this._mediaObject.rtcpRsize = "rtcp-rsize";
                        const encoding = offerRtpParameters.encodings[0];
                        const ssrc = encoding.ssrc;
                        const rtxSsrc = (_a = encoding.rtx) == null ? void 0 : _a.ssrc;
                        this._mediaObject.ssrcs = [];
                        this._mediaObject.ssrcGroups = [];
                        if (ssrc && offerRtpParameters.rtcp.cname) {
                          this._mediaObject.ssrcs.push({
                            id: ssrc,
                            attribute: "cname",
                            value: offerRtpParameters.rtcp.cname
                          });
                        }
                        if (rtxSsrc) {
                          if (offerRtpParameters.rtcp.cname) {
                            this._mediaObject.ssrcs.push({
                              id: rtxSsrc,
                              attribute: "cname",
                              value: offerRtpParameters.rtcp.cname
                            });
                          }
                          if (ssrc) {
                            this._mediaObject.ssrcGroups.push({
                              semantics: "FID",
                              ssrcs: `${ssrc} ${rtxSsrc}`
                            });
                          }
                        }
                        break;
                      }
                      case "application": {
                        this._mediaObject.payloads = "webrtc-datachannel";
                        this._mediaObject.sctpPort = sctpParameters.port;
                        this._mediaObject.maxMessageSize = sctpParameters.maxMessageSize;
                        break;
                      }
                    }
                  }
                  // eslint-disable-next-line @typescript-eslint/no-unused-vars
                  setDtlsRole(role) {
                    this._mediaObject.setup = "actpass";
                  }
                  resume() {
                    this._mediaObject.direction = "sendonly";
                  }
                }
                exports2.OfferMediaSection = OfferMediaSection;
                function getCodecName(codec) {
                  const MimeTypeRegex = new RegExp("^(audio|video)/(.+)", "i");
                  const mimeTypeMatch = MimeTypeRegex.exec(codec.mimeType);
                  if (!mimeTypeMatch) {
                    throw new TypeError("invalid codec.mimeType");
                  }
                  return mimeTypeMatch[2];
                }
              }
            ),
            /***/
            3518: (
              /***/
              (__unused_webpack_module, exports2, __webpack_require__2) => {
                "use strict";
                Object.defineProperty(exports2, "__esModule", { value: true });
                exports2.Consumer = void 0;
                const Logger_1 = __webpack_require__2(2994);
                const enhancedEvents_1 = __webpack_require__2(3953);
                const errors_1 = __webpack_require__2(4893);
                const logger = new Logger_1.Logger("Consumer");
                class Consumer extends enhancedEvents_1.EnhancedEventEmitter {
                  constructor({ id, localId, producerId, rtpReceiver, track, rtpParameters, appData }) {
                    super();
                    // Id.
                    __publicField(this, "_id");
                    // Local id.
                    __publicField(this, "_localId");
                    // Associated Producer id.
                    __publicField(this, "_producerId");
                    // Closed flag.
                    __publicField(this, "_closed", false);
                    // Associated RTCRtpReceiver.
                    __publicField(this, "_rtpReceiver");
                    // Remote track.
                    __publicField(this, "_track");
                    // RTP parameters.
                    __publicField(this, "_rtpParameters");
                    // Paused flag.
                    __publicField(this, "_paused");
                    // App custom data.
                    __publicField(this, "_appData");
                    // Observer instance.
                    __publicField(this, "_observer", new enhancedEvents_1.EnhancedEventEmitter());
                    logger.debug("constructor()");
                    this._id = id;
                    this._localId = localId;
                    this._producerId = producerId;
                    this._rtpReceiver = rtpReceiver;
                    this._track = track;
                    this._rtpParameters = rtpParameters;
                    this._paused = !track.enabled;
                    this._appData = appData ?? {};
                    this.onTrackEnded = this.onTrackEnded.bind(this);
                    this.handleTrack();
                  }
                  /**
                   * Consumer id.
                   */
                  get id() {
                    return this._id;
                  }
                  /**
                   * Local id.
                   */
                  get localId() {
                    return this._localId;
                  }
                  /**
                   * Associated Producer id.
                   */
                  get producerId() {
                    return this._producerId;
                  }
                  /**
                   * Whether the Consumer is closed.
                   */
                  get closed() {
                    return this._closed;
                  }
                  /**
                   * Media kind.
                   */
                  get kind() {
                    return this._track.kind;
                  }
                  /**
                   * Associated RTCRtpReceiver.
                   */
                  get rtpReceiver() {
                    return this._rtpReceiver;
                  }
                  /**
                   * The associated track.
                   */
                  get track() {
                    return this._track;
                  }
                  /**
                   * RTP parameters.
                   */
                  get rtpParameters() {
                    return this._rtpParameters;
                  }
                  /**
                   * Whether the Consumer is paused.
                   */
                  get paused() {
                    return this._paused;
                  }
                  /**
                   * App custom data.
                   */
                  get appData() {
                    return this._appData;
                  }
                  /**
                   * App custom data setter.
                   */
                  set appData(appData) {
                    this._appData = appData;
                  }
                  get observer() {
                    return this._observer;
                  }
                  /**
                   * Closes the Consumer.
                   */
                  close() {
                    if (this._closed) {
                      return;
                    }
                    logger.debug("close()");
                    this._closed = true;
                    this.destroyTrack();
                    this.emit("@close");
                    this._observer.safeEmit("close");
                    super.close();
                    this._observer.close();
                  }
                  /**
                   * Transport was closed.
                   */
                  transportClosed() {
                    if (this._closed) {
                      return;
                    }
                    logger.debug("transportClosed()");
                    this._closed = true;
                    this.destroyTrack();
                    this.safeEmit("transportclose");
                    this._observer.safeEmit("close");
                  }
                  /**
                   * Get associated RTCRtpReceiver stats.
                   */
                  async getStats() {
                    if (this._closed) {
                      throw new errors_1.InvalidStateError("closed");
                    }
                    return new Promise((resolve, reject) => {
                      this.safeEmit("@getstats", resolve, reject);
                    });
                  }
                  /**
                   * Pauses receiving media.
                   */
                  pause() {
                    logger.debug("pause()");
                    if (this._closed) {
                      logger.error("pause() | Consumer closed");
                      return;
                    }
                    if (this._paused) {
                      logger.debug("pause() | Consumer is already paused");
                      return;
                    }
                    this._paused = true;
                    this._track.enabled = false;
                    this.emit("@pause");
                    this._observer.safeEmit("pause");
                  }
                  /**
                   * Resumes receiving media.
                   */
                  resume() {
                    logger.debug("resume()");
                    if (this._closed) {
                      logger.error("resume() | Consumer closed");
                      return;
                    }
                    if (!this._paused) {
                      logger.debug("resume() | Consumer is already resumed");
                      return;
                    }
                    this._paused = false;
                    this._track.enabled = true;
                    this.emit("@resume");
                    this._observer.safeEmit("resume");
                  }
                  onTrackEnded() {
                    logger.debug('track "ended" event');
                    this.safeEmit("trackended");
                    this._observer.safeEmit("trackended");
                  }
                  handleTrack() {
                    this._track.addEventListener("ended", this.onTrackEnded);
                  }
                  destroyTrack() {
                    try {
                      this._track.removeEventListener("ended", this.onTrackEnded);
                      this._track.stop();
                    } catch (error) {
                    }
                  }
                }
                exports2.Consumer = Consumer;
              }
            ),
            /***/
            3582: (
              /***/
              (__unused_webpack_module, exports2, __webpack_require__2) => {
                "use strict";
                Object.defineProperty(exports2, "__esModule", { value: true });
                exports2.Logger = void 0;
                const debug_1 = __webpack_require__2(7833);
                const APP_NAME = "h264-profile-level-id";
                class Logger {
                  constructor(prefix) {
                    __publicField(this, "_debug");
                    __publicField(this, "_warn");
                    __publicField(this, "_error");
                    if (prefix) {
                      this._debug = (0, debug_1.default)(`${APP_NAME}:${prefix}`);
                      this._warn = (0, debug_1.default)(`${APP_NAME}:WARN:${prefix}`);
                      this._error = (0, debug_1.default)(`${APP_NAME}:ERROR:${prefix}`);
                    } else {
                      this._debug = (0, debug_1.default)(APP_NAME);
                      this._warn = (0, debug_1.default)(`${APP_NAME}:WARN`);
                      this._error = (0, debug_1.default)(`${APP_NAME}:ERROR`);
                    }
                    this._debug.log = console.info.bind(console);
                    this._warn.log = console.warn.bind(console);
                    this._error.log = console.error.bind(console);
                  }
                  get debug() {
                    return this._debug;
                  }
                  get warn() {
                    return this._warn;
                  }
                  get error() {
                    return this._error;
                  }
                }
                exports2.Logger = Logger;
              }
            ),
            /***/
            3662: (
              /***/
              (__unused_webpack___webpack_module__, __webpack_exports__2, __webpack_require__2) => {
                "use strict";
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  A: () => (
                    /* binding */
                    _setPrototypeOf
                  )
                  /* harmony export */
                });
                function _setPrototypeOf(t, e) {
                  return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t2, e2) {
                    return t2.__proto__ = e2, t2;
                  }, _setPrototypeOf(t, e);
                }
              }
            ),
            /***/
            3738: (
              /***/
              (module2) => {
                function _typeof(o) {
                  "@babel/helpers - typeof";
                  return module2.exports = _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
                    return typeof o2;
                  } : function(o2) {
                    return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
                  }, module2.exports.__esModule = true, module2.exports["default"] = module2.exports, _typeof(o);
                }
                module2.exports = _typeof, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
              }
            ),
            /***/
            3785: (
              /***/
              (__unused_webpack_module, exports2) => {
                "use strict";
                Object.defineProperty(exports2, "__esModule", { value: true });
                exports2.clone = clone;
                function clone(value) {
                  if (value === void 0) {
                    return void 0;
                  } else if (Number.isNaN(value)) {
                    return NaN;
                  } else if (typeof structuredClone === "function") {
                    return structuredClone(value);
                  } else {
                    return JSON.parse(JSON.stringify(value));
                  }
                }
              }
            ),
            /***/
            3797: (
              /***/
              function(module2, exports2, __webpack_require__2) {
                ;
                (function(root, factory, undef) {
                  if (true) {
                    module2.exports = exports2 = factory(__webpack_require__2(9021), __webpack_require__2(7165));
                  } else {
                  }
                })(this, function(CryptoJS) {
                  CryptoJS.mode.OFB = function() {
                    var OFB = CryptoJS.lib.BlockCipherMode.extend();
                    var Encryptor = OFB.Encryptor = OFB.extend({
                      processBlock: function(words, offset) {
                        var cipher = this._cipher;
                        var blockSize = cipher.blockSize;
                        var iv = this._iv;
                        var keystream = this._keystream;
                        if (iv) {
                          keystream = this._keystream = iv.slice(0);
                          this._iv = void 0;
                        }
                        cipher.encryptBlock(keystream, 0);
                        for (var i = 0; i < blockSize; i++) {
                          words[offset + i] ^= keystream[i];
                        }
                      }
                    });
                    OFB.Decryptor = Encryptor;
                    return OFB;
                  }();
                  return CryptoJS.mode.OFB;
                });
              }
            ),
            /***/
            3804: (
              /***/
              (module2, __unused_webpack_exports, __webpack_require__2) => {
                var grammar = __webpack_require__2(5602);
                var formatRegExp = /%[sdv%]/g;
                var format = function(formatStr) {
                  var i = 1;
                  var args = arguments;
                  var len = args.length;
                  return formatStr.replace(formatRegExp, function(x) {
                    if (i >= len) {
                      return x;
                    }
                    var arg = args[i];
                    i += 1;
                    switch (x) {
                      case "%%":
                        return "%";
                      case "%s":
                        return String(arg);
                      case "%d":
                        return Number(arg);
                      case "%v":
                        return "";
                    }
                  });
                };
                var makeLine = function(type, obj, location2) {
                  var str = obj.format instanceof Function ? obj.format(obj.push ? location2 : location2[obj.name]) : obj.format;
                  var args = [type + "=" + str];
                  if (obj.names) {
                    for (var i = 0; i < obj.names.length; i += 1) {
                      var n = obj.names[i];
                      if (obj.name) {
                        args.push(location2[obj.name][n]);
                      } else {
                        args.push(location2[obj.names[i]]);
                      }
                    }
                  } else {
                    args.push(location2[obj.name]);
                  }
                  return format.apply(null, args);
                };
                var defaultOuterOrder = [
                  "v",
                  "o",
                  "s",
                  "i",
                  "u",
                  "e",
                  "p",
                  "c",
                  "b",
                  "t",
                  "r",
                  "z",
                  "a"
                ];
                var defaultInnerOrder = ["i", "c", "b", "a"];
                module2.exports = function(session, opts) {
                  opts = opts || {};
                  if (session.version == null) {
                    session.version = 0;
                  }
                  if (session.name == null) {
                    session.name = " ";
                  }
                  session.media.forEach(function(mLine) {
                    if (mLine.payloads == null) {
                      mLine.payloads = "";
                    }
                  });
                  var outerOrder = opts.outerOrder || defaultOuterOrder;
                  var innerOrder = opts.innerOrder || defaultInnerOrder;
                  var sdp = [];
                  outerOrder.forEach(function(type) {
                    grammar[type].forEach(function(obj) {
                      if (obj.name in session && session[obj.name] != null) {
                        sdp.push(makeLine(type, obj, session));
                      } else if (obj.push in session && session[obj.push] != null) {
                        session[obj.push].forEach(function(el) {
                          sdp.push(makeLine(type, obj, el));
                        });
                      }
                    });
                  });
                  session.media.forEach(function(mLine) {
                    sdp.push(makeLine("m", grammar.m[0], mLine));
                    innerOrder.forEach(function(type) {
                      grammar[type].forEach(function(obj) {
                        if (obj.name in mLine && mLine[obj.name] != null) {
                          sdp.push(makeLine(type, obj, mLine));
                        } else if (obj.push in mLine && mLine[obj.push] != null) {
                          mLine[obj.push].forEach(function(el) {
                            sdp.push(makeLine(type, obj, el));
                          });
                        }
                      });
                    });
                  });
                  return sdp.join("\r\n") + "\r\n";
                };
              }
            ),
            /***/
            3953: (
              /***/
              (__unused_webpack_module, exports2, __webpack_require__2) => {
                "use strict";
                Object.defineProperty(exports2, "__esModule", { value: true });
                exports2.EnhancedEventEmitter = void 0;
                const events_alias_1 = __webpack_require__2(5528);
                const Logger_1 = __webpack_require__2(2994);
                const enhancedEventEmitterLogger = new Logger_1.Logger("EnhancedEventEmitter");
                class EnhancedEventEmitter extends events_alias_1.EventEmitter {
                  constructor() {
                    super();
                    this.setMaxListeners(Infinity);
                  }
                  /**
                   * Empties all stored event listeners.
                   */
                  close() {
                    super.removeAllListeners();
                  }
                  emit(eventName, ...args) {
                    return super.emit(eventName, ...args);
                  }
                  /**
                   * Special addition to the EventEmitter API.
                   */
                  safeEmit(eventName, ...args) {
                    try {
                      return super.emit(eventName, ...args);
                    } catch (error) {
                      enhancedEventEmitterLogger.error("safeEmit() | event listener threw an error [eventName:%s]:%o", eventName, error);
                      try {
                        super.emit("listenererror", eventName, error);
                      } catch (error2) {
                      }
                      return Boolean(super.listenerCount(eventName));
                    }
                  }
                  on(eventName, listener) {
                    super.on(eventName, listener);
                    return this;
                  }
                  off(eventName, listener) {
                    super.off(eventName, listener);
                    return this;
                  }
                  addListener(eventName, listener) {
                    super.on(eventName, listener);
                    return this;
                  }
                  prependListener(eventName, listener) {
                    super.prependListener(eventName, listener);
                    return this;
                  }
                  once(eventName, listener) {
                    super.once(eventName, listener);
                    return this;
                  }
                  prependOnceListener(eventName, listener) {
                    super.prependOnceListener(eventName, listener);
                    return this;
                  }
                  removeListener(eventName, listener) {
                    super.off(eventName, listener);
                    return this;
                  }
                  removeAllListeners(eventName) {
                    super.removeAllListeners(eventName);
                    return this;
                  }
                  listenerCount(eventName) {
                    return super.listenerCount(eventName);
                  }
                  listeners(eventName) {
                    return super.listeners(eventName);
                  }
                  rawListeners(eventName) {
                    return super.rawListeners(eventName);
                  }
                }
                exports2.EnhancedEventEmitter = EnhancedEventEmitter;
              }
            ),
            /***/
            3954: (
              /***/
              (__unused_webpack___webpack_module__, __webpack_exports__2, __webpack_require__2) => {
                "use strict";
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  A: () => (
                    /* binding */
                    _getPrototypeOf
                  )
                  /* harmony export */
                });
                function _getPrototypeOf(t) {
                  return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t2) {
                    return t2.__proto__ || Object.getPrototypeOf(t2);
                  }, _getPrototypeOf(t);
                }
              }
            ),
            /***/
            4253: (
              /***/
              (__unused_webpack_module, exports2) => {
                "use strict";
                Object.defineProperty(exports2, "__esModule", { value: true });
                exports2.AwaitQueueRemovedTaskError = exports2.AwaitQueueStoppedError = void 0;
                class AwaitQueueStoppedError extends Error {
                  constructor(message) {
                    super(message ?? "queue stopped");
                    this.name = "AwaitQueueStoppedError";
                    if (typeof Error.captureStackTrace === "function") {
                      Error.captureStackTrace(this, AwaitQueueStoppedError);
                    }
                  }
                }
                exports2.AwaitQueueStoppedError = AwaitQueueStoppedError;
                class AwaitQueueRemovedTaskError extends Error {
                  constructor(message) {
                    super(message ?? "queue task removed");
                    this.name = "AwaitQueueRemovedTaskError";
                    if (typeof Error.captureStackTrace === "function") {
                      Error.captureStackTrace(this, AwaitQueueRemovedTaskError);
                    }
                  }
                }
                exports2.AwaitQueueRemovedTaskError = AwaitQueueRemovedTaskError;
              }
            ),
            /***/
            4256: (
              /***/
              (__unused_webpack_module, exports2) => {
                "use strict";
                Object.defineProperty(exports2, "__esModule", { value: true });
                exports2.addNackSupportForOpus = addNackSupportForOpus;
                function addNackSupportForOpus(rtpCapabilities) {
                  var _a;
                  for (const codec of rtpCapabilities.codecs ?? []) {
                    if ((codec.mimeType.toLowerCase() === "audio/opus" || codec.mimeType.toLowerCase() === "audio/multiopus") && !((_a = codec.rtcpFeedback) == null ? void 0 : _a.some((fb) => fb.type === "nack" && !fb.parameter))) {
                      if (!codec.rtcpFeedback) {
                        codec.rtcpFeedback = [];
                      }
                      codec.rtcpFeedback.push({ type: "nack" });
                    }
                  }
                }
              }
            ),
            /***/
            4373: (
              /***/
              (module2) => {
                function _regeneratorKeys(e) {
                  var n = Object(e), r = [];
                  for (var t in n) r.unshift(t);
                  return function e2() {
                    for (; r.length; ) if ((t = r.pop()) in n) return e2.value = t, e2.done = false, e2;
                    return e2.done = true, e2;
                  };
                }
                module2.exports = _regeneratorKeys, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
              }
            ),
            /***/
            4467: (
              /***/
              (__unused_webpack___webpack_module__, __webpack_exports__2, __webpack_require__2) => {
                "use strict";
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  A: () => (
                    /* binding */
                    _defineProperty
                  )
                  /* harmony export */
                });
                var _toPropertyKey_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(816);
                function _defineProperty(e, r, t) {
                  return (r = (0, _toPropertyKey_js__WEBPACK_IMPORTED_MODULE_0__.A)(r)) in e ? Object.defineProperty(e, r, {
                    value: t,
                    enumerable: true,
                    configurable: true,
                    writable: true
                  }) : e[r] = t, e;
                }
              }
            ),
            /***/
            4633: (
              /***/
              (module2, __unused_webpack_exports, __webpack_require__2) => {
                var OverloadYield = __webpack_require__2(5172);
                var regenerator = __webpack_require__2(6993);
                var regeneratorAsync = __webpack_require__2(5869);
                var regeneratorAsyncGen = __webpack_require__2(887);
                var regeneratorAsyncIterator = __webpack_require__2(1791);
                var regeneratorKeys = __webpack_require__2(4373);
                var regeneratorValues = __webpack_require__2(579);
                function _regeneratorRuntime2() {
                  "use strict";
                  var r = regenerator(), e = r.m(_regeneratorRuntime2), t = (Object.getPrototypeOf ? Object.getPrototypeOf(e) : e.__proto__).constructor;
                  function n(r2) {
                    var e2 = "function" == typeof r2 && r2.constructor;
                    return !!e2 && (e2 === t || "GeneratorFunction" === (e2.displayName || e2.name));
                  }
                  var o = {
                    "throw": 1,
                    "return": 2,
                    "break": 3,
                    "continue": 3
                  };
                  function a(r2) {
                    var e2, t2;
                    return function(n2) {
                      e2 || (e2 = {
                        stop: function stop() {
                          return t2(n2.a, 2);
                        },
                        "catch": function _catch2() {
                          return n2.v;
                        },
                        abrupt: function abrupt(r3, e3) {
                          return t2(n2.a, o[r3], e3);
                        },
                        delegateYield: function delegateYield(r3, o2, a2) {
                          return e2.resultName = o2, t2(n2.d, regeneratorValues(r3), a2);
                        },
                        finish: function finish(r3) {
                          return t2(n2.f, r3);
                        }
                      }, t2 = function t3(r3, _t, o2) {
                        n2.p = e2.prev, n2.n = e2.next;
                        try {
                          return r3(_t, o2);
                        } finally {
                          e2.next = n2.n;
                        }
                      }), e2.resultName && (e2[e2.resultName] = n2.v, e2.resultName = void 0), e2.sent = n2.v, e2.next = n2.n;
                      try {
                        return r2.call(this, e2);
                      } finally {
                        n2.p = e2.prev, n2.n = e2.next;
                      }
                    };
                  }
                  return (module2.exports = _regeneratorRuntime2 = function _regeneratorRuntime3() {
                    return {
                      wrap: function wrap(e2, t2, n2, o2) {
                        return r.w(a(e2), t2, n2, o2 && o2.reverse());
                      },
                      isGeneratorFunction: n,
                      mark: r.m,
                      awrap: function awrap(r2, e2) {
                        return new OverloadYield(r2, e2);
                      },
                      AsyncIterator: regeneratorAsyncIterator,
                      async: function async(r2, e2, t2, o2, u) {
                        return (n(e2) ? regeneratorAsyncGen : regeneratorAsync)(a(r2), e2, t2, o2, u);
                      },
                      keys: regeneratorKeys,
                      values: regeneratorValues
                    };
                  }, module2.exports.__esModule = true, module2.exports["default"] = module2.exports)();
                }
                module2.exports = _regeneratorRuntime2, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
              }
            ),
            /***/
            4636: (
              /***/
              function(module2, exports2, __webpack_require__2) {
                ;
                (function(root, factory) {
                  if (true) {
                    module2.exports = exports2 = factory(__webpack_require__2(9021));
                  } else {
                  }
                })(this, function(CryptoJS) {
                  (function(Math2) {
                    var C = CryptoJS;
                    var C_lib = C.lib;
                    var WordArray = C_lib.WordArray;
                    var Hasher = C_lib.Hasher;
                    var C_algo = C.algo;
                    var T = [];
                    (function() {
                      for (var i = 0; i < 64; i++) {
                        T[i] = Math2.abs(Math2.sin(i + 1)) * 4294967296 | 0;
                      }
                    })();
                    var MD5 = C_algo.MD5 = Hasher.extend({
                      _doReset: function() {
                        this._hash = new WordArray.init([
                          1732584193,
                          4023233417,
                          2562383102,
                          271733878
                        ]);
                      },
                      _doProcessBlock: function(M, offset) {
                        for (var i = 0; i < 16; i++) {
                          var offset_i = offset + i;
                          var M_offset_i = M[offset_i];
                          M[offset_i] = (M_offset_i << 8 | M_offset_i >>> 24) & 16711935 | (M_offset_i << 24 | M_offset_i >>> 8) & 4278255360;
                        }
                        var H = this._hash.words;
                        var M_offset_0 = M[offset + 0];
                        var M_offset_1 = M[offset + 1];
                        var M_offset_2 = M[offset + 2];
                        var M_offset_3 = M[offset + 3];
                        var M_offset_4 = M[offset + 4];
                        var M_offset_5 = M[offset + 5];
                        var M_offset_6 = M[offset + 6];
                        var M_offset_7 = M[offset + 7];
                        var M_offset_8 = M[offset + 8];
                        var M_offset_9 = M[offset + 9];
                        var M_offset_10 = M[offset + 10];
                        var M_offset_11 = M[offset + 11];
                        var M_offset_12 = M[offset + 12];
                        var M_offset_13 = M[offset + 13];
                        var M_offset_14 = M[offset + 14];
                        var M_offset_15 = M[offset + 15];
                        var a = H[0];
                        var b = H[1];
                        var c = H[2];
                        var d = H[3];
                        a = FF(a, b, c, d, M_offset_0, 7, T[0]);
                        d = FF(d, a, b, c, M_offset_1, 12, T[1]);
                        c = FF(c, d, a, b, M_offset_2, 17, T[2]);
                        b = FF(b, c, d, a, M_offset_3, 22, T[3]);
                        a = FF(a, b, c, d, M_offset_4, 7, T[4]);
                        d = FF(d, a, b, c, M_offset_5, 12, T[5]);
                        c = FF(c, d, a, b, M_offset_6, 17, T[6]);
                        b = FF(b, c, d, a, M_offset_7, 22, T[7]);
                        a = FF(a, b, c, d, M_offset_8, 7, T[8]);
                        d = FF(d, a, b, c, M_offset_9, 12, T[9]);
                        c = FF(c, d, a, b, M_offset_10, 17, T[10]);
                        b = FF(b, c, d, a, M_offset_11, 22, T[11]);
                        a = FF(a, b, c, d, M_offset_12, 7, T[12]);
                        d = FF(d, a, b, c, M_offset_13, 12, T[13]);
                        c = FF(c, d, a, b, M_offset_14, 17, T[14]);
                        b = FF(b, c, d, a, M_offset_15, 22, T[15]);
                        a = GG(a, b, c, d, M_offset_1, 5, T[16]);
                        d = GG(d, a, b, c, M_offset_6, 9, T[17]);
                        c = GG(c, d, a, b, M_offset_11, 14, T[18]);
                        b = GG(b, c, d, a, M_offset_0, 20, T[19]);
                        a = GG(a, b, c, d, M_offset_5, 5, T[20]);
                        d = GG(d, a, b, c, M_offset_10, 9, T[21]);
                        c = GG(c, d, a, b, M_offset_15, 14, T[22]);
                        b = GG(b, c, d, a, M_offset_4, 20, T[23]);
                        a = GG(a, b, c, d, M_offset_9, 5, T[24]);
                        d = GG(d, a, b, c, M_offset_14, 9, T[25]);
                        c = GG(c, d, a, b, M_offset_3, 14, T[26]);
                        b = GG(b, c, d, a, M_offset_8, 20, T[27]);
                        a = GG(a, b, c, d, M_offset_13, 5, T[28]);
                        d = GG(d, a, b, c, M_offset_2, 9, T[29]);
                        c = GG(c, d, a, b, M_offset_7, 14, T[30]);
                        b = GG(b, c, d, a, M_offset_12, 20, T[31]);
                        a = HH(a, b, c, d, M_offset_5, 4, T[32]);
                        d = HH(d, a, b, c, M_offset_8, 11, T[33]);
                        c = HH(c, d, a, b, M_offset_11, 16, T[34]);
                        b = HH(b, c, d, a, M_offset_14, 23, T[35]);
                        a = HH(a, b, c, d, M_offset_1, 4, T[36]);
                        d = HH(d, a, b, c, M_offset_4, 11, T[37]);
                        c = HH(c, d, a, b, M_offset_7, 16, T[38]);
                        b = HH(b, c, d, a, M_offset_10, 23, T[39]);
                        a = HH(a, b, c, d, M_offset_13, 4, T[40]);
                        d = HH(d, a, b, c, M_offset_0, 11, T[41]);
                        c = HH(c, d, a, b, M_offset_3, 16, T[42]);
                        b = HH(b, c, d, a, M_offset_6, 23, T[43]);
                        a = HH(a, b, c, d, M_offset_9, 4, T[44]);
                        d = HH(d, a, b, c, M_offset_12, 11, T[45]);
                        c = HH(c, d, a, b, M_offset_15, 16, T[46]);
                        b = HH(b, c, d, a, M_offset_2, 23, T[47]);
                        a = II(a, b, c, d, M_offset_0, 6, T[48]);
                        d = II(d, a, b, c, M_offset_7, 10, T[49]);
                        c = II(c, d, a, b, M_offset_14, 15, T[50]);
                        b = II(b, c, d, a, M_offset_5, 21, T[51]);
                        a = II(a, b, c, d, M_offset_12, 6, T[52]);
                        d = II(d, a, b, c, M_offset_3, 10, T[53]);
                        c = II(c, d, a, b, M_offset_10, 15, T[54]);
                        b = II(b, c, d, a, M_offset_1, 21, T[55]);
                        a = II(a, b, c, d, M_offset_8, 6, T[56]);
                        d = II(d, a, b, c, M_offset_15, 10, T[57]);
                        c = II(c, d, a, b, M_offset_6, 15, T[58]);
                        b = II(b, c, d, a, M_offset_13, 21, T[59]);
                        a = II(a, b, c, d, M_offset_4, 6, T[60]);
                        d = II(d, a, b, c, M_offset_11, 10, T[61]);
                        c = II(c, d, a, b, M_offset_2, 15, T[62]);
                        b = II(b, c, d, a, M_offset_9, 21, T[63]);
                        H[0] = H[0] + a | 0;
                        H[1] = H[1] + b | 0;
                        H[2] = H[2] + c | 0;
                        H[3] = H[3] + d | 0;
                      },
                      _doFinalize: function() {
                        var data = this._data;
                        var dataWords = data.words;
                        var nBitsTotal = this._nDataBytes * 8;
                        var nBitsLeft = data.sigBytes * 8;
                        dataWords[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;
                        var nBitsTotalH = Math2.floor(nBitsTotal / 4294967296);
                        var nBitsTotalL = nBitsTotal;
                        dataWords[(nBitsLeft + 64 >>> 9 << 4) + 15] = (nBitsTotalH << 8 | nBitsTotalH >>> 24) & 16711935 | (nBitsTotalH << 24 | nBitsTotalH >>> 8) & 4278255360;
                        dataWords[(nBitsLeft + 64 >>> 9 << 4) + 14] = (nBitsTotalL << 8 | nBitsTotalL >>> 24) & 16711935 | (nBitsTotalL << 24 | nBitsTotalL >>> 8) & 4278255360;
                        data.sigBytes = (dataWords.length + 1) * 4;
                        this._process();
                        var hash = this._hash;
                        var H = hash.words;
                        for (var i = 0; i < 4; i++) {
                          var H_i = H[i];
                          H[i] = (H_i << 8 | H_i >>> 24) & 16711935 | (H_i << 24 | H_i >>> 8) & 4278255360;
                        }
                        return hash;
                      },
                      clone: function() {
                        var clone = Hasher.clone.call(this);
                        clone._hash = this._hash.clone();
                        return clone;
                      }
                    });
                    function FF(a, b, c, d, x, s, t) {
                      var n = a + (b & c | ~b & d) + x + t;
                      return (n << s | n >>> 32 - s) + b;
                    }
                    function GG(a, b, c, d, x, s, t) {
                      var n = a + (b & d | c & ~d) + x + t;
                      return (n << s | n >>> 32 - s) + b;
                    }
                    function HH(a, b, c, d, x, s, t) {
                      var n = a + (b ^ c ^ d) + x + t;
                      return (n << s | n >>> 32 - s) + b;
                    }
                    function II(a, b, c, d, x, s, t) {
                      var n = a + (c ^ (b | ~d)) + x + t;
                      return (n << s | n >>> 32 - s) + b;
                    }
                    C.MD5 = Hasher._createHelper(MD5);
                    C.HmacMD5 = Hasher._createHmacHelper(MD5);
                  })(Math);
                  return CryptoJS.MD5;
                });
              }
            ),
            /***/
            4725: (
              /***/
              function(module2, exports2, __webpack_require__2) {
                ;
                (function(root, factory) {
                  if (true) {
                    module2.exports = exports2 = factory(__webpack_require__2(9021));
                  } else {
                  }
                })(this, function(CryptoJS) {
                  (function() {
                    var C = CryptoJS;
                    var C_lib = C.lib;
                    var WordArray = C_lib.WordArray;
                    var C_enc = C.enc;
                    var Base64url = C_enc.Base64url = {
                      /**
                       * Converts a word array to a Base64url string.
                       *
                       * @param {WordArray} wordArray The word array.
                       *
                       * @param {boolean} urlSafe Whether to use url safe
                       *
                       * @return {string} The Base64url string.
                       *
                       * @static
                       *
                       * @example
                       *
                       *     var base64String = CryptoJS.enc.Base64url.stringify(wordArray);
                       */
                      stringify: function(wordArray, urlSafe) {
                        if (urlSafe === void 0) {
                          urlSafe = true;
                        }
                        var words = wordArray.words;
                        var sigBytes = wordArray.sigBytes;
                        var map = urlSafe ? this._safe_map : this._map;
                        wordArray.clamp();
                        var base64Chars = [];
                        for (var i = 0; i < sigBytes; i += 3) {
                          var byte1 = words[i >>> 2] >>> 24 - i % 4 * 8 & 255;
                          var byte2 = words[i + 1 >>> 2] >>> 24 - (i + 1) % 4 * 8 & 255;
                          var byte3 = words[i + 2 >>> 2] >>> 24 - (i + 2) % 4 * 8 & 255;
                          var triplet = byte1 << 16 | byte2 << 8 | byte3;
                          for (var j = 0; j < 4 && i + j * 0.75 < sigBytes; j++) {
                            base64Chars.push(map.charAt(triplet >>> 6 * (3 - j) & 63));
                          }
                        }
                        var paddingChar = map.charAt(64);
                        if (paddingChar) {
                          while (base64Chars.length % 4) {
                            base64Chars.push(paddingChar);
                          }
                        }
                        return base64Chars.join("");
                      },
                      /**
                       * Converts a Base64url string to a word array.
                       *
                       * @param {string} base64Str The Base64url string.
                       *
                       * @param {boolean} urlSafe Whether to use url safe
                       *
                       * @return {WordArray} The word array.
                       *
                       * @static
                       *
                       * @example
                       *
                       *     var wordArray = CryptoJS.enc.Base64url.parse(base64String);
                       */
                      parse: function(base64Str, urlSafe) {
                        if (urlSafe === void 0) {
                          urlSafe = true;
                        }
                        var base64StrLength = base64Str.length;
                        var map = urlSafe ? this._safe_map : this._map;
                        var reverseMap = this._reverseMap;
                        if (!reverseMap) {
                          reverseMap = this._reverseMap = [];
                          for (var j = 0; j < map.length; j++) {
                            reverseMap[map.charCodeAt(j)] = j;
                          }
                        }
                        var paddingChar = map.charAt(64);
                        if (paddingChar) {
                          var paddingIndex = base64Str.indexOf(paddingChar);
                          if (paddingIndex !== -1) {
                            base64StrLength = paddingIndex;
                          }
                        }
                        return parseLoop(base64Str, base64StrLength, reverseMap);
                      },
                      _map: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
                      _safe_map: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"
                    };
                    function parseLoop(base64Str, base64StrLength, reverseMap) {
                      var words = [];
                      var nBytes = 0;
                      for (var i = 0; i < base64StrLength; i++) {
                        if (i % 4) {
                          var bits1 = reverseMap[base64Str.charCodeAt(i - 1)] << i % 4 * 2;
                          var bits2 = reverseMap[base64Str.charCodeAt(i)] >>> 6 - i % 4 * 2;
                          var bitsCombined = bits1 | bits2;
                          words[nBytes >>> 2] |= bitsCombined << 24 - nBytes % 4 * 8;
                          nBytes++;
                        }
                      }
                      return WordArray.create(words, nBytes);
                    }
                  })();
                  return CryptoJS.enc.Base64url;
                });
              }
            ),
            /***/
            4756: (
              /***/
              (module2, __unused_webpack_exports, __webpack_require__2) => {
                var runtime = __webpack_require__2(4633)();
                module2.exports = runtime;
                try {
                  regeneratorRuntime = runtime;
                } catch (accidentalStrictMode) {
                  if (typeof globalThis === "object") {
                    globalThis.regeneratorRuntime = runtime;
                  } else {
                    Function("r", "regeneratorRuntime = r")(runtime);
                  }
                }
              }
            ),
            /***/
            4893: (
              /***/
              (__unused_webpack_module, exports2) => {
                "use strict";
                Object.defineProperty(exports2, "__esModule", { value: true });
                exports2.InvalidStateError = exports2.UnsupportedError = void 0;
                class UnsupportedError extends Error {
                  constructor(message) {
                    super(message);
                    this.name = "UnsupportedError";
                    if (Error.hasOwnProperty("captureStackTrace")) {
                      Error.captureStackTrace(this, UnsupportedError);
                    } else {
                      this.stack = new Error(message).stack;
                    }
                  }
                }
                exports2.UnsupportedError = UnsupportedError;
                class InvalidStateError extends Error {
                  constructor(message) {
                    super(message);
                    this.name = "InvalidStateError";
                    if (Error.hasOwnProperty("captureStackTrace")) {
                      Error.captureStackTrace(this, InvalidStateError);
                    } else {
                      this.stack = new Error(message).stack;
                    }
                  }
                }
                exports2.InvalidStateError = InvalidStateError;
              }
            ),
            /***/
            4905: (
              /***/
              function(module2, exports2, __webpack_require__2) {
                ;
                (function(root, factory, undef) {
                  if (true) {
                    module2.exports = exports2 = factory(__webpack_require__2(9021), __webpack_require__2(7165));
                  } else {
                  }
                })(this, function(CryptoJS) {
                  CryptoJS.pad.Iso10126 = {
                    pad: function(data, blockSize) {
                      var blockSizeBytes = blockSize * 4;
                      var nPaddingBytes = blockSizeBytes - data.sigBytes % blockSizeBytes;
                      data.concat(CryptoJS.lib.WordArray.random(nPaddingBytes - 1)).concat(CryptoJS.lib.WordArray.create([nPaddingBytes << 24], 1));
                    },
                    unpad: function(data) {
                      var nPaddingBytes = data.words[data.sigBytes - 1 >>> 2] & 255;
                      data.sigBytes -= nPaddingBytes;
                    }
                  };
                  return CryptoJS.pad.Iso10126;
                });
              }
            ),
            /***/
            4973: (
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                "use strict";
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  Zu: () => (
                    /* binding */
                    getNavigatorDisplayMediaDevices
                  ),
                  /* harmony export */
                  lp: () => (
                    /* binding */
                    getNavigatorMediaDevices
                  )
                  /* harmony export */
                });
                var _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(467);
                var _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(4756);
                var _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default = __webpack_require__2.n(_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1__);
                var _config__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__2(9027);
                var getNavigatorMediaDevices = function() {
                  var _ref = (0, _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__.A)(_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().mark(function _callee(constraints) {
                    return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().wrap(function(_context) {
                      while (1) switch (_context.prev = _context.next) {
                        case 0:
                          if (navigator.mediaDevices === void 0) {
                            navigator.mediaDevices = {};
                          }
                          if (navigator.mediaDevices.getUserMedia === void 0) {
                            navigator.mediaDevices.getUserMedia = function(constraints2) {
                              var getUserMedia = navigator.webkitGetUserMedia || navigator.mozGetUserMedia;
                              if (!getUserMedia) {
                                return Promise.reject(new Error("getUserMedia is not implemented in this browser"));
                              }
                              return new Promise(function(resolve, reject) {
                                getUserMedia.call(navigator, constraints2, resolve, reject);
                              });
                            };
                          }
                          _context.next = 1;
                          return navigator.mediaDevices.getUserMedia(constraints);
                        case 1:
                          return _context.abrupt("return", _context.sent);
                        case 2:
                        case "end":
                          return _context.stop();
                      }
                    }, _callee);
                  }));
                  return function getNavigatorMediaDevices2(_x) {
                    return _ref.apply(this, arguments);
                  };
                }();
                var getNavigatorDisplayMediaDevices = function() {
                  var _ref2 = (0, _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__.A)(_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().mark(function _callee2(constraints) {
                    return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().wrap(function(_context2) {
                      while (1) switch (_context2.prev = _context2.next) {
                        case 0:
                          if (navigator.mediaDevices === void 0) {
                            navigator.mediaDevices = {};
                          }
                          if (navigator.mediaDevices.getDisplayMedia === void 0) {
                            navigator.mediaDevices.getDisplayMedia = function(constraints2) {
                              var getDisplayMedia = navigator.webkitGetDisplayMedia || navigator.mozGetDisplayMedia;
                              if (!getDisplayMedia) {
                                return Promise.reject(new Error("getDisplayMedia is not implemented in this browser"));
                              }
                              return new Promise(function(resolve, reject) {
                                getDisplayMedia.call(navigator, constraints2, resolve, reject);
                              });
                            };
                          }
                          _context2.next = 1;
                          return navigator.mediaDevices.getDisplayMedia(constraints);
                        case 1:
                          return _context2.abrupt("return", _context2.sent);
                        case 2:
                        case "end":
                          return _context2.stop();
                      }
                    }, _callee2);
                  }));
                  return function getNavigatorDisplayMediaDevices2(_x2) {
                    return _ref2.apply(this, arguments);
                  };
                }();
                function getAspectRatio(width, height) {
                  var aspect = width > height ? width / height : height / width;
                  if (Math.abs(aspect - 16 / 9) < Math.abs(aspect - 4 / 3)) {
                    return config.aspectRatios.oneSixNine;
                  }
                  return config.aspectRatios.fourThree;
                }
                function presetsForResolution(isScreenShare, width, height) {
                  if (isScreenShare) {
                    return presetsScreenShare;
                  }
                  var aspect = width > height ? width / height : height / width;
                  if (Math.abs(aspect - 16 / 9) < Math.abs(aspect - 4 / 3)) {
                    return presets169;
                  }
                  return presets43;
                }
              }
            ),
            /***/
            5020: (
              /***/
              (__unused_webpack_module, exports2, __webpack_require__2) => {
                var toIntIfInt = function(v) {
                  return String(Number(v)) === v ? Number(v) : v;
                };
                var attachProperties = function(match, location2, names, rawName) {
                  if (rawName && !names) {
                    location2[rawName] = toIntIfInt(match[1]);
                  } else {
                    for (var i = 0; i < names.length; i += 1) {
                      if (match[i + 1] != null) {
                        location2[names[i]] = toIntIfInt(match[i + 1]);
                      }
                    }
                  }
                };
                var parseReg = function(obj, location2, content) {
                  var needsBlank = obj.name && obj.names;
                  if (obj.push && !location2[obj.push]) {
                    location2[obj.push] = [];
                  } else if (needsBlank && !location2[obj.name]) {
                    location2[obj.name] = {};
                  }
                  var keyLocation = obj.push ? {} : (
                    // blank object that will be pushed
                    needsBlank ? location2[obj.name] : location2
                  );
                  attachProperties(content.match(obj.reg), keyLocation, obj.names, obj.name);
                  if (obj.push) {
                    location2[obj.push].push(keyLocation);
                  }
                };
                var grammar = __webpack_require__2(5602);
                var validLine = RegExp.prototype.test.bind(/^([a-z])=(.*)/);
                exports2.parse = function(sdp) {
                  var session = {}, media = [], location2 = session;
                  sdp.split(/(\r\n|\r|\n)/).filter(validLine).forEach(function(l) {
                    var type = l[0];
                    var content = l.slice(2);
                    if (type === "m") {
                      media.push({ rtp: [], fmtp: [] });
                      location2 = media[media.length - 1];
                    }
                    for (var j = 0; j < (grammar[type] || []).length; j += 1) {
                      var obj = grammar[type][j];
                      if (obj.reg.test(content)) {
                        return parseReg(obj, location2, content);
                      }
                    }
                  });
                  session.media = media;
                  return session;
                };
                var paramReducer = function(acc, expr) {
                  var s = expr.split(/=(.+)/, 2);
                  if (s.length === 2) {
                    acc[s[0]] = toIntIfInt(s[1]);
                  } else if (s.length === 1 && expr.length > 1) {
                    acc[s[0]] = void 0;
                  }
                  return acc;
                };
                exports2.parseParams = function(str) {
                  return str.split(/;\s?/).reduce(paramReducer, {});
                };
                exports2.parseFmtpConfig = exports2.parseParams;
                exports2.parsePayloads = function(str) {
                  return str.toString().split(" ").map(Number);
                };
                exports2.parseRemoteCandidates = function(str) {
                  var candidates = [];
                  var parts = str.split(" ").map(toIntIfInt);
                  for (var i = 0; i < parts.length; i += 3) {
                    candidates.push({
                      component: parts[i],
                      ip: parts[i + 1],
                      port: parts[i + 2]
                    });
                  }
                  return candidates;
                };
                exports2.parseImageAttributes = function(str) {
                  return str.split(" ").map(function(item) {
                    return item.substring(1, item.length - 1).split(",").reduce(paramReducer, {});
                  });
                };
                exports2.parseSimulcastStreamList = function(str) {
                  return str.split(";").map(function(stream) {
                    return stream.split(",").map(function(format) {
                      var scid, paused = false;
                      if (format[0] !== "~") {
                        scid = toIntIfInt(format);
                      } else {
                        scid = toIntIfInt(format.substring(1, format.length));
                        paused = true;
                      }
                      return {
                        scid,
                        paused
                      };
                    });
                  });
                };
              }
            ),
            /***/
            5071: (
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                "use strict";
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  V: () => (
                    /* binding */
                    hlsEvents
                  )
                  /* harmony export */
                });
                var hlsEvents = {
                  HLS_STARTING: "HLS_STARTING",
                  HLS_STARTED: "HLS_STARTED",
                  HLS_PLAYABLE: "HLS_PLAYABLE",
                  HLS_STOPPING: "HLS_STOPPING",
                  HLS_STOPPED: "HLS_STOPPED"
                };
              }
            ),
            /***/
            5172: (
              /***/
              (module2) => {
                function _OverloadYield(e, d) {
                  this.v = e, this.k = d;
                }
                module2.exports = _OverloadYield, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
              }
            ),
            /***/
            5248: (
              /***/
              (__unused_webpack_module, exports2, __webpack_require__2) => {
                "use strict";
                var __webpack_unused_export__;
                __webpack_unused_export__ = { value: true };
                __webpack_unused_export__ = generateRouterRtpCapabilities;
                __webpack_unused_export__ = generateNativeRtpCapabilities;
                __webpack_unused_export__ = generateNativeSctpCapabilities;
                __webpack_unused_export__ = generateLocalDtlsParameters;
                __webpack_unused_export__ = generateTransportRemoteParameters;
                __webpack_unused_export__ = generateProducerRemoteParameters;
                __webpack_unused_export__ = generateConsumerRemoteParameters;
                __webpack_unused_export__ = generateDataProducerRemoteParameters;
                __webpack_unused_export__ = generateDataConsumerRemoteParameters;
                const utils = __webpack_require__2(1765);
                function generateFakeUuid() {
                  return String(utils.generateRandomNumber());
                }
                function generateRouterRtpCapabilities() {
                  return utils.deepFreeze({
                    codecs: [
                      {
                        mimeType: "audio/opus",
                        kind: "audio",
                        preferredPayloadType: 100,
                        clockRate: 48e3,
                        channels: 2,
                        rtcpFeedback: [{ type: "transport-cc" }],
                        parameters: {
                          useinbandfec: 1,
                          foo: "bar"
                        }
                      },
                      {
                        mimeType: "video/VP8",
                        kind: "video",
                        preferredPayloadType: 101,
                        clockRate: 9e4,
                        rtcpFeedback: [
                          { type: "nack" },
                          { type: "nack", parameter: "pli" },
                          { type: "ccm", parameter: "fir" },
                          { type: "goog-remb" },
                          { type: "transport-cc" }
                        ],
                        parameters: {
                          "x-google-start-bitrate": 1500
                        }
                      },
                      {
                        mimeType: "video/rtx",
                        kind: "video",
                        preferredPayloadType: 102,
                        clockRate: 9e4,
                        rtcpFeedback: [],
                        parameters: {
                          apt: 101
                        }
                      },
                      {
                        mimeType: "video/H264",
                        kind: "video",
                        preferredPayloadType: 103,
                        clockRate: 9e4,
                        rtcpFeedback: [
                          { type: "nack" },
                          { type: "nack", parameter: "pli" },
                          { type: "ccm", parameter: "fir" },
                          { type: "goog-remb" },
                          { type: "transport-cc" }
                        ],
                        parameters: {
                          "level-asymmetry-allowed": 1,
                          "packetization-mode": 1,
                          "profile-level-id": "42e01f"
                        }
                      },
                      {
                        mimeType: "video/rtx",
                        kind: "video",
                        preferredPayloadType: 104,
                        clockRate: 9e4,
                        rtcpFeedback: [],
                        parameters: {
                          apt: 103
                        }
                      },
                      {
                        mimeType: "video/VP9",
                        kind: "video",
                        preferredPayloadType: 105,
                        clockRate: 9e4,
                        rtcpFeedback: [
                          { type: "nack" },
                          { type: "nack", parameter: "pli" },
                          { type: "ccm", parameter: "fir" },
                          { type: "goog-remb" },
                          { type: "transport-cc" }
                        ],
                        parameters: {
                          "profile-id": 0,
                          "x-google-start-bitrate": 1500
                        }
                      },
                      {
                        mimeType: "video/rtx",
                        kind: "video",
                        preferredPayloadType: 106,
                        clockRate: 9e4,
                        rtcpFeedback: [],
                        parameters: {
                          apt: 105
                        }
                      }
                    ],
                    headerExtensions: [
                      {
                        kind: "audio",
                        uri: "urn:ietf:params:rtp-hdrext:sdes:mid",
                        preferredId: 1,
                        preferredEncrypt: false,
                        direction: "sendrecv"
                      },
                      {
                        kind: "video",
                        uri: "urn:ietf:params:rtp-hdrext:sdes:mid",
                        preferredId: 1,
                        preferredEncrypt: false,
                        direction: "sendrecv"
                      },
                      {
                        kind: "video",
                        uri: "urn:ietf:params:rtp-hdrext:sdes:rtp-stream-id",
                        preferredId: 2,
                        preferredEncrypt: false,
                        direction: "recvonly"
                      },
                      {
                        kind: "video",
                        uri: "urn:ietf:params:rtp-hdrext:sdes:repaired-rtp-stream-id",
                        preferredId: 3,
                        preferredEncrypt: false,
                        direction: "recvonly"
                      },
                      {
                        kind: "audio",
                        uri: "http://www.webrtc.org/experiments/rtp-hdrext/abs-send-time",
                        preferredId: 4,
                        preferredEncrypt: false,
                        direction: "sendrecv"
                      },
                      {
                        kind: "video",
                        uri: "http://www.webrtc.org/experiments/rtp-hdrext/abs-send-time",
                        preferredId: 4,
                        preferredEncrypt: false,
                        direction: "sendrecv"
                      },
                      {
                        kind: "audio",
                        uri: "http://www.ietf.org/id/draft-holmer-rmcat-transport-wide-cc-extensions-01",
                        preferredId: 5,
                        preferredEncrypt: false,
                        direction: "recvonly"
                      },
                      {
                        kind: "video",
                        uri: "http://www.ietf.org/id/draft-holmer-rmcat-transport-wide-cc-extensions-01",
                        preferredId: 5,
                        preferredEncrypt: false,
                        direction: "sendrecv"
                      },
                      {
                        kind: "audio",
                        uri: "urn:ietf:params:rtp-hdrext:ssrc-audio-level",
                        preferredId: 10,
                        preferredEncrypt: false,
                        direction: "sendrecv"
                      },
                      {
                        kind: "video",
                        uri: "urn:3gpp:video-orientation",
                        preferredId: 11,
                        preferredEncrypt: false,
                        direction: "sendrecv"
                      },
                      {
                        kind: "video",
                        uri: "urn:ietf:params:rtp-hdrext:toffset",
                        preferredId: 12,
                        preferredEncrypt: false,
                        direction: "sendrecv"
                      }
                    ]
                  });
                }
                function generateNativeRtpCapabilities() {
                  return {
                    codecs: [
                      {
                        mimeType: "audio/opus",
                        kind: "audio",
                        preferredPayloadType: 111,
                        clockRate: 48e3,
                        channels: 2,
                        rtcpFeedback: [{ type: "transport-cc" }],
                        parameters: {
                          minptime: 10,
                          useinbandfec: 1
                        }
                      },
                      {
                        mimeType: "audio/ISAC",
                        kind: "audio",
                        preferredPayloadType: 103,
                        clockRate: 16e3,
                        channels: 1,
                        rtcpFeedback: [{ type: "transport-cc" }],
                        parameters: {}
                      },
                      {
                        mimeType: "audio/CN",
                        kind: "audio",
                        preferredPayloadType: 106,
                        clockRate: 32e3,
                        channels: 1,
                        rtcpFeedback: [{ type: "transport-cc" }],
                        parameters: {}
                      },
                      {
                        mimeType: "audio/foo",
                        kind: "audio",
                        preferredPayloadType: 107,
                        clockRate: 9e4,
                        channels: 4,
                        rtcpFeedback: [{ type: "foo-qwe-qwe" }],
                        parameters: {
                          foo: "lalala"
                        }
                      },
                      {
                        mimeType: "video/BAZCODEC",
                        kind: "video",
                        preferredPayloadType: 100,
                        clockRate: 9e4,
                        rtcpFeedback: [
                          { type: "foo" },
                          { type: "transport-cc" },
                          { type: "ccm", parameter: "fir" },
                          { type: "nack" },
                          { type: "nack", parameter: "pli" }
                        ],
                        parameters: {
                          baz: "1234abcd"
                        }
                      },
                      {
                        mimeType: "video/rtx",
                        kind: "video",
                        preferredPayloadType: 101,
                        clockRate: 9e4,
                        rtcpFeedback: [],
                        parameters: {
                          apt: 100
                        }
                      },
                      {
                        mimeType: "video/VP8",
                        kind: "video",
                        preferredPayloadType: 96,
                        clockRate: 9e4,
                        rtcpFeedback: [
                          { type: "goog-remb" },
                          { type: "transport-cc" },
                          { type: "ccm", parameter: "fir" },
                          { type: "nack" },
                          { type: "nack", parameter: "pli" }
                        ],
                        parameters: {
                          baz: "1234abcd"
                        }
                      },
                      {
                        mimeType: "video/rtx",
                        kind: "video",
                        preferredPayloadType: 97,
                        clockRate: 9e4,
                        rtcpFeedback: [],
                        parameters: {
                          apt: 96
                        }
                      },
                      {
                        mimeType: "video/VP9",
                        kind: "video",
                        preferredPayloadType: 98,
                        clockRate: 9e4,
                        rtcpFeedback: [
                          { type: "goog-remb" },
                          { type: "transport-cc" },
                          { type: "ccm", parameter: "fir" },
                          { type: "nack" },
                          { type: "nack", parameter: "pli" }
                        ],
                        parameters: {
                          "profile-id": 0
                        }
                      },
                      {
                        mimeType: "video/rtx",
                        kind: "video",
                        preferredPayloadType: 99,
                        clockRate: 9e4,
                        rtcpFeedback: [],
                        parameters: {
                          apt: 98
                        }
                      }
                    ],
                    headerExtensions: [
                      {
                        kind: "audio",
                        uri: "urn:ietf:params:rtp-hdrext:sdes:mid",
                        preferredId: 1
                      },
                      {
                        kind: "video",
                        uri: "urn:ietf:params:rtp-hdrext:sdes:mid",
                        preferredId: 1
                      },
                      {
                        kind: "video",
                        uri: "urn:ietf:params:rtp-hdrext:toffset",
                        preferredId: 2
                      },
                      {
                        kind: "video",
                        uri: "http://www.webrtc.org/experiments/rtp-hdrext/abs-send-time",
                        preferredId: 3
                      },
                      {
                        kind: "video",
                        uri: "urn:3gpp:video-orientation",
                        preferredId: 4
                      },
                      {
                        kind: "video",
                        uri: "http://www.ietf.org/id/draft-holmer-rmcat-transport-wide-cc-extensions-01",
                        preferredId: 5
                      },
                      {
                        kind: "video",
                        uri: "http://www.webrtc.org/experiments/rtp-hdrext/playout-delay",
                        preferredId: 6
                      },
                      {
                        kind: "video",
                        // @ts-expect-error --- ON purpose.
                        uri: "http://www.webrtc.org/experiments/rtp-hdrext/video-content-type",
                        preferredId: 7
                      },
                      {
                        kind: "video",
                        // @ts-expect-error --- ON purpose.
                        uri: "http://www.webrtc.org/experiments/rtp-hdrext/video-timing",
                        preferredId: 8
                      },
                      {
                        kind: "audio",
                        uri: "urn:ietf:params:rtp-hdrext:ssrc-audio-level",
                        preferredId: 10
                      }
                    ]
                  };
                }
                function generateNativeSctpCapabilities() {
                  return utils.deepFreeze({
                    numStreams: { OS: 2048, MIS: 2048 }
                  });
                }
                function generateLocalDtlsParameters() {
                  return utils.deepFreeze({
                    fingerprints: [
                      {
                        algorithm: "sha-256",
                        value: "82:5A:68:3D:36:C3:0A:DE:AF:E7:32:43:D2:88:83:57:AC:2D:65:E5:80:C4:B6:FB:AF:1A:A0:21:9F:6D:0C:AD"
                      }
                    ],
                    role: "auto"
                  });
                }
                function generateTransportRemoteParameters() {
                  return {
                    id: generateFakeUuid(),
                    iceParameters: utils.deepFreeze({
                      iceLite: true,
                      password: "yku5ej8nvfaor28lvtrabcx0wkrpkztz",
                      usernameFragment: "h3hk1iz6qqlnqlne"
                    }),
                    iceCandidates: utils.deepFreeze([
                      {
                        foundation: "udpcandidate",
                        address: "9.9.9.9",
                        ip: "9.9.9.9",
                        port: 40533,
                        priority: 1078862079,
                        protocol: "udp",
                        type: "host",
                        tcpType: "passive"
                      },
                      {
                        foundation: "udpcandidate",
                        address: "9.9.9.9",
                        ip: "9:9:9:9:9:9",
                        port: 41333,
                        priority: 1078862089,
                        protocol: "udp",
                        type: "host",
                        tcpType: "passive"
                      }
                    ]),
                    dtlsParameters: utils.deepFreeze({
                      fingerprints: [
                        {
                          algorithm: "sha-256",
                          value: "A9:F4:E0:D2:74:D3:0F:D9:CA:A5:2F:9F:7F:47:FA:F0:C4:72:DD:73:49:D0:3B:14:90:20:51:30:1B:90:8E:71"
                        },
                        {
                          algorithm: "sha-384",
                          value: "03:D9:0B:87:13:98:F6:6D:BC:FC:92:2E:39:D4:E1:97:32:61:30:56:84:70:81:6E:D1:82:97:EA:D9:C1:21:0F:6B:C5:E7:7F:E1:97:0C:17:97:6E:CF:B3:EF:2E:74:B0"
                        },
                        {
                          algorithm: "sha-512",
                          value: "84:27:A4:28:A4:73:AF:43:02:2A:44:68:FF:2F:29:5C:3B:11:9A:60:F4:A8:F0:F5:AC:A0:E3:49:3E:B1:34:53:A9:85:CE:51:9B:ED:87:5E:B8:F4:8E:3D:FA:20:51:B8:96:EE:DA:56:DC:2F:5C:62:79:15:23:E0:21:82:2B:2C"
                        }
                      ],
                      role: "auto"
                    }),
                    sctpParameters: utils.deepFreeze({
                      port: 5e3,
                      OS: 2048,
                      MIS: 2048,
                      maxMessageSize: 2e6
                    })
                  };
                }
                function generateProducerRemoteParameters() {
                  return utils.deepFreeze({
                    id: generateFakeUuid()
                  });
                }
                function generateConsumerRemoteParameters({ id, codecMimeType } = {}) {
                  switch (codecMimeType) {
                    case "audio/opus": {
                      return {
                        id: id ?? generateFakeUuid(),
                        producerId: generateFakeUuid(),
                        kind: "audio",
                        rtpParameters: utils.deepFreeze({
                          codecs: [
                            {
                              mimeType: "audio/opus",
                              payloadType: 100,
                              clockRate: 48e3,
                              channels: 2,
                              rtcpFeedback: [{ type: "transport-cc" }],
                              parameters: {
                                useinbandfec: 1,
                                foo: "bar"
                              }
                            }
                          ],
                          encodings: [
                            {
                              ssrc: 46687003
                            }
                          ],
                          headerExtensions: [
                            {
                              uri: "urn:ietf:params:rtp-hdrext:sdes:mid",
                              id: 1
                            },
                            {
                              uri: "http://www.ietf.org/id/draft-holmer-rmcat-transport-wide-cc-extensions-01",
                              id: 5
                            },
                            {
                              uri: "urn:ietf:params:rtp-hdrext:ssrc-audio-level",
                              id: 10
                            }
                          ],
                          rtcp: {
                            cname: "wB4Ql4lrsxYLjzuN",
                            reducedSize: true,
                            mux: true
                          }
                        })
                      };
                    }
                    case "audio/ISAC": {
                      return {
                        id: id ?? generateFakeUuid(),
                        producerId: generateFakeUuid(),
                        kind: "audio",
                        rtpParameters: utils.deepFreeze({
                          codecs: [
                            {
                              mimeType: "audio/ISAC",
                              payloadType: 111,
                              clockRate: 16e3,
                              channels: 1,
                              rtcpFeedback: [{ type: "transport-cc" }],
                              parameters: {}
                            }
                          ],
                          encodings: [
                            {
                              ssrc: 46687004
                            }
                          ],
                          headerExtensions: [
                            {
                              uri: "urn:ietf:params:rtp-hdrext:sdes:mid",
                              id: 1
                            },
                            {
                              uri: "http://www.ietf.org/id/draft-holmer-rmcat-transport-wide-cc-extensions-01",
                              id: 5
                            }
                          ],
                          rtcp: {
                            cname: "wB4Ql4lrsxYLjzuN",
                            reducedSize: true,
                            mux: true
                          }
                        })
                      };
                    }
                    case "video/VP8": {
                      return {
                        id: id ?? generateFakeUuid(),
                        producerId: generateFakeUuid(),
                        kind: "video",
                        rtpParameters: utils.deepFreeze({
                          codecs: [
                            {
                              mimeType: "video/VP8",
                              payloadType: 101,
                              clockRate: 9e4,
                              rtcpFeedback: [
                                { type: "nack" },
                                { type: "nack", parameter: "pli" },
                                { type: "ccm", parameter: "fir" },
                                { type: "goog-remb" },
                                { type: "transport-cc" }
                              ],
                              parameters: {
                                "x-google-start-bitrate": 1500
                              }
                            },
                            {
                              mimeType: "video/rtx",
                              payloadType: 102,
                              clockRate: 9e4,
                              rtcpFeedback: [],
                              parameters: {
                                apt: 101
                              }
                            }
                          ],
                          encodings: [
                            {
                              ssrc: 99991111,
                              rtx: {
                                ssrc: 99991112
                              }
                            }
                          ],
                          headerExtensions: [
                            {
                              uri: "urn:ietf:params:rtp-hdrext:sdes:mid",
                              id: 1
                            },
                            {
                              uri: "http://www.webrtc.org/experiments/rtp-hdrext/abs-send-time",
                              id: 4
                            },
                            {
                              uri: "http://www.ietf.org/id/draft-holmer-rmcat-transport-wide-cc-extensions-01",
                              id: 5
                            },
                            {
                              uri: "urn:3gpp:video-orientation",
                              id: 11
                            },
                            {
                              uri: "urn:ietf:params:rtp-hdrext:toffset",
                              id: 12
                            }
                          ],
                          rtcp: {
                            cname: "wB4Ql4lrsxYLjzuN",
                            reducedSize: true,
                            mux: true
                          }
                        })
                      };
                    }
                    case "video/H264": {
                      return {
                        id: id ?? generateFakeUuid(),
                        producerId: generateFakeUuid(),
                        kind: "video",
                        rtpParameters: utils.deepFreeze({
                          codecs: [
                            {
                              mimeType: "video/H264",
                              payloadType: 103,
                              clockRate: 9e4,
                              rtcpFeedback: [
                                { type: "nack" },
                                { type: "nack", parameter: "pli" },
                                { type: "ccm", parameter: "fir" },
                                { type: "goog-remb" },
                                { type: "transport-cc" }
                              ],
                              parameters: {
                                "level-asymmetry-allowed": 1,
                                "packetization-mode": 1,
                                "profile-level-id": "42e01f"
                              }
                            },
                            {
                              mimeType: "video/rtx",
                              payloadType: 104,
                              clockRate: 9e4,
                              rtcpFeedback: [],
                              parameters: {
                                apt: 103
                              }
                            }
                          ],
                          encodings: [
                            {
                              ssrc: 99991113,
                              rtx: {
                                ssrc: 99991114
                              }
                            }
                          ],
                          headerExtensions: [
                            {
                              uri: "urn:ietf:params:rtp-hdrext:sdes:mid",
                              id: 1
                            },
                            {
                              uri: "http://www.webrtc.org/experiments/rtp-hdrext/abs-send-time",
                              id: 4
                            },
                            {
                              uri: "http://www.ietf.org/id/draft-holmer-rmcat-transport-wide-cc-extensions-01",
                              id: 5
                            },
                            {
                              uri: "urn:3gpp:video-orientation",
                              id: 11
                            },
                            {
                              uri: "urn:ietf:params:rtp-hdrext:toffset",
                              id: 12
                            }
                          ],
                          rtcp: {
                            cname: "wB4Ql4lrsxYLjzuN",
                            reducedSize: true,
                            mux: true
                          }
                        })
                      };
                    }
                    default: {
                      throw new TypeError(`unknown codecMimeType '${codecMimeType}'`);
                    }
                  }
                }
                function generateDataProducerRemoteParameters() {
                  return utils.deepFreeze({
                    id: generateFakeUuid()
                  });
                }
                function generateDataConsumerRemoteParameters({ id } = {}) {
                  return {
                    id: id ?? generateFakeUuid(),
                    dataProducerId: generateFakeUuid(),
                    sctpStreamParameters: utils.deepFreeze({
                      streamId: 666,
                      maxPacketLifeTime: 5e3,
                      maxRetransmits: void 0
                    })
                  };
                }
              }
            ),
            /***/
            5328: (
              /***/
              (__unused_webpack_module, exports2, __webpack_require__2) => {
                "use strict";
                var _id, _kind, _label, _readyState, _enabled, _muted, _contentHint, _capabilities, _constraints, _settings, _data, _onmute, _onunmute, _onended, _onenabledchange, _onstopped;
                Object.defineProperty(exports2, "__esModule", { value: true });
                exports2.FakeMediaStreamTrack = void 0;
                const uuid_1 = __webpack_require__2(2614);
                const FakeEventTarget_1 = __webpack_require__2(5935);
                const FakeEvent_1 = __webpack_require__2(878);
                const utils_1 = __webpack_require__2(3785);
                const _FakeMediaStreamTrack = class _FakeMediaStreamTrack extends FakeEventTarget_1.FakeEventTarget {
                  constructor({ kind, id, label, contentHint, enabled, muted, readyState, capabilities, constraints, settings, data }) {
                    super();
                    __privateAdd(this, _id);
                    __privateAdd(this, _kind);
                    __privateAdd(this, _label);
                    __privateAdd(this, _readyState);
                    __privateAdd(this, _enabled);
                    __privateAdd(this, _muted);
                    __privateAdd(this, _contentHint);
                    __privateAdd(this, _capabilities);
                    __privateAdd(this, _constraints);
                    __privateAdd(this, _settings);
                    __privateAdd(this, _data);
                    // Events.
                    __privateAdd(this, _onmute, null);
                    __privateAdd(this, _onunmute, null);
                    __privateAdd(this, _onended, null);
                    // Custom events.
                    __privateAdd(this, _onenabledchange, null);
                    __privateAdd(this, _onstopped, null);
                    __privateSet(this, _id, id ?? (0, uuid_1.v4)());
                    __privateSet(this, _kind, kind);
                    __privateSet(this, _label, label ?? "");
                    __privateSet(this, _contentHint, contentHint ?? "");
                    __privateSet(this, _enabled, enabled ?? true);
                    __privateSet(this, _muted, muted ?? false);
                    __privateSet(this, _readyState, readyState ?? "live");
                    __privateSet(this, _capabilities, capabilities ?? {});
                    __privateSet(this, _constraints, constraints ?? {});
                    __privateSet(this, _settings, settings ?? {});
                    __privateSet(this, _data, data ?? {});
                  }
                  get id() {
                    return __privateGet(this, _id);
                  }
                  get kind() {
                    return __privateGet(this, _kind);
                  }
                  get label() {
                    return __privateGet(this, _label);
                  }
                  get contentHint() {
                    return __privateGet(this, _contentHint);
                  }
                  set contentHint(contentHint) {
                    __privateSet(this, _contentHint, contentHint);
                  }
                  get enabled() {
                    return __privateGet(this, _enabled);
                  }
                  /**
                   * Changes `enabled` member value and fires a custom "enabledchange" event.
                   */
                  set enabled(enabled) {
                    const changed = __privateGet(this, _enabled) !== enabled;
                    __privateSet(this, _enabled, enabled);
                    if (changed) {
                      this.dispatchEvent(new FakeEvent_1.FakeEvent("enabledchange"));
                    }
                  }
                  get muted() {
                    return __privateGet(this, _muted);
                  }
                  get readyState() {
                    return __privateGet(this, _readyState);
                  }
                  /**
                   * Application custom data getter.
                   */
                  get data() {
                    return __privateGet(this, _data);
                  }
                  /**
                   * Application custom data setter.
                   */
                  set data(data) {
                    __privateSet(this, _data, data);
                  }
                  get onmute() {
                    return __privateGet(this, _onmute);
                  }
                  set onmute(handler) {
                    if (__privateGet(this, _onmute)) {
                      this.removeEventListener("mute", __privateGet(this, _onmute));
                    }
                    __privateSet(this, _onmute, handler);
                    if (handler) {
                      this.addEventListener("mute", handler);
                    }
                  }
                  get onunmute() {
                    return __privateGet(this, _onunmute);
                  }
                  set onunmute(handler) {
                    if (__privateGet(this, _onunmute)) {
                      this.removeEventListener("unmute", __privateGet(this, _onunmute));
                    }
                    __privateSet(this, _onunmute, handler);
                    if (handler) {
                      this.addEventListener("unmute", handler);
                    }
                  }
                  get onended() {
                    return __privateGet(this, _onended);
                  }
                  set onended(handler) {
                    if (__privateGet(this, _onended)) {
                      this.removeEventListener("ended", __privateGet(this, _onended));
                    }
                    __privateSet(this, _onended, handler);
                    if (handler) {
                      this.addEventListener("ended", handler);
                    }
                  }
                  get onenabledchange() {
                    return __privateGet(this, _onenabledchange);
                  }
                  set onenabledchange(handler) {
                    if (__privateGet(this, _onenabledchange)) {
                      this.removeEventListener("enabledchange", __privateGet(this, _onenabledchange));
                    }
                    __privateSet(this, _onenabledchange, handler);
                    if (handler) {
                      this.addEventListener("enabledchange", handler);
                    }
                  }
                  get onstopped() {
                    return __privateGet(this, _onstopped);
                  }
                  set onstopped(handler) {
                    if (__privateGet(this, _onstopped)) {
                      this.removeEventListener("stopped", __privateGet(this, _onstopped));
                    }
                    __privateSet(this, _onstopped, handler);
                    if (handler) {
                      this.addEventListener("stopped", handler);
                    }
                  }
                  addEventListener(type, listener, options) {
                    super.addEventListener(type, listener, options);
                  }
                  removeEventListener(type, listener, options) {
                    super.removeEventListener(type, listener, options);
                  }
                  /**
                   * Changes `readyState` member to "ended" and fires a custom "stopped" event
                   * (if not already stopped).
                   */
                  stop() {
                    if (__privateGet(this, _readyState) === "ended") {
                      return;
                    }
                    __privateSet(this, _readyState, "ended");
                    this.dispatchEvent(new FakeEvent_1.FakeEvent("stopped"));
                  }
                  /**
                   * Clones current track into another FakeMediaStreamTrack. `id` and `data`
                   * can be optionally given.
                   */
                  clone({ id, data } = {}) {
                    return new _FakeMediaStreamTrack({
                      id: id ?? (0, uuid_1.v4)(),
                      kind: __privateGet(this, _kind),
                      label: __privateGet(this, _label),
                      contentHint: __privateGet(this, _contentHint),
                      enabled: __privateGet(this, _enabled),
                      muted: __privateGet(this, _muted),
                      readyState: __privateGet(this, _readyState),
                      capabilities: (0, utils_1.clone)(__privateGet(this, _capabilities)),
                      constraints: (0, utils_1.clone)(__privateGet(this, _constraints)),
                      settings: (0, utils_1.clone)(__privateGet(this, _settings)),
                      data: data ?? (0, utils_1.clone)(__privateGet(this, _data))
                    });
                  }
                  getCapabilities() {
                    return __privateGet(this, _capabilities);
                  }
                  getConstraints() {
                    return __privateGet(this, _constraints);
                  }
                  async applyConstraints(constraints = {}) {
                    __privateSet(this, _constraints, constraints);
                    return Promise.resolve();
                  }
                  getSettings() {
                    return __privateGet(this, _settings);
                  }
                  /**
                   * Simulates a remotely triggered stop. It fires a custom "stopped" event and
                   * the standard "ended" event (if the track was not already stopped).
                   */
                  remoteStop() {
                    if (__privateGet(this, _readyState) === "ended") {
                      return;
                    }
                    __privateSet(this, _readyState, "ended");
                    this.dispatchEvent(new FakeEvent_1.FakeEvent("stopped"));
                    this.dispatchEvent(new FakeEvent_1.FakeEvent("ended"));
                  }
                  /**
                   * Simulates a remotely triggered mute. It fires a "mute" event (if the track
                   * was not already muted).
                   */
                  remoteMute() {
                    if (__privateGet(this, _muted)) {
                      return;
                    }
                    __privateSet(this, _muted, true);
                    this.dispatchEvent(new FakeEvent_1.FakeEvent("mute"));
                  }
                  /**
                   * Simulates a remotely triggered unmute. It fires an "unmute" event (if the
                   * track was muted).
                   */
                  remoteUnmute() {
                    if (!__privateGet(this, _muted)) {
                      return;
                    }
                    __privateSet(this, _muted, false);
                    this.dispatchEvent(new FakeEvent_1.FakeEvent("unmute"));
                  }
                };
                _id = new WeakMap();
                _kind = new WeakMap();
                _label = new WeakMap();
                _readyState = new WeakMap();
                _enabled = new WeakMap();
                _muted = new WeakMap();
                _contentHint = new WeakMap();
                _capabilities = new WeakMap();
                _constraints = new WeakMap();
                _settings = new WeakMap();
                _data = new WeakMap();
                _onmute = new WeakMap();
                _onunmute = new WeakMap();
                _onended = new WeakMap();
                _onenabledchange = new WeakMap();
                _onstopped = new WeakMap();
                let FakeMediaStreamTrack = _FakeMediaStreamTrack;
                exports2.FakeMediaStreamTrack = FakeMediaStreamTrack;
              }
            ),
            /***/
            5414: (
              /***/
              (module2) => {
                !function(t, e) {
                  if (true) module2.exports = e();
                  else {
                    var o, a;
                  }
                }(self, function() {
                  return (() => {
                    var t = { 43: function(t2, e2, a2) {
                      var o2, s;
                      !function(r, l) {
                        "use strict";
                        o2 = function() {
                          var t3 = function() {
                          }, e3 = "undefined", a3 = typeof window !== e3 && typeof window.navigator !== e3 && /Trident\/|MSIE /.test(window.navigator.userAgent), o3 = ["trace", "debug", "info", "warn", "error"];
                          function s2(t4, e4) {
                            var a4 = t4[e4];
                            if ("function" == typeof a4.bind) return a4.bind(t4);
                            try {
                              return Function.prototype.bind.call(a4, t4);
                            } catch (e5) {
                              return function() {
                                return Function.prototype.apply.apply(a4, [t4, arguments]);
                              };
                            }
                          }
                          function r2() {
                            console.log && (console.log.apply ? console.log.apply(console, arguments) : Function.prototype.apply.apply(console.log, [console, arguments])), console.trace && console.trace();
                          }
                          function l2(o4) {
                            return "debug" === o4 && (o4 = "log"), typeof console !== e3 && ("trace" === o4 && a3 ? r2 : void 0 !== console[o4] ? s2(console, o4) : void 0 !== console.log ? s2(console, "log") : t3);
                          }
                          function c(e4, a4) {
                            for (var s3 = 0; s3 < o3.length; s3++) {
                              var r3 = o3[s3];
                              this[r3] = s3 < e4 ? t3 : this.methodFactory(r3, e4, a4);
                            }
                            this.log = this.debug;
                          }
                          function n(t4, a4, o4) {
                            return function() {
                              typeof console !== e3 && (c.call(this, a4, o4), this[t4].apply(this, arguments));
                            };
                          }
                          function i(t4, e4, a4) {
                            return l2(t4) || n.apply(this, arguments);
                          }
                          function _(t4, a4, s3) {
                            var r3, l3 = this, n2 = "loglevel";
                            function _2() {
                              var t5;
                              if (typeof window !== e3 && n2) {
                                try {
                                  t5 = window.localStorage[n2];
                                } catch (t6) {
                                }
                                if (typeof t5 === e3) try {
                                  var a5 = window.document.cookie, o4 = a5.indexOf(encodeURIComponent(n2) + "=");
                                  -1 !== o4 && (t5 = /^([^;]+)/.exec(a5.slice(o4))[1]);
                                } catch (t6) {
                                }
                                return void 0 === l3.levels[t5] && (t5 = void 0), t5;
                              }
                            }
                            "string" == typeof t4 ? n2 += ":" + t4 : "symbol" == typeof t4 && (n2 = void 0), l3.name = t4, l3.levels = { TRACE: 0, DEBUG: 1, INFO: 2, WARN: 3, ERROR: 4, SILENT: 5 }, l3.methodFactory = s3 || i, l3.getLevel = function() {
                              return r3;
                            }, l3.setLevel = function(a5, s4) {
                              if ("string" == typeof a5 && void 0 !== l3.levels[a5.toUpperCase()] && (a5 = l3.levels[a5.toUpperCase()]), !("number" == typeof a5 && a5 >= 0 && a5 <= l3.levels.SILENT)) throw "log.setLevel() called with invalid level: " + a5;
                              if (r3 = a5, false !== s4 && function(t5) {
                                var a6 = (o3[t5] || "silent").toUpperCase();
                                if (typeof window !== e3 && n2) {
                                  try {
                                    return void (window.localStorage[n2] = a6);
                                  } catch (t6) {
                                  }
                                  try {
                                    window.document.cookie = encodeURIComponent(n2) + "=" + a6 + ";";
                                  } catch (t6) {
                                  }
                                }
                              }(a5), c.call(l3, a5, t4), typeof console === e3 && a5 < l3.levels.SILENT) return "No console available for logging";
                            }, l3.setDefaultLevel = function(t5) {
                              _2() || l3.setLevel(t5, false);
                            }, l3.enableAll = function(t5) {
                              l3.setLevel(l3.levels.TRACE, t5);
                            }, l3.disableAll = function(t5) {
                              l3.setLevel(l3.levels.SILENT, t5);
                            };
                            var d2 = _2();
                            null == d2 && (d2 = null == a4 ? "WARN" : a4), l3.setLevel(d2, false);
                          }
                          var d = new _(), u = {};
                          d.getLogger = function(t4) {
                            if ("symbol" != typeof t4 && "string" != typeof t4 || "" === t4) throw new TypeError("You must supply a name when creating a logger.");
                            var e4 = u[t4];
                            return e4 || (e4 = u[t4] = new _(t4, d.getLevel(), d.methodFactory)), e4;
                          };
                          var p = typeof window !== e3 ? window.log : void 0;
                          return d.noConflict = function() {
                            return typeof window !== e3 && window.log === d && (window.log = p), d;
                          }, d.getLoggers = function() {
                            return u;
                          }, d.default = d, d;
                        }, void 0 === (s = o2.call(e2, a2, e2, t2)) || (t2.exports = s);
                      }();
                    } }, e = {};
                    function a(o2) {
                      var s = e[o2];
                      if (void 0 !== s) return s.exports;
                      var r = e[o2] = { exports: {} };
                      return t[o2].call(r.exports, r, r.exports, a), r.exports;
                    }
                    a.d = (t2, e2) => {
                      for (var o2 in e2) a.o(e2, o2) && !a.o(t2, o2) && Object.defineProperty(t2, o2, { enumerable: true, get: e2[o2] });
                    }, a.o = (t2, e2) => Object.prototype.hasOwnProperty.call(t2, e2), a.r = (t2) => {
                      "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(t2, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(t2, "__esModule", { value: true });
                    };
                    var o = {};
                    return (() => {
                      "use strict";
                      a.r(o), a.d(o, { VideoSDKMetrics: () => st });
                      const t2 = "inbound", e2 = "outbound", s = { codec_id_in: "", codec_in: { mime_type: null, clock_rate: null, sdp_fmtp_line: null }, delta_jitter_ms_in: 0, delta_rtt_ms_out: null, percent_packets_lost_in: 0, delta_packets_in: 0, delta_packets_lost_in: 0, total_packets_in: 0, total_packets_lost_in: 0, total_KBytes_in: 0, delta_KBytes_in: 0, delta_kbs_in: 0, timestamp_in: null, ssrc: "", total_concealment_events: 0, delta_concealment_events: 0, total_inserted_samples_for_decelaration: 0, delta_inserted_samples_for_decelaration: 0, total_removed_samples_for_accelaration: 0, delta_removed_samples_for_accelaration: 0, direction: t2 }, r = { codec_id_out: "", codec_out: { mime_type: null, clock_rate: null, sdp_fmtp_line: null }, delta_jitter_ms_out: 0, delta_rtt_ms_out: null, percent_packets_lost_out: 0, delta_packets_out: 0, delta_packets_lost_out: 0, total_packets_out: 0, total_packets_lost_out: 0, total_KBytes_out: 0, delta_KBytes_out: 0, delta_kbs_out: 0, timestamp_out: null, ssrc: "", direction: e2 }, l = { codec_id_in: "", size_in: { width: null, height: null, framerate: null }, codec_in: { mime_type: null, clock_rate: null }, delta_jitter_ms_in: 0, percent_packets_lost_in: 0, delta_packets_in: 0, delta_packets_lost_in: 0, total_packets_in: 0, total_packets_lost_in: 0, total_KBytes_in: 0, delta_KBytes_in: 0, delta_kbs_in: 0, ssrc: "", direction: t2 }, c = { codec_id_out: "", size_out: { width: null, height: null, framerate: null }, codec_out: { mime_type: null, clock_rate: null }, delta_jitter_ms_out: 0, delta_rtt_ms_out: null, percent_packets_lost_out: 0, delta_packets_out: 0, delta_packets_lost_out: 0, total_packets_out: 0, total_packets_lost_out: 0, total_KBytes_out: 0, delta_KBytes_out: 0, delta_kbs_out: 0, limitation_out: { reason: null, durations: null, resolutionChanges: 0 }, timestamp_out: null, ssrc: "", direction: e2 }, n = "inbound-rtp", i = "bytesReceived", _ = "bytesSent", d = "currentRoundTripTime", u = "roundTripTime", p = "fractionLost", m = "frameHeight", y = "frameWidth", v = "qualityLimitationReason", k = "qualityLimitationDurations", f = "qualityLimitationResolutionChanges", b = "jitter", h = "packetsLost", g = "packetsReceived", w = "packetsSent", O = "responsesReceived", S = "selected", I = "totalRoundTripTime", j = "roundTripTimeMeasurements", P = "framesDecoded", R = "framesEncoded", L = "totalDecodeTime", T = "totalEncodeTime", C = "pliCount", B = "nackCount", K = "audio", E = "video", N = { 0: "ETHERNET", 2: "CELLULAR_5G", 3: "WIFI", 5: "CELLULAR_4G", 10: "CELLULAR" }, $ = "audio", z = "video", D = "network", F = "data";
                      var A = a(43);
                      const x = () => `${(/* @__PURE__ */ new Date()).toISOString()} | metrics`, M = (t3, e3, a2) => `${t3} | ${e3} | ${a2}`;
                      A.setDefaultLevel(A.levels.TRACE);
                      const U = (t3, e3, a2) => {
                        a2 ? A.debug(M(x(), t3, e3), a2) : A.debug(M(x(), t3, e3));
                      }, q = (t3, e3) => {
                        A.warn(M(x(), t3, e3));
                      }, W = (t3, e3) => {
                        A.error(M(x(), t3, e3));
                      }, G = "extractor   ", H = (e3, a2, o2) => {
                        if (!a2) return null;
                        const n2 = {};
                        let i2 = a2.audio[e3];
                        i2 || (i2 = o2 === t2 ? { ...s } : { ...r }), n2.audio = i2;
                        let _2 = a2.video[e3];
                        return _2 || (_2 = o2 === t2 ? { ...l } : { ...c }), n2.video = _2, n2;
                      }, V = (t3, e3, a2, o2) => {
                        let s2 = false;
                        const r2 = o2[e3].total_rtt_ms_out, l2 = o2[e3].total_rtt_measure_out, c2 = a2 ? a2[e3].total_rtt_ms_out : 0, n2 = a2 ? a2[e3].total_rtt_measure_out : 0, i2 = { rtt: null, totalRTT: r2, totalRTTMeasurements: l2 };
                        if (t3.timestamp === o2[e3].timestamp_out) return i2;
                        if (!Object.prototype.hasOwnProperty.call(t3, u)) return i2;
                        if (Object.prototype.hasOwnProperty.call(t3, j) && (s2 = true, 0 === Number(t3.roundTripTimeMeasurements) || Number(t3.roundTripTimeMeasurements) - n2 === l2)) return i2;
                        const _2 = Number(1e3) * Number(t3.roundTripTime);
                        let d2 = r2 + _2, p2 = l2 + 1;
                        return s2 && (d2 = Number(1e3) * Number(t3.totalRoundTripTime) - c2, p2 = Number(t3.roundTripTimeMeasurements) - n2), { rtt: _2, totalRTT: d2, totalRTTMeasurements: p2 };
                      }, J = (t3, e3, a2) => t3.timestamp === a2[e3].timestamp_out ? null : Object.prototype.hasOwnProperty.call(t3, b) ? Number(1e3) * (Number(t3.jitter) || 0) : null, Y = (t3, e3, a2, o2) => {
                        if (!Object.prototype.hasOwnProperty.call(t3, w) || !Object.prototype.hasOwnProperty.call(t3, _)) return { packetsSent: a2[e3].total_packets_out, packetsLost: a2[e3].total_packets_lost_out, bytesSent: a2[e3].total_KBytes_out };
                        const s2 = Number(t3.packetsSent) || 0 - (o2 ? o2[e3].total_packets_out : 0), r2 = s2 - a2[e3].total_packets_out, l2 = Number(t3.bytesSent) / 1024 - (o2 ? o2[e3].total_KBytes_out : 0), c2 = l2 - a2[e3].total_KBytes_out, n2 = t3.timestamp || Date.now(), i2 = o2 ? o2.timestamp : null;
                        let d2 = a2.timestamp;
                        !d2 && i2 && (d2 = i2);
                        const u2 = d2 ? n2 - d2 : 0;
                        return { packetsSent: s2, deltaPacketsSent: r2, KBytesSent: l2, deltaKBytesSent: c2, kbsSent: u2 > 0 ? 8e-3 * c2 * 1024 / u2 * 1e3 : 0 };
                      }, Q = (t3, e3, a2, o2) => {
                        let s2 = a2[e3].total_packets_lost_out, r2 = 0, l2 = 0;
                        return Object.prototype.hasOwnProperty.call(t3, h) && (s2 = Number(t3.packetsLost) || 0 - (o2 ? o2[e3].total_packets_lost_out : 0), r2 = s2 - a2[e3].total_packets_lost_out), Object.prototype.hasOwnProperty.call(t3, p) && (l2 = Number(100 * t3.fractionLost)), { packetsLost: s2, deltaPacketsLost: r2, fractionLost: l2 };
                      }, X = (t3, e3, a2, o2) => {
                        if (!Object.prototype.hasOwnProperty.call(t3, g) || !Object.prototype.hasOwnProperty.call(t3, h) || !Object.prototype.hasOwnProperty.call(t3, i)) return { percent_packets_lost: a2[e3].percent_packets_lost_in, packetsReceived: a2[e3].total_packets_in, packetsLost: a2[e3].total_packets_lost_in, bytesReceived: a2[e3].total_KBytes_in };
                        const s2 = (Number(t3.packetsReceived) || 0) - (o2 ? o2[e3].total_packets_in : 0), r2 = (Number(t3.packetsLost) || 0) - (o2 ? o2[e3].total_packets_lost_in : 0), l2 = r2 - a2[e3].total_packets_lost_in, c2 = s2 - a2[e3].total_packets_in, n2 = s2 !== a2[e3].total_packets_in ? 100 * l2 / (l2 + c2) : 0, _2 = Number(t3.bytesReceived) / 1024 - (o2 ? o2[e3].total_KBytes_in : 0), d2 = _2 - a2[e3].total_KBytes_in, u2 = t3.timestamp || Date.now(), p2 = o2 ? o2.timestamp : null;
                        let m2 = a2.timestamp;
                        !m2 && p2 && (m2 = p2);
                        const y2 = m2 ? u2 - m2 : 0;
                        return { percentPacketsLost: n2, packetsReceived: s2, deltaPacketsReceived: c2, packetsLost: r2, deltaPacketsLost: l2, KBytesReceived: _2, deltaKBytesReceived: d2, kbsReceived: y2 > 0 ? 8e-3 * d2 * 1024 / y2 * 1e3 : 0 };
                      }, Z = (t3) => "relay" !== t3.candidateType ? "" : t3.relayProtocol || "", tt = (t3) => Object.prototype.hasOwnProperty.call(t3, m) && Object.prototype.hasOwnProperty.call(t3, y) ? { width: t3.frameWidth || null, height: t3.frameHeight || null, framerate: t3.framesPerSecond } : { width: null, height: null, framerate: null };
                      class et {
                        constructor(t3, e3) {
                          this._callbacks = { onStatsCollected: null }, this._id = `collector-${e3}`, this._moduleName = this._id, this._probeId = e3, this._config = t3, this._state = "idle", this._statsReports = [];
                        }
                        registerCallback(t3, e3, a2) {
                          t3 in this._callbacks ? (this._callbacks[t3] = { callback: e3, context: a2 }, U(this._moduleName, `registered callback '${t3}'`)) : W(this._moduleName, `can't register callback for '${t3}' - not found`);
                        }
                        unregisterCallback(t3) {
                          t3 in this._callbacks ? (this._callbacks[t3] = null, delete this._callbacks[t3], U(this._moduleName, `unregistered callback '${t3}'`)) : W(this._moduleName, `can't unregister callback for '${t3}' - not found`);
                        }
                        analyze(a2, o2) {
                          const i2 = ((t3) => {
                            const e3 = { name: "", meetingId: "", peerId: "", timestamp: null, count: 0, audio: {}, video: {}, network: { infrastructure: 3 }, data: { delta_kbs_bandwidth_in: 0, delta_kbs_bandwidth_out: 0, delta_rtt_connectivity_ms: null, total_rtt_connectivity_ms: 0 } };
                            if (t3) {
                              const e4 = { ...t3, audio: {}, video: {}, data: { ...t3.data }, network: { ...t3.network } };
                              return Object.keys(t3.audio).forEach((a3) => {
                                e4.audio[a3] = { ...t3.audio[a3] };
                              }), Object.keys(t3.video).forEach((a3) => {
                                e4.video[a3] = { ...t3.video[a3] };
                              }), e4;
                            }
                            return { ...e3, audio: {}, video: {}, data: { ...e3.data }, network: { ...e3.network } };
                          })(o2);
                          i2.name = this._config.name, i2.meetingId = this._config.meetingId, i2.peerId = this._config.peerId, i2.count = o2 ? o2.count + 1 : 1;
                          let _2 = null;
                          return a2.forEach((a3) => {
                            !_2 && a3.timestamp && (_2 = a3.timestamp), ((a4, o3, s2, r2) => {
                              if (!a4) return [];
                              switch (a4.type) {
                                case "candidate-pair":
                                  let l2 = false;
                                  if (a4.nominated && "succeeded" === a4.state && (l2 = true, U(G, `analyze() - got stats ${a4.type} for ${s2}`, a4), S in a4 && !a4.selected && (l2 = false)), l2) {
                                    a4.localCandidateId, a4.remoteCandidateId;
                                    const t3 = ((t4, e4, a5) => {
                                      const o4 = (t4.bytesReceived || 0) / 1024 - (a5 ? a5.data.total_KBytes_in : 0), s3 = (t4.bytesSent || 0) / 1024 - (a5 ? a5.data.total_KBytes_out : 0), r3 = t4.timestamp || Date.now(), l3 = o4 - e4.data.total_KBytes_in, c3 = s3 - e4.data.total_KBytes_out, n2 = a5 ? a5.timestamp : null;
                                      let i3 = e4.timestamp;
                                      !i3 && n2 && (i3 = n2);
                                      const _3 = i3 ? r3 - i3 : 0;
                                      return { total_KBytes_received: o4, total_KBytes_sent: s3, delta_KBytes_received: l3, delta_KBytes_sent: c3, kbs_speed_received: _3 > 0 ? 8e-3 * l3 * 1024 / _3 * 1e3 : 0, kbs_speed_sent: _3 > 0 ? 8e-3 * c3 * 1024 / _3 * 1e3 : 0 };
                                    })(a4, o3, r2), e3 = (((t4) => {
                                      t4.availableIncomingBitrate, t4.availableOutgoingBitrate;
                                    })(a4), ((t4, e4, a5, o4) => {
                                      if (!Object.prototype.hasOwnProperty.call(t4, d)) return { rtt: null, totalRTT: o4.data.total_rtt_connectivity_ms, totalRTTMeasurements: o4.data.total_rtt_connectivity_measure };
                                      const s3 = Number(1e3) * Number(t4.currentRoundTripTime);
                                      let r3 = o4.data.total_rtt_connectivity_ms + s3, l3 = o4.data.total_rtt_connectivity_measure + 1;
                                      return Object.prototype.hasOwnProperty.call(t4, I) && (r3 = Number(1e3) * Number(t4.totalRoundTripTime) - (a5 ? a5.data.total_rtt_connectivity_ms : 0)), Object.prototype.hasOwnProperty.call(t4, O) && (l3 = Number(t4.responsesReceived) - (a5 ? a5.data.total_rtt_connectivity_measure : 0)), { rtt: s3, totalRTT: r3, totalRTTMeasurements: l3 };
                                    })(a4, 0, r2, o3));
                                    return [{ type: F, value: { total_KBytes_in: t3.total_KBytes_received } }, { type: F, value: { total_KBytes_out: t3.total_KBytes_sent } }, { type: F, value: { delta_KBytes_in: t3.delta_KBytes_received } }, { type: F, value: { delta_KBytes_out: t3.delta_KBytes_sent } }, { type: F, value: { delta_kbs_in: t3.kbs_speed_received } }, { type: F, value: { delta_kbs_out: t3.kbs_speed_sent } }, { type: F, value: { delta_rtt_connectivity_ms: e3.rtt } }];
                                  }
                                  break;
                                case "local-candidate":
                                  if (a4.id === o3.network.local_candidate_id) return [{ type: D, value: { infrastructure: a4.networkType } }, { type: D, value: { local_candidate_protocol: a4.protocol || "" } }, { type: D, value: { local_candidate_relay_protocol: Z(a4) } }];
                                  break;
                                case n: {
                                  U(G, `analyze() - got stats ${a4.type} for ${s2}`, a4);
                                  const e3 = a4.ssrc, l3 = H(e3, o3, t2);
                                  l3 && (l3.timestamp = o3.timestamp);
                                  const c3 = H(e3, r2, t2);
                                  if (c3 && (c3.timestamp = r2.timestamp), a4.kind === K) {
                                    const t3 = X(a4, K, l3, c3), o4 = J(a4, K, l3), s3 = a4.codecId || "", r3 = ((t4, e4, a5, o5) => {
                                      const s4 = Number(t4.concealmentEvents) || 0, r4 = s4 - (a5.audio.total_concealment_events || 0), l4 = Number(t4.insertedSamplesForDeceleration) || 0, c4 = l4 - (a5.audio.total_inserted_samples_for_decelaration || 0), n2 = Number(t4.removedSamplesForAcceleration) || 0;
                                      return { totalConcealmentEvents: s4, deltaConcealmentEvents: r4, totalInsertedSamplesForDecelaration: l4, deltaInsertedSamplesForDecelaration: c4, totalRemovedSamplesForAccelaration: n2, deltaRemovedSampleForAccelaration: n2 - (a5.audio.total_removed_samples_for_accelaration || 0) };
                                    })(a4, 0, l3);
                                    return [{ ssrc: e3, type: $, value: { codec_id_in: s3 } }, { ssrc: e3, type: $, value: { total_packets_in: t3.packetsReceived } }, { ssrc: e3, type: $, value: { delta_packets_in: t3.deltaPacketsReceived } }, { ssrc: e3, type: $, value: { total_packets_lost_in: t3.packetsLost } }, { ssrc: e3, type: $, value: { delta_packets_lost_in: t3.deltaPacketsLost } }, { ssrc: e3, type: $, value: { percent_packets_lost_in: t3.percentPacketsLost } }, { ssrc: e3, type: $, value: { total_KBytes_in: t3.KBytesReceived } }, { ssrc: e3, type: $, value: { delta_KBytes_in: t3.deltaKBytesReceived } }, { ssrc: e3, type: $, value: { delta_kbs_in: t3.kbsReceived } }, { ssrc: e3, type: $, value: { delta_jitter_ms_in: o4 } }, { ssrc: e3, type: $, value: { total_concealment_events: r3.totalConcealmentEvents } }, { ssrc: e3, type: $, value: { delta_concealment_events: r3.deltaConcealmentEvents } }, { ssrc: e3, type: $, value: { total_inserted_samples_for_decelaration: r3.totalInsertedSamplesForDecelaration } }, { ssrc: e3, type: $, value: { delta_inserted_samples_for_decelaration: r3.deltaInsertedSamplesForDecelaration } }, { ssrc: e3, type: $, value: { total_removed_samples_for_accelaration: r3.totalRemovedSamplesForAccelaration } }, { ssrc: e3, type: $, value: { delta_removed_samples_for_accelaration: r3.deltaRemovedSampleForAccelaration } }, { ssrc: e3, type: $, value: { track_in: a4.trackId } }, { ssrc: e3, type: $, value: { track_id_in: a4.trackIdentifier } }, { ssrc: e3, type: $, value: { media_source_id: a4.mediaSourceId } }];
                                  }
                                  if (a4.kind === E) {
                                    ((t4, e4) => {
                                      if (!Object.prototype.hasOwnProperty.call(t4, P) || !Object.prototype.hasOwnProperty.call(t4, L)) return { delta_ms_decode_frame: e4.video.delta_ms_decode_frame_in, frames_decoded: e4.video.total_frames_decoded_in, total_decode_time: e4.video.total_time_decoded_in };
                                      t4.framesDecoded;
                                      t4.totalDecodeTime, e4.video.total_time_decoded_in, e4.video.total_frames_decoded_in;
                                    })(a4, l3);
                                    const t3 = X(a4, E, l3, c3), o4 = J(a4, E, l3), s3 = (a4.decoderImplementation, a4.codecId || null), r3 = tt(a4);
                                    return ((t4, e4, a5) => {
                                      if (!Object.prototype.hasOwnProperty.call(t4, C) || !Object.prototype.hasOwnProperty.call(t4, B)) return { pliCount: e4.total_pli_sent_in, nackCount: e4.total_nack_sent_in, deltaPliCount: 0, deltaNackCount: 0 };
                                      t4.pliCount, a5 && a5.video.total_pli_sent_in, t4.nackCount, a5 && a5.video.total_nack_sent_in, e4.video.total_pli_sent_in, e4.video.total_nack_sent_in;
                                    })(a4, l3, c3), [{ ssrc: e3, type: z, value: { codec_id_in: s3 } }, { ssrc: e3, type: z, value: { total_packets_in: t3.packetsReceived } }, { ssrc: e3, type: z, value: { delta_packets_in: t3.deltaPacketsReceived } }, { ssrc: e3, type: z, value: { total_packets_lost_in: t3.packetsLost } }, { ssrc: e3, type: z, value: { delta_packets_lost_in: t3.deltaPacketsLost } }, { ssrc: e3, type: z, value: { percent_packets_lost_in: t3.percentPacketsLost } }, { ssrc: e3, type: z, value: { total_KBytes_in: t3.KBytesReceived } }, { ssrc: e3, type: z, value: { delta_KBytes_in: t3.deltaKBytesReceived } }, { ssrc: e3, type: z, value: { delta_kbs_in: t3.kbsReceived } }, { ssrc: e3, type: z, value: { delta_jitter_ms_in: o4 } }, { ssrc: e3, type: z, value: { size_in: r3 } }, { ssrc: e3, type: z, value: { track_in: a4.trackId } }, { ssrc: e3, type: z, value: { track_id_in: a4.trackIdentifier } }, { ssrc: e3, type: z, value: { media_source_id: a4.mediaSourceId } }, { ssrc: e3, type: z, value: { pause_count: a4.pauseCount } }, { ssrc: e3, type: z, value: { total_pauses_duration: a4.totalPausesDuration } }, { ssrc: e3, type: z, value: { freeze_count: a4.freezeCount } }, { ssrc: e3, type: z, value: { total_freezes_duration: a4.totalFreezesDuration } }];
                                  }
                                  break;
                                }
                                case "outbound-rtp": {
                                  U(G, `analyze() - got stats ${a4.type} for ${s2}`, a4);
                                  const t3 = a4.ssrc, l3 = H(t3, o3, e2);
                                  l3 && (l3.timestamp = o3.timestamp);
                                  const c3 = H(t3, r2, e2);
                                  if (c3 && (c3.timestamp = r2.timestamp), a4.kind === K) {
                                    const e3 = a4.codecId || null, o4 = Y(a4, K, l3, c3);
                                    return [{ ssrc: t3, type: $, value: { codec_id_out: e3 } }, { ssrc: t3, type: $, value: { total_packets_out: o4.packetsSent } }, { ssrc: t3, type: $, value: { delta_packets_out: o4.deltaPacketsSent } }, { ssrc: t3, type: $, value: { total_KBytes_out: o4.KBytesSent } }, { type: $, value: { delta_KBytes_out: o4.deltaKBytesSent } }, { ssrc: t3, type: $, value: { delta_kbs_out: o4.kbsSent } }, { ssrc: t3, type: $, value: { track_out: a4.trackId } }, { ssrc: t3, type: $, value: { track_id_out: a4.trackIdentifier } }, { ssrc: t3, type: $, value: { media_source_id: a4.mediaSourceId } }];
                                  }
                                  if (a4.kind === E) {
                                    a4.encoderImplementation;
                                    const e3 = a4.codecId || null, o4 = (((t4, e4) => {
                                      if (!Object.prototype.hasOwnProperty.call(t4, R) || !Object.prototype.hasOwnProperty.call(t4, T)) return { delta_ms_encode_frame: e4.video.delta_ms_encode_frame_out, frames_encoded: e4.video.total_frames_encoded_out, total_encode_time: e4.video.total_time_encoded_out };
                                      t4.framesEncoded;
                                      t4.totalEncodeTime, e4.video.total_time_encoded_out, e4.video.total_frames_encoded_out;
                                    })(a4, l3), tt(a4)), s3 = ((t4) => {
                                      const e4 = Object.prototype.hasOwnProperty.call(t4, v) ? t4.qualityLimitationReason : null, a5 = Object.prototype.hasOwnProperty.call(t4, f) ? t4.qualityLimitationResolutionChanges : null, o5 = Object.prototype.hasOwnProperty.call(t4, k) ? t4.qualityLimitationDurations : null;
                                      return o5 && Object.keys(o5).forEach((t5) => {
                                        o5[t5] > 1e3 && (o5[t5] = Number(o5[t5] / 1e3));
                                      }), { reason: e4, durations: o5, resolutionChanges: a5 };
                                    })(a4), r3 = (((t4, e4, a5) => {
                                      if (!Object.prototype.hasOwnProperty.call(t4, C) || !Object.prototype.hasOwnProperty.call(t4, B)) return { pliCount: e4.total_pli_received_out, nackCount: e4.total_nack_received_out, deltaPliCount: 0, deltaNackCount: 0 };
                                      t4.pliCount, a5 && a5.video.total_pli_received_out, t4.nackCount, a5 && a5.video.total_nack_received_out, e4.video.total_pli_received_out, e4.video.total_nack_received_out;
                                    })(a4, l3, c3), Y(a4, E, l3, c3));
                                    return [{ ssrc: t3, type: z, value: { codec_id_out: e3 } }, { ssrc: t3, type: z, value: { total_packets_out: r3.packetsSent } }, { ssrc: t3, type: z, value: { delta_packets_out: r3.deltaPacketsSent } }, { ssrc: t3, type: z, value: { total_KBytes_out: r3.KBytesSent } }, { ssrc: t3, type: z, value: { delta_KBytes_out: r3.deltaKBytesSent } }, { ssrc: t3, type: z, value: { delta_kbs_out: r3.kbsSent } }, { ssrc: t3, type: z, value: { size_out: o4 } }, { ssrc: t3, type: z, value: { limitation_out: s3 } }, { ssrc: t3, type: z, value: { track_out: a4.trackId } }, { ssrc: t3, type: z, value: { track_id_out: a4.trackIdentifier } }, { ssrc: t3, type: z, value: { media_source_id: a4.mediaSourceId } }];
                                  }
                                  break;
                                }
                                case "media-source": {
                                  U(G, `analyze() - got stats ${a4.type} for ${s2}`, a4);
                                  const t3 = [];
                                  return Object.keys(o3.audio).forEach((e3) => {
                                    const s3 = o3.audio[e3];
                                    if (s3.media_source_id === a4.id) {
                                      var r3 = a4.trackIdentifier;
                                      t3.push({ ssrc: s3.ssrc, type: $, value: { track_id_out: r3 } });
                                    }
                                  }), Object.keys(o3.video).forEach((e3) => {
                                    const s3 = o3.video[e3];
                                    if (s3.media_source_id === a4.id) {
                                      var r3 = a4.trackIdentifier;
                                      t3.push({ ssrc: s3.ssrc, type: z, value: { track_id_out: r3 } });
                                    }
                                  }), t3;
                                }
                                case "track": {
                                  U(G, `analyze() - got stats ${a4.type} for ${s2}`, a4);
                                  const t3 = [];
                                  return Object.keys(o3.audio).forEach((e3) => {
                                    const r3 = o3.audio[e3];
                                    if (r3.track_in === a4.id || r3.track_out === a4.id) {
                                      U(G, `analyze() - got stats ${a4.type} for ${s2}`, a4);
                                      var l3 = a4.trackIdentifier;
                                      a4.id === r3.track_in ? t3.push({ ssrc: r3.ssrc, type: $, value: { track_id_in: l3 } }) : t3.push({ ssrc: r3.ssrc, type: $, value: { track_id_out: l3 } });
                                    }
                                  }), Object.keys(o3.video).forEach((e3) => {
                                    const r3 = o3.video[e3];
                                    if (r3.track_in === a4.id || r3.track_out === a4.id) {
                                      U(G, `analyze() - got stats ${a4.type} for ${s2}`, a4);
                                      var l3 = a4.trackIdentifier;
                                      a4.id === r3.track_in ? t3.push({ ssrc: r3.ssrc, type: z, value: { track_id_in: l3 } }) : t3.push({ ssrc: r3.ssrc, type: z, value: { track_id_out: l3 } });
                                    }
                                  }), t3;
                                }
                                case "codec":
                                  const c2 = [];
                                  return Object.keys(o3.audio).forEach((t3) => {
                                    const e3 = o3.audio[t3];
                                    if (e3.codec_id_in === a4.id || e3.codec_id_out === a4.id) {
                                      U(G, `analyze() - got stats ${a4.type} for ${s2}`, a4);
                                      const t4 = ((t5) => ({ channels: t5.channels || null, clock_rate: t5.clockRate || null, mime_type: t5.mimeType || null, sdp_fmtp_line: t5.sdpFmtpLine || null }))(a4);
                                      a4.id === e3.codec_id_in ? c2.push({ ssrc: e3.ssrc, type: $, value: { codec_in: t4 } }) : c2.push({ ssrc: e3.ssrc, type: $, value: { codec_out: t4 } });
                                    }
                                  }), Object.keys(o3.video).forEach((t3) => {
                                    const e3 = o3.video[t3];
                                    if (e3.codec_id_in === a4.id || e3.codec_id_out === a4.id) {
                                      U(G, `analyze() - got stats ${a4.type} for ${s2}`, a4);
                                      const t4 = ((t5) => ({ clock_rate: t5.clockRate || null, mime_type: t5.mimeType || null }))(a4);
                                      a4.id === e3.codec_id_in ? c2.push({ ssrc: e3.ssrc, type: z, value: { codec_in: t4 } }) : c2.push({ ssrc: e3.ssrc, type: z, value: { codec_out: t4 } });
                                    }
                                  }), c2;
                                case "remote-inbound-rtp": {
                                  U(G, `analyze() - got stats ${a4.type} for ${s2}`, a4);
                                  const t3 = a4.ssrc, l3 = H(t3, o3, e2), c3 = H(t3, r2, e2);
                                  if (a4.kind === K) {
                                    const e3 = V(a4, K, c3, l3), o4 = J(a4, K, l3), s3 = Q(a4, K, l3, c3);
                                    return [{ ssrc: t3, type: $, value: { delta_rtt_ms_out: e3.rtt } }, { ssrc: t3, type: $, value: { delta_jitter_ms_out: o4 } }, { ssrc: t3, type: $, value: { timestamp_out: a4.timestamp } }, { ssrc: t3, type: $, value: { total_packets_lost_out: s3.packetsLost } }, { ssrc: t3, type: $, value: { delta_packets_lost_out: s3.deltaPacketsLost } }, { ssrc: t3, type: $, value: { percent_packets_lost_out: s3.fractionLost } }];
                                  }
                                  if (a4.kind === E) {
                                    const e3 = V(a4, E, c3, l3), o4 = J(a4, E, l3), s3 = Q(a4, E, l3, c3);
                                    return [{ ssrc: t3, type: z, value: { delta_rtt_ms_out: e3.rtt } }, { ssrc: t3, type: z, value: { delta_jitter_ms_out: o4 } }, { ssrc: t3, type: z, value: { timestamp_out: a4.timestamp } }, { ssrc: t3, type: z, value: { total_packets_lost_out: s3.packetsLost } }, { ssrc: t3, type: z, value: { delta_packets_lost_out: s3.deltaPacketsLost } }];
                                  }
                                  break;
                                }
                                case "remote-outbound-rtp": {
                                  U(G, `analyze() - got stats ${a4.type} for ${s2}`, a4);
                                  const t3 = a4.ssrc, l3 = H(t3, o3, e2), c3 = H(t3, r2, e2);
                                  if (a4.kind === K) {
                                    const e3 = V(a4, K, c3, l3);
                                    return [{ ssrc: t3, type: $, value: { delta_rtt_ms_in: e3.rtt } }, { ssrc: t3, type: $, value: { timestamp_in: a4.timestamp } }];
                                  }
                                  break;
                                }
                              }
                              return [];
                            })(a3, i2, i2.name, null).forEach((t3) => {
                              if (t3.value && t3.type) if (t3.ssrc) {
                                let _3 = i2[t3.type][t3.ssrc];
                                _3 || (e3 = t3.type, o3 = a3.type, _3 = e3 === K ? o3 === n ? { ...s } : { ...r } : o3 === n ? { ...l } : { ...c }, _3.ssrc = t3.ssrc, i2[t3.type][t3.ssrc] = _3), Object.keys(t3.value).forEach((e4) => {
                                  void 0 !== t3.value[e4] && (_3[e4] = t3.value[e4]);
                                });
                              } else Object.keys(t3.value).forEach((e4) => {
                                void 0 !== t3.value[e4] && (i2[t3.type][e4] = t3.value[e4]);
                              });
                              var e3, o3;
                            });
                          }), i2.timestamp = _2, i2;
                        }
                        async collectStats() {
                          try {
                            const t3 = await this._config.monitoringObject.getStats(), e3 = this.analyze(t3, this._statsReports.slice().pop() || null);
                            return this._statsReports.push(e3), this.fireOnStatsCollected(e3), t3;
                          } catch (t3) {
                            return W(this._moduleName, `got error ${t3}`), null;
                          }
                        }
                        fireOnStatsCollected(a2) {
                          if (this._callbacks.onStatsCollected) {
                            const o2 = {};
                            o2.meetingId = a2.meetingId, o2.peerId = a2.peerId, o2.name = a2.name, o2.audio = [], o2.video = [], Object.values(a2.audio).forEach((s2) => {
                              const r2 = {};
                              if (r2.network = N[a2.network.infrastructure], r2.timestamp = a2.timestamp, s2.direction == t2) {
                                r2.codec = s2.codec_in.mime_type, r2.jitter = s2.delta_jitter_ms_in, r2.bitrate = s2.delta_kbs_in, r2.packetsLost = s2.delta_packets_lost_in, r2.rtt = a2.data.delta_rtt_connectivity_ms || 0, r2.totalPackets = s2.delta_packets_in, r2.concealmentEvents = s2.delta_concealment_events, r2.removedSampleForAccelaration = s2.delta_removed_samples_for_accelaration, r2.insertedSamplesForDecelaration = s2.delta_inserted_samples_for_decelaration;
                                const t3 = JSON.stringify(s2.track_id_in).replace(/[{}"]/g, "");
                                r2.trackId = t3;
                              } else s2.direction == e2 && (r2.codec = s2.codec_out.mime_type, r2.jitter = s2.delta_jitter_ms_out, r2.bitrate = s2.delta_kbs_out, r2.packetsLost = s2.delta_packets_lost_out, r2.rtt = a2.data.delta_rtt_connectivity_ms || 0, r2.totalPackets = s2.delta_packets_out, r2.trackId = s2.track_id_out);
                              s2.direction && o2.audio.push(r2);
                            }), Object.values(a2.video).forEach((s2) => {
                              const r2 = {};
                              if (r2.network = N[a2.network.infrastructure], r2.timestamp = a2.timestamp, s2.direction == t2) {
                                r2.codec = s2.codec_in.mime_type, r2.jitter = s2.delta_jitter_ms_in, r2.bitrate = s2.delta_kbs_in, r2.packetsLost = s2.delta_packets_lost_in, r2.rtt = a2.data.delta_rtt_connectivity_ms || 0, r2.totalPackets = s2.delta_packets_in, r2.size = s2.size_in, r2.pauseCount = s2.pause_count, r2.totalPausesDuration = s2.total_pauses_duration, r2.freezeCount = s2.freeze_count, r2.totalFreezesDuration = s2.total_freezes_duration;
                                const t3 = JSON.stringify(s2.track_id_in).replace(/[{}"]/g, "");
                                r2.trackId = t3;
                              } else s2.direction == e2 && (r2.codec = s2.codec_out.mime_type, r2.jitter = s2.delta_jitter_ms_out, r2.bitrate = s2.delta_kbs_out, r2.packetsLost = s2.delta_packets_lost_out, r2.rtt = a2.data.delta_rtt_connectivity_ms || 0, r2.totalPackets = s2.delta_packets_out, r2.limitation = s2.limitation_out, r2.size = s2.size_out, r2.trackId = s2.track_id_out);
                              s2.direction && o2.video.push(r2);
                            }), this._callbacks.onStatsCollected.callback(o2);
                          }
                        }
                      }
                      class at {
                        constructor(t3) {
                          this._id = t3.name && t3.name.substr(0, 12).padEnd(12, " "), this._moduleName = this._id, this._config = t3, this._collector = new et(this._config, this._id);
                        }
                        get id() {
                          return this._id;
                        }
                        start() {
                          this._collectorIntervalId ? q("Probe already started.") : (U(this._moduleName, "Probe Started"), this._collectorIntervalId = setInterval(() => {
                            U(this._moduleName, "Collector collecting stats"), this._collector.collectStats();
                          }, this._config.refreshEvery));
                        }
                        stop() {
                          this._collectorIntervalId ? (clearInterval(this._collectorIntervalId), U(this._moduleName, "Probe Stopped")) : q("Probe not running, Please start first.");
                        }
                        set onStatsCollected(t3) {
                          t3 ? this._collector.registerCallback("onStatsCollected", t3) : this._collector.unregisterCallback("onStatsCollected");
                        }
                      }
                      const ot = { refreshEvery: 2e3, startAfter: 0, stopAfter: -1, verbose: false, peerId: "peerId", meetingId: "meetingId", name: "name" };
                      class st {
                        constructor(t3) {
                          var e3;
                          this._config = { defaultConfig: ot, ...t3 }, this._probes = [], e3 = this._config.verbose || false, A.setLevel(e3 ? A.levels.TRACE : A.levels.INFO), U("VideoSDKMetrics", "VideoSDKMetrics initialized");
                        }
                        get probes() {
                          return this._probes;
                        }
                        addNewProbe(t3, e3) {
                          if (!t3) throw new Error("undefined monitoring object");
                          const a2 = { monitoringObject: t3, ...e3, ...this._config }, o2 = new at(a2);
                          return this._probes.push(o2), o2;
                        }
                        removeExistingProbe(t3) {
                          if (!t3) throw new Error("undefined probe");
                          t3.stop(), this._probes = this._probes.filter((e3) => t3.id !== e3.id);
                        }
                        getProbe(t3) {
                          for (let e3 of this.probes) if (e3.id == t3) return e3;
                        }
                        startAllProbes() {
                          this._probes.forEach((t3, e3) => {
                            t3.start();
                          });
                        }
                        stopAllProbes() {
                          this._probes.forEach((t3) => t3.stop());
                        }
                      }
                    })(), o;
                  })();
                });
              }
            ),
            /***/
            5458: (
              /***/
              (__unused_webpack___webpack_module__, __webpack_exports__2, __webpack_require__2) => {
                "use strict";
                __webpack_require__2.d(__webpack_exports__2, {
                  A: () => (
                    /* binding */
                    _toConsumableArray
                  )
                });
                var arrayLikeToArray = __webpack_require__2(3145);
                ;
                function _arrayWithoutHoles(r) {
                  if (Array.isArray(r)) return (0, arrayLikeToArray.A)(r);
                }
                ;
                function _iterableToArray(r) {
                  if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r);
                }
                var unsupportedIterableToArray = __webpack_require__2(7800);
                ;
                function _nonIterableSpread() {
                  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
                }
                ;
                function _toConsumableArray(r) {
                  return _arrayWithoutHoles(r) || _iterableToArray(r) || (0, unsupportedIterableToArray.A)(r) || _nonIterableSpread();
                }
              }
            ),
            /***/
            5471: (
              /***/
              function(module2, exports2, __webpack_require__2) {
                ;
                (function(root, factory) {
                  if (true) {
                    module2.exports = exports2 = factory(__webpack_require__2(9021));
                  } else {
                  }
                })(this, function(CryptoJS) {
                  (function() {
                    var C = CryptoJS;
                    var C_lib = C.lib;
                    var WordArray = C_lib.WordArray;
                    var Hasher = C_lib.Hasher;
                    var C_algo = C.algo;
                    var W = [];
                    var SHA1 = C_algo.SHA1 = Hasher.extend({
                      _doReset: function() {
                        this._hash = new WordArray.init([
                          1732584193,
                          4023233417,
                          2562383102,
                          271733878,
                          3285377520
                        ]);
                      },
                      _doProcessBlock: function(M, offset) {
                        var H = this._hash.words;
                        var a = H[0];
                        var b = H[1];
                        var c = H[2];
                        var d = H[3];
                        var e = H[4];
                        for (var i = 0; i < 80; i++) {
                          if (i < 16) {
                            W[i] = M[offset + i] | 0;
                          } else {
                            var n = W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16];
                            W[i] = n << 1 | n >>> 31;
                          }
                          var t = (a << 5 | a >>> 27) + e + W[i];
                          if (i < 20) {
                            t += (b & c | ~b & d) + 1518500249;
                          } else if (i < 40) {
                            t += (b ^ c ^ d) + 1859775393;
                          } else if (i < 60) {
                            t += (b & c | b & d | c & d) - 1894007588;
                          } else {
                            t += (b ^ c ^ d) - 899497514;
                          }
                          e = d;
                          d = c;
                          c = b << 30 | b >>> 2;
                          b = a;
                          a = t;
                        }
                        H[0] = H[0] + a | 0;
                        H[1] = H[1] + b | 0;
                        H[2] = H[2] + c | 0;
                        H[3] = H[3] + d | 0;
                        H[4] = H[4] + e | 0;
                      },
                      _doFinalize: function() {
                        var data = this._data;
                        var dataWords = data.words;
                        var nBitsTotal = this._nDataBytes * 8;
                        var nBitsLeft = data.sigBytes * 8;
                        dataWords[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;
                        dataWords[(nBitsLeft + 64 >>> 9 << 4) + 14] = Math.floor(nBitsTotal / 4294967296);
                        dataWords[(nBitsLeft + 64 >>> 9 << 4) + 15] = nBitsTotal;
                        data.sigBytes = dataWords.length * 4;
                        this._process();
                        return this._hash;
                      },
                      clone: function() {
                        var clone = Hasher.clone.call(this);
                        clone._hash = this._hash.clone();
                        return clone;
                      }
                    });
                    C.SHA1 = Hasher._createHelper(SHA1);
                    C.HmacSHA1 = Hasher._createHmacHelper(SHA1);
                  })();
                  return CryptoJS.SHA1;
                });
              }
            ),
            /***/
            5501: (
              /***/
              (__unused_webpack___webpack_module__, __webpack_exports__2, __webpack_require__2) => {
                "use strict";
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  A: () => (
                    /* binding */
                    _inherits
                  )
                  /* harmony export */
                });
                var _setPrototypeOf_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(3662);
                function _inherits(t, e) {
                  if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
                  t.prototype = Object.create(e && e.prototype, {
                    constructor: {
                      value: t,
                      writable: true,
                      configurable: true
                    }
                  }), Object.defineProperty(t, "prototype", {
                    writable: false
                  }), e && (0, _setPrototypeOf_js__WEBPACK_IMPORTED_MODULE_0__.A)(t, e);
                }
              }
            ),
            /***/
            5503: (
              /***/
              function(module2, exports2, __webpack_require__2) {
                ;
                (function(root, factory) {
                  if (true) {
                    module2.exports = exports2 = factory(__webpack_require__2(9021));
                  } else {
                  }
                })(this, function(CryptoJS) {
                  (function() {
                    var C = CryptoJS;
                    var C_lib = C.lib;
                    var WordArray = C_lib.WordArray;
                    var C_enc = C.enc;
                    var Utf16BE = C_enc.Utf16 = C_enc.Utf16BE = {
                      /**
                       * Converts a word array to a UTF-16 BE string.
                       *
                       * @param {WordArray} wordArray The word array.
                       *
                       * @return {string} The UTF-16 BE string.
                       *
                       * @static
                       *
                       * @example
                       *
                       *     var utf16String = CryptoJS.enc.Utf16.stringify(wordArray);
                       */
                      stringify: function(wordArray) {
                        var words = wordArray.words;
                        var sigBytes = wordArray.sigBytes;
                        var utf16Chars = [];
                        for (var i = 0; i < sigBytes; i += 2) {
                          var codePoint = words[i >>> 2] >>> 16 - i % 4 * 8 & 65535;
                          utf16Chars.push(String.fromCharCode(codePoint));
                        }
                        return utf16Chars.join("");
                      },
                      /**
                       * Converts a UTF-16 BE string to a word array.
                       *
                       * @param {string} utf16Str The UTF-16 BE string.
                       *
                       * @return {WordArray} The word array.
                       *
                       * @static
                       *
                       * @example
                       *
                       *     var wordArray = CryptoJS.enc.Utf16.parse(utf16String);
                       */
                      parse: function(utf16Str) {
                        var utf16StrLength = utf16Str.length;
                        var words = [];
                        for (var i = 0; i < utf16StrLength; i++) {
                          words[i >>> 1] |= utf16Str.charCodeAt(i) << 16 - i % 2 * 16;
                        }
                        return WordArray.create(words, utf16StrLength * 2);
                      }
                    };
                    C_enc.Utf16LE = {
                      /**
                       * Converts a word array to a UTF-16 LE string.
                       *
                       * @param {WordArray} wordArray The word array.
                       *
                       * @return {string} The UTF-16 LE string.
                       *
                       * @static
                       *
                       * @example
                       *
                       *     var utf16Str = CryptoJS.enc.Utf16LE.stringify(wordArray);
                       */
                      stringify: function(wordArray) {
                        var words = wordArray.words;
                        var sigBytes = wordArray.sigBytes;
                        var utf16Chars = [];
                        for (var i = 0; i < sigBytes; i += 2) {
                          var codePoint = swapEndian(words[i >>> 2] >>> 16 - i % 4 * 8 & 65535);
                          utf16Chars.push(String.fromCharCode(codePoint));
                        }
                        return utf16Chars.join("");
                      },
                      /**
                       * Converts a UTF-16 LE string to a word array.
                       *
                       * @param {string} utf16Str The UTF-16 LE string.
                       *
                       * @return {WordArray} The word array.
                       *
                       * @static
                       *
                       * @example
                       *
                       *     var wordArray = CryptoJS.enc.Utf16LE.parse(utf16Str);
                       */
                      parse: function(utf16Str) {
                        var utf16StrLength = utf16Str.length;
                        var words = [];
                        for (var i = 0; i < utf16StrLength; i++) {
                          words[i >>> 1] |= swapEndian(utf16Str.charCodeAt(i) << 16 - i % 2 * 16);
                        }
                        return WordArray.create(words, utf16StrLength * 2);
                      }
                    };
                    function swapEndian(word) {
                      return word << 8 & 4278255360 | word >>> 8 & 16711935;
                    }
                  })();
                  return CryptoJS.enc.Utf16;
                });
              }
            ),
            /***/
            5528: (
              /***/
              (module2) => {
                "use strict";
                var R = typeof Reflect === "object" ? Reflect : null;
                var ReflectApply = R && typeof R.apply === "function" ? R.apply : function ReflectApply2(target, receiver, args) {
                  return Function.prototype.apply.call(target, receiver, args);
                };
                var ReflectOwnKeys;
                if (R && typeof R.ownKeys === "function") {
                  ReflectOwnKeys = R.ownKeys;
                } else if (Object.getOwnPropertySymbols) {
                  ReflectOwnKeys = function ReflectOwnKeys2(target) {
                    return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));
                  };
                } else {
                  ReflectOwnKeys = function ReflectOwnKeys2(target) {
                    return Object.getOwnPropertyNames(target);
                  };
                }
                function ProcessEmitWarning(warning) {
                  if (console && console.warn) console.warn(warning);
                }
                var NumberIsNaN = Number.isNaN || function NumberIsNaN2(value) {
                  return value !== value;
                };
                function EventEmitter2() {
                  EventEmitter2.init.call(this);
                }
                module2.exports = EventEmitter2;
                module2.exports.once = once;
                EventEmitter2.EventEmitter = EventEmitter2;
                EventEmitter2.prototype._events = void 0;
                EventEmitter2.prototype._eventsCount = 0;
                EventEmitter2.prototype._maxListeners = void 0;
                var defaultMaxListeners = 10;
                function checkListener(listener) {
                  if (typeof listener !== "function") {
                    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
                  }
                }
                Object.defineProperty(EventEmitter2, "defaultMaxListeners", {
                  enumerable: true,
                  get: function() {
                    return defaultMaxListeners;
                  },
                  set: function(arg) {
                    if (typeof arg !== "number" || arg < 0 || NumberIsNaN(arg)) {
                      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + ".");
                    }
                    defaultMaxListeners = arg;
                  }
                });
                EventEmitter2.init = function() {
                  if (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) {
                    this._events = /* @__PURE__ */ Object.create(null);
                    this._eventsCount = 0;
                  }
                  this._maxListeners = this._maxListeners || void 0;
                };
                EventEmitter2.prototype.setMaxListeners = function setMaxListeners(n) {
                  if (typeof n !== "number" || n < 0 || NumberIsNaN(n)) {
                    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + ".");
                  }
                  this._maxListeners = n;
                  return this;
                };
                function _getMaxListeners(that) {
                  if (that._maxListeners === void 0)
                    return EventEmitter2.defaultMaxListeners;
                  return that._maxListeners;
                }
                EventEmitter2.prototype.getMaxListeners = function getMaxListeners() {
                  return _getMaxListeners(this);
                };
                EventEmitter2.prototype.emit = function emit(type) {
                  var args = [];
                  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);
                  var doError = type === "error";
                  var events2 = this._events;
                  if (events2 !== void 0)
                    doError = doError && events2.error === void 0;
                  else if (!doError)
                    return false;
                  if (doError) {
                    var er;
                    if (args.length > 0)
                      er = args[0];
                    if (er instanceof Error) {
                      throw er;
                    }
                    var err = new Error("Unhandled error." + (er ? " (" + er.message + ")" : ""));
                    err.context = er;
                    throw err;
                  }
                  var handler = events2[type];
                  if (handler === void 0)
                    return false;
                  if (typeof handler === "function") {
                    ReflectApply(handler, this, args);
                  } else {
                    var len = handler.length;
                    var listeners = arrayClone(handler, len);
                    for (var i = 0; i < len; ++i)
                      ReflectApply(listeners[i], this, args);
                  }
                  return true;
                };
                function _addListener(target, type, listener, prepend) {
                  var m;
                  var events2;
                  var existing;
                  checkListener(listener);
                  events2 = target._events;
                  if (events2 === void 0) {
                    events2 = target._events = /* @__PURE__ */ Object.create(null);
                    target._eventsCount = 0;
                  } else {
                    if (events2.newListener !== void 0) {
                      target.emit(
                        "newListener",
                        type,
                        listener.listener ? listener.listener : listener
                      );
                      events2 = target._events;
                    }
                    existing = events2[type];
                  }
                  if (existing === void 0) {
                    existing = events2[type] = listener;
                    ++target._eventsCount;
                  } else {
                    if (typeof existing === "function") {
                      existing = events2[type] = prepend ? [listener, existing] : [existing, listener];
                    } else if (prepend) {
                      existing.unshift(listener);
                    } else {
                      existing.push(listener);
                    }
                    m = _getMaxListeners(target);
                    if (m > 0 && existing.length > m && !existing.warned) {
                      existing.warned = true;
                      var w = new Error("Possible EventEmitter memory leak detected. " + existing.length + " " + String(type) + " listeners added. Use emitter.setMaxListeners() to increase limit");
                      w.name = "MaxListenersExceededWarning";
                      w.emitter = target;
                      w.type = type;
                      w.count = existing.length;
                      ProcessEmitWarning(w);
                    }
                  }
                  return target;
                }
                EventEmitter2.prototype.addListener = function addListener(type, listener) {
                  return _addListener(this, type, listener, false);
                };
                EventEmitter2.prototype.on = EventEmitter2.prototype.addListener;
                EventEmitter2.prototype.prependListener = function prependListener(type, listener) {
                  return _addListener(this, type, listener, true);
                };
                function onceWrapper() {
                  if (!this.fired) {
                    this.target.removeListener(this.type, this.wrapFn);
                    this.fired = true;
                    if (arguments.length === 0)
                      return this.listener.call(this.target);
                    return this.listener.apply(this.target, arguments);
                  }
                }
                function _onceWrap(target, type, listener) {
                  var state = { fired: false, wrapFn: void 0, target, type, listener };
                  var wrapped = onceWrapper.bind(state);
                  wrapped.listener = listener;
                  state.wrapFn = wrapped;
                  return wrapped;
                }
                EventEmitter2.prototype.once = function once2(type, listener) {
                  checkListener(listener);
                  this.on(type, _onceWrap(this, type, listener));
                  return this;
                };
                EventEmitter2.prototype.prependOnceListener = function prependOnceListener(type, listener) {
                  checkListener(listener);
                  this.prependListener(type, _onceWrap(this, type, listener));
                  return this;
                };
                EventEmitter2.prototype.removeListener = function removeListener(type, listener) {
                  var list, events2, position, i, originalListener;
                  checkListener(listener);
                  events2 = this._events;
                  if (events2 === void 0)
                    return this;
                  list = events2[type];
                  if (list === void 0)
                    return this;
                  if (list === listener || list.listener === listener) {
                    if (--this._eventsCount === 0)
                      this._events = /* @__PURE__ */ Object.create(null);
                    else {
                      delete events2[type];
                      if (events2.removeListener)
                        this.emit("removeListener", type, list.listener || listener);
                    }
                  } else if (typeof list !== "function") {
                    position = -1;
                    for (i = list.length - 1; i >= 0; i--) {
                      if (list[i] === listener || list[i].listener === listener) {
                        originalListener = list[i].listener;
                        position = i;
                        break;
                      }
                    }
                    if (position < 0)
                      return this;
                    if (position === 0)
                      list.shift();
                    else {
                      spliceOne(list, position);
                    }
                    if (list.length === 1)
                      events2[type] = list[0];
                    if (events2.removeListener !== void 0)
                      this.emit("removeListener", type, originalListener || listener);
                  }
                  return this;
                };
                EventEmitter2.prototype.off = EventEmitter2.prototype.removeListener;
                EventEmitter2.prototype.removeAllListeners = function removeAllListeners(type) {
                  var listeners, events2, i;
                  events2 = this._events;
                  if (events2 === void 0)
                    return this;
                  if (events2.removeListener === void 0) {
                    if (arguments.length === 0) {
                      this._events = /* @__PURE__ */ Object.create(null);
                      this._eventsCount = 0;
                    } else if (events2[type] !== void 0) {
                      if (--this._eventsCount === 0)
                        this._events = /* @__PURE__ */ Object.create(null);
                      else
                        delete events2[type];
                    }
                    return this;
                  }
                  if (arguments.length === 0) {
                    var keys = Object.keys(events2);
                    var key;
                    for (i = 0; i < keys.length; ++i) {
                      key = keys[i];
                      if (key === "removeListener") continue;
                      this.removeAllListeners(key);
                    }
                    this.removeAllListeners("removeListener");
                    this._events = /* @__PURE__ */ Object.create(null);
                    this._eventsCount = 0;
                    return this;
                  }
                  listeners = events2[type];
                  if (typeof listeners === "function") {
                    this.removeListener(type, listeners);
                  } else if (listeners !== void 0) {
                    for (i = listeners.length - 1; i >= 0; i--) {
                      this.removeListener(type, listeners[i]);
                    }
                  }
                  return this;
                };
                function _listeners(target, type, unwrap) {
                  var events2 = target._events;
                  if (events2 === void 0)
                    return [];
                  var evlistener = events2[type];
                  if (evlistener === void 0)
                    return [];
                  if (typeof evlistener === "function")
                    return unwrap ? [evlistener.listener || evlistener] : [evlistener];
                  return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
                }
                EventEmitter2.prototype.listeners = function listeners(type) {
                  return _listeners(this, type, true);
                };
                EventEmitter2.prototype.rawListeners = function rawListeners(type) {
                  return _listeners(this, type, false);
                };
                EventEmitter2.listenerCount = function(emitter, type) {
                  if (typeof emitter.listenerCount === "function") {
                    return emitter.listenerCount(type);
                  } else {
                    return listenerCount.call(emitter, type);
                  }
                };
                EventEmitter2.prototype.listenerCount = listenerCount;
                function listenerCount(type) {
                  var events2 = this._events;
                  if (events2 !== void 0) {
                    var evlistener = events2[type];
                    if (typeof evlistener === "function") {
                      return 1;
                    } else if (evlistener !== void 0) {
                      return evlistener.length;
                    }
                  }
                  return 0;
                }
                EventEmitter2.prototype.eventNames = function eventNames() {
                  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
                };
                function arrayClone(arr, n) {
                  var copy = new Array(n);
                  for (var i = 0; i < n; ++i)
                    copy[i] = arr[i];
                  return copy;
                }
                function spliceOne(list, index) {
                  for (; index + 1 < list.length; index++)
                    list[index] = list[index + 1];
                  list.pop();
                }
                function unwrapListeners(arr) {
                  var ret = new Array(arr.length);
                  for (var i = 0; i < ret.length; ++i) {
                    ret[i] = arr[i].listener || arr[i];
                  }
                  return ret;
                }
                function once(emitter, name) {
                  return new Promise(function(resolve, reject) {
                    function errorListener(err) {
                      emitter.removeListener(name, resolver);
                      reject(err);
                    }
                    function resolver() {
                      if (typeof emitter.removeListener === "function") {
                        emitter.removeListener("error", errorListener);
                      }
                      resolve([].slice.call(arguments));
                    }
                    ;
                    eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });
                    if (name !== "error") {
                      addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });
                    }
                  });
                }
                function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
                  if (typeof emitter.on === "function") {
                    eventTargetAgnosticAddListener(emitter, "error", handler, flags);
                  }
                }
                function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
                  if (typeof emitter.on === "function") {
                    if (flags.once) {
                      emitter.once(name, listener);
                    } else {
                      emitter.on(name, listener);
                    }
                  } else if (typeof emitter.addEventListener === "function") {
                    emitter.addEventListener(name, function wrapListener(arg) {
                      if (flags.once) {
                        emitter.removeEventListener(name, wrapListener);
                      }
                      listener(arg);
                    });
                  } else {
                    throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
                  }
                }
              }
            ),
            /***/
            5544: (
              /***/
              (__unused_webpack_module, exports2, __webpack_require__2) => {
                "use strict";
                Object.defineProperty(exports2, "__esModule", { value: true });
                exports2.extractRtpCapabilities = extractRtpCapabilities;
                exports2.extractDtlsParameters = extractDtlsParameters;
                exports2.getCname = getCname;
                exports2.applyCodecParameters = applyCodecParameters;
                const sdpTransform = __webpack_require__2(7363);
                function extractRtpCapabilities({ sdpObject }) {
                  const codecsMap = /* @__PURE__ */ new Map();
                  const headerExtensionMap = /* @__PURE__ */ new Map();
                  for (const m of sdpObject.media) {
                    const kind = m.type;
                    switch (kind) {
                      case "audio":
                      case "video": {
                        break;
                      }
                      default: {
                        continue;
                      }
                    }
                    for (const rtp of m.rtp) {
                      const codec = {
                        kind,
                        mimeType: `${kind}/${rtp.codec}`,
                        preferredPayloadType: rtp.payload,
                        clockRate: rtp.rate,
                        channels: rtp.encoding,
                        parameters: {},
                        rtcpFeedback: []
                      };
                      codecsMap.set(codec.preferredPayloadType, codec);
                    }
                    for (const fmtp of m.fmtp ?? []) {
                      const parameters = sdpTransform.parseParams(fmtp.config);
                      const codec = codecsMap.get(fmtp.payload);
                      if (!codec) {
                        continue;
                      }
                      if (parameters == null ? void 0 : parameters.hasOwnProperty("profile-level-id")) {
                        parameters["profile-level-id"] = String(parameters["profile-level-id"]);
                      }
                      codec.parameters = parameters;
                    }
                    for (const fb of m.rtcpFb ?? []) {
                      const feedback = {
                        type: fb.type,
                        parameter: fb.subtype
                      };
                      if (!feedback.parameter) {
                        delete feedback.parameter;
                      }
                      if (fb.payload !== "*") {
                        const codec = codecsMap.get(Number(fb.payload));
                        if (!codec) {
                          continue;
                        }
                        codec.rtcpFeedback.push(feedback);
                      } else {
                        for (const codec of codecsMap.values()) {
                          if (codec.kind === kind && !/.+\/rtx$/i.test(codec.mimeType)) {
                            codec.rtcpFeedback.push(feedback);
                          }
                        }
                      }
                    }
                    for (const ext of m.ext ?? []) {
                      if (ext["encrypt-uri"]) {
                        continue;
                      }
                      const headerExtension = {
                        kind,
                        uri: ext.uri,
                        preferredId: ext.value
                      };
                      headerExtensionMap.set(headerExtension.preferredId, headerExtension);
                    }
                  }
                  const rtpCapabilities = {
                    codecs: Array.from(codecsMap.values()),
                    headerExtensions: Array.from(headerExtensionMap.values())
                  };
                  return rtpCapabilities;
                }
                function extractDtlsParameters({ sdpObject }) {
                  let setup = sdpObject.setup;
                  let fingerprint = sdpObject.fingerprint;
                  if (!setup || !fingerprint) {
                    const mediaObject = (sdpObject.media ?? []).find((m) => m.port !== 0);
                    if (mediaObject) {
                      setup ?? (setup = mediaObject.setup);
                      fingerprint ?? (fingerprint = mediaObject.fingerprint);
                    }
                  }
                  if (!setup) {
                    throw new Error("no a=setup found at SDP session or media level");
                  } else if (!fingerprint) {
                    throw new Error("no a=fingerprint found at SDP session or media level");
                  }
                  let role;
                  switch (setup) {
                    case "active": {
                      role = "client";
                      break;
                    }
                    case "passive": {
                      role = "server";
                      break;
                    }
                    case "actpass": {
                      role = "auto";
                      break;
                    }
                  }
                  const dtlsParameters = {
                    role,
                    fingerprints: [
                      {
                        algorithm: fingerprint.type,
                        value: fingerprint.hash
                      }
                    ]
                  };
                  return dtlsParameters;
                }
                function getCname({ offerMediaObject }) {
                  const ssrcCnameLine = (offerMediaObject.ssrcs ?? []).find((line) => line.attribute === "cname");
                  if (!ssrcCnameLine) {
                    return "";
                  }
                  return ssrcCnameLine.value;
                }
                function applyCodecParameters({ offerRtpParameters, answerMediaObject }) {
                  var _a;
                  for (const codec of offerRtpParameters.codecs) {
                    const mimeType = codec.mimeType.toLowerCase();
                    if (mimeType !== "audio/opus") {
                      continue;
                    }
                    const rtp = (answerMediaObject.rtp ?? []).find((r) => r.payload === codec.payloadType);
                    if (!rtp) {
                      continue;
                    }
                    answerMediaObject.fmtp = answerMediaObject.fmtp ?? [];
                    let fmtp = answerMediaObject.fmtp.find((f) => f.payload === codec.payloadType);
                    if (!fmtp) {
                      fmtp = { payload: codec.payloadType, config: "" };
                      answerMediaObject.fmtp.push(fmtp);
                    }
                    const parameters = sdpTransform.parseParams(fmtp.config);
                    switch (mimeType) {
                      case "audio/opus": {
                        const spropStereo = (_a = codec.parameters) == null ? void 0 : _a["sprop-stereo"];
                        if (spropStereo !== void 0) {
                          parameters["stereo"] = Number(spropStereo) ? 1 : 0;
                        }
                        break;
                      }
                    }
                    fmtp.config = "";
                    for (const key of Object.keys(parameters)) {
                      if (fmtp.config) {
                        fmtp.config += ";";
                      }
                      fmtp.config += `${key}=${parameters[key]}`;
                    }
                  }
                }
              }
            ),
            /***/
            5546: (
              /***/
              (module2) => {
                function _regeneratorDefine(e, r, n, t) {
                  var i = Object.defineProperty;
                  try {
                    i({}, "", {});
                  } catch (e2) {
                    i = 0;
                  }
                  module2.exports = _regeneratorDefine = function regeneratorDefine(e2, r2, n2, t2) {
                    function o(r3, n3) {
                      _regeneratorDefine(e2, r3, function(e3) {
                        return this._invoke(r3, n3, e3);
                      });
                    }
                    r2 ? i ? i(e2, r2, {
                      value: n2,
                      enumerable: !t2,
                      configurable: !t2,
                      writable: !t2
                    }) : e2[r2] = n2 : (o("next", 0), o("throw", 1), o("return", 2));
                  }, module2.exports.__esModule = true, module2.exports["default"] = module2.exports, _regeneratorDefine(e, r, n, t);
                }
                module2.exports = _regeneratorDefine, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
              }
            ),
            /***/
            5601: (
              /***/
              (__unused_webpack_module, exports2, __webpack_require__2) => {
                "use strict";
                Object.defineProperty(exports2, "__esModule", { value: true });
                exports2.Transport = void 0;
                const awaitqueue_1 = __webpack_require__2(8876);
                const Logger_1 = __webpack_require__2(2994);
                const enhancedEvents_1 = __webpack_require__2(3953);
                const errors_1 = __webpack_require__2(4893);
                const utils = __webpack_require__2(1765);
                const ortc = __webpack_require__2(8046);
                const Producer_1 = __webpack_require__2(9792);
                const Consumer_1 = __webpack_require__2(3518);
                const DataProducer_1 = __webpack_require__2(7504);
                const DataConsumer_1 = __webpack_require__2(9166);
                const logger = new Logger_1.Logger("Transport");
                class ConsumerCreationTask {
                  constructor(consumerOptions) {
                    __publicField(this, "consumerOptions");
                    __publicField(this, "promise");
                    __publicField(this, "resolve");
                    __publicField(this, "reject");
                    this.consumerOptions = consumerOptions;
                    this.promise = new Promise((resolve, reject) => {
                      this.resolve = resolve;
                      this.reject = reject;
                    });
                  }
                }
                class Transport extends enhancedEvents_1.EnhancedEventEmitter {
                  constructor({ direction, id, iceParameters, iceCandidates, dtlsParameters, sctpParameters, iceServers, iceTransportPolicy, additionalSettings, appData, handlerFactory, getSendExtendedRtpCapabilities, recvRtpCapabilities, canProduceByKind }) {
                    super();
                    // Id.
                    __publicField(this, "_id");
                    // Closed flag.
                    __publicField(this, "_closed", false);
                    // Direction.
                    __publicField(this, "_direction");
                    // Callback for sending Transports to request sending extended RTP capabilities
                    // on demand.
                    __publicField(this, "_getSendExtendedRtpCapabilities");
                    // Recv RTP capabilities.
                    __publicField(this, "_recvRtpCapabilities");
                    // Whether we can produce audio/video based on computed extended RTP
                    // capabilities.
                    __publicField(this, "_canProduceByKind");
                    // SCTP max message size if enabled, null otherwise.
                    __publicField(this, "_maxSctpMessageSize");
                    // RTC handler isntance.
                    __publicField(this, "_handler");
                    // Transport ICE gathering state.
                    __publicField(this, "_iceGatheringState", "new");
                    // Transport connection state.
                    __publicField(this, "_connectionState", "new");
                    // App custom data.
                    __publicField(this, "_appData");
                    // Map of Producers indexed by id.
                    __publicField(this, "_producers", /* @__PURE__ */ new Map());
                    // Map of Consumers indexed by id.
                    __publicField(this, "_consumers", /* @__PURE__ */ new Map());
                    // Map of DataProducers indexed by id.
                    __publicField(this, "_dataProducers", /* @__PURE__ */ new Map());
                    // Map of DataConsumers indexed by id.
                    __publicField(this, "_dataConsumers", /* @__PURE__ */ new Map());
                    // Whether the Consumer for RTP probation has been created.
                    __publicField(this, "_probatorConsumerCreated", false);
                    // AwaitQueue instance to make async tasks happen sequentially.
                    __publicField(this, "_awaitQueue", new awaitqueue_1.AwaitQueue());
                    // Consumer creation tasks awaiting to be processed.
                    __publicField(this, "_pendingConsumerTasks", []);
                    // Consumer creation in progress flag.
                    __publicField(this, "_consumerCreationInProgress", false);
                    // Consumers pending to be paused.
                    __publicField(this, "_pendingPauseConsumers", /* @__PURE__ */ new Map());
                    // Consumer pause in progress flag.
                    __publicField(this, "_consumerPauseInProgress", false);
                    // Consumers pending to be resumed.
                    __publicField(this, "_pendingResumeConsumers", /* @__PURE__ */ new Map());
                    // Consumer resume in progress flag.
                    __publicField(this, "_consumerResumeInProgress", false);
                    // Consumers pending to be closed.
                    __publicField(this, "_pendingCloseConsumers", /* @__PURE__ */ new Map());
                    // Consumer close in progress flag.
                    __publicField(this, "_consumerCloseInProgress", false);
                    // Observer instance.
                    __publicField(this, "_observer", new enhancedEvents_1.EnhancedEventEmitter());
                    logger.debug("constructor() [id:%s, direction:%s]", id, direction);
                    this._id = id;
                    this._direction = direction;
                    this._getSendExtendedRtpCapabilities = getSendExtendedRtpCapabilities;
                    this._recvRtpCapabilities = recvRtpCapabilities;
                    this._canProduceByKind = canProduceByKind;
                    this._maxSctpMessageSize = sctpParameters ? sctpParameters.maxMessageSize : null;
                    const clonedAdditionalSettings = utils.clone(additionalSettings) ?? {};
                    delete clonedAdditionalSettings.iceServers;
                    delete clonedAdditionalSettings.iceTransportPolicy;
                    delete clonedAdditionalSettings.bundlePolicy;
                    delete clonedAdditionalSettings.rtcpMuxPolicy;
                    this._handler = handlerFactory.factory({
                      direction,
                      iceParameters,
                      iceCandidates,
                      dtlsParameters,
                      sctpParameters,
                      iceServers,
                      iceTransportPolicy,
                      additionalSettings: clonedAdditionalSettings,
                      getSendExtendedRtpCapabilities: this._getSendExtendedRtpCapabilities
                    });
                    this._appData = appData ?? {};
                    this.handleHandler();
                  }
                  /**
                   * Transport id.
                   */
                  get id() {
                    return this._id;
                  }
                  /**
                   * Whether the Transport is closed.
                   */
                  get closed() {
                    return this._closed;
                  }
                  /**
                   * Transport direction.
                   */
                  get direction() {
                    return this._direction;
                  }
                  /**
                   * RTC handler instance.
                   */
                  get handler() {
                    return this._handler;
                  }
                  /**
                   * ICE gathering state.
                   */
                  get iceGatheringState() {
                    return this._iceGatheringState;
                  }
                  /**
                   * Connection state.
                   */
                  get connectionState() {
                    return this._connectionState;
                  }
                  /**
                   * App custom data.
                   */
                  get appData() {
                    return this._appData;
                  }
                  /**
                   * App custom data setter.
                   */
                  set appData(appData) {
                    this._appData = appData;
                  }
                  get observer() {
                    return this._observer;
                  }
                  /**
                   * Close the Transport.
                   */
                  close() {
                    if (this._closed) {
                      return;
                    }
                    logger.debug("close()");
                    this._closed = true;
                    this._awaitQueue.stop();
                    this._handler.close();
                    this._connectionState = "closed";
                    for (const producer of this._producers.values()) {
                      producer.transportClosed();
                    }
                    this._producers.clear();
                    for (const consumer of this._consumers.values()) {
                      consumer.transportClosed();
                    }
                    this._consumers.clear();
                    for (const dataProducer of this._dataProducers.values()) {
                      dataProducer.transportClosed();
                    }
                    this._dataProducers.clear();
                    for (const dataConsumer of this._dataConsumers.values()) {
                      dataConsumer.transportClosed();
                    }
                    this._dataConsumers.clear();
                    this._observer.safeEmit("close");
                    super.close();
                    this._observer.close();
                  }
                  /**
                   * Get associated Transport (RTCPeerConnection) stats.
                   *
                   * @returns {RTCStatsReport}
                   */
                  async getStats() {
                    if (this._closed) {
                      throw new errors_1.InvalidStateError("closed");
                    }
                    return this._handler.getTransportStats();
                  }
                  /**
                   * Restart ICE connection.
                   */
                  async restartIce({ iceParameters }) {
                    logger.debug("restartIce()");
                    if (this._closed) {
                      throw new errors_1.InvalidStateError("closed");
                    } else if (!iceParameters) {
                      throw new TypeError("missing iceParameters");
                    }
                    return this._awaitQueue.push(async () => await this._handler.restartIce(iceParameters), "transport.restartIce()");
                  }
                  /**
                   * Update ICE servers.
                   */
                  async updateIceServers({ iceServers } = {}) {
                    logger.debug("updateIceServers()");
                    if (this._closed) {
                      throw new errors_1.InvalidStateError("closed");
                    } else if (!Array.isArray(iceServers)) {
                      throw new TypeError("missing iceServers");
                    }
                    return this._awaitQueue.push(async () => this._handler.updateIceServers(iceServers), "transport.updateIceServers()");
                  }
                  /**
                   * Create a Producer.
                   */
                  async produce({ track, encodings, codecOptions, codec, stopTracks = true, disableTrackOnPause = true, zeroRtpOnPause = false, onRtpSender, appData = {} } = {}) {
                    logger.debug("produce() [track:%o]", track);
                    if (this._closed) {
                      throw new errors_1.InvalidStateError("closed");
                    } else if (!track) {
                      throw new TypeError("missing track");
                    } else if (this._direction !== "send") {
                      throw new errors_1.UnsupportedError("not a sending Transport");
                    } else if (!this._canProduceByKind[track.kind]) {
                      throw new errors_1.UnsupportedError(`cannot produce ${track.kind}`);
                    } else if (track.readyState === "ended") {
                      throw new errors_1.InvalidStateError("track ended");
                    } else if (this.listenerCount("connect") === 0 && this._connectionState === "new") {
                      throw new TypeError('no "connect" listener set into this transport');
                    } else if (this.listenerCount("produce") === 0) {
                      throw new TypeError('no "produce" listener set into this transport');
                    } else if (appData && typeof appData !== "object") {
                      throw new TypeError("if given, appData must be an object");
                    }
                    return this._awaitQueue.push(async () => {
                      let normalizedEncodings;
                      if (encodings && !Array.isArray(encodings)) {
                        throw TypeError("encodings must be an array");
                      } else if (encodings && encodings.length === 0) {
                        normalizedEncodings = void 0;
                      } else if (encodings) {
                        normalizedEncodings = encodings.map((encoding) => {
                          const normalizedEncoding = {
                            active: true
                          };
                          if (encoding.active === false) {
                            normalizedEncoding.active = false;
                          }
                          if (typeof encoding.dtx === "boolean") {
                            normalizedEncoding.dtx = encoding.dtx;
                          }
                          if (typeof encoding.scalabilityMode === "string") {
                            normalizedEncoding.scalabilityMode = encoding.scalabilityMode;
                          }
                          if (typeof encoding.scaleResolutionDownBy === "number") {
                            normalizedEncoding.scaleResolutionDownBy = encoding.scaleResolutionDownBy;
                          }
                          if (typeof encoding.maxBitrate === "number") {
                            normalizedEncoding.maxBitrate = encoding.maxBitrate;
                          }
                          if (typeof encoding.maxFramerate === "number") {
                            normalizedEncoding.maxFramerate = encoding.maxFramerate;
                          }
                          if (typeof encoding.adaptivePtime === "boolean") {
                            normalizedEncoding.adaptivePtime = encoding.adaptivePtime;
                          }
                          if (typeof encoding.priority === "string") {
                            normalizedEncoding.priority = encoding.priority;
                          }
                          if (typeof encoding.networkPriority === "string") {
                            normalizedEncoding.networkPriority = encoding.networkPriority;
                          }
                          return normalizedEncoding;
                        });
                      }
                      const { localId, rtpParameters, rtpSender } = await this._handler.send({
                        track,
                        encodings: normalizedEncodings,
                        codecOptions,
                        codec,
                        onRtpSender
                      });
                      try {
                        ortc.validateAndNormalizeRtpParameters(rtpParameters);
                        const { id } = await new Promise((resolve, reject) => {
                          this.safeEmit("produce", {
                            kind: track.kind,
                            rtpParameters,
                            appData
                          }, resolve, reject);
                        });
                        const producer = new Producer_1.Producer({
                          id,
                          localId,
                          rtpSender,
                          track,
                          rtpParameters,
                          stopTracks,
                          disableTrackOnPause,
                          zeroRtpOnPause,
                          appData
                        });
                        this._producers.set(producer.id, producer);
                        this.handleProducer(producer);
                        this._observer.safeEmit("newproducer", producer);
                        return producer;
                      } catch (error) {
                        this._handler.stopSending(localId).catch(() => {
                        });
                        throw error;
                      }
                    }, "transport.produce()").catch((error) => {
                      if (stopTracks) {
                        try {
                          track.stop();
                        } catch (error2) {
                        }
                      }
                      throw error;
                    });
                  }
                  /**
                   * Create a Consumer to consume a remote Producer.
                   */
                  async consume({ id, producerId, kind, rtpParameters, streamId, onRtpReceiver, appData = {} }) {
                    logger.debug("consume()");
                    if (this._closed) {
                      throw new errors_1.InvalidStateError("closed");
                    } else if (this._direction !== "recv") {
                      throw new errors_1.UnsupportedError("not a receiving Transport");
                    } else if (typeof id !== "string") {
                      throw new TypeError("missing id");
                    } else if (typeof producerId !== "string") {
                      throw new TypeError("missing producerId");
                    } else if (kind !== "audio" && kind !== "video") {
                      throw new TypeError(`invalid kind '${kind}'`);
                    } else if (this.listenerCount("connect") === 0 && this._connectionState === "new") {
                      throw new TypeError('no "connect" listener set into this transport');
                    } else if (appData && typeof appData !== "object") {
                      throw new TypeError("if given, appData must be an object");
                    }
                    const clonedRtpParameters = utils.clone(rtpParameters);
                    const canConsume = ortc.canReceive(clonedRtpParameters, this._recvRtpCapabilities);
                    if (!canConsume) {
                      throw new errors_1.UnsupportedError("cannot consume this Producer");
                    }
                    const consumerCreationTask = new ConsumerCreationTask({
                      id,
                      producerId,
                      kind,
                      rtpParameters: clonedRtpParameters,
                      streamId,
                      onRtpReceiver,
                      appData
                    });
                    this._pendingConsumerTasks.push(consumerCreationTask);
                    queueMicrotask(() => {
                      if (this._closed) {
                        return;
                      }
                      if (this._consumerCreationInProgress === false) {
                        this.createPendingConsumers();
                      }
                    });
                    return consumerCreationTask.promise;
                  }
                  /**
                   * Create a DataProducer
                   */
                  async produceData({ ordered = true, maxPacketLifeTime, maxRetransmits, label = "", protocol = "", appData = {} } = {}) {
                    logger.debug("produceData()");
                    if (this._closed) {
                      throw new errors_1.InvalidStateError("closed");
                    } else if (this._direction !== "send") {
                      throw new errors_1.UnsupportedError("not a sending Transport");
                    } else if (!this._maxSctpMessageSize) {
                      throw new errors_1.UnsupportedError("SCTP not enabled by remote Transport");
                    } else if (this.listenerCount("connect") === 0 && this._connectionState === "new") {
                      throw new TypeError('no "connect" listener set into this transport');
                    } else if (this.listenerCount("producedata") === 0) {
                      throw new TypeError('no "producedata" listener set into this transport');
                    } else if (appData && typeof appData !== "object") {
                      throw new TypeError("if given, appData must be an object");
                    }
                    if (maxPacketLifeTime || maxRetransmits) {
                      ordered = false;
                    }
                    return this._awaitQueue.push(async () => {
                      const { dataChannel, sctpStreamParameters } = await this._handler.sendDataChannel({
                        ordered,
                        maxPacketLifeTime,
                        maxRetransmits,
                        label,
                        protocol
                      });
                      ortc.validateAndNormalizeSctpStreamParameters(sctpStreamParameters);
                      const { id } = await new Promise((resolve, reject) => {
                        this.safeEmit("producedata", {
                          sctpStreamParameters,
                          label,
                          protocol,
                          appData
                        }, resolve, reject);
                      });
                      const dataProducer = new DataProducer_1.DataProducer({
                        id,
                        dataChannel,
                        sctpStreamParameters,
                        appData
                      });
                      this._dataProducers.set(dataProducer.id, dataProducer);
                      this.handleDataProducer(dataProducer);
                      this._observer.safeEmit("newdataproducer", dataProducer);
                      return dataProducer;
                    }, "transport.produceData()");
                  }
                  /**
                   * Create a DataConsumer
                   */
                  async consumeData({ id, dataProducerId, sctpStreamParameters, label = "", protocol = "", appData = {} }) {
                    logger.debug("consumeData()");
                    if (this._closed) {
                      throw new errors_1.InvalidStateError("closed");
                    } else if (this._direction !== "recv") {
                      throw new errors_1.UnsupportedError("not a receiving Transport");
                    } else if (!this._maxSctpMessageSize) {
                      throw new errors_1.UnsupportedError("SCTP not enabled by remote Transport");
                    } else if (typeof id !== "string") {
                      throw new TypeError("missing id");
                    } else if (typeof dataProducerId !== "string") {
                      throw new TypeError("missing dataProducerId");
                    } else if (this.listenerCount("connect") === 0 && this._connectionState === "new") {
                      throw new TypeError('no "connect" listener set into this transport');
                    } else if (appData && typeof appData !== "object") {
                      throw new TypeError("if given, appData must be an object");
                    }
                    const clonedSctpStreamParameters = utils.clone(sctpStreamParameters);
                    ortc.validateAndNormalizeSctpStreamParameters(clonedSctpStreamParameters);
                    return this._awaitQueue.push(async () => {
                      const { dataChannel } = await this._handler.receiveDataChannel({
                        sctpStreamParameters: clonedSctpStreamParameters,
                        label,
                        protocol
                      });
                      const dataConsumer = new DataConsumer_1.DataConsumer({
                        id,
                        dataProducerId,
                        dataChannel,
                        sctpStreamParameters: clonedSctpStreamParameters,
                        appData
                      });
                      this._dataConsumers.set(dataConsumer.id, dataConsumer);
                      this.handleDataConsumer(dataConsumer);
                      this._observer.safeEmit("newdataconsumer", dataConsumer);
                      return dataConsumer;
                    }, "transport.consumeData()");
                  }
                  // This method is guaranteed to never throw.
                  createPendingConsumers() {
                    this._consumerCreationInProgress = true;
                    this._awaitQueue.push(async () => {
                      if (this._pendingConsumerTasks.length === 0) {
                        logger.debug("createPendingConsumers() | there is no Consumer to be created");
                        return;
                      }
                      const pendingConsumerTasks = [...this._pendingConsumerTasks];
                      this._pendingConsumerTasks = [];
                      let videoConsumerForProbator = void 0;
                      const optionsList = [];
                      for (const task of pendingConsumerTasks) {
                        const { id, kind, rtpParameters, streamId, onRtpReceiver } = task.consumerOptions;
                        optionsList.push({
                          trackId: id,
                          kind,
                          rtpParameters,
                          streamId,
                          onRtpReceiver
                        });
                      }
                      try {
                        const results = await this._handler.receive(optionsList);
                        for (let idx = 0; idx < results.length; ++idx) {
                          const task = pendingConsumerTasks[idx];
                          const result = results[idx];
                          const { id, producerId, kind, rtpParameters, appData } = task.consumerOptions;
                          const { localId, rtpReceiver, track } = result;
                          const consumer = new Consumer_1.Consumer({
                            id,
                            localId,
                            producerId,
                            rtpReceiver,
                            track,
                            rtpParameters,
                            appData
                          });
                          this._consumers.set(consumer.id, consumer);
                          this.handleConsumer(consumer);
                          if (!this._probatorConsumerCreated && !videoConsumerForProbator && kind === "video") {
                            videoConsumerForProbator = consumer;
                          }
                          this._observer.safeEmit("newconsumer", consumer);
                          task.resolve(consumer);
                        }
                      } catch (error) {
                        for (const task of pendingConsumerTasks) {
                          task.reject(error);
                        }
                      }
                      if (videoConsumerForProbator) {
                        try {
                          const probatorRtpParameters = ortc.generateProbatorRtpParameters(videoConsumerForProbator.rtpParameters);
                          await this._handler.receive([
                            {
                              trackId: "probator",
                              kind: "video",
                              rtpParameters: probatorRtpParameters
                            }
                          ]);
                          logger.debug("createPendingConsumers() | Consumer for RTP probation created");
                          this._probatorConsumerCreated = true;
                        } catch (error) {
                          logger.error("createPendingConsumers() | failed to create Consumer for RTP probation:%o", error);
                        }
                      }
                    }, "transport.createPendingConsumers()").then(() => {
                      this._consumerCreationInProgress = false;
                      if (this._pendingConsumerTasks.length > 0) {
                        this.createPendingConsumers();
                      }
                    }).catch(() => {
                    });
                  }
                  pausePendingConsumers() {
                    this._consumerPauseInProgress = true;
                    this._awaitQueue.push(async () => {
                      if (this._pendingPauseConsumers.size === 0) {
                        logger.debug("pausePendingConsumers() | there is no Consumer to be paused");
                        return;
                      }
                      const pendingPauseConsumers = Array.from(this._pendingPauseConsumers.values());
                      this._pendingPauseConsumers.clear();
                      try {
                        const localIds = pendingPauseConsumers.map((consumer) => consumer.localId);
                        await this._handler.pauseReceiving(localIds);
                      } catch (error) {
                        logger.error("pausePendingConsumers() | failed to pause Consumers:", error);
                      }
                    }, "transport.pausePendingConsumers").then(() => {
                      this._consumerPauseInProgress = false;
                      if (this._pendingPauseConsumers.size > 0) {
                        this.pausePendingConsumers();
                      }
                    }).catch(() => {
                    });
                  }
                  resumePendingConsumers() {
                    this._consumerResumeInProgress = true;
                    this._awaitQueue.push(async () => {
                      if (this._pendingResumeConsumers.size === 0) {
                        logger.debug("resumePendingConsumers() | there is no Consumer to be resumed");
                        return;
                      }
                      const pendingResumeConsumers = Array.from(this._pendingResumeConsumers.values());
                      this._pendingResumeConsumers.clear();
                      try {
                        const localIds = pendingResumeConsumers.map((consumer) => consumer.localId);
                        await this._handler.resumeReceiving(localIds);
                      } catch (error) {
                        logger.error("resumePendingConsumers() | failed to resume Consumers:", error);
                      }
                    }, "transport.resumePendingConsumers").then(() => {
                      this._consumerResumeInProgress = false;
                      if (this._pendingResumeConsumers.size > 0) {
                        this.resumePendingConsumers();
                      }
                    }).catch(() => {
                    });
                  }
                  closePendingConsumers() {
                    this._consumerCloseInProgress = true;
                    this._awaitQueue.push(async () => {
                      if (this._pendingCloseConsumers.size === 0) {
                        logger.debug("closePendingConsumers() | there is no Consumer to be closed");
                        return;
                      }
                      const pendingCloseConsumers = Array.from(this._pendingCloseConsumers.values());
                      this._pendingCloseConsumers.clear();
                      try {
                        await this._handler.stopReceiving(pendingCloseConsumers.map((consumer) => consumer.localId));
                      } catch (error) {
                        logger.error("closePendingConsumers() | failed to close Consumers:", error);
                      }
                    }, "transport.closePendingConsumers").then(() => {
                      this._consumerCloseInProgress = false;
                      if (this._pendingCloseConsumers.size > 0) {
                        this.closePendingConsumers();
                      }
                    }).catch(() => {
                    });
                  }
                  handleHandler() {
                    const handler = this._handler;
                    handler.on("@connect", ({ dtlsParameters }, callback, errback) => {
                      if (this._closed) {
                        errback(new errors_1.InvalidStateError("closed"));
                        return;
                      }
                      this.safeEmit("connect", { dtlsParameters }, callback, errback);
                    });
                    handler.on("@icegatheringstatechange", (iceGatheringState) => {
                      if (iceGatheringState === this._iceGatheringState) {
                        return;
                      }
                      logger.debug("ICE gathering state changed to %s", iceGatheringState);
                      this._iceGatheringState = iceGatheringState;
                      if (!this._closed) {
                        this.safeEmit("icegatheringstatechange", iceGatheringState);
                      }
                    });
                    handler.on("@icecandidateerror", (event) => {
                      logger.warn(`ICE candidate error [url:${event.url}, localAddress:${event.address}, localPort:${event.port}]: ${event.errorCode} "${event.errorText}"`);
                      this.safeEmit("icecandidateerror", event);
                    });
                    handler.on("@connectionstatechange", (connectionState) => {
                      if (connectionState === this._connectionState) {
                        return;
                      }
                      logger.debug("connection state changed to %s", connectionState);
                      this._connectionState = connectionState;
                      if (!this._closed) {
                        this.safeEmit("connectionstatechange", connectionState);
                      }
                    });
                  }
                  handleProducer(producer) {
                    producer.on("@close", () => {
                      this._producers.delete(producer.id);
                      if (this._closed) {
                        return;
                      }
                      this._awaitQueue.push(async () => await this._handler.stopSending(producer.localId), "producer @close event").catch((error) => logger.warn("producer.close() failed:%o", error));
                    });
                    producer.on("@pause", (callback, errback) => {
                      this._awaitQueue.push(async () => await this._handler.pauseSending(producer.localId), "producer @pause event").then(callback).catch(errback);
                    });
                    producer.on("@resume", (callback, errback) => {
                      this._awaitQueue.push(async () => await this._handler.resumeSending(producer.localId), "producer @resume event").then(callback).catch(errback);
                    });
                    producer.on("@replacetrack", (track, callback, errback) => {
                      this._awaitQueue.push(async () => await this._handler.replaceTrack(producer.localId, track), "producer @replacetrack event").then(callback).catch(errback);
                    });
                    producer.on("@setmaxspatiallayer", (spatialLayer, callback, errback) => {
                      this._awaitQueue.push(async () => await this._handler.setMaxSpatialLayer(producer.localId, spatialLayer), "producer @setmaxspatiallayer event").then(callback).catch(errback);
                    });
                    producer.on("@setrtpencodingparameters", (params, callback, errback) => {
                      this._awaitQueue.push(async () => await this._handler.setRtpEncodingParameters(producer.localId, params), "producer @setrtpencodingparameters event").then(callback).catch(errback);
                    });
                    producer.on("@getstats", (callback, errback) => {
                      if (this._closed) {
                        return errback(new errors_1.InvalidStateError("closed"));
                      }
                      this._handler.getSenderStats(producer.localId).then(callback).catch(errback);
                    });
                  }
                  handleConsumer(consumer) {
                    consumer.on("@close", () => {
                      this._consumers.delete(consumer.id);
                      this._pendingPauseConsumers.delete(consumer.id);
                      this._pendingResumeConsumers.delete(consumer.id);
                      if (this._closed) {
                        return;
                      }
                      this._pendingCloseConsumers.set(consumer.id, consumer);
                      if (this._consumerCloseInProgress === false) {
                        this.closePendingConsumers();
                      }
                    });
                    consumer.on("@pause", () => {
                      if (this._pendingResumeConsumers.has(consumer.id)) {
                        this._pendingResumeConsumers.delete(consumer.id);
                      }
                      this._pendingPauseConsumers.set(consumer.id, consumer);
                      queueMicrotask(() => {
                        if (this._closed) {
                          return;
                        }
                        if (this._consumerPauseInProgress === false) {
                          this.pausePendingConsumers();
                        }
                      });
                    });
                    consumer.on("@resume", () => {
                      if (this._pendingPauseConsumers.has(consumer.id)) {
                        this._pendingPauseConsumers.delete(consumer.id);
                      }
                      this._pendingResumeConsumers.set(consumer.id, consumer);
                      queueMicrotask(() => {
                        if (this._closed) {
                          return;
                        }
                        if (this._consumerResumeInProgress === false) {
                          this.resumePendingConsumers();
                        }
                      });
                    });
                    consumer.on("@getstats", (callback, errback) => {
                      if (this._closed) {
                        return errback(new errors_1.InvalidStateError("closed"));
                      }
                      this._handler.getReceiverStats(consumer.localId).then(callback).catch(errback);
                    });
                  }
                  handleDataProducer(dataProducer) {
                    dataProducer.on("@close", () => {
                      this._dataProducers.delete(dataProducer.id);
                    });
                  }
                  handleDataConsumer(dataConsumer) {
                    dataConsumer.on("@close", () => {
                      this._dataConsumers.delete(dataConsumer.id);
                    });
                  }
                }
                exports2.Transport = Transport;
              }
            ),
            /***/
            5602: (
              /***/
              (module2) => {
                var grammar = module2.exports = {
                  v: [{
                    name: "version",
                    reg: /^(\d*)$/
                  }],
                  o: [{
                    // o=- 20518 0 IN IP4 203.0.113.1
                    // NB: sessionId will be a String in most cases because it is huge
                    name: "origin",
                    reg: /^(\S*) (\d*) (\d*) (\S*) IP(\d) (\S*)/,
                    names: ["username", "sessionId", "sessionVersion", "netType", "ipVer", "address"],
                    format: "%s %s %d %s IP%d %s"
                  }],
                  // default parsing of these only (though some of these feel outdated)
                  s: [{ name: "name" }],
                  i: [{ name: "description" }],
                  u: [{ name: "uri" }],
                  e: [{ name: "email" }],
                  p: [{ name: "phone" }],
                  z: [{ name: "timezones" }],
                  // TODO: this one can actually be parsed properly...
                  r: [{ name: "repeats" }],
                  // TODO: this one can also be parsed properly
                  // k: [{}], // outdated thing ignored
                  t: [{
                    // t=0 0
                    name: "timing",
                    reg: /^(\d*) (\d*)/,
                    names: ["start", "stop"],
                    format: "%d %d"
                  }],
                  c: [{
                    // c=IN IP4 10.47.197.26
                    name: "connection",
                    reg: /^IN IP(\d) (\S*)/,
                    names: ["version", "ip"],
                    format: "IN IP%d %s"
                  }],
                  b: [{
                    // b=AS:4000
                    push: "bandwidth",
                    reg: /^(TIAS|AS|CT|RR|RS):(\d*)/,
                    names: ["type", "limit"],
                    format: "%s:%s"
                  }],
                  m: [{
                    // m=video 51744 RTP/AVP 126 97 98 34 31
                    // NB: special - pushes to session
                    // TODO: rtp/fmtp should be filtered by the payloads found here?
                    reg: /^(\w*) (\d*) ([\w/]*)(?: (.*))?/,
                    names: ["type", "port", "protocol", "payloads"],
                    format: "%s %d %s %s"
                  }],
                  a: [
                    {
                      // a=rtpmap:110 opus/48000/2
                      push: "rtp",
                      reg: /^rtpmap:(\d*) ([\w\-.]*)(?:\s*\/(\d*)(?:\s*\/(\S*))?)?/,
                      names: ["payload", "codec", "rate", "encoding"],
                      format: function(o) {
                        return o.encoding ? "rtpmap:%d %s/%s/%s" : o.rate ? "rtpmap:%d %s/%s" : "rtpmap:%d %s";
                      }
                    },
                    {
                      // a=fmtp:108 profile-level-id=24;object=23;bitrate=64000
                      // a=fmtp:111 minptime=10; useinbandfec=1
                      push: "fmtp",
                      reg: /^fmtp:(\d*) ([\S| ]*)/,
                      names: ["payload", "config"],
                      format: "fmtp:%d %s"
                    },
                    {
                      // a=control:streamid=0
                      name: "control",
                      reg: /^control:(.*)/,
                      format: "control:%s"
                    },
                    {
                      // a=rtcp:65179 IN IP4 193.84.77.194
                      name: "rtcp",
                      reg: /^rtcp:(\d*)(?: (\S*) IP(\d) (\S*))?/,
                      names: ["port", "netType", "ipVer", "address"],
                      format: function(o) {
                        return o.address != null ? "rtcp:%d %s IP%d %s" : "rtcp:%d";
                      }
                    },
                    {
                      // a=rtcp-fb:98 trr-int 100
                      push: "rtcpFbTrrInt",
                      reg: /^rtcp-fb:(\*|\d*) trr-int (\d*)/,
                      names: ["payload", "value"],
                      format: "rtcp-fb:%s trr-int %d"
                    },
                    {
                      // a=rtcp-fb:98 nack rpsi
                      push: "rtcpFb",
                      reg: /^rtcp-fb:(\*|\d*) ([\w-_]*)(?: ([\w-_]*))?/,
                      names: ["payload", "type", "subtype"],
                      format: function(o) {
                        return o.subtype != null ? "rtcp-fb:%s %s %s" : "rtcp-fb:%s %s";
                      }
                    },
                    {
                      // a=extmap:2 urn:ietf:params:rtp-hdrext:toffset
                      // a=extmap:1/recvonly URI-gps-string
                      // a=extmap:3 urn:ietf:params:rtp-hdrext:encrypt urn:ietf:params:rtp-hdrext:smpte-tc 25@600/24
                      push: "ext",
                      reg: /^extmap:(\d+)(?:\/(\w+))?(?: (urn:ietf:params:rtp-hdrext:encrypt))? (\S*)(?: (\S*))?/,
                      names: ["value", "direction", "encrypt-uri", "uri", "config"],
                      format: function(o) {
                        return "extmap:%d" + (o.direction ? "/%s" : "%v") + (o["encrypt-uri"] ? " %s" : "%v") + " %s" + (o.config ? " %s" : "");
                      }
                    },
                    {
                      // a=extmap-allow-mixed
                      name: "extmapAllowMixed",
                      reg: /^(extmap-allow-mixed)/
                    },
                    {
                      // a=crypto:1 AES_CM_128_HMAC_SHA1_80 inline:PS1uQCVeeCFCanVmcjkpPywjNWhcYD0mXXtxaVBR|2^20|1:32
                      push: "crypto",
                      reg: /^crypto:(\d*) ([\w_]*) (\S*)(?: (\S*))?/,
                      names: ["id", "suite", "config", "sessionConfig"],
                      format: function(o) {
                        return o.sessionConfig != null ? "crypto:%d %s %s %s" : "crypto:%d %s %s";
                      }
                    },
                    {
                      // a=setup:actpass
                      name: "setup",
                      reg: /^setup:(\w*)/,
                      format: "setup:%s"
                    },
                    {
                      // a=connection:new
                      name: "connectionType",
                      reg: /^connection:(new|existing)/,
                      format: "connection:%s"
                    },
                    {
                      // a=mid:1
                      name: "mid",
                      reg: /^mid:([^\s]*)/,
                      format: "mid:%s"
                    },
                    {
                      // a=msid:0c8b064d-d807-43b4-b434-f92a889d8587 98178685-d409-46e0-8e16-7ef0db0db64a
                      name: "msid",
                      reg: /^msid:(.*)/,
                      format: "msid:%s"
                    },
                    {
                      // a=ptime:20
                      name: "ptime",
                      reg: /^ptime:(\d*(?:\.\d*)*)/,
                      format: "ptime:%d"
                    },
                    {
                      // a=maxptime:60
                      name: "maxptime",
                      reg: /^maxptime:(\d*(?:\.\d*)*)/,
                      format: "maxptime:%d"
                    },
                    {
                      // a=sendrecv
                      name: "direction",
                      reg: /^(sendrecv|recvonly|sendonly|inactive)/
                    },
                    {
                      // a=ice-lite
                      name: "icelite",
                      reg: /^(ice-lite)/
                    },
                    {
                      // a=ice-ufrag:F7gI
                      name: "iceUfrag",
                      reg: /^ice-ufrag:(\S*)/,
                      format: "ice-ufrag:%s"
                    },
                    {
                      // a=ice-pwd:x9cml/YzichV2+XlhiMu8g
                      name: "icePwd",
                      reg: /^ice-pwd:(\S*)/,
                      format: "ice-pwd:%s"
                    },
                    {
                      // a=fingerprint:SHA-1 00:11:22:33:44:55:66:77:88:99:AA:BB:CC:DD:EE:FF:00:11:22:33
                      name: "fingerprint",
                      reg: /^fingerprint:(\S*) (\S*)/,
                      names: ["type", "hash"],
                      format: "fingerprint:%s %s"
                    },
                    {
                      // a=candidate:0 1 UDP 2113667327 203.0.113.1 54400 typ host
                      // a=candidate:1162875081 1 udp 2113937151 192.168.34.75 60017 typ host generation 0 network-id 3 network-cost 10
                      // a=candidate:3289912957 2 udp 1845501695 193.84.77.194 60017 typ srflx raddr 192.168.34.75 rport 60017 generation 0 network-id 3 network-cost 10
                      // a=candidate:229815620 1 tcp 1518280447 192.168.150.19 60017 typ host tcptype active generation 0 network-id 3 network-cost 10
                      // a=candidate:3289912957 2 tcp 1845501695 193.84.77.194 60017 typ srflx raddr 192.168.34.75 rport 60017 tcptype passive generation 0 network-id 3 network-cost 10
                      push: "candidates",
                      reg: /^candidate:(\S*) (\d*) (\S*) (\d*) (\S*) (\d*) typ (\S*)(?: raddr (\S*) rport (\d*))?(?: tcptype (\S*))?(?: generation (\d*))?(?: network-id (\d*))?(?: network-cost (\d*))?/,
                      names: ["foundation", "component", "transport", "priority", "ip", "port", "type", "raddr", "rport", "tcptype", "generation", "network-id", "network-cost"],
                      format: function(o) {
                        var str = "candidate:%s %d %s %d %s %d typ %s";
                        str += o.raddr != null ? " raddr %s rport %d" : "%v%v";
                        str += o.tcptype != null ? " tcptype %s" : "%v";
                        if (o.generation != null) {
                          str += " generation %d";
                        }
                        str += o["network-id"] != null ? " network-id %d" : "%v";
                        str += o["network-cost"] != null ? " network-cost %d" : "%v";
                        return str;
                      }
                    },
                    {
                      // a=end-of-candidates (keep after the candidates line for readability)
                      name: "endOfCandidates",
                      reg: /^(end-of-candidates)/
                    },
                    {
                      // a=remote-candidates:1 203.0.113.1 54400 2 203.0.113.1 54401 ...
                      name: "remoteCandidates",
                      reg: /^remote-candidates:(.*)/,
                      format: "remote-candidates:%s"
                    },
                    {
                      // a=ice-options:google-ice
                      name: "iceOptions",
                      reg: /^ice-options:(\S*)/,
                      format: "ice-options:%s"
                    },
                    {
                      // a=ssrc:2566107569 cname:t9YU8M1UxTF8Y1A1
                      push: "ssrcs",
                      reg: /^ssrc:(\d*) ([\w_-]*)(?::(.*))?/,
                      names: ["id", "attribute", "value"],
                      format: function(o) {
                        var str = "ssrc:%d";
                        if (o.attribute != null) {
                          str += " %s";
                          if (o.value != null) {
                            str += ":%s";
                          }
                        }
                        return str;
                      }
                    },
                    {
                      // a=ssrc-group:FEC 1 2
                      // a=ssrc-group:FEC-FR 3004364195 1080772241
                      push: "ssrcGroups",
                      // token-char = %x21 / %x23-27 / %x2A-2B / %x2D-2E / %x30-39 / %x41-5A / %x5E-7E
                      reg: /^ssrc-group:([\x21\x23\x24\x25\x26\x27\x2A\x2B\x2D\x2E\w]*) (.*)/,
                      names: ["semantics", "ssrcs"],
                      format: "ssrc-group:%s %s"
                    },
                    {
                      // a=msid-semantic: WMS Jvlam5X3SX1OP6pn20zWogvaKJz5Hjf9OnlV
                      name: "msidSemantic",
                      reg: /^msid-semantic:\s?(\w*) (\S*)/,
                      names: ["semantic", "token"],
                      format: "msid-semantic: %s %s"
                      // space after ':' is not accidental
                    },
                    {
                      // a=group:BUNDLE audio video
                      push: "groups",
                      reg: /^group:(\w*) (.*)/,
                      names: ["type", "mids"],
                      format: "group:%s %s"
                    },
                    {
                      // a=rtcp-mux
                      name: "rtcpMux",
                      reg: /^(rtcp-mux)/
                    },
                    {
                      // a=rtcp-rsize
                      name: "rtcpRsize",
                      reg: /^(rtcp-rsize)/
                    },
                    {
                      // a=sctpmap:5000 webrtc-datachannel 1024
                      name: "sctpmap",
                      reg: /^sctpmap:([\w_/]*) (\S*)(?: (\S*))?/,
                      names: ["sctpmapNumber", "app", "maxMessageSize"],
                      format: function(o) {
                        return o.maxMessageSize != null ? "sctpmap:%s %s %s" : "sctpmap:%s %s";
                      }
                    },
                    {
                      // a=x-google-flag:conference
                      name: "xGoogleFlag",
                      reg: /^x-google-flag:([^\s]*)/,
                      format: "x-google-flag:%s"
                    },
                    {
                      // a=rid:1 send max-width=1280;max-height=720;max-fps=30;depend=0
                      push: "rids",
                      reg: /^rid:([\d\w]+) (\w+)(?: ([\S| ]*))?/,
                      names: ["id", "direction", "params"],
                      format: function(o) {
                        return o.params ? "rid:%s %s %s" : "rid:%s %s";
                      }
                    },
                    {
                      // a=imageattr:97 send [x=800,y=640,sar=1.1,q=0.6] [x=480,y=320] recv [x=330,y=250]
                      // a=imageattr:* send [x=800,y=640] recv *
                      // a=imageattr:100 recv [x=320,y=240]
                      push: "imageattrs",
                      reg: new RegExp(
                        // a=imageattr:97
                        "^imageattr:(\\d+|\\*)[\\s\\t]+(send|recv)[\\s\\t]+(\\*|\\[\\S+\\](?:[\\s\\t]+\\[\\S+\\])*)(?:[\\s\\t]+(recv|send)[\\s\\t]+(\\*|\\[\\S+\\](?:[\\s\\t]+\\[\\S+\\])*))?"
                      ),
                      names: ["pt", "dir1", "attrs1", "dir2", "attrs2"],
                      format: function(o) {
                        return "imageattr:%s %s %s" + (o.dir2 ? " %s %s" : "");
                      }
                    },
                    {
                      // a=simulcast:send 1,2,3;~4,~5 recv 6;~7,~8
                      // a=simulcast:recv 1;4,5 send 6;7
                      name: "simulcast",
                      reg: new RegExp(
                        // a=simulcast:
                        "^simulcast:(send|recv) ([a-zA-Z0-9\\-_~;,]+)(?:\\s?(send|recv) ([a-zA-Z0-9\\-_~;,]+))?$"
                      ),
                      names: ["dir1", "list1", "dir2", "list2"],
                      format: function(o) {
                        return "simulcast:%s %s" + (o.dir2 ? " %s %s" : "");
                      }
                    },
                    {
                      // old simulcast draft 03 (implemented by Firefox)
                      //   https://tools.ietf.org/html/draft-ietf-mmusic-sdp-simulcast-03
                      // a=simulcast: recv pt=97;98 send pt=97
                      // a=simulcast: send rid=5;6;7 paused=6,7
                      name: "simulcast_03",
                      reg: /^simulcast:[\s\t]+([\S+\s\t]+)$/,
                      names: ["value"],
                      format: "simulcast: %s"
                    },
                    {
                      // a=framerate:25
                      // a=framerate:29.97
                      name: "framerate",
                      reg: /^framerate:(\d+(?:$|\.\d+))/,
                      format: "framerate:%s"
                    },
                    {
                      // RFC4570
                      // a=source-filter: incl IN IP4 239.5.2.31 10.1.15.5
                      name: "sourceFilter",
                      reg: /^source-filter: *(excl|incl) (\S*) (IP4|IP6|\*) (\S*) (.*)/,
                      names: ["filterMode", "netType", "addressTypes", "destAddress", "srcList"],
                      format: "source-filter: %s %s %s %s %s"
                    },
                    {
                      // a=bundle-only
                      name: "bundleOnly",
                      reg: /^(bundle-only)/
                    },
                    {
                      // a=label:1
                      name: "label",
                      reg: /^label:(.+)/,
                      format: "label:%s"
                    },
                    {
                      // RFC version 26 for SCTP over DTLS
                      // https://tools.ietf.org/html/draft-ietf-mmusic-sctp-sdp-26#section-5
                      name: "sctpPort",
                      reg: /^sctp-port:(\d+)$/,
                      format: "sctp-port:%s"
                    },
                    {
                      // RFC version 26 for SCTP over DTLS
                      // https://tools.ietf.org/html/draft-ietf-mmusic-sctp-sdp-26#section-6
                      name: "maxMessageSize",
                      reg: /^max-message-size:(\d+)$/,
                      format: "max-message-size:%s"
                    },
                    {
                      // RFC7273
                      // a=ts-refclk:ptp=IEEE1588-2008:39-A7-94-FF-FE-07-CB-D0:37
                      push: "tsRefClocks",
                      reg: /^ts-refclk:([^\s=]*)(?:=(\S*))?/,
                      names: ["clksrc", "clksrcExt"],
                      format: function(o) {
                        return "ts-refclk:%s" + (o.clksrcExt != null ? "=%s" : "");
                      }
                    },
                    {
                      // RFC7273
                      // a=mediaclk:direct=963214424
                      name: "mediaClk",
                      reg: /^mediaclk:(?:id=(\S*))? *([^\s=]*)(?:=(\S*))?(?: *rate=(\d+)\/(\d+))?/,
                      names: ["id", "mediaClockName", "mediaClockValue", "rateNumerator", "rateDenominator"],
                      format: function(o) {
                        var str = "mediaclk:";
                        str += o.id != null ? "id=%s %s" : "%v%s";
                        str += o.mediaClockValue != null ? "=%s" : "";
                        str += o.rateNumerator != null ? " rate=%s" : "";
                        str += o.rateDenominator != null ? "/%s" : "";
                        return str;
                      }
                    },
                    {
                      // a=keywds:keywords
                      name: "keywords",
                      reg: /^keywds:(.+)$/,
                      format: "keywds:%s"
                    },
                    {
                      // a=content:main
                      name: "content",
                      reg: /^content:(.+)/,
                      format: "content:%s"
                    },
                    // BFCP https://tools.ietf.org/html/rfc4583
                    {
                      // a=floorctrl:c-s
                      name: "bfcpFloorCtrl",
                      reg: /^floorctrl:(c-only|s-only|c-s)/,
                      format: "floorctrl:%s"
                    },
                    {
                      // a=confid:1
                      name: "bfcpConfId",
                      reg: /^confid:(\d+)/,
                      format: "confid:%s"
                    },
                    {
                      // a=userid:1
                      name: "bfcpUserId",
                      reg: /^userid:(\d+)/,
                      format: "userid:%s"
                    },
                    {
                      // a=floorid:1
                      name: "bfcpFloorId",
                      reg: /^floorid:(.+) (?:m-stream|mstrm):(.+)/,
                      names: ["id", "mStream"],
                      format: "floorid:%s mstrm:%s"
                    },
                    {
                      // any a= that we don't understand is kept verbatim on media.invalid
                      push: "invalid",
                      names: ["value"]
                    }
                  ]
                };
                Object.keys(grammar).forEach(function(key) {
                  var objs = grammar[key];
                  objs.forEach(function(obj) {
                    if (!obj.reg) {
                      obj.reg = /(.*)/;
                    }
                    if (!obj.format) {
                      obj.format = "%s";
                    }
                  });
                });
              }
            ),
            /***/
            5765: (
              /***/
              (__unused_webpack_module, exports2, __webpack_require__2) => {
                "use strict";
                Object.defineProperty(exports2, "__esModule", { value: true });
                exports2.Safari12 = void 0;
                const sdpTransform = __webpack_require__2(7363);
                const enhancedEvents_1 = __webpack_require__2(3953);
                const Logger_1 = __webpack_require__2(2994);
                const ortc = __webpack_require__2(8046);
                const errors_1 = __webpack_require__2(4893);
                const scalabilityModes_1 = __webpack_require__2(3303);
                const RemoteSdp_1 = __webpack_require__2(1305);
                const sdpCommonUtils = __webpack_require__2(5544);
                const sdpUnifiedPlanUtils = __webpack_require__2(5938);
                const ortcUtils = __webpack_require__2(4256);
                const logger = new Logger_1.Logger("Safari12");
                const NAME = "Safari12";
                const SCTP_NUM_STREAMS = { OS: 1024, MIS: 1024 };
                class Safari12 extends enhancedEvents_1.EnhancedEventEmitter {
                  constructor({ direction, iceParameters, iceCandidates, dtlsParameters, sctpParameters, iceServers, iceTransportPolicy, additionalSettings, getSendExtendedRtpCapabilities }) {
                    super();
                    // Closed flag.
                    __publicField(this, "_closed", false);
                    // Handler direction.
                    __publicField(this, "_direction");
                    // Remote SDP handler.
                    __publicField(this, "_remoteSdp");
                    // Callback to request sending extended RTP capabilities on demand.
                    __publicField(this, "_getSendExtendedRtpCapabilities");
                    // Initial server side DTLS role. If not 'auto', it will force the opposite
                    // value in client side.
                    __publicField(this, "_forcedLocalDtlsRole");
                    // RTCPeerConnection instance.
                    __publicField(this, "_pc");
                    // Map of RTCTransceivers indexed by MID.
                    __publicField(this, "_mapMidTransceiver", /* @__PURE__ */ new Map());
                    // Local stream for sending.
                    __publicField(this, "_sendStream", new MediaStream());
                    // Whether a DataChannel m=application section has been created.
                    __publicField(this, "_hasDataChannelMediaSection", false);
                    // Sending DataChannel id value counter. Incremented for each new DataChannel.
                    __publicField(this, "_nextSendSctpStreamId", 0);
                    // Got transport local and remote parameters.
                    __publicField(this, "_transportReady", false);
                    __publicField(this, "onIceGatheringStateChange", () => {
                      this.emit("@icegatheringstatechange", this._pc.iceGatheringState);
                    });
                    __publicField(this, "onIceCandidateError", (event) => {
                      this.emit("@icecandidateerror", event);
                    });
                    __publicField(this, "onConnectionStateChange", () => {
                      this.emit("@connectionstatechange", this._pc.connectionState);
                    });
                    __publicField(this, "onIceConnectionStateChange", () => {
                      switch (this._pc.iceConnectionState) {
                        case "checking": {
                          this.emit("@connectionstatechange", "connecting");
                          break;
                        }
                        case "connected":
                        case "completed": {
                          this.emit("@connectionstatechange", "connected");
                          break;
                        }
                        case "failed": {
                          this.emit("@connectionstatechange", "failed");
                          break;
                        }
                        case "disconnected": {
                          this.emit("@connectionstatechange", "disconnected");
                          break;
                        }
                        case "closed": {
                          this.emit("@connectionstatechange", "closed");
                          break;
                        }
                      }
                    });
                    logger.debug("constructor()");
                    this._direction = direction;
                    this._remoteSdp = new RemoteSdp_1.RemoteSdp({
                      iceParameters,
                      iceCandidates,
                      dtlsParameters,
                      sctpParameters
                    });
                    this._getSendExtendedRtpCapabilities = getSendExtendedRtpCapabilities;
                    if (dtlsParameters.role && dtlsParameters.role !== "auto") {
                      this._forcedLocalDtlsRole = dtlsParameters.role === "server" ? "client" : "server";
                    }
                    this._pc = new RTCPeerConnection({
                      iceServers: iceServers ?? [],
                      iceTransportPolicy: iceTransportPolicy ?? "all",
                      bundlePolicy: "max-bundle",
                      rtcpMuxPolicy: "require",
                      ...additionalSettings
                    });
                    this._pc.addEventListener("icegatheringstatechange", () => {
                      this.emit("@icegatheringstatechange", this._pc.iceGatheringState);
                    });
                    this._pc.addEventListener("icecandidateerror", (event) => {
                      this.emit("@icecandidateerror", event);
                    });
                    this._pc.addEventListener("icegatheringstatechange", this.onIceGatheringStateChange);
                    this._pc.addEventListener("icecandidateerror", this.onIceCandidateError);
                    if (this._pc.connectionState) {
                      this._pc.addEventListener("connectionstatechange", this.onConnectionStateChange);
                    } else {
                      logger.warn("run() | pc.connectionState not supported, using pc.iceConnectionState");
                      this._pc.addEventListener("iceconnectionstatechange", this.onIceConnectionStateChange);
                    }
                  }
                  /**
                   * Creates a factory function.
                   */
                  static createFactory() {
                    return {
                      name: NAME,
                      factory: (options) => new Safari12(options),
                      getNativeRtpCapabilities: async () => {
                        logger.debug("getNativeRtpCapabilities()");
                        let pc = new RTCPeerConnection({
                          iceServers: [],
                          iceTransportPolicy: "all",
                          bundlePolicy: "max-bundle",
                          rtcpMuxPolicy: "require"
                        });
                        try {
                          pc.addTransceiver("audio");
                          pc.addTransceiver("video");
                          const offer = await pc.createOffer();
                          try {
                            pc.close();
                          } catch (error) {
                          }
                          pc = void 0;
                          const sdpObject = sdpTransform.parse(offer.sdp);
                          const nativeRtpCapabilities = Safari12.getLocalRtpCapabilities(sdpObject);
                          return nativeRtpCapabilities;
                        } catch (error) {
                          try {
                            pc == null ? void 0 : pc.close();
                          } catch (error2) {
                          }
                          pc = void 0;
                          throw error;
                        }
                      },
                      getNativeSctpCapabilities: async () => {
                        logger.debug("getNativeSctpCapabilities()");
                        return {
                          numStreams: SCTP_NUM_STREAMS
                        };
                      }
                    };
                  }
                  static getLocalRtpCapabilities(localSdpObject) {
                    const nativeRtpCapabilities = sdpCommonUtils.extractRtpCapabilities({
                      sdpObject: localSdpObject
                    });
                    ortc.validateAndNormalizeRtpCapabilities(nativeRtpCapabilities);
                    ortcUtils.addNackSupportForOpus(nativeRtpCapabilities);
                    return nativeRtpCapabilities;
                  }
                  get name() {
                    return NAME;
                  }
                  close() {
                    logger.debug("close()");
                    if (this._closed) {
                      return;
                    }
                    this._closed = true;
                    try {
                      this._pc.close();
                    } catch (error) {
                    }
                    this._pc.removeEventListener("icegatheringstatechange", this.onIceGatheringStateChange);
                    this._pc.removeEventListener("icecandidateerror", this.onIceCandidateError);
                    this._pc.removeEventListener("connectionstatechange", this.onConnectionStateChange);
                    this._pc.removeEventListener("iceconnectionstatechange", this.onIceConnectionStateChange);
                    this.emit("@close");
                    super.close();
                  }
                  async updateIceServers(iceServers) {
                    this.assertNotClosed();
                    logger.debug("updateIceServers()");
                    const configuration = this._pc.getConfiguration();
                    configuration.iceServers = iceServers;
                    this._pc.setConfiguration(configuration);
                  }
                  async restartIce(iceParameters) {
                    this.assertNotClosed();
                    logger.debug("restartIce()");
                    this._remoteSdp.updateIceParameters(iceParameters);
                    if (!this._transportReady) {
                      return;
                    }
                    if (this._direction === "send") {
                      const offer = await this._pc.createOffer({ iceRestart: true });
                      logger.debug("restartIce() | calling pc.setLocalDescription() [offer:%o]", offer);
                      await this._pc.setLocalDescription(offer);
                      const answer = {
                        type: "answer",
                        sdp: this._remoteSdp.getSdp()
                      };
                      logger.debug("restartIce() | calling pc.setRemoteDescription() [answer:%o]", answer);
                      await this._pc.setRemoteDescription(answer);
                    } else {
                      const offer = {
                        type: "offer",
                        sdp: this._remoteSdp.getSdp()
                      };
                      logger.debug("restartIce() | calling pc.setRemoteDescription() [offer:%o]", offer);
                      await this._pc.setRemoteDescription(offer);
                      const answer = await this._pc.createAnswer();
                      logger.debug("restartIce() | calling pc.setLocalDescription() [answer:%o]", answer);
                      await this._pc.setLocalDescription(answer);
                    }
                  }
                  async getTransportStats() {
                    this.assertNotClosed();
                    return this._pc.getStats();
                  }
                  async send({ track, encodings, codecOptions, codec, onRtpSender }) {
                    this.assertNotClosed();
                    this.assertSendDirection();
                    logger.debug("send() [kind:%s, track.id:%s]", track.kind, track.id);
                    const mediaSectionIdx = this._remoteSdp.getNextMediaSectionIdx();
                    const transceiver = this._pc.addTransceiver(track, {
                      direction: "sendonly",
                      streams: [this._sendStream]
                    });
                    if (onRtpSender) {
                      onRtpSender(transceiver.sender);
                    }
                    let offer = await this._pc.createOffer();
                    let localSdpObject = sdpTransform.parse(offer.sdp);
                    if (localSdpObject.extmapAllowMixed) {
                      this._remoteSdp.setSessionExtmapAllowMixed();
                    }
                    const nativeRtpCapabilities = Safari12.getLocalRtpCapabilities(localSdpObject);
                    const sendExtendedRtpCapabilities = this._getSendExtendedRtpCapabilities(nativeRtpCapabilities);
                    const sendingRtpParameters = ortc.getSendingRtpParameters(track.kind, sendExtendedRtpCapabilities);
                    sendingRtpParameters.codecs = ortc.reduceCodecs(sendingRtpParameters.codecs, codec);
                    const sendingRemoteRtpParameters = ortc.getSendingRemoteRtpParameters(track.kind, sendExtendedRtpCapabilities);
                    sendingRemoteRtpParameters.codecs = ortc.reduceCodecs(sendingRemoteRtpParameters.codecs, codec);
                    let offerMediaObject;
                    if (!this._transportReady) {
                      await this.setupTransport({
                        localDtlsRole: this._forcedLocalDtlsRole ?? "client",
                        localSdpObject
                      });
                    }
                    const layers = (0, scalabilityModes_1.parse)((encodings ?? [{}])[0].scalabilityMode);
                    if (encodings && encodings.length > 1) {
                      logger.debug("send() | enabling legacy simulcast");
                      localSdpObject = sdpTransform.parse(offer.sdp);
                      offerMediaObject = localSdpObject.media[mediaSectionIdx.idx];
                      sdpUnifiedPlanUtils.addLegacySimulcast({
                        offerMediaObject,
                        numStreams: encodings.length
                      });
                      offer = {
                        type: "offer",
                        sdp: sdpTransform.write(localSdpObject)
                      };
                    }
                    logger.debug("send() | calling pc.setLocalDescription() [offer:%o]", offer);
                    await this._pc.setLocalDescription(offer);
                    const localId = transceiver.mid;
                    sendingRtpParameters.mid = localId;
                    localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
                    offerMediaObject = localSdpObject.media[mediaSectionIdx.idx];
                    sendingRtpParameters.rtcp.cname = sdpCommonUtils.getCname({
                      offerMediaObject
                    });
                    sendingRtpParameters.encodings = sdpUnifiedPlanUtils.getRtpEncodings({
                      offerMediaObject
                    });
                    if (encodings) {
                      for (let idx = 0; idx < sendingRtpParameters.encodings.length; ++idx) {
                        if (encodings[idx]) {
                          Object.assign(sendingRtpParameters.encodings[idx], encodings[idx]);
                        }
                      }
                    }
                    if (sendingRtpParameters.encodings.length > 1 && (sendingRtpParameters.codecs[0].mimeType.toLowerCase() === "video/vp8" || sendingRtpParameters.codecs[0].mimeType.toLowerCase() === "video/h264")) {
                      for (const encoding of sendingRtpParameters.encodings) {
                        if (encoding.scalabilityMode) {
                          encoding.scalabilityMode = `L1T${layers.temporalLayers}`;
                        } else {
                          encoding.scalabilityMode = "L1T3";
                        }
                      }
                    }
                    this._remoteSdp.send({
                      offerMediaObject,
                      reuseMid: mediaSectionIdx.reuseMid,
                      offerRtpParameters: sendingRtpParameters,
                      answerRtpParameters: sendingRemoteRtpParameters,
                      codecOptions
                    });
                    const answer = {
                      type: "answer",
                      sdp: this._remoteSdp.getSdp()
                    };
                    logger.debug("send() | calling pc.setRemoteDescription() [answer:%o]", answer);
                    await this._pc.setRemoteDescription(answer);
                    this._mapMidTransceiver.set(localId, transceiver);
                    return {
                      localId,
                      rtpParameters: sendingRtpParameters,
                      rtpSender: transceiver.sender
                    };
                  }
                  async stopSending(localId) {
                    this.assertSendDirection();
                    if (this._closed) {
                      return;
                    }
                    logger.debug("stopSending() [localId:%s]", localId);
                    const transceiver = this._mapMidTransceiver.get(localId);
                    if (!transceiver) {
                      throw new Error("associated RTCRtpTransceiver not found");
                    }
                    void transceiver.sender.replaceTrack(null);
                    this._pc.removeTrack(transceiver.sender);
                    const mediaSectionClosed = this._remoteSdp.closeMediaSection(transceiver.mid);
                    if (mediaSectionClosed) {
                      try {
                        transceiver.stop();
                      } catch (error) {
                      }
                    }
                    const offer = await this._pc.createOffer();
                    logger.debug("stopSending() | calling pc.setLocalDescription() [offer:%o]", offer);
                    await this._pc.setLocalDescription(offer);
                    const answer = {
                      type: "answer",
                      sdp: this._remoteSdp.getSdp()
                    };
                    logger.debug("stopSending() | calling pc.setRemoteDescription() [answer:%o]", answer);
                    await this._pc.setRemoteDescription(answer);
                    this._mapMidTransceiver.delete(localId);
                  }
                  async pauseSending(localId) {
                    this.assertNotClosed();
                    this.assertSendDirection();
                    logger.debug("pauseSending() [localId:%s]", localId);
                    const transceiver = this._mapMidTransceiver.get(localId);
                    if (!transceiver) {
                      throw new Error("associated RTCRtpTransceiver not found");
                    }
                    transceiver.direction = "inactive";
                    this._remoteSdp.pauseMediaSection(localId);
                    const offer = await this._pc.createOffer();
                    logger.debug("pauseSending() | calling pc.setLocalDescription() [offer:%o]", offer);
                    await this._pc.setLocalDescription(offer);
                    const answer = {
                      type: "answer",
                      sdp: this._remoteSdp.getSdp()
                    };
                    logger.debug("pauseSending() | calling pc.setRemoteDescription() [answer:%o]", answer);
                    await this._pc.setRemoteDescription(answer);
                  }
                  async resumeSending(localId) {
                    this.assertNotClosed();
                    this.assertSendDirection();
                    logger.debug("resumeSending() [localId:%s]", localId);
                    const transceiver = this._mapMidTransceiver.get(localId);
                    if (!transceiver) {
                      throw new Error("associated RTCRtpTransceiver not found");
                    }
                    transceiver.direction = "sendonly";
                    this._remoteSdp.resumeSendingMediaSection(localId);
                    const offer = await this._pc.createOffer();
                    logger.debug("resumeSending() | calling pc.setLocalDescription() [offer:%o]", offer);
                    await this._pc.setLocalDescription(offer);
                    const answer = {
                      type: "answer",
                      sdp: this._remoteSdp.getSdp()
                    };
                    logger.debug("resumeSending() | calling pc.setRemoteDescription() [answer:%o]", answer);
                    await this._pc.setRemoteDescription(answer);
                  }
                  async replaceTrack(localId, track) {
                    this.assertNotClosed();
                    this.assertSendDirection();
                    if (track) {
                      logger.debug("replaceTrack() [localId:%s, track.id:%s]", localId, track.id);
                    } else {
                      logger.debug("replaceTrack() [localId:%s, no track]", localId);
                    }
                    const transceiver = this._mapMidTransceiver.get(localId);
                    if (!transceiver) {
                      throw new Error("associated RTCRtpTransceiver not found");
                    }
                    await transceiver.sender.replaceTrack(track);
                  }
                  async setMaxSpatialLayer(localId, spatialLayer) {
                    this.assertNotClosed();
                    this.assertSendDirection();
                    logger.debug("setMaxSpatialLayer() [localId:%s, spatialLayer:%s]", localId, spatialLayer);
                    const transceiver = this._mapMidTransceiver.get(localId);
                    if (!transceiver) {
                      throw new Error("associated RTCRtpTransceiver not found");
                    }
                    const parameters = transceiver.sender.getParameters();
                    parameters.encodings.forEach((encoding, idx) => {
                      if (idx <= spatialLayer) {
                        encoding.active = true;
                      } else {
                        encoding.active = false;
                      }
                    });
                    await transceiver.sender.setParameters(parameters);
                    this._remoteSdp.muxMediaSectionSimulcast(localId, parameters.encodings);
                    const offer = await this._pc.createOffer();
                    logger.debug("setMaxSpatialLayer() | calling pc.setLocalDescription() [offer:%o]", offer);
                    await this._pc.setLocalDescription(offer);
                    const answer = {
                      type: "answer",
                      sdp: this._remoteSdp.getSdp()
                    };
                    logger.debug("setMaxSpatialLayer() | calling pc.setRemoteDescription() [answer:%o]", answer);
                    await this._pc.setRemoteDescription(answer);
                  }
                  async setRtpEncodingParameters(localId, params) {
                    this.assertNotClosed();
                    this.assertSendDirection();
                    logger.debug("setRtpEncodingParameters() [localId:%s, params:%o]", localId, params);
                    const transceiver = this._mapMidTransceiver.get(localId);
                    if (!transceiver) {
                      throw new Error("associated RTCRtpTransceiver not found");
                    }
                    const parameters = transceiver.sender.getParameters();
                    parameters.encodings.forEach((encoding, idx) => {
                      parameters.encodings[idx] = { ...encoding, ...params };
                    });
                    await transceiver.sender.setParameters(parameters);
                    this._remoteSdp.muxMediaSectionSimulcast(localId, parameters.encodings);
                    const offer = await this._pc.createOffer();
                    logger.debug("setRtpEncodingParameters() | calling pc.setLocalDescription() [offer:%o]", offer);
                    await this._pc.setLocalDescription(offer);
                    const answer = {
                      type: "answer",
                      sdp: this._remoteSdp.getSdp()
                    };
                    logger.debug("setRtpEncodingParameters() | calling pc.setRemoteDescription() [answer:%o]", answer);
                    await this._pc.setRemoteDescription(answer);
                  }
                  async getSenderStats(localId) {
                    this.assertNotClosed();
                    this.assertSendDirection();
                    const transceiver = this._mapMidTransceiver.get(localId);
                    if (!transceiver) {
                      throw new Error("associated RTCRtpTransceiver not found");
                    }
                    return transceiver.sender.getStats();
                  }
                  async sendDataChannel({ ordered, maxPacketLifeTime, maxRetransmits, label, protocol }) {
                    this.assertNotClosed();
                    this.assertSendDirection();
                    const options = {
                      negotiated: true,
                      id: this._nextSendSctpStreamId,
                      ordered,
                      maxPacketLifeTime,
                      maxRetransmits,
                      protocol
                    };
                    logger.debug("sendDataChannel() [options:%o]", options);
                    const dataChannel = this._pc.createDataChannel(label, options);
                    this._nextSendSctpStreamId = ++this._nextSendSctpStreamId % SCTP_NUM_STREAMS.MIS;
                    if (!this._hasDataChannelMediaSection) {
                      const offer = await this._pc.createOffer();
                      const localSdpObject = sdpTransform.parse(offer.sdp);
                      const offerMediaObject = localSdpObject.media.find((m) => m.type === "application");
                      if (!this._transportReady) {
                        await this.setupTransport({
                          localDtlsRole: this._forcedLocalDtlsRole ?? "client",
                          localSdpObject
                        });
                      }
                      logger.debug("sendDataChannel() | calling pc.setLocalDescription() [offer:%o]", offer);
                      await this._pc.setLocalDescription(offer);
                      this._remoteSdp.sendSctpAssociation({ offerMediaObject });
                      const answer = {
                        type: "answer",
                        sdp: this._remoteSdp.getSdp()
                      };
                      logger.debug("sendDataChannel() | calling pc.setRemoteDescription() [answer:%o]", answer);
                      await this._pc.setRemoteDescription(answer);
                      this._hasDataChannelMediaSection = true;
                    }
                    const sctpStreamParameters = {
                      streamId: options.id,
                      ordered: options.ordered,
                      maxPacketLifeTime: options.maxPacketLifeTime,
                      maxRetransmits: options.maxRetransmits
                    };
                    return { dataChannel, sctpStreamParameters };
                  }
                  async receive(optionsList) {
                    this.assertNotClosed();
                    this.assertRecvDirection();
                    const results = [];
                    const mapLocalId = /* @__PURE__ */ new Map();
                    for (const options of optionsList) {
                      const { trackId, kind, rtpParameters, streamId } = options;
                      logger.debug("receive() [trackId:%s, kind:%s]", trackId, kind);
                      const localId = rtpParameters.mid ?? String(this._mapMidTransceiver.size);
                      mapLocalId.set(trackId, localId);
                      this._remoteSdp.receive({
                        mid: localId,
                        kind,
                        offerRtpParameters: rtpParameters,
                        streamId: streamId ?? rtpParameters.rtcp.cname,
                        trackId
                      });
                    }
                    const offer = {
                      type: "offer",
                      sdp: this._remoteSdp.getSdp()
                    };
                    logger.debug("receive() | calling pc.setRemoteDescription() [offer:%o]", offer);
                    await this._pc.setRemoteDescription(offer);
                    for (const options of optionsList) {
                      const { trackId, onRtpReceiver } = options;
                      if (onRtpReceiver) {
                        const localId = mapLocalId.get(trackId);
                        const transceiver = this._pc.getTransceivers().find((t) => t.mid === localId);
                        if (!transceiver) {
                          throw new Error("transceiver not found");
                        }
                        onRtpReceiver(transceiver.receiver);
                      }
                    }
                    let answer = await this._pc.createAnswer();
                    const localSdpObject = sdpTransform.parse(answer.sdp);
                    for (const options of optionsList) {
                      const { trackId, rtpParameters } = options;
                      const localId = mapLocalId.get(trackId);
                      const answerMediaObject = localSdpObject.media.find((m) => String(m.mid) === localId);
                      sdpCommonUtils.applyCodecParameters({
                        offerRtpParameters: rtpParameters,
                        answerMediaObject
                      });
                    }
                    answer = {
                      type: "answer",
                      sdp: sdpTransform.write(localSdpObject)
                    };
                    if (!this._transportReady) {
                      await this.setupTransport({
                        localDtlsRole: this._forcedLocalDtlsRole ?? "client",
                        localSdpObject
                      });
                    }
                    logger.debug("receive() | calling pc.setLocalDescription() [answer:%o]", answer);
                    await this._pc.setLocalDescription(answer);
                    for (const options of optionsList) {
                      const { trackId } = options;
                      const localId = mapLocalId.get(trackId);
                      const transceiver = this._pc.getTransceivers().find((t) => t.mid === localId);
                      if (!transceiver) {
                        throw new Error("new RTCRtpTransceiver not found");
                      }
                      this._mapMidTransceiver.set(localId, transceiver);
                      results.push({
                        localId,
                        track: transceiver.receiver.track,
                        rtpReceiver: transceiver.receiver
                      });
                    }
                    return results;
                  }
                  async stopReceiving(localIds) {
                    this.assertRecvDirection();
                    if (this._closed) {
                      return;
                    }
                    for (const localId of localIds) {
                      logger.debug("stopReceiving() [localId:%s]", localId);
                      const transceiver = this._mapMidTransceiver.get(localId);
                      if (!transceiver) {
                        throw new Error("associated RTCRtpTransceiver not found");
                      }
                      this._remoteSdp.closeMediaSection(transceiver.mid);
                    }
                    const offer = {
                      type: "offer",
                      sdp: this._remoteSdp.getSdp()
                    };
                    logger.debug("stopReceiving() | calling pc.setRemoteDescription() [offer:%o]", offer);
                    await this._pc.setRemoteDescription(offer);
                    const answer = await this._pc.createAnswer();
                    logger.debug("stopReceiving() | calling pc.setLocalDescription() [answer:%o]", answer);
                    await this._pc.setLocalDescription(answer);
                    for (const localId of localIds) {
                      this._mapMidTransceiver.delete(localId);
                    }
                  }
                  async pauseReceiving(localIds) {
                    this.assertNotClosed();
                    this.assertRecvDirection();
                    for (const localId of localIds) {
                      logger.debug("pauseReceiving() [localId:%s]", localId);
                      const transceiver = this._mapMidTransceiver.get(localId);
                      if (!transceiver) {
                        throw new Error("associated RTCRtpTransceiver not found");
                      }
                      transceiver.direction = "inactive";
                      this._remoteSdp.pauseMediaSection(localId);
                    }
                    const offer = {
                      type: "offer",
                      sdp: this._remoteSdp.getSdp()
                    };
                    logger.debug("pauseReceiving() | calling pc.setRemoteDescription() [offer:%o]", offer);
                    await this._pc.setRemoteDescription(offer);
                    const answer = await this._pc.createAnswer();
                    logger.debug("pauseReceiving() | calling pc.setLocalDescription() [answer:%o]", answer);
                    await this._pc.setLocalDescription(answer);
                  }
                  async resumeReceiving(localIds) {
                    this.assertNotClosed();
                    this.assertRecvDirection();
                    for (const localId of localIds) {
                      logger.debug("resumeReceiving() [localId:%s]", localId);
                      const transceiver = this._mapMidTransceiver.get(localId);
                      if (!transceiver) {
                        throw new Error("associated RTCRtpTransceiver not found");
                      }
                      transceiver.direction = "recvonly";
                      this._remoteSdp.resumeReceivingMediaSection(localId);
                    }
                    const offer = {
                      type: "offer",
                      sdp: this._remoteSdp.getSdp()
                    };
                    logger.debug("resumeReceiving() | calling pc.setRemoteDescription() [offer:%o]", offer);
                    await this._pc.setRemoteDescription(offer);
                    const answer = await this._pc.createAnswer();
                    logger.debug("resumeReceiving() | calling pc.setLocalDescription() [answer:%o]", answer);
                    await this._pc.setLocalDescription(answer);
                  }
                  async getReceiverStats(localId) {
                    this.assertNotClosed();
                    this.assertRecvDirection();
                    const transceiver = this._mapMidTransceiver.get(localId);
                    if (!transceiver) {
                      throw new Error("associated RTCRtpTransceiver not found");
                    }
                    return transceiver.receiver.getStats();
                  }
                  async receiveDataChannel({ sctpStreamParameters, label, protocol }) {
                    this.assertNotClosed();
                    this.assertRecvDirection();
                    const { streamId, ordered, maxPacketLifeTime, maxRetransmits } = sctpStreamParameters;
                    const options = {
                      negotiated: true,
                      id: streamId,
                      ordered,
                      maxPacketLifeTime,
                      maxRetransmits,
                      protocol
                    };
                    logger.debug("receiveDataChannel() [options:%o]", options);
                    const dataChannel = this._pc.createDataChannel(label, options);
                    if (!this._hasDataChannelMediaSection) {
                      this._remoteSdp.receiveSctpAssociation();
                      const offer = {
                        type: "offer",
                        sdp: this._remoteSdp.getSdp()
                      };
                      logger.debug("receiveDataChannel() | calling pc.setRemoteDescription() [offer:%o]", offer);
                      await this._pc.setRemoteDescription(offer);
                      const answer = await this._pc.createAnswer();
                      if (!this._transportReady) {
                        const localSdpObject = sdpTransform.parse(answer.sdp);
                        await this.setupTransport({
                          localDtlsRole: this._forcedLocalDtlsRole ?? "client",
                          localSdpObject
                        });
                      }
                      logger.debug("receiveDataChannel() | calling pc.setRemoteDescription() [answer:%o]", answer);
                      await this._pc.setLocalDescription(answer);
                      this._hasDataChannelMediaSection = true;
                    }
                    return { dataChannel };
                  }
                  async setupTransport({ localDtlsRole, localSdpObject }) {
                    if (!localSdpObject) {
                      localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
                    }
                    const dtlsParameters = sdpCommonUtils.extractDtlsParameters({
                      sdpObject: localSdpObject
                    });
                    dtlsParameters.role = localDtlsRole;
                    this._remoteSdp.updateDtlsRole(localDtlsRole === "client" ? "server" : "client");
                    await new Promise((resolve, reject) => {
                      this.safeEmit("@connect", { dtlsParameters }, resolve, reject);
                    });
                    this._transportReady = true;
                  }
                  assertNotClosed() {
                    if (this._closed) {
                      throw new errors_1.InvalidStateError("method called in a closed handler");
                    }
                  }
                  assertSendDirection() {
                    if (this._direction !== "send") {
                      throw new Error('method can just be called for handlers with "send" direction');
                    }
                  }
                  assertRecvDirection() {
                    if (this._direction !== "recv") {
                      throw new Error('method can just be called for handlers with "recv" direction');
                    }
                  }
                }
                exports2.Safari12 = Safari12;
              }
            ),
            /***/
            5869: (
              /***/
              (module2, __unused_webpack_exports, __webpack_require__2) => {
                var regeneratorAsyncGen = __webpack_require__2(887);
                function _regeneratorAsync(n, e, r, t, o) {
                  var a = regeneratorAsyncGen(n, e, r, t, o);
                  return a.next().then(function(n2) {
                    return n2.done ? n2.value : a.next();
                  });
                }
                module2.exports = _regeneratorAsync, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
              }
            ),
            /***/
            5935: (
              /***/
              (__unused_webpack_module, exports2) => {
                "use strict";
                Object.defineProperty(exports2, "__esModule", { value: true });
                exports2.FakeEventTarget = void 0;
                class FakeEventTarget {
                  constructor() {
                    __publicField(this, "listeners", {});
                  }
                  addEventListener(type, callback, options) {
                    if (!callback) {
                      return;
                    }
                    this.listeners[type] = this.listeners[type] ?? [];
                    this.listeners[type].push({
                      callback: (
                        // eslint-disable-next-line @typescript-eslint/unbound-method
                        typeof callback === "function" ? callback : callback.handleEvent
                      ),
                      once: typeof options === "object" && options.once === true
                    });
                  }
                  removeEventListener(type, callback, options) {
                    if (!this.listeners[type]) {
                      return;
                    }
                    if (!callback) {
                      return;
                    }
                    this.listeners[type] = this.listeners[type].filter((listener) => listener.callback !== // eslint-disable-next-line @typescript-eslint/unbound-method
                    (typeof callback === "function" ? callback : callback.handleEvent));
                  }
                  dispatchEvent(event) {
                    if (!event || typeof event.type !== "string") {
                      throw new Error("invalid event object");
                    }
                    const entries = this.listeners[event.type];
                    if (!entries) {
                      return true;
                    }
                    for (const listener of [...entries]) {
                      try {
                        listener.callback.call(this, event);
                      } catch (error) {
                        setTimeout(() => {
                          throw error;
                        }, 0);
                      }
                      if (listener.once) {
                        this.removeEventListener(event.type, listener.callback);
                      }
                    }
                    return !event.defaultPrevented;
                  }
                }
                exports2.FakeEventTarget = FakeEventTarget;
              }
            ),
            /***/
            5938: (
              /***/
              (__unused_webpack_module, exports2) => {
                "use strict";
                Object.defineProperty(exports2, "__esModule", { value: true });
                exports2.getRtpEncodings = getRtpEncodings;
                exports2.addLegacySimulcast = addLegacySimulcast;
                function getRtpEncodings({ offerMediaObject }) {
                  const ssrcs = /* @__PURE__ */ new Set();
                  for (const line of offerMediaObject.ssrcs ?? []) {
                    const ssrc = line.id;
                    if (ssrc) {
                      ssrcs.add(ssrc);
                    }
                  }
                  if (ssrcs.size === 0) {
                    throw new Error("no a=ssrc lines found");
                  }
                  const ssrcToRtxSsrc = /* @__PURE__ */ new Map();
                  for (const line of offerMediaObject.ssrcGroups ?? []) {
                    if (line.semantics !== "FID") {
                      continue;
                    }
                    const ssrcsStr = line.ssrcs.split(/\s+/);
                    const ssrc = Number(ssrcsStr[0]);
                    const rtxSsrc = Number(ssrcsStr[1]);
                    if (ssrcs.has(ssrc)) {
                      ssrcs.delete(ssrc);
                      ssrcs.delete(rtxSsrc);
                      ssrcToRtxSsrc.set(ssrc, rtxSsrc);
                    }
                  }
                  for (const ssrc of ssrcs) {
                    ssrcToRtxSsrc.set(ssrc, void 0);
                  }
                  const encodings = [];
                  for (const [ssrc, rtxSsrc] of ssrcToRtxSsrc) {
                    const encoding = { ssrc };
                    if (rtxSsrc) {
                      encoding.rtx = { ssrc: rtxSsrc };
                    }
                    encodings.push(encoding);
                  }
                  return encodings;
                }
                function addLegacySimulcast({ offerMediaObject, numStreams }) {
                  if (numStreams <= 1) {
                    throw new TypeError("numStreams must be greater than 1");
                  }
                  const ssrcMsidLine = (offerMediaObject.ssrcs ?? []).find((line) => line.attribute === "msid");
                  if (!ssrcMsidLine) {
                    throw new Error("a=ssrc line with msid information not found");
                  }
                  const [streamId, trackId] = ssrcMsidLine.value.split(" ");
                  const firstSsrc = Number(ssrcMsidLine.id);
                  let firstRtxSsrc;
                  (offerMediaObject.ssrcGroups ?? []).some((line) => {
                    if (line.semantics !== "FID") {
                      return false;
                    }
                    const ssrcs2 = line.ssrcs.split(/\s+/);
                    if (Number(ssrcs2[0]) === firstSsrc) {
                      firstRtxSsrc = Number(ssrcs2[1]);
                      return true;
                    } else {
                      return false;
                    }
                  });
                  const ssrcCnameLine = (offerMediaObject.ssrcs ?? []).find((line) => line.attribute === "cname");
                  if (!ssrcCnameLine) {
                    throw new Error("a=ssrc line with cname information not found");
                  }
                  const cname = ssrcCnameLine.value;
                  const ssrcs = [];
                  const rtxSsrcs = [];
                  for (let i = 0; i < numStreams; ++i) {
                    ssrcs.push(firstSsrc + i);
                    if (firstRtxSsrc) {
                      rtxSsrcs.push(firstRtxSsrc + i);
                    }
                  }
                  offerMediaObject.ssrcGroups = [];
                  offerMediaObject.ssrcs = [];
                  offerMediaObject.ssrcGroups.push({
                    semantics: "SIM",
                    ssrcs: ssrcs.join(" ")
                  });
                  for (const ssrc of ssrcs) {
                    offerMediaObject.ssrcs.push({
                      id: ssrc,
                      attribute: "cname",
                      value: cname
                    });
                    offerMediaObject.ssrcs.push({
                      id: ssrc,
                      attribute: "msid",
                      value: `${streamId} ${trackId}`
                    });
                  }
                  for (let i = 0; i < rtxSsrcs.length; ++i) {
                    const ssrc = ssrcs[i];
                    const rtxSsrc = rtxSsrcs[i];
                    offerMediaObject.ssrcs.push({
                      id: rtxSsrc,
                      attribute: "cname",
                      value: cname
                    });
                    offerMediaObject.ssrcs.push({
                      id: rtxSsrc,
                      attribute: "msid",
                      value: `${streamId} ${trackId}`
                    });
                    offerMediaObject.ssrcGroups.push({
                      semantics: "FID",
                      ssrcs: `${ssrc} ${rtxSsrc}`
                    });
                  }
                }
              }
            ),
            /***/
            5953: (
              /***/
              function(module2, exports2, __webpack_require__2) {
                ;
                (function(root, factory, undef) {
                  if (true) {
                    module2.exports = exports2 = factory(__webpack_require__2(9021), __webpack_require__2(3240));
                  } else {
                  }
                })(this, function(CryptoJS) {
                  (function(Math2) {
                    var C = CryptoJS;
                    var C_lib = C.lib;
                    var WordArray = C_lib.WordArray;
                    var Hasher = C_lib.Hasher;
                    var C_x64 = C.x64;
                    var X64Word = C_x64.Word;
                    var C_algo = C.algo;
                    var RHO_OFFSETS = [];
                    var PI_INDEXES = [];
                    var ROUND_CONSTANTS = [];
                    (function() {
                      var x = 1, y = 0;
                      for (var t = 0; t < 24; t++) {
                        RHO_OFFSETS[x + 5 * y] = (t + 1) * (t + 2) / 2 % 64;
                        var newX = y % 5;
                        var newY = (2 * x + 3 * y) % 5;
                        x = newX;
                        y = newY;
                      }
                      for (var x = 0; x < 5; x++) {
                        for (var y = 0; y < 5; y++) {
                          PI_INDEXES[x + 5 * y] = y + (2 * x + 3 * y) % 5 * 5;
                        }
                      }
                      var LFSR = 1;
                      for (var i = 0; i < 24; i++) {
                        var roundConstantMsw = 0;
                        var roundConstantLsw = 0;
                        for (var j = 0; j < 7; j++) {
                          if (LFSR & 1) {
                            var bitPosition = (1 << j) - 1;
                            if (bitPosition < 32) {
                              roundConstantLsw ^= 1 << bitPosition;
                            } else {
                              roundConstantMsw ^= 1 << bitPosition - 32;
                            }
                          }
                          if (LFSR & 128) {
                            LFSR = LFSR << 1 ^ 113;
                          } else {
                            LFSR <<= 1;
                          }
                        }
                        ROUND_CONSTANTS[i] = X64Word.create(roundConstantMsw, roundConstantLsw);
                      }
                    })();
                    var T = [];
                    (function() {
                      for (var i = 0; i < 25; i++) {
                        T[i] = X64Word.create();
                      }
                    })();
                    var SHA3 = C_algo.SHA3 = Hasher.extend({
                      /**
                       * Configuration options.
                       *
                       * @property {number} outputLength
                       *   The desired number of bits in the output hash.
                       *   Only values permitted are: 224, 256, 384, 512.
                       *   Default: 512
                       */
                      cfg: Hasher.cfg.extend({
                        outputLength: 512
                      }),
                      _doReset: function() {
                        var state = this._state = [];
                        for (var i = 0; i < 25; i++) {
                          state[i] = new X64Word.init();
                        }
                        this.blockSize = (1600 - 2 * this.cfg.outputLength) / 32;
                      },
                      _doProcessBlock: function(M, offset) {
                        var state = this._state;
                        var nBlockSizeLanes = this.blockSize / 2;
                        for (var i = 0; i < nBlockSizeLanes; i++) {
                          var M2i = M[offset + 2 * i];
                          var M2i1 = M[offset + 2 * i + 1];
                          M2i = (M2i << 8 | M2i >>> 24) & 16711935 | (M2i << 24 | M2i >>> 8) & 4278255360;
                          M2i1 = (M2i1 << 8 | M2i1 >>> 24) & 16711935 | (M2i1 << 24 | M2i1 >>> 8) & 4278255360;
                          var lane = state[i];
                          lane.high ^= M2i1;
                          lane.low ^= M2i;
                        }
                        for (var round = 0; round < 24; round++) {
                          for (var x = 0; x < 5; x++) {
                            var tMsw = 0, tLsw = 0;
                            for (var y = 0; y < 5; y++) {
                              var lane = state[x + 5 * y];
                              tMsw ^= lane.high;
                              tLsw ^= lane.low;
                            }
                            var Tx = T[x];
                            Tx.high = tMsw;
                            Tx.low = tLsw;
                          }
                          for (var x = 0; x < 5; x++) {
                            var Tx4 = T[(x + 4) % 5];
                            var Tx1 = T[(x + 1) % 5];
                            var Tx1Msw = Tx1.high;
                            var Tx1Lsw = Tx1.low;
                            var tMsw = Tx4.high ^ (Tx1Msw << 1 | Tx1Lsw >>> 31);
                            var tLsw = Tx4.low ^ (Tx1Lsw << 1 | Tx1Msw >>> 31);
                            for (var y = 0; y < 5; y++) {
                              var lane = state[x + 5 * y];
                              lane.high ^= tMsw;
                              lane.low ^= tLsw;
                            }
                          }
                          for (var laneIndex = 1; laneIndex < 25; laneIndex++) {
                            var tMsw;
                            var tLsw;
                            var lane = state[laneIndex];
                            var laneMsw = lane.high;
                            var laneLsw = lane.low;
                            var rhoOffset = RHO_OFFSETS[laneIndex];
                            if (rhoOffset < 32) {
                              tMsw = laneMsw << rhoOffset | laneLsw >>> 32 - rhoOffset;
                              tLsw = laneLsw << rhoOffset | laneMsw >>> 32 - rhoOffset;
                            } else {
                              tMsw = laneLsw << rhoOffset - 32 | laneMsw >>> 64 - rhoOffset;
                              tLsw = laneMsw << rhoOffset - 32 | laneLsw >>> 64 - rhoOffset;
                            }
                            var TPiLane = T[PI_INDEXES[laneIndex]];
                            TPiLane.high = tMsw;
                            TPiLane.low = tLsw;
                          }
                          var T0 = T[0];
                          var state0 = state[0];
                          T0.high = state0.high;
                          T0.low = state0.low;
                          for (var x = 0; x < 5; x++) {
                            for (var y = 0; y < 5; y++) {
                              var laneIndex = x + 5 * y;
                              var lane = state[laneIndex];
                              var TLane = T[laneIndex];
                              var Tx1Lane = T[(x + 1) % 5 + 5 * y];
                              var Tx2Lane = T[(x + 2) % 5 + 5 * y];
                              lane.high = TLane.high ^ ~Tx1Lane.high & Tx2Lane.high;
                              lane.low = TLane.low ^ ~Tx1Lane.low & Tx2Lane.low;
                            }
                          }
                          var lane = state[0];
                          var roundConstant = ROUND_CONSTANTS[round];
                          lane.high ^= roundConstant.high;
                          lane.low ^= roundConstant.low;
                        }
                      },
                      _doFinalize: function() {
                        var data = this._data;
                        var dataWords = data.words;
                        var nBitsTotal = this._nDataBytes * 8;
                        var nBitsLeft = data.sigBytes * 8;
                        var blockSizeBits = this.blockSize * 32;
                        dataWords[nBitsLeft >>> 5] |= 1 << 24 - nBitsLeft % 32;
                        dataWords[(Math2.ceil((nBitsLeft + 1) / blockSizeBits) * blockSizeBits >>> 5) - 1] |= 128;
                        data.sigBytes = dataWords.length * 4;
                        this._process();
                        var state = this._state;
                        var outputLengthBytes = this.cfg.outputLength / 8;
                        var outputLengthLanes = outputLengthBytes / 8;
                        var hashWords = [];
                        for (var i = 0; i < outputLengthLanes; i++) {
                          var lane = state[i];
                          var laneMsw = lane.high;
                          var laneLsw = lane.low;
                          laneMsw = (laneMsw << 8 | laneMsw >>> 24) & 16711935 | (laneMsw << 24 | laneMsw >>> 8) & 4278255360;
                          laneLsw = (laneLsw << 8 | laneLsw >>> 24) & 16711935 | (laneLsw << 24 | laneLsw >>> 8) & 4278255360;
                          hashWords.push(laneLsw);
                          hashWords.push(laneMsw);
                        }
                        return new WordArray.init(hashWords, outputLengthBytes);
                      },
                      clone: function() {
                        var clone = Hasher.clone.call(this);
                        var state = clone._state = this._state.slice(0);
                        for (var i = 0; i < 25; i++) {
                          state[i] = state[i].clone();
                        }
                        return clone;
                      }
                    });
                    C.SHA3 = Hasher._createHelper(SHA3);
                    C.HmacSHA3 = Hasher._createHmacHelper(SHA3);
                  })(Math);
                  return CryptoJS.SHA3;
                });
              }
            ),
            /***/
            6004: (
              /***/
              (__unused_webpack_module, exports2, __webpack_require__2) => {
                "use strict";
                Object.defineProperty(exports2, "__esModule", { value: true });
                exports2.Device = void 0;
                exports2.detectDeviceAsync = detectDeviceAsync;
                exports2.detectDevice = detectDevice;
                const ua_parser_js_1 = __webpack_require__2(2109);
                const Logger_1 = __webpack_require__2(2994);
                const enhancedEvents_1 = __webpack_require__2(3953);
                const errors_1 = __webpack_require__2(4893);
                const utils = __webpack_require__2(1765);
                const ortc = __webpack_require__2(8046);
                const Transport_1 = __webpack_require__2(5601);
                const Chrome111_1 = __webpack_require__2(2183);
                const Chrome74_1 = __webpack_require__2(11);
                const Firefox120_1 = __webpack_require__2(2292);
                const Safari12_1 = __webpack_require__2(5765);
                const ReactNative106_1 = __webpack_require__2(867);
                const logger = new Logger_1.Logger("Device");
                async function detectDeviceAsync(userAgent) {
                  logger.debug("detectDeviceAsync() [userAgent:%s]", userAgent);
                  if (!userAgent && typeof navigator === "object") {
                    userAgent = navigator.userAgent;
                  }
                  const uaParserResult = await (0, ua_parser_js_1.UAParser)(userAgent).withFeatureCheck();
                  return detectDeviceImpl(uaParserResult);
                }
                function detectDevice(userAgent) {
                  logger.debug("detectDevice() [userAgent:%s]", userAgent);
                  if (!userAgent && typeof navigator === "object") {
                    userAgent = navigator.userAgent;
                  }
                  const uaParserResult = (0, ua_parser_js_1.UAParser)(userAgent);
                  return detectDeviceImpl(uaParserResult);
                }
                class Device {
                  /**
                   * Create a new Device to connect to mediasoup server.
                   *
                   * @throws {UnsupportedError} if device is not supported.
                   */
                  constructor({ handlerName, handlerFactory } = {}) {
                    // RTC handler factory.
                    __publicField(this, "_handlerFactory");
                    // Handler name.
                    __publicField(this, "_handlerName");
                    // Loaded flag.
                    __publicField(this, "_loaded", false);
                    // Callback for sending Transports to request sending extended RTP capabilities
                    // on demand.
                    __publicField(this, "_getSendExtendedRtpCapabilities");
                    // Local RTP capabilities for receiving media.
                    __publicField(this, "_recvRtpCapabilities");
                    // Whether we can produce audio/video based on remote RTP capabilities.
                    __publicField(this, "_canProduceByKind", {
                      audio: false,
                      video: false
                    });
                    // Local SCTP capabilities.
                    __publicField(this, "_sctpCapabilities");
                    // Observer instance.
                    __publicField(this, "_observer", new enhancedEvents_1.EnhancedEventEmitter());
                    logger.debug("constructor()");
                    if (handlerName && handlerFactory) {
                      throw new TypeError("just one of handlerName or handlerInterface can be given");
                    }
                    if (handlerFactory) {
                      this._handlerFactory = handlerFactory;
                    } else {
                      if (handlerName) {
                        logger.debug("constructor() | handler given: %s", handlerName);
                      } else {
                        handlerName = detectDevice();
                        if (handlerName) {
                          logger.debug("constructor() | detected handler: %s", handlerName);
                        } else {
                          throw new errors_1.UnsupportedError("device not supported");
                        }
                      }
                      switch (handlerName) {
                        case "Chrome111": {
                          this._handlerFactory = Chrome111_1.Chrome111.createFactory();
                          break;
                        }
                        case "Chrome74": {
                          this._handlerFactory = Chrome74_1.Chrome74.createFactory();
                          break;
                        }
                        case "Firefox120": {
                          this._handlerFactory = Firefox120_1.Firefox120.createFactory();
                          break;
                        }
                        case "Safari12": {
                          this._handlerFactory = Safari12_1.Safari12.createFactory();
                          break;
                        }
                        case "ReactNative106": {
                          this._handlerFactory = ReactNative106_1.ReactNative106.createFactory();
                          break;
                        }
                        default: {
                          throw new TypeError(`unknown handlerName "${handlerName}"`);
                        }
                      }
                    }
                    this._handlerName = this._handlerFactory.name;
                  }
                  /**
                   * Create a new Device to connect to mediasoup server. It uses a more advanced
                   * device detection.
                   *
                   * @throws {UnsupportedError} if device is not supported.
                   */
                  static async factory({ handlerName, handlerFactory } = {}) {
                    logger.debug("factory()");
                    if (handlerName && handlerFactory) {
                      throw new TypeError("just one of handlerName or handlerInterface can be given");
                    }
                    if (!handlerName && !handlerFactory) {
                      handlerName = await detectDeviceAsync();
                      if (!handlerName) {
                        throw new errors_1.UnsupportedError("device not supported");
                      }
                    }
                    return new Device({ handlerName, handlerFactory });
                  }
                  /**
                   * The RTC handler name.
                   */
                  get handlerName() {
                    return this._handlerName;
                  }
                  /**
                   * Whether the Device is loaded.
                   */
                  get loaded() {
                    return this._loaded;
                  }
                  /**
                   * RTP capabilities of the Device for receiving media.
                   *
                   * @throws {InvalidStateError} if not loaded.
                   */
                  get rtpCapabilities() {
                    if (!this._loaded) {
                      throw new errors_1.InvalidStateError("not loaded");
                    }
                    return this._recvRtpCapabilities;
                  }
                  /**
                   * SCTP capabilities of the Device.
                   *
                   * @throws {InvalidStateError} if not loaded.
                   */
                  get sctpCapabilities() {
                    if (!this._loaded) {
                      throw new errors_1.InvalidStateError("not loaded");
                    }
                    return this._sctpCapabilities;
                  }
                  get observer() {
                    return this._observer;
                  }
                  /**
                   * Initialize the Device.
                   */
                  async load({ routerRtpCapabilities, preferLocalCodecsOrder = false }) {
                    logger.debug("load() [routerRtpCapabilities:%o]", routerRtpCapabilities);
                    if (this._loaded) {
                      throw new errors_1.InvalidStateError("already loaded");
                    }
                    const clonedRouterRtpCapabilities = utils.clone(routerRtpCapabilities);
                    ortc.validateAndNormalizeRtpCapabilities(clonedRouterRtpCapabilities);
                    const { getNativeRtpCapabilities, getNativeSctpCapabilities } = this._handlerFactory;
                    const clonedNativeRtpCapabilities = utils.clone(await getNativeRtpCapabilities());
                    ortc.validateAndNormalizeRtpCapabilities(clonedNativeRtpCapabilities);
                    logger.debug("load() | got native RTP capabilities:%o", clonedNativeRtpCapabilities);
                    this._getSendExtendedRtpCapabilities = (nativeRtpCapabilities) => {
                      return utils.clone(ortc.getExtendedRtpCapabilities(nativeRtpCapabilities, clonedRouterRtpCapabilities, preferLocalCodecsOrder));
                    };
                    const recvExtendedRtpCapabilities = ortc.getExtendedRtpCapabilities(
                      clonedNativeRtpCapabilities,
                      clonedRouterRtpCapabilities,
                      /* preferLocalCodecsOrder */
                      false
                    );
                    this._recvRtpCapabilities = ortc.getRecvRtpCapabilities(recvExtendedRtpCapabilities);
                    ortc.validateAndNormalizeRtpCapabilities(this._recvRtpCapabilities);
                    logger.debug("load() | got receiving RTP capabilities:%o", this._recvRtpCapabilities);
                    this._canProduceByKind.audio = ortc.canSend("audio", this._recvRtpCapabilities);
                    this._canProduceByKind.video = ortc.canSend("video", this._recvRtpCapabilities);
                    this._sctpCapabilities = await getNativeSctpCapabilities();
                    ortc.validateSctpCapabilities(this._sctpCapabilities);
                    logger.debug("load() | got native SCTP capabilities:%o", this._sctpCapabilities);
                    logger.debug("load() succeeded");
                    this._loaded = true;
                  }
                  /**
                   * Whether we can produce audio/video.
                   *
                   * @throws {InvalidStateError} if not loaded.
                   * @throws {TypeError} if wrong arguments.
                   */
                  canProduce(kind) {
                    if (!this._loaded) {
                      throw new errors_1.InvalidStateError("not loaded");
                    } else if (kind !== "audio" && kind !== "video") {
                      throw new TypeError(`invalid kind "${kind}"`);
                    }
                    return this._canProduceByKind[kind];
                  }
                  /**
                   * Creates a Transport for sending media.
                   *
                   * @throws {InvalidStateError} if not loaded.
                   * @throws {TypeError} if wrong arguments.
                   */
                  createSendTransport({ id, iceParameters, iceCandidates, dtlsParameters, sctpParameters, iceServers, iceTransportPolicy, additionalSettings, appData }) {
                    logger.debug("createSendTransport()");
                    return this.createTransport({
                      direction: "send",
                      id,
                      iceParameters,
                      iceCandidates,
                      dtlsParameters,
                      sctpParameters,
                      iceServers,
                      iceTransportPolicy,
                      additionalSettings,
                      appData
                    });
                  }
                  /**
                   * Creates a Transport for receiving media.
                   *
                   * @throws {InvalidStateError} if not loaded.
                   * @throws {TypeError} if wrong arguments.
                   */
                  createRecvTransport({ id, iceParameters, iceCandidates, dtlsParameters, sctpParameters, iceServers, iceTransportPolicy, additionalSettings, appData }) {
                    logger.debug("createRecvTransport()");
                    return this.createTransport({
                      direction: "recv",
                      id,
                      iceParameters,
                      iceCandidates,
                      dtlsParameters,
                      sctpParameters,
                      iceServers,
                      iceTransportPolicy,
                      additionalSettings,
                      appData
                    });
                  }
                  createTransport({ direction, id, iceParameters, iceCandidates, dtlsParameters, sctpParameters, iceServers, iceTransportPolicy, additionalSettings, appData }) {
                    if (!this._loaded) {
                      throw new errors_1.InvalidStateError("not loaded");
                    } else if (typeof id !== "string") {
                      throw new TypeError("missing id");
                    } else if (typeof iceParameters !== "object") {
                      throw new TypeError("missing iceParameters");
                    } else if (!Array.isArray(iceCandidates)) {
                      throw new TypeError("missing iceCandidates");
                    } else if (typeof dtlsParameters !== "object") {
                      throw new TypeError("missing dtlsParameters");
                    } else if (sctpParameters && typeof sctpParameters !== "object") {
                      throw new TypeError("wrong sctpParameters");
                    } else if (appData && typeof appData !== "object") {
                      throw new TypeError("if given, appData must be an object");
                    }
                    const transport = new Transport_1.Transport({
                      direction,
                      id,
                      iceParameters,
                      iceCandidates,
                      dtlsParameters,
                      sctpParameters,
                      iceServers,
                      iceTransportPolicy,
                      additionalSettings,
                      appData,
                      handlerFactory: this._handlerFactory,
                      getSendExtendedRtpCapabilities: this._getSendExtendedRtpCapabilities,
                      recvRtpCapabilities: this._recvRtpCapabilities,
                      canProduceByKind: this._canProduceByKind
                    });
                    this._observer.safeEmit("newtransport", transport);
                    return transport;
                  }
                }
                exports2.Device = Device;
                function detectDeviceImpl(uaParserResult) {
                  var _a, _b, _c, _d;
                  if (typeof navigator === "object" && navigator.product === "ReactNative") {
                    logger.debug("detectDeviceImpl() | React-Native detected");
                    if (typeof RTCPeerConnection === "undefined" || typeof RTCRtpTransceiver === "undefined") {
                      logger.warn("detectDeviceImpl() | unsupported react-native-webrtc without RTCPeerConnection or RTCRtpTransceiver, forgot to call registerGlobals() on it?");
                      return void 0;
                    }
                    return "ReactNative106";
                  } else {
                    logger.debug("detectDeviceImpl() | browser detected [userAgent:%s, parsed:%o]", uaParserResult.ua, uaParserResult);
                    const browser = uaParserResult.browser;
                    const browserName = (_a = browser.name) == null ? void 0 : _a.toLowerCase();
                    const browserVersion = parseInt(browser.major ?? "0");
                    const engine = uaParserResult.engine;
                    const engineName = (_b = engine.name) == null ? void 0 : _b.toLowerCase();
                    const os = uaParserResult.os;
                    const osName = (_c = os.name) == null ? void 0 : _c.toLowerCase();
                    const osVersion = parseFloat(os.version ?? "0");
                    const device = uaParserResult.device;
                    const deviceModel = (_d = device.model) == null ? void 0 : _d.toLowerCase();
                    const isIOS = osName === "ios" || deviceModel === "ipad";
                    const isChrome = browserName && [
                      "chrome",
                      "chromium",
                      "mobile chrome",
                      "chrome webview",
                      "chrome headless"
                    ].includes(browserName);
                    const isFirefox = browserName && ["firefox", "mobile firefox", "mobile focus"].includes(browserName);
                    const isSafari = browserName && ["safari", "mobile safari"].includes(browserName);
                    const isEdge = browserName && ["edge"].includes(browserName);
                    if ((isChrome || isEdge) && !isIOS && browserVersion >= 111) {
                      return "Chrome111";
                    } else if (isChrome && !isIOS && browserVersion >= 74 || isEdge && !isIOS && browserVersion >= 88) {
                      return "Chrome74";
                    } else if (isFirefox && !isIOS && browserVersion >= 120) {
                      return "Firefox120";
                    } else if (isFirefox && isIOS && osVersion >= 14.3) {
                      return "Safari12";
                    } else if (isSafari && browserVersion >= 12 && typeof RTCRtpTransceiver !== "undefined" && RTCRtpTransceiver.prototype.hasOwnProperty("currentDirection")) {
                      return "Safari12";
                    } else if (engineName === "webkit" && isIOS && typeof RTCRtpTransceiver !== "undefined" && RTCRtpTransceiver.prototype.hasOwnProperty("currentDirection")) {
                      return "Safari12";
                    } else if (engineName === "blink") {
                      const match = uaParserResult.ua.match(/(?:(?:Chrome|Chromium))[ /](\w+)/i);
                      if (match) {
                        const version2 = Number(match[1]);
                        if (version2 >= 111) {
                          return "Chrome111";
                        } else {
                          return "Chrome74";
                        }
                      } else {
                        return "Chrome111";
                      }
                    } else {
                      logger.warn("detectDeviceImpl() | browser not supported [name:%s, version:%s]", browserName, browserVersion);
                      return void 0;
                    }
                  }
                }
              }
            ),
            /***/
            6298: (
              /***/
              function(module2, exports2, __webpack_require__2) {
                ;
                (function(root, factory, undef) {
                  if (true) {
                    module2.exports = exports2 = factory(__webpack_require__2(9021), __webpack_require__2(754), __webpack_require__2(4636), __webpack_require__2(9506), __webpack_require__2(7165));
                  } else {
                  }
                })(this, function(CryptoJS) {
                  (function() {
                    var C = CryptoJS;
                    var C_lib = C.lib;
                    var StreamCipher = C_lib.StreamCipher;
                    var C_algo = C.algo;
                    var S = [];
                    var C_ = [];
                    var G = [];
                    var Rabbit = C_algo.Rabbit = StreamCipher.extend({
                      _doReset: function() {
                        var K = this._key.words;
                        var iv = this.cfg.iv;
                        for (var i = 0; i < 4; i++) {
                          K[i] = (K[i] << 8 | K[i] >>> 24) & 16711935 | (K[i] << 24 | K[i] >>> 8) & 4278255360;
                        }
                        var X = this._X = [
                          K[0],
                          K[3] << 16 | K[2] >>> 16,
                          K[1],
                          K[0] << 16 | K[3] >>> 16,
                          K[2],
                          K[1] << 16 | K[0] >>> 16,
                          K[3],
                          K[2] << 16 | K[1] >>> 16
                        ];
                        var C2 = this._C = [
                          K[2] << 16 | K[2] >>> 16,
                          K[0] & 4294901760 | K[1] & 65535,
                          K[3] << 16 | K[3] >>> 16,
                          K[1] & 4294901760 | K[2] & 65535,
                          K[0] << 16 | K[0] >>> 16,
                          K[2] & 4294901760 | K[3] & 65535,
                          K[1] << 16 | K[1] >>> 16,
                          K[3] & 4294901760 | K[0] & 65535
                        ];
                        this._b = 0;
                        for (var i = 0; i < 4; i++) {
                          nextState.call(this);
                        }
                        for (var i = 0; i < 8; i++) {
                          C2[i] ^= X[i + 4 & 7];
                        }
                        if (iv) {
                          var IV = iv.words;
                          var IV_0 = IV[0];
                          var IV_1 = IV[1];
                          var i0 = (IV_0 << 8 | IV_0 >>> 24) & 16711935 | (IV_0 << 24 | IV_0 >>> 8) & 4278255360;
                          var i2 = (IV_1 << 8 | IV_1 >>> 24) & 16711935 | (IV_1 << 24 | IV_1 >>> 8) & 4278255360;
                          var i1 = i0 >>> 16 | i2 & 4294901760;
                          var i3 = i2 << 16 | i0 & 65535;
                          C2[0] ^= i0;
                          C2[1] ^= i1;
                          C2[2] ^= i2;
                          C2[3] ^= i3;
                          C2[4] ^= i0;
                          C2[5] ^= i1;
                          C2[6] ^= i2;
                          C2[7] ^= i3;
                          for (var i = 0; i < 4; i++) {
                            nextState.call(this);
                          }
                        }
                      },
                      _doProcessBlock: function(M, offset) {
                        var X = this._X;
                        nextState.call(this);
                        S[0] = X[0] ^ X[5] >>> 16 ^ X[3] << 16;
                        S[1] = X[2] ^ X[7] >>> 16 ^ X[5] << 16;
                        S[2] = X[4] ^ X[1] >>> 16 ^ X[7] << 16;
                        S[3] = X[6] ^ X[3] >>> 16 ^ X[1] << 16;
                        for (var i = 0; i < 4; i++) {
                          S[i] = (S[i] << 8 | S[i] >>> 24) & 16711935 | (S[i] << 24 | S[i] >>> 8) & 4278255360;
                          M[offset + i] ^= S[i];
                        }
                      },
                      blockSize: 128 / 32,
                      ivSize: 64 / 32
                    });
                    function nextState() {
                      var X = this._X;
                      var C2 = this._C;
                      for (var i = 0; i < 8; i++) {
                        C_[i] = C2[i];
                      }
                      C2[0] = C2[0] + 1295307597 + this._b | 0;
                      C2[1] = C2[1] + 3545052371 + (C2[0] >>> 0 < C_[0] >>> 0 ? 1 : 0) | 0;
                      C2[2] = C2[2] + 886263092 + (C2[1] >>> 0 < C_[1] >>> 0 ? 1 : 0) | 0;
                      C2[3] = C2[3] + 1295307597 + (C2[2] >>> 0 < C_[2] >>> 0 ? 1 : 0) | 0;
                      C2[4] = C2[4] + 3545052371 + (C2[3] >>> 0 < C_[3] >>> 0 ? 1 : 0) | 0;
                      C2[5] = C2[5] + 886263092 + (C2[4] >>> 0 < C_[4] >>> 0 ? 1 : 0) | 0;
                      C2[6] = C2[6] + 1295307597 + (C2[5] >>> 0 < C_[5] >>> 0 ? 1 : 0) | 0;
                      C2[7] = C2[7] + 3545052371 + (C2[6] >>> 0 < C_[6] >>> 0 ? 1 : 0) | 0;
                      this._b = C2[7] >>> 0 < C_[7] >>> 0 ? 1 : 0;
                      for (var i = 0; i < 8; i++) {
                        var gx = X[i] + C2[i];
                        var ga = gx & 65535;
                        var gb = gx >>> 16;
                        var gh = ((ga * ga >>> 17) + ga * gb >>> 15) + gb * gb;
                        var gl = ((gx & 4294901760) * gx | 0) + ((gx & 65535) * gx | 0);
                        G[i] = gh ^ gl;
                      }
                      X[0] = G[0] + (G[7] << 16 | G[7] >>> 16) + (G[6] << 16 | G[6] >>> 16) | 0;
                      X[1] = G[1] + (G[0] << 8 | G[0] >>> 24) + G[7] | 0;
                      X[2] = G[2] + (G[1] << 16 | G[1] >>> 16) + (G[0] << 16 | G[0] >>> 16) | 0;
                      X[3] = G[3] + (G[2] << 8 | G[2] >>> 24) + G[1] | 0;
                      X[4] = G[4] + (G[3] << 16 | G[3] >>> 16) + (G[2] << 16 | G[2] >>> 16) | 0;
                      X[5] = G[5] + (G[4] << 8 | G[4] >>> 24) + G[3] | 0;
                      X[6] = G[6] + (G[5] << 16 | G[5] >>> 16) + (G[4] << 16 | G[4] >>> 16) | 0;
                      X[7] = G[7] + (G[6] << 8 | G[6] >>> 24) + G[5] | 0;
                    }
                    C.Rabbit = StreamCipher._createHelper(Rabbit);
                  })();
                  return CryptoJS.Rabbit;
                });
              }
            ),
            /***/
            6308: (
              /***/
              function(module2, exports2, __webpack_require__2) {
                ;
                (function(root, factory, undef) {
                  if (true) {
                    module2.exports = exports2 = factory(__webpack_require__2(9021), __webpack_require__2(3009));
                  } else {
                  }
                })(this, function(CryptoJS) {
                  (function() {
                    var C = CryptoJS;
                    var C_lib = C.lib;
                    var WordArray = C_lib.WordArray;
                    var C_algo = C.algo;
                    var SHA256 = C_algo.SHA256;
                    var SHA224 = C_algo.SHA224 = SHA256.extend({
                      _doReset: function() {
                        this._hash = new WordArray.init([
                          3238371032,
                          914150663,
                          812702999,
                          4144912697,
                          4290775857,
                          1750603025,
                          1694076839,
                          3204075428
                        ]);
                      },
                      _doFinalize: function() {
                        var hash = SHA256._doFinalize.call(this);
                        hash.sigBytes -= 4;
                        return hash;
                      }
                    });
                    C.SHA224 = SHA256._createHelper(SHA224);
                    C.HmacSHA224 = SHA256._createHmacHelper(SHA224);
                  })();
                  return CryptoJS.SHA224;
                });
              }
            ),
            /***/
            6372: (
              /***/
              function(module2, exports2, __webpack_require__2) {
                ;
                (function(root, factory, undef) {
                  if (true) {
                    module2.exports = exports2 = factory(__webpack_require__2(9021), __webpack_require__2(7165));
                  } else {
                  }
                })(this, function(CryptoJS) {
                  CryptoJS.mode.CTRGladman = function() {
                    var CTRGladman = CryptoJS.lib.BlockCipherMode.extend();
                    function incWord(word) {
                      if ((word >> 24 & 255) === 255) {
                        var b1 = word >> 16 & 255;
                        var b2 = word >> 8 & 255;
                        var b3 = word & 255;
                        if (b1 === 255) {
                          b1 = 0;
                          if (b2 === 255) {
                            b2 = 0;
                            if (b3 === 255) {
                              b3 = 0;
                            } else {
                              ++b3;
                            }
                          } else {
                            ++b2;
                          }
                        } else {
                          ++b1;
                        }
                        word = 0;
                        word += b1 << 16;
                        word += b2 << 8;
                        word += b3;
                      } else {
                        word += 1 << 24;
                      }
                      return word;
                    }
                    function incCounter(counter) {
                      if ((counter[0] = incWord(counter[0])) === 0) {
                        counter[1] = incWord(counter[1]);
                      }
                      return counter;
                    }
                    var Encryptor = CTRGladman.Encryptor = CTRGladman.extend({
                      processBlock: function(words, offset) {
                        var cipher = this._cipher;
                        var blockSize = cipher.blockSize;
                        var iv = this._iv;
                        var counter = this._counter;
                        if (iv) {
                          counter = this._counter = iv.slice(0);
                          this._iv = void 0;
                        }
                        incCounter(counter);
                        var keystream = counter.slice(0);
                        cipher.encryptBlock(keystream, 0);
                        for (var i = 0; i < blockSize; i++) {
                          words[offset + i] ^= keystream[i];
                        }
                      }
                    });
                    CTRGladman.Decryptor = Encryptor;
                    return CTRGladman;
                  }();
                  return CryptoJS.mode.CTRGladman;
                });
              }
            ),
            /***/
            6440: (
              /***/
              function(module2, exports2, __webpack_require__2) {
                ;
                (function(root, factory) {
                  if (true) {
                    module2.exports = exports2 = factory(__webpack_require__2(9021));
                  } else {
                  }
                })(this, function(CryptoJS) {
                  (function() {
                    if (typeof ArrayBuffer != "function") {
                      return;
                    }
                    var C = CryptoJS;
                    var C_lib = C.lib;
                    var WordArray = C_lib.WordArray;
                    var superInit = WordArray.init;
                    var subInit = WordArray.init = function(typedArray) {
                      if (typedArray instanceof ArrayBuffer) {
                        typedArray = new Uint8Array(typedArray);
                      }
                      if (typedArray instanceof Int8Array || typeof Uint8ClampedArray !== "undefined" && typedArray instanceof Uint8ClampedArray || typedArray instanceof Int16Array || typedArray instanceof Uint16Array || typedArray instanceof Int32Array || typedArray instanceof Uint32Array || typedArray instanceof Float32Array || typedArray instanceof Float64Array) {
                        typedArray = new Uint8Array(typedArray.buffer, typedArray.byteOffset, typedArray.byteLength);
                      }
                      if (typedArray instanceof Uint8Array) {
                        var typedArrayByteLength = typedArray.byteLength;
                        var words = [];
                        for (var i = 0; i < typedArrayByteLength; i++) {
                          words[i >>> 2] |= typedArray[i] << 24 - i % 4 * 8;
                        }
                        superInit.call(this, words, typedArrayByteLength);
                      } else {
                        superInit.apply(this, arguments);
                      }
                    };
                    subInit.prototype = WordArray;
                  })();
                  return CryptoJS.lib.WordArray;
                });
              }
            ),
            /***/
            6585: (
              /***/
              (module2) => {
                var s = 1e3;
                var m = s * 60;
                var h = m * 60;
                var d = h * 24;
                var w = d * 7;
                var y = d * 365.25;
                module2.exports = function(val, options) {
                  options = options || {};
                  var type = typeof val;
                  if (type === "string" && val.length > 0) {
                    return parse(val);
                  } else if (type === "number" && isFinite(val)) {
                    return options.long ? fmtLong(val) : fmtShort(val);
                  }
                  throw new Error(
                    "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
                  );
                };
                function parse(str) {
                  str = String(str);
                  if (str.length > 100) {
                    return;
                  }
                  var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
                    str
                  );
                  if (!match) {
                    return;
                  }
                  var n = parseFloat(match[1]);
                  var type = (match[2] || "ms").toLowerCase();
                  switch (type) {
                    case "years":
                    case "year":
                    case "yrs":
                    case "yr":
                    case "y":
                      return n * y;
                    case "weeks":
                    case "week":
                    case "w":
                      return n * w;
                    case "days":
                    case "day":
                    case "d":
                      return n * d;
                    case "hours":
                    case "hour":
                    case "hrs":
                    case "hr":
                    case "h":
                      return n * h;
                    case "minutes":
                    case "minute":
                    case "mins":
                    case "min":
                    case "m":
                      return n * m;
                    case "seconds":
                    case "second":
                    case "secs":
                    case "sec":
                    case "s":
                      return n * s;
                    case "milliseconds":
                    case "millisecond":
                    case "msecs":
                    case "msec":
                    case "ms":
                      return n;
                    default:
                      return void 0;
                  }
                }
                function fmtShort(ms) {
                  var msAbs = Math.abs(ms);
                  if (msAbs >= d) {
                    return Math.round(ms / d) + "d";
                  }
                  if (msAbs >= h) {
                    return Math.round(ms / h) + "h";
                  }
                  if (msAbs >= m) {
                    return Math.round(ms / m) + "m";
                  }
                  if (msAbs >= s) {
                    return Math.round(ms / s) + "s";
                  }
                  return ms + "ms";
                }
                function fmtLong(ms) {
                  var msAbs = Math.abs(ms);
                  if (msAbs >= d) {
                    return plural(ms, msAbs, d, "day");
                  }
                  if (msAbs >= h) {
                    return plural(ms, msAbs, h, "hour");
                  }
                  if (msAbs >= m) {
                    return plural(ms, msAbs, m, "minute");
                  }
                  if (msAbs >= s) {
                    return plural(ms, msAbs, s, "second");
                  }
                  return ms + " ms";
                }
                function plural(ms, msAbs, n, name) {
                  var isPlural = msAbs >= n * 1.5;
                  return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
                }
              }
            ),
            /***/
            6746: (
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                "use strict";
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  KS: () => (
                    /* binding */
                    EncryptionEvent
                  ),
                  /* harmony export */
                  fo: () => (
                    /* binding */
                    KeyProviderEvent
                  )
                  /* harmony export */
                });
                var KeyProviderEvent = Object.freeze({
                  SetKey: "setKey",
                  RatchetRequest: "ratchetRequest",
                  KeyRatcheted: "keyRatcheted"
                });
                var KeyHandlerEvent = Object.freeze({
                  KeyRatcheted: "keyRatcheted"
                });
                var EncryptionEvent = Object.freeze({
                  ParticipantEncryptionStatusChanged: "participantEncryptionStatusChanged",
                  EncryptionError: "encryptionError",
                  E2EEStateChange: "e2eeStateChange"
                });
                var CryptorEvent = Object.freeze({
                  Error: "cryptorError",
                  Message: "cryptorMessage"
                });
                var CryptorMessageTypes = Object.freeze({
                  EncryptionSuccess: "EncryptionSuccess",
                  EncryptionFailed: "EncryptionFailed",
                  DecryptionSuccess: "DecryptionSuccess",
                  DecryptionFailed: "DecryptionFailed",
                  MissingKey: "MissingKey",
                  InternalError: "InternalError",
                  InvalidKey: "InvalidKey"
                });
              }
            ),
            /***/
            6880: (
              /***/
              function(module2) {
                !function(e, t) {
                  true ? module2.exports = t() : 0;
                }(this, function() {
                  return function(e) {
                    var t = {};
                    function r(i) {
                      if (t[i]) return t[i].exports;
                      var n = t[i] = { i, l: false, exports: {} };
                      return e[i].call(n.exports, n, n.exports, r), n.l = true, n.exports;
                    }
                    return r.m = e, r.c = t, r.d = function(e2, t2, i) {
                      r.o(e2, t2) || Object.defineProperty(e2, t2, { enumerable: true, get: i });
                    }, r.r = function(e2) {
                      "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e2, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(e2, "__esModule", { value: true });
                    }, r.t = function(e2, t2) {
                      if (1 & t2 && (e2 = r(e2)), 8 & t2) return e2;
                      if (4 & t2 && "object" == typeof e2 && e2 && e2.__esModule) return e2;
                      var i = /* @__PURE__ */ Object.create(null);
                      if (r.r(i), Object.defineProperty(i, "default", { enumerable: true, value: e2 }), 2 & t2 && "string" != typeof e2) for (var n in e2) r.d(i, n, (function(t3) {
                        return e2[t3];
                      }).bind(null, n));
                      return i;
                    }, r.n = function(e2) {
                      var t2 = e2 && e2.__esModule ? function() {
                        return e2.default;
                      } : function() {
                        return e2;
                      };
                      return r.d(t2, "a", t2), t2;
                    }, r.o = function(e2, t2) {
                      return Object.prototype.hasOwnProperty.call(e2, t2);
                    }, r.p = "", r(r.s = 90);
                  }({ 17: function(e, t, r) {
                    "use strict";
                    t.__esModule = true, t.default = void 0;
                    var i = r(18), n = function() {
                      function e2() {
                      }
                      return e2.getFirstMatch = function(e3, t2) {
                        var r2 = t2.match(e3);
                        return r2 && r2.length > 0 && r2[1] || "";
                      }, e2.getSecondMatch = function(e3, t2) {
                        var r2 = t2.match(e3);
                        return r2 && r2.length > 1 && r2[2] || "";
                      }, e2.matchAndReturnConst = function(e3, t2, r2) {
                        if (e3.test(t2)) return r2;
                      }, e2.getWindowsVersionName = function(e3) {
                        switch (e3) {
                          case "NT":
                            return "NT";
                          case "XP":
                            return "XP";
                          case "NT 5.0":
                            return "2000";
                          case "NT 5.1":
                            return "XP";
                          case "NT 5.2":
                            return "2003";
                          case "NT 6.0":
                            return "Vista";
                          case "NT 6.1":
                            return "7";
                          case "NT 6.2":
                            return "8";
                          case "NT 6.3":
                            return "8.1";
                          case "NT 10.0":
                            return "10";
                          default:
                            return;
                        }
                      }, e2.getMacOSVersionName = function(e3) {
                        var t2 = e3.split(".").splice(0, 2).map(function(e4) {
                          return parseInt(e4, 10) || 0;
                        });
                        if (t2.push(0), 10 === t2[0]) switch (t2[1]) {
                          case 5:
                            return "Leopard";
                          case 6:
                            return "Snow Leopard";
                          case 7:
                            return "Lion";
                          case 8:
                            return "Mountain Lion";
                          case 9:
                            return "Mavericks";
                          case 10:
                            return "Yosemite";
                          case 11:
                            return "El Capitan";
                          case 12:
                            return "Sierra";
                          case 13:
                            return "High Sierra";
                          case 14:
                            return "Mojave";
                          case 15:
                            return "Catalina";
                          default:
                            return;
                        }
                      }, e2.getAndroidVersionName = function(e3) {
                        var t2 = e3.split(".").splice(0, 2).map(function(e4) {
                          return parseInt(e4, 10) || 0;
                        });
                        if (t2.push(0), !(1 === t2[0] && t2[1] < 5)) return 1 === t2[0] && t2[1] < 6 ? "Cupcake" : 1 === t2[0] && t2[1] >= 6 ? "Donut" : 2 === t2[0] && t2[1] < 2 ? "Eclair" : 2 === t2[0] && 2 === t2[1] ? "Froyo" : 2 === t2[0] && t2[1] > 2 ? "Gingerbread" : 3 === t2[0] ? "Honeycomb" : 4 === t2[0] && t2[1] < 1 ? "Ice Cream Sandwich" : 4 === t2[0] && t2[1] < 4 ? "Jelly Bean" : 4 === t2[0] && t2[1] >= 4 ? "KitKat" : 5 === t2[0] ? "Lollipop" : 6 === t2[0] ? "Marshmallow" : 7 === t2[0] ? "Nougat" : 8 === t2[0] ? "Oreo" : 9 === t2[0] ? "Pie" : void 0;
                      }, e2.getVersionPrecision = function(e3) {
                        return e3.split(".").length;
                      }, e2.compareVersions = function(t2, r2, i2) {
                        void 0 === i2 && (i2 = false);
                        var n2 = e2.getVersionPrecision(t2), s = e2.getVersionPrecision(r2), a = Math.max(n2, s), o = 0, u = e2.map([t2, r2], function(t3) {
                          var r3 = a - e2.getVersionPrecision(t3), i3 = t3 + new Array(r3 + 1).join(".0");
                          return e2.map(i3.split("."), function(e3) {
                            return new Array(20 - e3.length).join("0") + e3;
                          }).reverse();
                        });
                        for (i2 && (o = a - Math.min(n2, s)), a -= 1; a >= o; ) {
                          if (u[0][a] > u[1][a]) return 1;
                          if (u[0][a] === u[1][a]) {
                            if (a === o) return 0;
                            a -= 1;
                          } else if (u[0][a] < u[1][a]) return -1;
                        }
                      }, e2.map = function(e3, t2) {
                        var r2, i2 = [];
                        if (Array.prototype.map) return Array.prototype.map.call(e3, t2);
                        for (r2 = 0; r2 < e3.length; r2 += 1) i2.push(t2(e3[r2]));
                        return i2;
                      }, e2.find = function(e3, t2) {
                        var r2, i2;
                        if (Array.prototype.find) return Array.prototype.find.call(e3, t2);
                        for (r2 = 0, i2 = e3.length; r2 < i2; r2 += 1) {
                          var n2 = e3[r2];
                          if (t2(n2, r2)) return n2;
                        }
                      }, e2.assign = function(e3) {
                        for (var t2, r2, i2 = e3, n2 = arguments.length, s = new Array(n2 > 1 ? n2 - 1 : 0), a = 1; a < n2; a++) s[a - 1] = arguments[a];
                        if (Object.assign) return Object.assign.apply(Object, [e3].concat(s));
                        var o = function() {
                          var e4 = s[t2];
                          "object" == typeof e4 && null !== e4 && Object.keys(e4).forEach(function(t3) {
                            i2[t3] = e4[t3];
                          });
                        };
                        for (t2 = 0, r2 = s.length; t2 < r2; t2 += 1) o();
                        return e3;
                      }, e2.getBrowserAlias = function(e3) {
                        return i.BROWSER_ALIASES_MAP[e3];
                      }, e2.getBrowserTypeByAlias = function(e3) {
                        return i.BROWSER_MAP[e3] || "";
                      }, e2;
                    }();
                    t.default = n, e.exports = t.default;
                  }, 18: function(e, t, r) {
                    "use strict";
                    t.__esModule = true, t.ENGINE_MAP = t.OS_MAP = t.PLATFORMS_MAP = t.BROWSER_MAP = t.BROWSER_ALIASES_MAP = void 0;
                    t.BROWSER_ALIASES_MAP = { "Amazon Silk": "amazon_silk", "Android Browser": "android", Bada: "bada", BlackBerry: "blackberry", Chrome: "chrome", Chromium: "chromium", Electron: "electron", Epiphany: "epiphany", Firefox: "firefox", Focus: "focus", Generic: "generic", "Google Search": "google_search", Googlebot: "googlebot", "Internet Explorer": "ie", "K-Meleon": "k_meleon", Maxthon: "maxthon", "Microsoft Edge": "edge", "MZ Browser": "mz", "NAVER Whale Browser": "naver", Opera: "opera", "Opera Coast": "opera_coast", "Pale Moon": "pale_moon", PhantomJS: "phantomjs", Puffin: "puffin", QupZilla: "qupzilla", QQ: "qq", QQLite: "qqlite", Safari: "safari", Sailfish: "sailfish", "Samsung Internet for Android": "samsung_internet", SeaMonkey: "seamonkey", Sleipnir: "sleipnir", Swing: "swing", Tizen: "tizen", "UC Browser": "uc", Vivaldi: "vivaldi", "WebOS Browser": "webos", WeChat: "wechat", "Yandex Browser": "yandex", Roku: "roku" };
                    t.BROWSER_MAP = { amazon_silk: "Amazon Silk", android: "Android Browser", bada: "Bada", blackberry: "BlackBerry", chrome: "Chrome", chromium: "Chromium", electron: "Electron", epiphany: "Epiphany", firefox: "Firefox", focus: "Focus", generic: "Generic", googlebot: "Googlebot", google_search: "Google Search", ie: "Internet Explorer", k_meleon: "K-Meleon", maxthon: "Maxthon", edge: "Microsoft Edge", mz: "MZ Browser", naver: "NAVER Whale Browser", opera: "Opera", opera_coast: "Opera Coast", pale_moon: "Pale Moon", phantomjs: "PhantomJS", puffin: "Puffin", qupzilla: "QupZilla", qq: "QQ Browser", qqlite: "QQ Browser Lite", safari: "Safari", sailfish: "Sailfish", samsung_internet: "Samsung Internet for Android", seamonkey: "SeaMonkey", sleipnir: "Sleipnir", swing: "Swing", tizen: "Tizen", uc: "UC Browser", vivaldi: "Vivaldi", webos: "WebOS Browser", wechat: "WeChat", yandex: "Yandex Browser" };
                    t.PLATFORMS_MAP = { tablet: "tablet", mobile: "mobile", desktop: "desktop", tv: "tv", bot: "bot" };
                    t.OS_MAP = { WindowsPhone: "Windows Phone", Windows: "Windows", MacOS: "macOS", iOS: "iOS", Android: "Android", WebOS: "WebOS", BlackBerry: "BlackBerry", Bada: "Bada", Tizen: "Tizen", Linux: "Linux", ChromeOS: "Chrome OS", PlayStation4: "PlayStation 4", Roku: "Roku" };
                    t.ENGINE_MAP = { EdgeHTML: "EdgeHTML", Blink: "Blink", Trident: "Trident", Presto: "Presto", Gecko: "Gecko", WebKit: "WebKit" };
                  }, 90: function(e, t, r) {
                    "use strict";
                    t.__esModule = true, t.default = void 0;
                    var i, n = (i = r(91)) && i.__esModule ? i : { default: i }, s = r(18);
                    function a(e2, t2) {
                      for (var r2 = 0; r2 < t2.length; r2++) {
                        var i2 = t2[r2];
                        i2.enumerable = i2.enumerable || false, i2.configurable = true, "value" in i2 && (i2.writable = true), Object.defineProperty(e2, i2.key, i2);
                      }
                    }
                    var o = function() {
                      function e2() {
                      }
                      var t2, r2, i2;
                      return e2.getParser = function(e3, t3) {
                        if (void 0 === t3 && (t3 = false), "string" != typeof e3) throw new Error("UserAgent should be a string");
                        return new n.default(e3, t3);
                      }, e2.parse = function(e3) {
                        return new n.default(e3).getResult();
                      }, t2 = e2, i2 = [{ key: "BROWSER_MAP", get: function() {
                        return s.BROWSER_MAP;
                      } }, { key: "ENGINE_MAP", get: function() {
                        return s.ENGINE_MAP;
                      } }, { key: "OS_MAP", get: function() {
                        return s.OS_MAP;
                      } }, { key: "PLATFORMS_MAP", get: function() {
                        return s.PLATFORMS_MAP;
                      } }], (r2 = null) && a(t2.prototype, r2), i2 && a(t2, i2), e2;
                    }();
                    t.default = o, e.exports = t.default;
                  }, 91: function(e, t, r) {
                    "use strict";
                    t.__esModule = true, t.default = void 0;
                    var i = u(r(92)), n = u(r(93)), s = u(r(94)), a = u(r(95)), o = u(r(17));
                    function u(e2) {
                      return e2 && e2.__esModule ? e2 : { default: e2 };
                    }
                    var d = function() {
                      function e2(e3, t3) {
                        if (void 0 === t3 && (t3 = false), null == e3 || "" === e3) throw new Error("UserAgent parameter can't be empty");
                        this._ua = e3, this.parsedResult = {}, true !== t3 && this.parse();
                      }
                      var t2 = e2.prototype;
                      return t2.getUA = function() {
                        return this._ua;
                      }, t2.test = function(e3) {
                        return e3.test(this._ua);
                      }, t2.parseBrowser = function() {
                        var e3 = this;
                        this.parsedResult.browser = {};
                        var t3 = o.default.find(i.default, function(t4) {
                          if ("function" == typeof t4.test) return t4.test(e3);
                          if (Array.isArray(t4.test)) return t4.test.some(function(t5) {
                            return e3.test(t5);
                          });
                          throw new Error("Browser's test function is not valid");
                        });
                        return t3 && (this.parsedResult.browser = t3.describe(this.getUA())), this.parsedResult.browser;
                      }, t2.getBrowser = function() {
                        return this.parsedResult.browser ? this.parsedResult.browser : this.parseBrowser();
                      }, t2.getBrowserName = function(e3) {
                        return e3 ? String(this.getBrowser().name).toLowerCase() || "" : this.getBrowser().name || "";
                      }, t2.getBrowserVersion = function() {
                        return this.getBrowser().version;
                      }, t2.getOS = function() {
                        return this.parsedResult.os ? this.parsedResult.os : this.parseOS();
                      }, t2.parseOS = function() {
                        var e3 = this;
                        this.parsedResult.os = {};
                        var t3 = o.default.find(n.default, function(t4) {
                          if ("function" == typeof t4.test) return t4.test(e3);
                          if (Array.isArray(t4.test)) return t4.test.some(function(t5) {
                            return e3.test(t5);
                          });
                          throw new Error("Browser's test function is not valid");
                        });
                        return t3 && (this.parsedResult.os = t3.describe(this.getUA())), this.parsedResult.os;
                      }, t2.getOSName = function(e3) {
                        var t3 = this.getOS().name;
                        return e3 ? String(t3).toLowerCase() || "" : t3 || "";
                      }, t2.getOSVersion = function() {
                        return this.getOS().version;
                      }, t2.getPlatform = function() {
                        return this.parsedResult.platform ? this.parsedResult.platform : this.parsePlatform();
                      }, t2.getPlatformType = function(e3) {
                        void 0 === e3 && (e3 = false);
                        var t3 = this.getPlatform().type;
                        return e3 ? String(t3).toLowerCase() || "" : t3 || "";
                      }, t2.parsePlatform = function() {
                        var e3 = this;
                        this.parsedResult.platform = {};
                        var t3 = o.default.find(s.default, function(t4) {
                          if ("function" == typeof t4.test) return t4.test(e3);
                          if (Array.isArray(t4.test)) return t4.test.some(function(t5) {
                            return e3.test(t5);
                          });
                          throw new Error("Browser's test function is not valid");
                        });
                        return t3 && (this.parsedResult.platform = t3.describe(this.getUA())), this.parsedResult.platform;
                      }, t2.getEngine = function() {
                        return this.parsedResult.engine ? this.parsedResult.engine : this.parseEngine();
                      }, t2.getEngineName = function(e3) {
                        return e3 ? String(this.getEngine().name).toLowerCase() || "" : this.getEngine().name || "";
                      }, t2.parseEngine = function() {
                        var e3 = this;
                        this.parsedResult.engine = {};
                        var t3 = o.default.find(a.default, function(t4) {
                          if ("function" == typeof t4.test) return t4.test(e3);
                          if (Array.isArray(t4.test)) return t4.test.some(function(t5) {
                            return e3.test(t5);
                          });
                          throw new Error("Browser's test function is not valid");
                        });
                        return t3 && (this.parsedResult.engine = t3.describe(this.getUA())), this.parsedResult.engine;
                      }, t2.parse = function() {
                        return this.parseBrowser(), this.parseOS(), this.parsePlatform(), this.parseEngine(), this;
                      }, t2.getResult = function() {
                        return o.default.assign({}, this.parsedResult);
                      }, t2.satisfies = function(e3) {
                        var t3 = this, r2 = {}, i2 = 0, n2 = {}, s2 = 0;
                        if (Object.keys(e3).forEach(function(t4) {
                          var a3 = e3[t4];
                          "string" == typeof a3 ? (n2[t4] = a3, s2 += 1) : "object" == typeof a3 && (r2[t4] = a3, i2 += 1);
                        }), i2 > 0) {
                          var a2 = Object.keys(r2), u2 = o.default.find(a2, function(e4) {
                            return t3.isOS(e4);
                          });
                          if (u2) {
                            var d2 = this.satisfies(r2[u2]);
                            if (void 0 !== d2) return d2;
                          }
                          var c = o.default.find(a2, function(e4) {
                            return t3.isPlatform(e4);
                          });
                          if (c) {
                            var f = this.satisfies(r2[c]);
                            if (void 0 !== f) return f;
                          }
                        }
                        if (s2 > 0) {
                          var l = Object.keys(n2), h = o.default.find(l, function(e4) {
                            return t3.isBrowser(e4, true);
                          });
                          if (void 0 !== h) return this.compareVersion(n2[h]);
                        }
                      }, t2.isBrowser = function(e3, t3) {
                        void 0 === t3 && (t3 = false);
                        var r2 = this.getBrowserName().toLowerCase(), i2 = e3.toLowerCase(), n2 = o.default.getBrowserTypeByAlias(i2);
                        return t3 && n2 && (i2 = n2.toLowerCase()), i2 === r2;
                      }, t2.compareVersion = function(e3) {
                        var t3 = [0], r2 = e3, i2 = false, n2 = this.getBrowserVersion();
                        if ("string" == typeof n2) return ">" === e3[0] || "<" === e3[0] ? (r2 = e3.substr(1), "=" === e3[1] ? (i2 = true, r2 = e3.substr(2)) : t3 = [], ">" === e3[0] ? t3.push(1) : t3.push(-1)) : "=" === e3[0] ? r2 = e3.substr(1) : "~" === e3[0] && (i2 = true, r2 = e3.substr(1)), t3.indexOf(o.default.compareVersions(n2, r2, i2)) > -1;
                      }, t2.isOS = function(e3) {
                        return this.getOSName(true) === String(e3).toLowerCase();
                      }, t2.isPlatform = function(e3) {
                        return this.getPlatformType(true) === String(e3).toLowerCase();
                      }, t2.isEngine = function(e3) {
                        return this.getEngineName(true) === String(e3).toLowerCase();
                      }, t2.is = function(e3, t3) {
                        return void 0 === t3 && (t3 = false), this.isBrowser(e3, t3) || this.isOS(e3) || this.isPlatform(e3);
                      }, t2.some = function(e3) {
                        var t3 = this;
                        return void 0 === e3 && (e3 = []), e3.some(function(e4) {
                          return t3.is(e4);
                        });
                      }, e2;
                    }();
                    t.default = d, e.exports = t.default;
                  }, 92: function(e, t, r) {
                    "use strict";
                    t.__esModule = true, t.default = void 0;
                    var i, n = (i = r(17)) && i.__esModule ? i : { default: i };
                    var s = /version\/(\d+(\.?_?\d+)+)/i, a = [{ test: [/googlebot/i], describe: function(e2) {
                      var t2 = { name: "Googlebot" }, r2 = n.default.getFirstMatch(/googlebot\/(\d+(\.\d+))/i, e2) || n.default.getFirstMatch(s, e2);
                      return r2 && (t2.version = r2), t2;
                    } }, { test: [/opera/i], describe: function(e2) {
                      var t2 = { name: "Opera" }, r2 = n.default.getFirstMatch(s, e2) || n.default.getFirstMatch(/(?:opera)[\s/](\d+(\.?_?\d+)+)/i, e2);
                      return r2 && (t2.version = r2), t2;
                    } }, { test: [/opr\/|opios/i], describe: function(e2) {
                      var t2 = { name: "Opera" }, r2 = n.default.getFirstMatch(/(?:opr|opios)[\s/](\S+)/i, e2) || n.default.getFirstMatch(s, e2);
                      return r2 && (t2.version = r2), t2;
                    } }, { test: [/SamsungBrowser/i], describe: function(e2) {
                      var t2 = { name: "Samsung Internet for Android" }, r2 = n.default.getFirstMatch(s, e2) || n.default.getFirstMatch(/(?:SamsungBrowser)[\s/](\d+(\.?_?\d+)+)/i, e2);
                      return r2 && (t2.version = r2), t2;
                    } }, { test: [/Whale/i], describe: function(e2) {
                      var t2 = { name: "NAVER Whale Browser" }, r2 = n.default.getFirstMatch(s, e2) || n.default.getFirstMatch(/(?:whale)[\s/](\d+(?:\.\d+)+)/i, e2);
                      return r2 && (t2.version = r2), t2;
                    } }, { test: [/PaleMoon/i], describe: function(e2) {
                      var t2 = { name: "Pale Moon" }, r2 = n.default.getFirstMatch(s, e2) || n.default.getFirstMatch(/(?:PaleMoon)[\s/](\d+(?:\.\d+)+)/i, e2);
                      return r2 && (t2.version = r2), t2;
                    } }, { test: [/MZBrowser/i], describe: function(e2) {
                      var t2 = { name: "MZ Browser" }, r2 = n.default.getFirstMatch(/(?:MZBrowser)[\s/](\d+(?:\.\d+)+)/i, e2) || n.default.getFirstMatch(s, e2);
                      return r2 && (t2.version = r2), t2;
                    } }, { test: [/focus/i], describe: function(e2) {
                      var t2 = { name: "Focus" }, r2 = n.default.getFirstMatch(/(?:focus)[\s/](\d+(?:\.\d+)+)/i, e2) || n.default.getFirstMatch(s, e2);
                      return r2 && (t2.version = r2), t2;
                    } }, { test: [/swing/i], describe: function(e2) {
                      var t2 = { name: "Swing" }, r2 = n.default.getFirstMatch(/(?:swing)[\s/](\d+(?:\.\d+)+)/i, e2) || n.default.getFirstMatch(s, e2);
                      return r2 && (t2.version = r2), t2;
                    } }, { test: [/coast/i], describe: function(e2) {
                      var t2 = { name: "Opera Coast" }, r2 = n.default.getFirstMatch(s, e2) || n.default.getFirstMatch(/(?:coast)[\s/](\d+(\.?_?\d+)+)/i, e2);
                      return r2 && (t2.version = r2), t2;
                    } }, { test: [/opt\/\d+(?:.?_?\d+)+/i], describe: function(e2) {
                      var t2 = { name: "Opera Touch" }, r2 = n.default.getFirstMatch(/(?:opt)[\s/](\d+(\.?_?\d+)+)/i, e2) || n.default.getFirstMatch(s, e2);
                      return r2 && (t2.version = r2), t2;
                    } }, { test: [/yabrowser/i], describe: function(e2) {
                      var t2 = { name: "Yandex Browser" }, r2 = n.default.getFirstMatch(/(?:yabrowser)[\s/](\d+(\.?_?\d+)+)/i, e2) || n.default.getFirstMatch(s, e2);
                      return r2 && (t2.version = r2), t2;
                    } }, { test: [/ucbrowser/i], describe: function(e2) {
                      var t2 = { name: "UC Browser" }, r2 = n.default.getFirstMatch(s, e2) || n.default.getFirstMatch(/(?:ucbrowser)[\s/](\d+(\.?_?\d+)+)/i, e2);
                      return r2 && (t2.version = r2), t2;
                    } }, { test: [/Maxthon|mxios/i], describe: function(e2) {
                      var t2 = { name: "Maxthon" }, r2 = n.default.getFirstMatch(s, e2) || n.default.getFirstMatch(/(?:Maxthon|mxios)[\s/](\d+(\.?_?\d+)+)/i, e2);
                      return r2 && (t2.version = r2), t2;
                    } }, { test: [/epiphany/i], describe: function(e2) {
                      var t2 = { name: "Epiphany" }, r2 = n.default.getFirstMatch(s, e2) || n.default.getFirstMatch(/(?:epiphany)[\s/](\d+(\.?_?\d+)+)/i, e2);
                      return r2 && (t2.version = r2), t2;
                    } }, { test: [/puffin/i], describe: function(e2) {
                      var t2 = { name: "Puffin" }, r2 = n.default.getFirstMatch(s, e2) || n.default.getFirstMatch(/(?:puffin)[\s/](\d+(\.?_?\d+)+)/i, e2);
                      return r2 && (t2.version = r2), t2;
                    } }, { test: [/sleipnir/i], describe: function(e2) {
                      var t2 = { name: "Sleipnir" }, r2 = n.default.getFirstMatch(s, e2) || n.default.getFirstMatch(/(?:sleipnir)[\s/](\d+(\.?_?\d+)+)/i, e2);
                      return r2 && (t2.version = r2), t2;
                    } }, { test: [/k-meleon/i], describe: function(e2) {
                      var t2 = { name: "K-Meleon" }, r2 = n.default.getFirstMatch(s, e2) || n.default.getFirstMatch(/(?:k-meleon)[\s/](\d+(\.?_?\d+)+)/i, e2);
                      return r2 && (t2.version = r2), t2;
                    } }, { test: [/micromessenger/i], describe: function(e2) {
                      var t2 = { name: "WeChat" }, r2 = n.default.getFirstMatch(/(?:micromessenger)[\s/](\d+(\.?_?\d+)+)/i, e2) || n.default.getFirstMatch(s, e2);
                      return r2 && (t2.version = r2), t2;
                    } }, { test: [/qqbrowser/i], describe: function(e2) {
                      var t2 = { name: /qqbrowserlite/i.test(e2) ? "QQ Browser Lite" : "QQ Browser" }, r2 = n.default.getFirstMatch(/(?:qqbrowserlite|qqbrowser)[/](\d+(\.?_?\d+)+)/i, e2) || n.default.getFirstMatch(s, e2);
                      return r2 && (t2.version = r2), t2;
                    } }, { test: [/msie|trident/i], describe: function(e2) {
                      var t2 = { name: "Internet Explorer" }, r2 = n.default.getFirstMatch(/(?:msie |rv:)(\d+(\.?_?\d+)+)/i, e2);
                      return r2 && (t2.version = r2), t2;
                    } }, { test: [/\sedg\//i], describe: function(e2) {
                      var t2 = { name: "Microsoft Edge" }, r2 = n.default.getFirstMatch(/\sedg\/(\d+(\.?_?\d+)+)/i, e2);
                      return r2 && (t2.version = r2), t2;
                    } }, { test: [/edg([ea]|ios)/i], describe: function(e2) {
                      var t2 = { name: "Microsoft Edge" }, r2 = n.default.getSecondMatch(/edg([ea]|ios)\/(\d+(\.?_?\d+)+)/i, e2);
                      return r2 && (t2.version = r2), t2;
                    } }, { test: [/vivaldi/i], describe: function(e2) {
                      var t2 = { name: "Vivaldi" }, r2 = n.default.getFirstMatch(/vivaldi\/(\d+(\.?_?\d+)+)/i, e2);
                      return r2 && (t2.version = r2), t2;
                    } }, { test: [/seamonkey/i], describe: function(e2) {
                      var t2 = { name: "SeaMonkey" }, r2 = n.default.getFirstMatch(/seamonkey\/(\d+(\.?_?\d+)+)/i, e2);
                      return r2 && (t2.version = r2), t2;
                    } }, { test: [/sailfish/i], describe: function(e2) {
                      var t2 = { name: "Sailfish" }, r2 = n.default.getFirstMatch(/sailfish\s?browser\/(\d+(\.\d+)?)/i, e2);
                      return r2 && (t2.version = r2), t2;
                    } }, { test: [/silk/i], describe: function(e2) {
                      var t2 = { name: "Amazon Silk" }, r2 = n.default.getFirstMatch(/silk\/(\d+(\.?_?\d+)+)/i, e2);
                      return r2 && (t2.version = r2), t2;
                    } }, { test: [/phantom/i], describe: function(e2) {
                      var t2 = { name: "PhantomJS" }, r2 = n.default.getFirstMatch(/phantomjs\/(\d+(\.?_?\d+)+)/i, e2);
                      return r2 && (t2.version = r2), t2;
                    } }, { test: [/slimerjs/i], describe: function(e2) {
                      var t2 = { name: "SlimerJS" }, r2 = n.default.getFirstMatch(/slimerjs\/(\d+(\.?_?\d+)+)/i, e2);
                      return r2 && (t2.version = r2), t2;
                    } }, { test: [/blackberry|\bbb\d+/i, /rim\stablet/i], describe: function(e2) {
                      var t2 = { name: "BlackBerry" }, r2 = n.default.getFirstMatch(s, e2) || n.default.getFirstMatch(/blackberry[\d]+\/(\d+(\.?_?\d+)+)/i, e2);
                      return r2 && (t2.version = r2), t2;
                    } }, { test: [/(web|hpw)[o0]s/i], describe: function(e2) {
                      var t2 = { name: "WebOS Browser" }, r2 = n.default.getFirstMatch(s, e2) || n.default.getFirstMatch(/w(?:eb)?[o0]sbrowser\/(\d+(\.?_?\d+)+)/i, e2);
                      return r2 && (t2.version = r2), t2;
                    } }, { test: [/bada/i], describe: function(e2) {
                      var t2 = { name: "Bada" }, r2 = n.default.getFirstMatch(/dolfin\/(\d+(\.?_?\d+)+)/i, e2);
                      return r2 && (t2.version = r2), t2;
                    } }, { test: [/tizen/i], describe: function(e2) {
                      var t2 = { name: "Tizen" }, r2 = n.default.getFirstMatch(/(?:tizen\s?)?browser\/(\d+(\.?_?\d+)+)/i, e2) || n.default.getFirstMatch(s, e2);
                      return r2 && (t2.version = r2), t2;
                    } }, { test: [/qupzilla/i], describe: function(e2) {
                      var t2 = { name: "QupZilla" }, r2 = n.default.getFirstMatch(/(?:qupzilla)[\s/](\d+(\.?_?\d+)+)/i, e2) || n.default.getFirstMatch(s, e2);
                      return r2 && (t2.version = r2), t2;
                    } }, { test: [/firefox|iceweasel|fxios/i], describe: function(e2) {
                      var t2 = { name: "Firefox" }, r2 = n.default.getFirstMatch(/(?:firefox|iceweasel|fxios)[\s/](\d+(\.?_?\d+)+)/i, e2);
                      return r2 && (t2.version = r2), t2;
                    } }, { test: [/electron/i], describe: function(e2) {
                      var t2 = { name: "Electron" }, r2 = n.default.getFirstMatch(/(?:electron)\/(\d+(\.?_?\d+)+)/i, e2);
                      return r2 && (t2.version = r2), t2;
                    } }, { test: [/MiuiBrowser/i], describe: function(e2) {
                      var t2 = { name: "Miui" }, r2 = n.default.getFirstMatch(/(?:MiuiBrowser)[\s/](\d+(\.?_?\d+)+)/i, e2);
                      return r2 && (t2.version = r2), t2;
                    } }, { test: [/chromium/i], describe: function(e2) {
                      var t2 = { name: "Chromium" }, r2 = n.default.getFirstMatch(/(?:chromium)[\s/](\d+(\.?_?\d+)+)/i, e2) || n.default.getFirstMatch(s, e2);
                      return r2 && (t2.version = r2), t2;
                    } }, { test: [/chrome|crios|crmo/i], describe: function(e2) {
                      var t2 = { name: "Chrome" }, r2 = n.default.getFirstMatch(/(?:chrome|crios|crmo)\/(\d+(\.?_?\d+)+)/i, e2);
                      return r2 && (t2.version = r2), t2;
                    } }, { test: [/GSA/i], describe: function(e2) {
                      var t2 = { name: "Google Search" }, r2 = n.default.getFirstMatch(/(?:GSA)\/(\d+(\.?_?\d+)+)/i, e2);
                      return r2 && (t2.version = r2), t2;
                    } }, { test: function(e2) {
                      var t2 = !e2.test(/like android/i), r2 = e2.test(/android/i);
                      return t2 && r2;
                    }, describe: function(e2) {
                      var t2 = { name: "Android Browser" }, r2 = n.default.getFirstMatch(s, e2);
                      return r2 && (t2.version = r2), t2;
                    } }, { test: [/playstation 4/i], describe: function(e2) {
                      var t2 = { name: "PlayStation 4" }, r2 = n.default.getFirstMatch(s, e2);
                      return r2 && (t2.version = r2), t2;
                    } }, { test: [/safari|applewebkit/i], describe: function(e2) {
                      var t2 = { name: "Safari" }, r2 = n.default.getFirstMatch(s, e2);
                      return r2 && (t2.version = r2), t2;
                    } }, { test: [/.*/i], describe: function(e2) {
                      var t2 = -1 !== e2.search("\\(") ? /^(.*)\/(.*)[ \t]\((.*)/ : /^(.*)\/(.*) /;
                      return { name: n.default.getFirstMatch(t2, e2), version: n.default.getSecondMatch(t2, e2) };
                    } }];
                    t.default = a, e.exports = t.default;
                  }, 93: function(e, t, r) {
                    "use strict";
                    t.__esModule = true, t.default = void 0;
                    var i, n = (i = r(17)) && i.__esModule ? i : { default: i }, s = r(18);
                    var a = [{ test: [/Roku\/DVP/], describe: function(e2) {
                      var t2 = n.default.getFirstMatch(/Roku\/DVP-(\d+\.\d+)/i, e2);
                      return { name: s.OS_MAP.Roku, version: t2 };
                    } }, { test: [/windows phone/i], describe: function(e2) {
                      var t2 = n.default.getFirstMatch(/windows phone (?:os)?\s?(\d+(\.\d+)*)/i, e2);
                      return { name: s.OS_MAP.WindowsPhone, version: t2 };
                    } }, { test: [/windows /i], describe: function(e2) {
                      var t2 = n.default.getFirstMatch(/Windows ((NT|XP)( \d\d?.\d)?)/i, e2), r2 = n.default.getWindowsVersionName(t2);
                      return { name: s.OS_MAP.Windows, version: t2, versionName: r2 };
                    } }, { test: [/Macintosh(.*?) FxiOS(.*?)\//], describe: function(e2) {
                      var t2 = { name: s.OS_MAP.iOS }, r2 = n.default.getSecondMatch(/(Version\/)(\d[\d.]+)/, e2);
                      return r2 && (t2.version = r2), t2;
                    } }, { test: [/macintosh/i], describe: function(e2) {
                      var t2 = n.default.getFirstMatch(/mac os x (\d+(\.?_?\d+)+)/i, e2).replace(/[_\s]/g, "."), r2 = n.default.getMacOSVersionName(t2), i2 = { name: s.OS_MAP.MacOS, version: t2 };
                      return r2 && (i2.versionName = r2), i2;
                    } }, { test: [/(ipod|iphone|ipad)/i], describe: function(e2) {
                      var t2 = n.default.getFirstMatch(/os (\d+([_\s]\d+)*) like mac os x/i, e2).replace(/[_\s]/g, ".");
                      return { name: s.OS_MAP.iOS, version: t2 };
                    } }, { test: function(e2) {
                      var t2 = !e2.test(/like android/i), r2 = e2.test(/android/i);
                      return t2 && r2;
                    }, describe: function(e2) {
                      var t2 = n.default.getFirstMatch(/android[\s/-](\d+(\.\d+)*)/i, e2), r2 = n.default.getAndroidVersionName(t2), i2 = { name: s.OS_MAP.Android, version: t2 };
                      return r2 && (i2.versionName = r2), i2;
                    } }, { test: [/(web|hpw)[o0]s/i], describe: function(e2) {
                      var t2 = n.default.getFirstMatch(/(?:web|hpw)[o0]s\/(\d+(\.\d+)*)/i, e2), r2 = { name: s.OS_MAP.WebOS };
                      return t2 && t2.length && (r2.version = t2), r2;
                    } }, { test: [/blackberry|\bbb\d+/i, /rim\stablet/i], describe: function(e2) {
                      var t2 = n.default.getFirstMatch(/rim\stablet\sos\s(\d+(\.\d+)*)/i, e2) || n.default.getFirstMatch(/blackberry\d+\/(\d+([_\s]\d+)*)/i, e2) || n.default.getFirstMatch(/\bbb(\d+)/i, e2);
                      return { name: s.OS_MAP.BlackBerry, version: t2 };
                    } }, { test: [/bada/i], describe: function(e2) {
                      var t2 = n.default.getFirstMatch(/bada\/(\d+(\.\d+)*)/i, e2);
                      return { name: s.OS_MAP.Bada, version: t2 };
                    } }, { test: [/tizen/i], describe: function(e2) {
                      var t2 = n.default.getFirstMatch(/tizen[/\s](\d+(\.\d+)*)/i, e2);
                      return { name: s.OS_MAP.Tizen, version: t2 };
                    } }, { test: [/linux/i], describe: function() {
                      return { name: s.OS_MAP.Linux };
                    } }, { test: [/CrOS/], describe: function() {
                      return { name: s.OS_MAP.ChromeOS };
                    } }, { test: [/PlayStation 4/], describe: function(e2) {
                      var t2 = n.default.getFirstMatch(/PlayStation 4[/\s](\d+(\.\d+)*)/i, e2);
                      return { name: s.OS_MAP.PlayStation4, version: t2 };
                    } }];
                    t.default = a, e.exports = t.default;
                  }, 94: function(e, t, r) {
                    "use strict";
                    t.__esModule = true, t.default = void 0;
                    var i, n = (i = r(17)) && i.__esModule ? i : { default: i }, s = r(18);
                    var a = [{ test: [/googlebot/i], describe: function() {
                      return { type: s.PLATFORMS_MAP.bot, vendor: "Google" };
                    } }, { test: [/huawei/i], describe: function(e2) {
                      var t2 = n.default.getFirstMatch(/(can-l01)/i, e2) && "Nova", r2 = { type: s.PLATFORMS_MAP.mobile, vendor: "Huawei" };
                      return t2 && (r2.model = t2), r2;
                    } }, { test: [/nexus\s*(?:7|8|9|10).*/i], describe: function() {
                      return { type: s.PLATFORMS_MAP.tablet, vendor: "Nexus" };
                    } }, { test: [/ipad/i], describe: function() {
                      return { type: s.PLATFORMS_MAP.tablet, vendor: "Apple", model: "iPad" };
                    } }, { test: [/Macintosh(.*?) FxiOS(.*?)\//], describe: function() {
                      return { type: s.PLATFORMS_MAP.tablet, vendor: "Apple", model: "iPad" };
                    } }, { test: [/kftt build/i], describe: function() {
                      return { type: s.PLATFORMS_MAP.tablet, vendor: "Amazon", model: "Kindle Fire HD 7" };
                    } }, { test: [/silk/i], describe: function() {
                      return { type: s.PLATFORMS_MAP.tablet, vendor: "Amazon" };
                    } }, { test: [/tablet(?! pc)/i], describe: function() {
                      return { type: s.PLATFORMS_MAP.tablet };
                    } }, { test: function(e2) {
                      var t2 = e2.test(/ipod|iphone/i), r2 = e2.test(/like (ipod|iphone)/i);
                      return t2 && !r2;
                    }, describe: function(e2) {
                      var t2 = n.default.getFirstMatch(/(ipod|iphone)/i, e2);
                      return { type: s.PLATFORMS_MAP.mobile, vendor: "Apple", model: t2 };
                    } }, { test: [/nexus\s*[0-6].*/i, /galaxy nexus/i], describe: function() {
                      return { type: s.PLATFORMS_MAP.mobile, vendor: "Nexus" };
                    } }, { test: [/Nokia/i], describe: function(e2) {
                      var t2 = n.default.getFirstMatch(/Nokia\s+([0-9]+(\.[0-9]+)?)/i, e2), r2 = { type: s.PLATFORMS_MAP.mobile, vendor: "Nokia" };
                      return t2 && (r2.model = t2), r2;
                    } }, { test: [/[^-]mobi/i], describe: function() {
                      return { type: s.PLATFORMS_MAP.mobile };
                    } }, { test: function(e2) {
                      return "blackberry" === e2.getBrowserName(true);
                    }, describe: function() {
                      return { type: s.PLATFORMS_MAP.mobile, vendor: "BlackBerry" };
                    } }, { test: function(e2) {
                      return "bada" === e2.getBrowserName(true);
                    }, describe: function() {
                      return { type: s.PLATFORMS_MAP.mobile };
                    } }, { test: function(e2) {
                      return "windows phone" === e2.getBrowserName();
                    }, describe: function() {
                      return { type: s.PLATFORMS_MAP.mobile, vendor: "Microsoft" };
                    } }, { test: function(e2) {
                      var t2 = Number(String(e2.getOSVersion()).split(".")[0]);
                      return "android" === e2.getOSName(true) && t2 >= 3;
                    }, describe: function() {
                      return { type: s.PLATFORMS_MAP.tablet };
                    } }, { test: function(e2) {
                      return "android" === e2.getOSName(true);
                    }, describe: function() {
                      return { type: s.PLATFORMS_MAP.mobile };
                    } }, { test: function(e2) {
                      return "macos" === e2.getOSName(true);
                    }, describe: function() {
                      return { type: s.PLATFORMS_MAP.desktop, vendor: "Apple" };
                    } }, { test: function(e2) {
                      return "windows" === e2.getOSName(true);
                    }, describe: function() {
                      return { type: s.PLATFORMS_MAP.desktop };
                    } }, { test: function(e2) {
                      return "linux" === e2.getOSName(true);
                    }, describe: function() {
                      return { type: s.PLATFORMS_MAP.desktop };
                    } }, { test: function(e2) {
                      return "playstation 4" === e2.getOSName(true);
                    }, describe: function() {
                      return { type: s.PLATFORMS_MAP.tv };
                    } }, { test: function(e2) {
                      return "roku" === e2.getOSName(true);
                    }, describe: function() {
                      return { type: s.PLATFORMS_MAP.tv };
                    } }];
                    t.default = a, e.exports = t.default;
                  }, 95: function(e, t, r) {
                    "use strict";
                    t.__esModule = true, t.default = void 0;
                    var i, n = (i = r(17)) && i.__esModule ? i : { default: i }, s = r(18);
                    var a = [{ test: function(e2) {
                      return "microsoft edge" === e2.getBrowserName(true);
                    }, describe: function(e2) {
                      if (/\sedg\//i.test(e2)) return { name: s.ENGINE_MAP.Blink };
                      var t2 = n.default.getFirstMatch(/edge\/(\d+(\.?_?\d+)+)/i, e2);
                      return { name: s.ENGINE_MAP.EdgeHTML, version: t2 };
                    } }, { test: [/trident/i], describe: function(e2) {
                      var t2 = { name: s.ENGINE_MAP.Trident }, r2 = n.default.getFirstMatch(/trident\/(\d+(\.?_?\d+)+)/i, e2);
                      return r2 && (t2.version = r2), t2;
                    } }, { test: function(e2) {
                      return e2.test(/presto/i);
                    }, describe: function(e2) {
                      var t2 = { name: s.ENGINE_MAP.Presto }, r2 = n.default.getFirstMatch(/presto\/(\d+(\.?_?\d+)+)/i, e2);
                      return r2 && (t2.version = r2), t2;
                    } }, { test: function(e2) {
                      var t2 = e2.test(/gecko/i), r2 = e2.test(/like gecko/i);
                      return t2 && !r2;
                    }, describe: function(e2) {
                      var t2 = { name: s.ENGINE_MAP.Gecko }, r2 = n.default.getFirstMatch(/gecko\/(\d+(\.?_?\d+)+)/i, e2);
                      return r2 && (t2.version = r2), t2;
                    } }, { test: [/(apple)?webkit\/537\.36/i], describe: function() {
                      return { name: s.ENGINE_MAP.Blink };
                    } }, { test: [/(apple)?webkit/i], describe: function(e2) {
                      var t2 = { name: s.ENGINE_MAP.WebKit }, r2 = n.default.getFirstMatch(/webkit\/(\d+(\.?_?\d+)+)/i, e2);
                      return r2 && (t2.version = r2), t2;
                    } }];
                    t.default = a, e.exports = t.default;
                  } });
                });
              }
            ),
            /***/
            6939: (
              /***/
              function(module2, exports2, __webpack_require__2) {
                ;
                (function(root, factory, undef) {
                  if (true) {
                    module2.exports = exports2 = factory(__webpack_require__2(9021), __webpack_require__2(7165));
                  } else {
                  }
                })(this, function(CryptoJS) {
                  CryptoJS.mode.CTR = function() {
                    var CTR = CryptoJS.lib.BlockCipherMode.extend();
                    var Encryptor = CTR.Encryptor = CTR.extend({
                      processBlock: function(words, offset) {
                        var cipher = this._cipher;
                        var blockSize = cipher.blockSize;
                        var iv = this._iv;
                        var counter = this._counter;
                        if (iv) {
                          counter = this._counter = iv.slice(0);
                          this._iv = void 0;
                        }
                        var keystream = counter.slice(0);
                        cipher.encryptBlock(keystream, 0);
                        counter[blockSize - 1] = counter[blockSize - 1] + 1 | 0;
                        for (var i = 0; i < blockSize; i++) {
                          words[offset + i] ^= keystream[i];
                        }
                      }
                    });
                    CTR.Decryptor = Encryptor;
                    return CTR;
                  }();
                  return CryptoJS.mode.CTR;
                });
              }
            ),
            /***/
            6993: (
              /***/
              (module2, __unused_webpack_exports, __webpack_require__2) => {
                var regeneratorDefine = __webpack_require__2(5546);
                function _regenerator() {
                  var e, t, r = "function" == typeof Symbol ? Symbol : {}, n = r.iterator || "@@iterator", o = r.toStringTag || "@@toStringTag";
                  function i(r2, n2, o2, i2) {
                    var c2 = n2 && n2.prototype instanceof Generator ? n2 : Generator, u2 = Object.create(c2.prototype);
                    return regeneratorDefine(u2, "_invoke", function(r3, n3, o3) {
                      var i3, c3, u3, f2 = 0, p = o3 || [], y = false, G = {
                        p: 0,
                        n: 0,
                        v: e,
                        a: d,
                        f: d.bind(e, 4),
                        d: function d2(t2, r4) {
                          return i3 = t2, c3 = 0, u3 = e, G.n = r4, a;
                        }
                      };
                      function d(r4, n4) {
                        for (c3 = r4, u3 = n4, t = 0; !y && f2 && !o4 && t < p.length; t++) {
                          var o4, i4 = p[t], d2 = G.p, l = i4[2];
                          r4 > 3 ? (o4 = l === n4) && (u3 = i4[(c3 = i4[4]) ? 5 : (c3 = 3, 3)], i4[4] = i4[5] = e) : i4[0] <= d2 && ((o4 = r4 < 2 && d2 < i4[1]) ? (c3 = 0, G.v = n4, G.n = i4[1]) : d2 < l && (o4 = r4 < 3 || i4[0] > n4 || n4 > l) && (i4[4] = r4, i4[5] = n4, G.n = l, c3 = 0));
                        }
                        if (o4 || r4 > 1) return a;
                        throw y = true, n4;
                      }
                      return function(o4, p2, l) {
                        if (f2 > 1) throw TypeError("Generator is already running");
                        for (y && 1 === p2 && d(p2, l), c3 = p2, u3 = l; (t = c3 < 2 ? e : u3) || !y; ) {
                          i3 || (c3 ? c3 < 3 ? (c3 > 1 && (G.n = -1), d(c3, u3)) : G.n = u3 : G.v = u3);
                          try {
                            if (f2 = 2, i3) {
                              if (c3 || (o4 = "next"), t = i3[o4]) {
                                if (!(t = t.call(i3, u3))) throw TypeError("iterator result is not an object");
                                if (!t.done) return t;
                                u3 = t.value, c3 < 2 && (c3 = 0);
                              } else 1 === c3 && (t = i3["return"]) && t.call(i3), c3 < 2 && (u3 = TypeError("The iterator does not provide a '" + o4 + "' method"), c3 = 1);
                              i3 = e;
                            } else if ((t = (y = G.n < 0) ? u3 : r3.call(n3, G)) !== a) break;
                          } catch (t2) {
                            i3 = e, c3 = 1, u3 = t2;
                          } finally {
                            f2 = 1;
                          }
                        }
                        return {
                          value: t,
                          done: y
                        };
                      };
                    }(r2, o2, i2), true), u2;
                  }
                  var a = {};
                  function Generator() {
                  }
                  function GeneratorFunction() {
                  }
                  function GeneratorFunctionPrototype() {
                  }
                  t = Object.getPrototypeOf;
                  var c = [][n] ? t(t([][n]())) : (regeneratorDefine(t = {}, n, function() {
                    return this;
                  }), t), u = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(c);
                  function f(e2) {
                    return Object.setPrototypeOf ? Object.setPrototypeOf(e2, GeneratorFunctionPrototype) : (e2.__proto__ = GeneratorFunctionPrototype, regeneratorDefine(e2, o, "GeneratorFunction")), e2.prototype = Object.create(u), e2;
                  }
                  return GeneratorFunction.prototype = GeneratorFunctionPrototype, regeneratorDefine(u, "constructor", GeneratorFunctionPrototype), regeneratorDefine(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = "GeneratorFunction", regeneratorDefine(GeneratorFunctionPrototype, o, "GeneratorFunction"), regeneratorDefine(u), regeneratorDefine(u, o, "Generator"), regeneratorDefine(u, n, function() {
                    return this;
                  }), regeneratorDefine(u, "toString", function() {
                    return "[object Generator]";
                  }), (module2.exports = _regenerator = function _regenerator2() {
                    return {
                      w: i,
                      m: f
                    };
                  }, module2.exports.__esModule = true, module2.exports["default"] = module2.exports)();
                }
                module2.exports = _regenerator, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
              }
            ),
            /***/
            7007: (
              /***/
              (module2) => {
                "use strict";
                var R = typeof Reflect === "object" ? Reflect : null;
                var ReflectApply = R && typeof R.apply === "function" ? R.apply : function ReflectApply2(target, receiver, args) {
                  return Function.prototype.apply.call(target, receiver, args);
                };
                var ReflectOwnKeys;
                if (R && typeof R.ownKeys === "function") {
                  ReflectOwnKeys = R.ownKeys;
                } else if (Object.getOwnPropertySymbols) {
                  ReflectOwnKeys = function ReflectOwnKeys2(target) {
                    return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));
                  };
                } else {
                  ReflectOwnKeys = function ReflectOwnKeys2(target) {
                    return Object.getOwnPropertyNames(target);
                  };
                }
                function ProcessEmitWarning(warning) {
                  if (console && console.warn) console.warn(warning);
                }
                var NumberIsNaN = Number.isNaN || function NumberIsNaN2(value) {
                  return value !== value;
                };
                function EventEmitter2() {
                  EventEmitter2.init.call(this);
                }
                module2.exports = EventEmitter2;
                module2.exports.once = once;
                EventEmitter2.EventEmitter = EventEmitter2;
                EventEmitter2.prototype._events = void 0;
                EventEmitter2.prototype._eventsCount = 0;
                EventEmitter2.prototype._maxListeners = void 0;
                var defaultMaxListeners = 10;
                function checkListener(listener) {
                  if (typeof listener !== "function") {
                    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
                  }
                }
                Object.defineProperty(EventEmitter2, "defaultMaxListeners", {
                  enumerable: true,
                  get: function() {
                    return defaultMaxListeners;
                  },
                  set: function(arg) {
                    if (typeof arg !== "number" || arg < 0 || NumberIsNaN(arg)) {
                      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + ".");
                    }
                    defaultMaxListeners = arg;
                  }
                });
                EventEmitter2.init = function() {
                  if (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) {
                    this._events = /* @__PURE__ */ Object.create(null);
                    this._eventsCount = 0;
                  }
                  this._maxListeners = this._maxListeners || void 0;
                };
                EventEmitter2.prototype.setMaxListeners = function setMaxListeners(n) {
                  if (typeof n !== "number" || n < 0 || NumberIsNaN(n)) {
                    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + ".");
                  }
                  this._maxListeners = n;
                  return this;
                };
                function _getMaxListeners(that) {
                  if (that._maxListeners === void 0)
                    return EventEmitter2.defaultMaxListeners;
                  return that._maxListeners;
                }
                EventEmitter2.prototype.getMaxListeners = function getMaxListeners() {
                  return _getMaxListeners(this);
                };
                EventEmitter2.prototype.emit = function emit(type) {
                  var args = [];
                  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);
                  var doError = type === "error";
                  var events2 = this._events;
                  if (events2 !== void 0)
                    doError = doError && events2.error === void 0;
                  else if (!doError)
                    return false;
                  if (doError) {
                    var er;
                    if (args.length > 0)
                      er = args[0];
                    if (er instanceof Error) {
                      throw er;
                    }
                    var err = new Error("Unhandled error." + (er ? " (" + er.message + ")" : ""));
                    err.context = er;
                    throw err;
                  }
                  var handler = events2[type];
                  if (handler === void 0)
                    return false;
                  if (typeof handler === "function") {
                    ReflectApply(handler, this, args);
                  } else {
                    var len = handler.length;
                    var listeners = arrayClone(handler, len);
                    for (var i = 0; i < len; ++i)
                      ReflectApply(listeners[i], this, args);
                  }
                  return true;
                };
                function _addListener(target, type, listener, prepend) {
                  var m;
                  var events2;
                  var existing;
                  checkListener(listener);
                  events2 = target._events;
                  if (events2 === void 0) {
                    events2 = target._events = /* @__PURE__ */ Object.create(null);
                    target._eventsCount = 0;
                  } else {
                    if (events2.newListener !== void 0) {
                      target.emit(
                        "newListener",
                        type,
                        listener.listener ? listener.listener : listener
                      );
                      events2 = target._events;
                    }
                    existing = events2[type];
                  }
                  if (existing === void 0) {
                    existing = events2[type] = listener;
                    ++target._eventsCount;
                  } else {
                    if (typeof existing === "function") {
                      existing = events2[type] = prepend ? [listener, existing] : [existing, listener];
                    } else if (prepend) {
                      existing.unshift(listener);
                    } else {
                      existing.push(listener);
                    }
                    m = _getMaxListeners(target);
                    if (m > 0 && existing.length > m && !existing.warned) {
                      existing.warned = true;
                      var w = new Error("Possible EventEmitter memory leak detected. " + existing.length + " " + String(type) + " listeners added. Use emitter.setMaxListeners() to increase limit");
                      w.name = "MaxListenersExceededWarning";
                      w.emitter = target;
                      w.type = type;
                      w.count = existing.length;
                      ProcessEmitWarning(w);
                    }
                  }
                  return target;
                }
                EventEmitter2.prototype.addListener = function addListener(type, listener) {
                  return _addListener(this, type, listener, false);
                };
                EventEmitter2.prototype.on = EventEmitter2.prototype.addListener;
                EventEmitter2.prototype.prependListener = function prependListener(type, listener) {
                  return _addListener(this, type, listener, true);
                };
                function onceWrapper() {
                  if (!this.fired) {
                    this.target.removeListener(this.type, this.wrapFn);
                    this.fired = true;
                    if (arguments.length === 0)
                      return this.listener.call(this.target);
                    return this.listener.apply(this.target, arguments);
                  }
                }
                function _onceWrap(target, type, listener) {
                  var state = { fired: false, wrapFn: void 0, target, type, listener };
                  var wrapped = onceWrapper.bind(state);
                  wrapped.listener = listener;
                  state.wrapFn = wrapped;
                  return wrapped;
                }
                EventEmitter2.prototype.once = function once2(type, listener) {
                  checkListener(listener);
                  this.on(type, _onceWrap(this, type, listener));
                  return this;
                };
                EventEmitter2.prototype.prependOnceListener = function prependOnceListener(type, listener) {
                  checkListener(listener);
                  this.prependListener(type, _onceWrap(this, type, listener));
                  return this;
                };
                EventEmitter2.prototype.removeListener = function removeListener(type, listener) {
                  var list, events2, position, i, originalListener;
                  checkListener(listener);
                  events2 = this._events;
                  if (events2 === void 0)
                    return this;
                  list = events2[type];
                  if (list === void 0)
                    return this;
                  if (list === listener || list.listener === listener) {
                    if (--this._eventsCount === 0)
                      this._events = /* @__PURE__ */ Object.create(null);
                    else {
                      delete events2[type];
                      if (events2.removeListener)
                        this.emit("removeListener", type, list.listener || listener);
                    }
                  } else if (typeof list !== "function") {
                    position = -1;
                    for (i = list.length - 1; i >= 0; i--) {
                      if (list[i] === listener || list[i].listener === listener) {
                        originalListener = list[i].listener;
                        position = i;
                        break;
                      }
                    }
                    if (position < 0)
                      return this;
                    if (position === 0)
                      list.shift();
                    else {
                      spliceOne(list, position);
                    }
                    if (list.length === 1)
                      events2[type] = list[0];
                    if (events2.removeListener !== void 0)
                      this.emit("removeListener", type, originalListener || listener);
                  }
                  return this;
                };
                EventEmitter2.prototype.off = EventEmitter2.prototype.removeListener;
                EventEmitter2.prototype.removeAllListeners = function removeAllListeners(type) {
                  var listeners, events2, i;
                  events2 = this._events;
                  if (events2 === void 0)
                    return this;
                  if (events2.removeListener === void 0) {
                    if (arguments.length === 0) {
                      this._events = /* @__PURE__ */ Object.create(null);
                      this._eventsCount = 0;
                    } else if (events2[type] !== void 0) {
                      if (--this._eventsCount === 0)
                        this._events = /* @__PURE__ */ Object.create(null);
                      else
                        delete events2[type];
                    }
                    return this;
                  }
                  if (arguments.length === 0) {
                    var keys = Object.keys(events2);
                    var key;
                    for (i = 0; i < keys.length; ++i) {
                      key = keys[i];
                      if (key === "removeListener") continue;
                      this.removeAllListeners(key);
                    }
                    this.removeAllListeners("removeListener");
                    this._events = /* @__PURE__ */ Object.create(null);
                    this._eventsCount = 0;
                    return this;
                  }
                  listeners = events2[type];
                  if (typeof listeners === "function") {
                    this.removeListener(type, listeners);
                  } else if (listeners !== void 0) {
                    for (i = listeners.length - 1; i >= 0; i--) {
                      this.removeListener(type, listeners[i]);
                    }
                  }
                  return this;
                };
                function _listeners(target, type, unwrap) {
                  var events2 = target._events;
                  if (events2 === void 0)
                    return [];
                  var evlistener = events2[type];
                  if (evlistener === void 0)
                    return [];
                  if (typeof evlistener === "function")
                    return unwrap ? [evlistener.listener || evlistener] : [evlistener];
                  return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
                }
                EventEmitter2.prototype.listeners = function listeners(type) {
                  return _listeners(this, type, true);
                };
                EventEmitter2.prototype.rawListeners = function rawListeners(type) {
                  return _listeners(this, type, false);
                };
                EventEmitter2.listenerCount = function(emitter, type) {
                  if (typeof emitter.listenerCount === "function") {
                    return emitter.listenerCount(type);
                  } else {
                    return listenerCount.call(emitter, type);
                  }
                };
                EventEmitter2.prototype.listenerCount = listenerCount;
                function listenerCount(type) {
                  var events2 = this._events;
                  if (events2 !== void 0) {
                    var evlistener = events2[type];
                    if (typeof evlistener === "function") {
                      return 1;
                    } else if (evlistener !== void 0) {
                      return evlistener.length;
                    }
                  }
                  return 0;
                }
                EventEmitter2.prototype.eventNames = function eventNames() {
                  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
                };
                function arrayClone(arr, n) {
                  var copy = new Array(n);
                  for (var i = 0; i < n; ++i)
                    copy[i] = arr[i];
                  return copy;
                }
                function spliceOne(list, index) {
                  for (; index + 1 < list.length; index++)
                    list[index] = list[index + 1];
                  list.pop();
                }
                function unwrapListeners(arr) {
                  var ret = new Array(arr.length);
                  for (var i = 0; i < ret.length; ++i) {
                    ret[i] = arr[i].listener || arr[i];
                  }
                  return ret;
                }
                function once(emitter, name) {
                  return new Promise(function(resolve, reject) {
                    function errorListener(err) {
                      emitter.removeListener(name, resolver);
                      reject(err);
                    }
                    function resolver() {
                      if (typeof emitter.removeListener === "function") {
                        emitter.removeListener("error", errorListener);
                      }
                      resolve([].slice.call(arguments));
                    }
                    ;
                    eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });
                    if (name !== "error") {
                      addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });
                    }
                  });
                }
                function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
                  if (typeof emitter.on === "function") {
                    eventTargetAgnosticAddListener(emitter, "error", handler, flags);
                  }
                }
                function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
                  if (typeof emitter.on === "function") {
                    if (flags.once) {
                      emitter.once(name, listener);
                    } else {
                      emitter.on(name, listener);
                    }
                  } else if (typeof emitter.addEventListener === "function") {
                    emitter.addEventListener(name, function wrapListener(arg) {
                      if (flags.once) {
                        emitter.removeEventListener(name, wrapListener);
                      }
                      listener(arg);
                    });
                  } else {
                    throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
                  }
                }
              }
            ),
            /***/
            7080: (
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                "use strict";
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  q: () => (
                    /* binding */
                    sdkErrors
                  ),
                  /* harmony export */
                  s: () => (
                    /* binding */
                    errors
                  )
                  /* harmony export */
                });
                var errors = {
                  // server errors
                  INVALID_API_KEY: 4001,
                  INVALID_TOKEN: 4002,
                  INVALID_MEETING_ID: 4003,
                  INVALID_PARTICIPANT_ID: 4004,
                  DUPLICATE_PARTICIPANT: 4005,
                  ACCOUNT_DEACTIVATED: 4006,
                  ACCOUNT_DISCONTINUED: 4007,
                  INVALID_PERMISSIONS: 4008,
                  MAX_PARTCIPANT_REACHED: 4009,
                  MAX_SPEAKER_REACHED: 4010,
                  START_RECORDING_FAILED: 4011,
                  STOP_RECORDING_FAILED: 4012,
                  START_LIVESTREAM_FAILED: 4013,
                  STOP_LIVESTREAM_FAILED: 4014,
                  INVALID_LIVESTREAM_CONFIG: 4015,
                  START_HLS_FAILED: 4016,
                  STOP_HLS_FAILED: 4017,
                  START_TRANSCRIPTION_FAILED: 4031,
                  STOP_TRANSCRIPTION_FAILED: 4032,
                  START_TRANSLATION_FAILED: 4042,
                  STOP_TRANSLATION_FAILED: 4043,
                  CHANGE_TRANSLATION_LANGUAGE_FAILED: 4044,
                  // server critical errors
                  RECORDING_FAILED: 5001,
                  LIVESTREAM_FAILED: 5002,
                  HLS_FAILED: 5003,
                  TRANSCRIPTION_FAILED: 5007,
                  TRANSLATION_FAILED: 5015,
                  // sdk errors
                  ERROR_GET_VIDEO_MEDIA: 3011,
                  ERROR_GET_AUDIO_MEDIA: 3012,
                  ERROR_GET_DISPLAY_MEDIA: 3013,
                  ERROR_GET_VIDEO_MEDIA_PERMISSION_DENIED: 3014,
                  ERROR_GET_AUDIO_MEDIA_PERMISSION_DENIED: 3015,
                  ERROR_GET_DISPLAY_MEDIA_PERMISSION_DENIED: 3016,
                  ERROR_CAMERA_ACCESS_DENIED_OR_DISMISSED: 3017,
                  ERROR_MICROPHONE_ACCESS_DENIED_OR_DISMISSED: 3018,
                  ERROR_CAMERA_PERMISSION_DENIED_BY_OS: 3019,
                  ERROR_MICROPHONE_PERMISSION_DENIED_BY_OS: 3020,
                  ERROR_CAMERA_NOT_FOUND: 3021,
                  ERROR_MICROPHONE_NOT_FOUND: 3022,
                  ERROR_CAMERA_IN_USE: 3023,
                  ERROR_MICROPHONE_IN_USE: 3024,
                  ERROR_CAMERA_PERMISSION_OR_AUTOPLAY_ISSUE: 3025,
                  ERROR_VIDEO_SOURCE_INITIATION_FAILED: 3026,
                  ERROR_WEBCAM_TRACK_ENDED: 3027,
                  ERROR_MICROPHONE_TRACK_ENDED: 3028,
                  ERROR_INVALID_CUSTOM_VIDEO_TRACK: 3029,
                  ERROR_INVALID_CUSTOM_AUDIO_TRACK: 3030,
                  ERROR_CUSTOM_VIDEO_TRACK_ENDED: 3031,
                  ERROR_CUSTOM_AUDIO_TRACK_ENDED: 3032,
                  ERROR_CAMERA_ACCESS_UNAVAILABLE: 3033,
                  ERROR_MICROPHONE_ACCESS_UNAVAILABLE: 3034,
                  ERROR_ACTION_PERFORMED_BEFORE_MEETING_JOINED: 3035,
                  ERROR_RN_CAMERA_ACCESS_DENIED_OR_DISMISSED: 3036,
                  ERROR_RN_CAMERA_NOT_FOUND: 3037,
                  ERROR_RN_MIC_ACCESS_DENIED_OR_DISMISSED: 3038,
                  ERROR_RN_MIC_NOT_FOUND: 3039,
                  ERROR_RN_CAMERA_ACCESS_UNAVAILABLE: 3040,
                  ERROR_RN_MIC_ACCESS_UNAVAILABLE: 3041,
                  ERROR_RN_CAMERA_TRACK_ENDED: 3042,
                  ERROR_RN_MIC_TRACK_ENDED: 3043
                };
                var sdkErrors = {
                  ERROR_GET_VIDEO_MEDIA: {
                    code: 3011,
                    message: "Your browser/Device does not support Video."
                  },
                  ERROR_GET_AUDIO_MEDIA: {
                    code: 3012,
                    message: "Your browser/Device does not support Audio."
                  },
                  ERROR_GET_DISPLAY_MEDIA: {
                    code: 3013,
                    message: "Your browser/Device does not support Screen Sharing."
                  },
                  ERROR_GET_VIDEO_MEDIA_PERMISSION_DENIED: {
                    code: 3014,
                    message: "Video capture permission denied."
                  },
                  ERROR_GET_AUDIO_MEDIA_PERMISSION_DENIED: {
                    code: 3015,
                    message: "Audio capture permission denied."
                  },
                  ERROR_GET_DISPLAY_MEDIA_PERMISSION_DENIED: {
                    code: 3016,
                    message: "Screen sharing permission denied."
                  },
                  ERROR_CAMERA_ACCESS_DENIED_OR_DISMISSED: {
                    code: 3017,
                    message: "Oops! It seems like camera access was denied or dismissed. To proceed, kindly grant access through your browser settings."
                  },
                  ERROR_MICROPHONE_ACCESS_DENIED_OR_DISMISSED: {
                    code: 3018,
                    message: "Oops! It seems like microphone access was denied or dismissed. To proceed, kindly grant access through your browser settings."
                  },
                  ERROR_CAMERA_PERMISSION_DENIED_BY_OS: {
                    code: 3019,
                    message: "Camera permission denied by OS system settings. Please check the system settings and grant permission for this browser."
                  },
                  ERROR_MICROPHONE_PERMISSION_DENIED_BY_OS: {
                    code: 3020,
                    message: "Microphone permission denied by OS system settings. Please check the system settings and grant permission for this browser."
                  },
                  ERROR_CAMERA_NOT_FOUND: {
                    code: 3021,
                    message: "Please ensure your camera is connected and turned on, and that the camera driver is installed and up-to-date."
                  },
                  ERROR_MICROPHONE_NOT_FOUND: {
                    code: 3022,
                    message: "Please ensure your microphone is connected and turned on."
                  },
                  ERROR_CAMERA_IN_USE: {
                    code: 3023,
                    message: "The camera is being used by another application. Please close any programs utilizing the camera, such as video conferencing tools, screen recording software, or other browsers. Restart your browser and attempt again."
                  },
                  ERROR_MICROPHONE_IN_USE: {
                    code: 3024,
                    message: "The microphone is being used by another application. Please close any programs utilizing the microphone, such as video conferencing tools, screen recording software, or other browsers. Restart your browser and attempt again."
                  },
                  ERROR_CAMERA_PERMISSION_OR_AUTOPLAY_ISSUE: {
                    code: 3025,
                    message: "It seems like there's an issue with camera permission or video autoplay, you can check out this link for details: http://tinyurl.com/autoplay-issue"
                  },
                  ERROR_VIDEO_SOURCE_INITIATION_FAILED: {
                    code: 3026,
                    message: "Unable to initiate video source. Please verify browser settings for video permissions."
                  },
                  ERROR_WEBCAM_TRACK_ENDED: {
                    code: 3027,
                    message: "Webcam track has ended or the webcam is disconnected. Please ensure your webcam is properly connected and try restarting it."
                  },
                  ERROR_MICROPHONE_TRACK_ENDED: {
                    code: 3028,
                    message: "Microphone track has ended or the microphone is disconnected. Please check your microphone connection and try again."
                  },
                  ERROR_INVALID_CUSTOM_VIDEO_TRACK: {
                    code: 3029,
                    message: "The provided custom video track is invalid; reverting to the default video track. Please ensure that the video track meets the required specifications."
                  },
                  ERROR_INVALID_CUSTOM_AUDIO_TRACK: {
                    code: 3030,
                    message: "The provided custom audio track is invalid; reverting to the default audio track. Please ensure that the audio track meets the required specifications."
                  },
                  ERROR_CUSTOM_VIDEO_TRACK_ENDED: {
                    code: 3031,
                    message: "The provided custom video track is in an ended state. Please verify the video track's status, and try again."
                  },
                  ERROR_CUSTOM_AUDIO_TRACK_ENDED: {
                    code: 3032,
                    message: "The provided custom audio track is in an ended state. Please verify the audio track's status, and try again."
                  },
                  ERROR_CAMERA_ACCESS_UNAVAILABLE: {
                    code: 3033,
                    message: "Camera access unavailable: Please ensure your device is compatible and that you're on a secure website (https://)."
                  },
                  ERROR_MICROPHONE_ACCESS_UNAVAILABLE: {
                    code: 3034,
                    message: "Microphone access unavailable: Please ensure your device is compatible and that you're on a secure website (https://)."
                  },
                  ERROR_ACTION_PERFORMED_BEFORE_MEETING_JOINED: {
                    code: 3035,
                    message: "Oops! Something went wrong. The room was in a connecting state, and during that time, an action encountered an issue. Please try again after joining a meeting."
                  },
                  // For React Native
                  ERROR_RN_CAMERA_ACCESS_DENIED_OR_DISMISSED: {
                    code: 3036,
                    message: "Oops! It seems like camera access was denied or dismissed. To proceed, kindly grant access through your App settings."
                  },
                  ERROR_RN_CAMERA_NOT_FOUND: {
                    code: 3037,
                    message: "Please ensure your camera is connected and turned on"
                  },
                  ERROR_RN_MIC_ACCESS_DENIED_OR_DISMISSED: {
                    code: 3038,
                    message: "Oops! It seems like mic access was denied or dismissed. To proceed, kindly grant access through your App settings."
                  },
                  ERROR_RN_MIC_NOT_FOUND: {
                    code: 3039,
                    message: "Please ensure your mic is connected and turned on"
                  },
                  ERROR_RN_CAMERA_ACCESS_UNAVAILABLE: {
                    code: 3040,
                    message: "Camera access unavailable: Please ensure your device is compatible."
                  },
                  ERROR_RN_MIC_ACCESS_UNAVAILABLE: {
                    code: 3041,
                    message: "Microphone access unavailable: Please ensure your device is compatible."
                  },
                  ERROR_RN_CAMERA_TRACK_ENDED: {
                    code: 3042,
                    message: "Camera track has ended. Please make sure your camera is turned on or try restarting it."
                  },
                  ERROR_RN_MIC_TRACK_ENDED: {
                    code: 3043,
                    message: "Microphone track has ended or the microphone is disconnected. Please check your microphone connection and try again."
                  }
                };
              }
            ),
            /***/
            7165: (
              /***/
              function(module2, exports2, __webpack_require__2) {
                ;
                (function(root, factory, undef) {
                  if (true) {
                    module2.exports = exports2 = factory(__webpack_require__2(9021), __webpack_require__2(9506));
                  } else {
                  }
                })(this, function(CryptoJS) {
                  CryptoJS.lib.Cipher || function(undefined2) {
                    var C = CryptoJS;
                    var C_lib = C.lib;
                    var Base = C_lib.Base;
                    var WordArray = C_lib.WordArray;
                    var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm;
                    var C_enc = C.enc;
                    var Utf8 = C_enc.Utf8;
                    var Base64 = C_enc.Base64;
                    var C_algo = C.algo;
                    var EvpKDF = C_algo.EvpKDF;
                    var Cipher = C_lib.Cipher = BufferedBlockAlgorithm.extend({
                      /**
                       * Configuration options.
                       *
                       * @property {WordArray} iv The IV to use for this operation.
                       */
                      cfg: Base.extend(),
                      /**
                       * Creates this cipher in encryption mode.
                       *
                       * @param {WordArray} key The key.
                       * @param {Object} cfg (Optional) The configuration options to use for this operation.
                       *
                       * @return {Cipher} A cipher instance.
                       *
                       * @static
                       *
                       * @example
                       *
                       *     var cipher = CryptoJS.algo.AES.createEncryptor(keyWordArray, { iv: ivWordArray });
                       */
                      createEncryptor: function(key, cfg) {
                        return this.create(this._ENC_XFORM_MODE, key, cfg);
                      },
                      /**
                       * Creates this cipher in decryption mode.
                       *
                       * @param {WordArray} key The key.
                       * @param {Object} cfg (Optional) The configuration options to use for this operation.
                       *
                       * @return {Cipher} A cipher instance.
                       *
                       * @static
                       *
                       * @example
                       *
                       *     var cipher = CryptoJS.algo.AES.createDecryptor(keyWordArray, { iv: ivWordArray });
                       */
                      createDecryptor: function(key, cfg) {
                        return this.create(this._DEC_XFORM_MODE, key, cfg);
                      },
                      /**
                       * Initializes a newly created cipher.
                       *
                       * @param {number} xformMode Either the encryption or decryption transormation mode constant.
                       * @param {WordArray} key The key.
                       * @param {Object} cfg (Optional) The configuration options to use for this operation.
                       *
                       * @example
                       *
                       *     var cipher = CryptoJS.algo.AES.create(CryptoJS.algo.AES._ENC_XFORM_MODE, keyWordArray, { iv: ivWordArray });
                       */
                      init: function(xformMode, key, cfg) {
                        this.cfg = this.cfg.extend(cfg);
                        this._xformMode = xformMode;
                        this._key = key;
                        this.reset();
                      },
                      /**
                       * Resets this cipher to its initial state.
                       *
                       * @example
                       *
                       *     cipher.reset();
                       */
                      reset: function() {
                        BufferedBlockAlgorithm.reset.call(this);
                        this._doReset();
                      },
                      /**
                       * Adds data to be encrypted or decrypted.
                       *
                       * @param {WordArray|string} dataUpdate The data to encrypt or decrypt.
                       *
                       * @return {WordArray} The data after processing.
                       *
                       * @example
                       *
                       *     var encrypted = cipher.process('data');
                       *     var encrypted = cipher.process(wordArray);
                       */
                      process: function(dataUpdate) {
                        this._append(dataUpdate);
                        return this._process();
                      },
                      /**
                       * Finalizes the encryption or decryption process.
                       * Note that the finalize operation is effectively a destructive, read-once operation.
                       *
                       * @param {WordArray|string} dataUpdate The final data to encrypt or decrypt.
                       *
                       * @return {WordArray} The data after final processing.
                       *
                       * @example
                       *
                       *     var encrypted = cipher.finalize();
                       *     var encrypted = cipher.finalize('data');
                       *     var encrypted = cipher.finalize(wordArray);
                       */
                      finalize: function(dataUpdate) {
                        if (dataUpdate) {
                          this._append(dataUpdate);
                        }
                        var finalProcessedData = this._doFinalize();
                        return finalProcessedData;
                      },
                      keySize: 128 / 32,
                      ivSize: 128 / 32,
                      _ENC_XFORM_MODE: 1,
                      _DEC_XFORM_MODE: 2,
                      /**
                       * Creates shortcut functions to a cipher's object interface.
                       *
                       * @param {Cipher} cipher The cipher to create a helper for.
                       *
                       * @return {Object} An object with encrypt and decrypt shortcut functions.
                       *
                       * @static
                       *
                       * @example
                       *
                       *     var AES = CryptoJS.lib.Cipher._createHelper(CryptoJS.algo.AES);
                       */
                      _createHelper: /* @__PURE__ */ function() {
                        function selectCipherStrategy(key) {
                          if (typeof key == "string") {
                            return PasswordBasedCipher;
                          } else {
                            return SerializableCipher;
                          }
                        }
                        return function(cipher) {
                          return {
                            encrypt: function(message, key, cfg) {
                              return selectCipherStrategy(key).encrypt(cipher, message, key, cfg);
                            },
                            decrypt: function(ciphertext, key, cfg) {
                              return selectCipherStrategy(key).decrypt(cipher, ciphertext, key, cfg);
                            }
                          };
                        };
                      }()
                    });
                    var StreamCipher = C_lib.StreamCipher = Cipher.extend({
                      _doFinalize: function() {
                        var finalProcessedBlocks = this._process(true);
                        return finalProcessedBlocks;
                      },
                      blockSize: 1
                    });
                    var C_mode = C.mode = {};
                    var BlockCipherMode = C_lib.BlockCipherMode = Base.extend({
                      /**
                       * Creates this mode for encryption.
                       *
                       * @param {Cipher} cipher A block cipher instance.
                       * @param {Array} iv The IV words.
                       *
                       * @static
                       *
                       * @example
                       *
                       *     var mode = CryptoJS.mode.CBC.createEncryptor(cipher, iv.words);
                       */
                      createEncryptor: function(cipher, iv) {
                        return this.Encryptor.create(cipher, iv);
                      },
                      /**
                       * Creates this mode for decryption.
                       *
                       * @param {Cipher} cipher A block cipher instance.
                       * @param {Array} iv The IV words.
                       *
                       * @static
                       *
                       * @example
                       *
                       *     var mode = CryptoJS.mode.CBC.createDecryptor(cipher, iv.words);
                       */
                      createDecryptor: function(cipher, iv) {
                        return this.Decryptor.create(cipher, iv);
                      },
                      /**
                       * Initializes a newly created mode.
                       *
                       * @param {Cipher} cipher A block cipher instance.
                       * @param {Array} iv The IV words.
                       *
                       * @example
                       *
                       *     var mode = CryptoJS.mode.CBC.Encryptor.create(cipher, iv.words);
                       */
                      init: function(cipher, iv) {
                        this._cipher = cipher;
                        this._iv = iv;
                      }
                    });
                    var CBC = C_mode.CBC = function() {
                      var CBC2 = BlockCipherMode.extend();
                      CBC2.Encryptor = CBC2.extend({
                        /**
                         * Processes the data block at offset.
                         *
                         * @param {Array} words The data words to operate on.
                         * @param {number} offset The offset where the block starts.
                         *
                         * @example
                         *
                         *     mode.processBlock(data.words, offset);
                         */
                        processBlock: function(words, offset) {
                          var cipher = this._cipher;
                          var blockSize = cipher.blockSize;
                          xorBlock.call(this, words, offset, blockSize);
                          cipher.encryptBlock(words, offset);
                          this._prevBlock = words.slice(offset, offset + blockSize);
                        }
                      });
                      CBC2.Decryptor = CBC2.extend({
                        /**
                         * Processes the data block at offset.
                         *
                         * @param {Array} words The data words to operate on.
                         * @param {number} offset The offset where the block starts.
                         *
                         * @example
                         *
                         *     mode.processBlock(data.words, offset);
                         */
                        processBlock: function(words, offset) {
                          var cipher = this._cipher;
                          var blockSize = cipher.blockSize;
                          var thisBlock = words.slice(offset, offset + blockSize);
                          cipher.decryptBlock(words, offset);
                          xorBlock.call(this, words, offset, blockSize);
                          this._prevBlock = thisBlock;
                        }
                      });
                      function xorBlock(words, offset, blockSize) {
                        var block;
                        var iv = this._iv;
                        if (iv) {
                          block = iv;
                          this._iv = undefined2;
                        } else {
                          block = this._prevBlock;
                        }
                        for (var i = 0; i < blockSize; i++) {
                          words[offset + i] ^= block[i];
                        }
                      }
                      return CBC2;
                    }();
                    var C_pad = C.pad = {};
                    var Pkcs7 = C_pad.Pkcs7 = {
                      /**
                       * Pads data using the algorithm defined in PKCS #5/7.
                       *
                       * @param {WordArray} data The data to pad.
                       * @param {number} blockSize The multiple that the data should be padded to.
                       *
                       * @static
                       *
                       * @example
                       *
                       *     CryptoJS.pad.Pkcs7.pad(wordArray, 4);
                       */
                      pad: function(data, blockSize) {
                        var blockSizeBytes = blockSize * 4;
                        var nPaddingBytes = blockSizeBytes - data.sigBytes % blockSizeBytes;
                        var paddingWord = nPaddingBytes << 24 | nPaddingBytes << 16 | nPaddingBytes << 8 | nPaddingBytes;
                        var paddingWords = [];
                        for (var i = 0; i < nPaddingBytes; i += 4) {
                          paddingWords.push(paddingWord);
                        }
                        var padding = WordArray.create(paddingWords, nPaddingBytes);
                        data.concat(padding);
                      },
                      /**
                       * Unpads data that had been padded using the algorithm defined in PKCS #5/7.
                       *
                       * @param {WordArray} data The data to unpad.
                       *
                       * @static
                       *
                       * @example
                       *
                       *     CryptoJS.pad.Pkcs7.unpad(wordArray);
                       */
                      unpad: function(data) {
                        var nPaddingBytes = data.words[data.sigBytes - 1 >>> 2] & 255;
                        data.sigBytes -= nPaddingBytes;
                      }
                    };
                    var BlockCipher = C_lib.BlockCipher = Cipher.extend({
                      /**
                       * Configuration options.
                       *
                       * @property {Mode} mode The block mode to use. Default: CBC
                       * @property {Padding} padding The padding strategy to use. Default: Pkcs7
                       */
                      cfg: Cipher.cfg.extend({
                        mode: CBC,
                        padding: Pkcs7
                      }),
                      reset: function() {
                        var modeCreator;
                        Cipher.reset.call(this);
                        var cfg = this.cfg;
                        var iv = cfg.iv;
                        var mode = cfg.mode;
                        if (this._xformMode == this._ENC_XFORM_MODE) {
                          modeCreator = mode.createEncryptor;
                        } else {
                          modeCreator = mode.createDecryptor;
                          this._minBufferSize = 1;
                        }
                        if (this._mode && this._mode.__creator == modeCreator) {
                          this._mode.init(this, iv && iv.words);
                        } else {
                          this._mode = modeCreator.call(mode, this, iv && iv.words);
                          this._mode.__creator = modeCreator;
                        }
                      },
                      _doProcessBlock: function(words, offset) {
                        this._mode.processBlock(words, offset);
                      },
                      _doFinalize: function() {
                        var finalProcessedBlocks;
                        var padding = this.cfg.padding;
                        if (this._xformMode == this._ENC_XFORM_MODE) {
                          padding.pad(this._data, this.blockSize);
                          finalProcessedBlocks = this._process(true);
                        } else {
                          finalProcessedBlocks = this._process(true);
                          padding.unpad(finalProcessedBlocks);
                        }
                        return finalProcessedBlocks;
                      },
                      blockSize: 128 / 32
                    });
                    var CipherParams = C_lib.CipherParams = Base.extend({
                      /**
                       * Initializes a newly created cipher params object.
                       *
                       * @param {Object} cipherParams An object with any of the possible cipher parameters.
                       *
                       * @example
                       *
                       *     var cipherParams = CryptoJS.lib.CipherParams.create({
                       *         ciphertext: ciphertextWordArray,
                       *         key: keyWordArray,
                       *         iv: ivWordArray,
                       *         salt: saltWordArray,
                       *         algorithm: CryptoJS.algo.AES,
                       *         mode: CryptoJS.mode.CBC,
                       *         padding: CryptoJS.pad.PKCS7,
                       *         blockSize: 4,
                       *         formatter: CryptoJS.format.OpenSSL
                       *     });
                       */
                      init: function(cipherParams) {
                        this.mixIn(cipherParams);
                      },
                      /**
                       * Converts this cipher params object to a string.
                       *
                       * @param {Format} formatter (Optional) The formatting strategy to use.
                       *
                       * @return {string} The stringified cipher params.
                       *
                       * @throws Error If neither the formatter nor the default formatter is set.
                       *
                       * @example
                       *
                       *     var string = cipherParams + '';
                       *     var string = cipherParams.toString();
                       *     var string = cipherParams.toString(CryptoJS.format.OpenSSL);
                       */
                      toString: function(formatter) {
                        return (formatter || this.formatter).stringify(this);
                      }
                    });
                    var C_format = C.format = {};
                    var OpenSSLFormatter = C_format.OpenSSL = {
                      /**
                       * Converts a cipher params object to an OpenSSL-compatible string.
                       *
                       * @param {CipherParams} cipherParams The cipher params object.
                       *
                       * @return {string} The OpenSSL-compatible string.
                       *
                       * @static
                       *
                       * @example
                       *
                       *     var openSSLString = CryptoJS.format.OpenSSL.stringify(cipherParams);
                       */
                      stringify: function(cipherParams) {
                        var wordArray;
                        var ciphertext = cipherParams.ciphertext;
                        var salt = cipherParams.salt;
                        if (salt) {
                          wordArray = WordArray.create([1398893684, 1701076831]).concat(salt).concat(ciphertext);
                        } else {
                          wordArray = ciphertext;
                        }
                        return wordArray.toString(Base64);
                      },
                      /**
                       * Converts an OpenSSL-compatible string to a cipher params object.
                       *
                       * @param {string} openSSLStr The OpenSSL-compatible string.
                       *
                       * @return {CipherParams} The cipher params object.
                       *
                       * @static
                       *
                       * @example
                       *
                       *     var cipherParams = CryptoJS.format.OpenSSL.parse(openSSLString);
                       */
                      parse: function(openSSLStr) {
                        var salt;
                        var ciphertext = Base64.parse(openSSLStr);
                        var ciphertextWords = ciphertext.words;
                        if (ciphertextWords[0] == 1398893684 && ciphertextWords[1] == 1701076831) {
                          salt = WordArray.create(ciphertextWords.slice(2, 4));
                          ciphertextWords.splice(0, 4);
                          ciphertext.sigBytes -= 16;
                        }
                        return CipherParams.create({ ciphertext, salt });
                      }
                    };
                    var SerializableCipher = C_lib.SerializableCipher = Base.extend({
                      /**
                       * Configuration options.
                       *
                       * @property {Formatter} format The formatting strategy to convert cipher param objects to and from a string. Default: OpenSSL
                       */
                      cfg: Base.extend({
                        format: OpenSSLFormatter
                      }),
                      /**
                       * Encrypts a message.
                       *
                       * @param {Cipher} cipher The cipher algorithm to use.
                       * @param {WordArray|string} message The message to encrypt.
                       * @param {WordArray} key The key.
                       * @param {Object} cfg (Optional) The configuration options to use for this operation.
                       *
                       * @return {CipherParams} A cipher params object.
                       *
                       * @static
                       *
                       * @example
                       *
                       *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key);
                       *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key, { iv: iv });
                       *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key, { iv: iv, format: CryptoJS.format.OpenSSL });
                       */
                      encrypt: function(cipher, message, key, cfg) {
                        cfg = this.cfg.extend(cfg);
                        var encryptor = cipher.createEncryptor(key, cfg);
                        var ciphertext = encryptor.finalize(message);
                        var cipherCfg = encryptor.cfg;
                        return CipherParams.create({
                          ciphertext,
                          key,
                          iv: cipherCfg.iv,
                          algorithm: cipher,
                          mode: cipherCfg.mode,
                          padding: cipherCfg.padding,
                          blockSize: cipher.blockSize,
                          formatter: cfg.format
                        });
                      },
                      /**
                       * Decrypts serialized ciphertext.
                       *
                       * @param {Cipher} cipher The cipher algorithm to use.
                       * @param {CipherParams|string} ciphertext The ciphertext to decrypt.
                       * @param {WordArray} key The key.
                       * @param {Object} cfg (Optional) The configuration options to use for this operation.
                       *
                       * @return {WordArray} The plaintext.
                       *
                       * @static
                       *
                       * @example
                       *
                       *     var plaintext = CryptoJS.lib.SerializableCipher.decrypt(CryptoJS.algo.AES, formattedCiphertext, key, { iv: iv, format: CryptoJS.format.OpenSSL });
                       *     var plaintext = CryptoJS.lib.SerializableCipher.decrypt(CryptoJS.algo.AES, ciphertextParams, key, { iv: iv, format: CryptoJS.format.OpenSSL });
                       */
                      decrypt: function(cipher, ciphertext, key, cfg) {
                        cfg = this.cfg.extend(cfg);
                        ciphertext = this._parse(ciphertext, cfg.format);
                        var plaintext = cipher.createDecryptor(key, cfg).finalize(ciphertext.ciphertext);
                        return plaintext;
                      },
                      /**
                       * Converts serialized ciphertext to CipherParams,
                       * else assumed CipherParams already and returns ciphertext unchanged.
                       *
                       * @param {CipherParams|string} ciphertext The ciphertext.
                       * @param {Formatter} format The formatting strategy to use to parse serialized ciphertext.
                       *
                       * @return {CipherParams} The unserialized ciphertext.
                       *
                       * @static
                       *
                       * @example
                       *
                       *     var ciphertextParams = CryptoJS.lib.SerializableCipher._parse(ciphertextStringOrParams, format);
                       */
                      _parse: function(ciphertext, format) {
                        if (typeof ciphertext == "string") {
                          return format.parse(ciphertext, this);
                        } else {
                          return ciphertext;
                        }
                      }
                    });
                    var C_kdf = C.kdf = {};
                    var OpenSSLKdf = C_kdf.OpenSSL = {
                      /**
                       * Derives a key and IV from a password.
                       *
                       * @param {string} password The password to derive from.
                       * @param {number} keySize The size in words of the key to generate.
                       * @param {number} ivSize The size in words of the IV to generate.
                       * @param {WordArray|string} salt (Optional) A 64-bit salt to use. If omitted, a salt will be generated randomly.
                       *
                       * @return {CipherParams} A cipher params object with the key, IV, and salt.
                       *
                       * @static
                       *
                       * @example
                       *
                       *     var derivedParams = CryptoJS.kdf.OpenSSL.execute('Password', 256/32, 128/32);
                       *     var derivedParams = CryptoJS.kdf.OpenSSL.execute('Password', 256/32, 128/32, 'saltsalt');
                       */
                      execute: function(password, keySize, ivSize, salt, hasher) {
                        if (!salt) {
                          salt = WordArray.random(64 / 8);
                        }
                        if (!hasher) {
                          var key = EvpKDF.create({ keySize: keySize + ivSize }).compute(password, salt);
                        } else {
                          var key = EvpKDF.create({ keySize: keySize + ivSize, hasher }).compute(password, salt);
                        }
                        var iv = WordArray.create(key.words.slice(keySize), ivSize * 4);
                        key.sigBytes = keySize * 4;
                        return CipherParams.create({ key, iv, salt });
                      }
                    };
                    var PasswordBasedCipher = C_lib.PasswordBasedCipher = SerializableCipher.extend({
                      /**
                       * Configuration options.
                       *
                       * @property {KDF} kdf The key derivation function to use to generate a key and IV from a password. Default: OpenSSL
                       */
                      cfg: SerializableCipher.cfg.extend({
                        kdf: OpenSSLKdf
                      }),
                      /**
                       * Encrypts a message using a password.
                       *
                       * @param {Cipher} cipher The cipher algorithm to use.
                       * @param {WordArray|string} message The message to encrypt.
                       * @param {string} password The password.
                       * @param {Object} cfg (Optional) The configuration options to use for this operation.
                       *
                       * @return {CipherParams} A cipher params object.
                       *
                       * @static
                       *
                       * @example
                       *
                       *     var ciphertextParams = CryptoJS.lib.PasswordBasedCipher.encrypt(CryptoJS.algo.AES, message, 'password');
                       *     var ciphertextParams = CryptoJS.lib.PasswordBasedCipher.encrypt(CryptoJS.algo.AES, message, 'password', { format: CryptoJS.format.OpenSSL });
                       */
                      encrypt: function(cipher, message, password, cfg) {
                        cfg = this.cfg.extend(cfg);
                        var derivedParams = cfg.kdf.execute(password, cipher.keySize, cipher.ivSize, cfg.salt, cfg.hasher);
                        cfg.iv = derivedParams.iv;
                        var ciphertext = SerializableCipher.encrypt.call(this, cipher, message, derivedParams.key, cfg);
                        ciphertext.mixIn(derivedParams);
                        return ciphertext;
                      },
                      /**
                       * Decrypts serialized ciphertext using a password.
                       *
                       * @param {Cipher} cipher The cipher algorithm to use.
                       * @param {CipherParams|string} ciphertext The ciphertext to decrypt.
                       * @param {string} password The password.
                       * @param {Object} cfg (Optional) The configuration options to use for this operation.
                       *
                       * @return {WordArray} The plaintext.
                       *
                       * @static
                       *
                       * @example
                       *
                       *     var plaintext = CryptoJS.lib.PasswordBasedCipher.decrypt(CryptoJS.algo.AES, formattedCiphertext, 'password', { format: CryptoJS.format.OpenSSL });
                       *     var plaintext = CryptoJS.lib.PasswordBasedCipher.decrypt(CryptoJS.algo.AES, ciphertextParams, 'password', { format: CryptoJS.format.OpenSSL });
                       */
                      decrypt: function(cipher, ciphertext, password, cfg) {
                        cfg = this.cfg.extend(cfg);
                        ciphertext = this._parse(ciphertext, cfg.format);
                        var derivedParams = cfg.kdf.execute(password, cipher.keySize, cipher.ivSize, ciphertext.salt, cfg.hasher);
                        cfg.iv = derivedParams.iv;
                        var plaintext = SerializableCipher.decrypt.call(this, cipher, ciphertext, derivedParams.key, cfg);
                        return plaintext;
                      }
                    });
                  }();
                });
              }
            ),
            /***/
            7193: (
              /***/
              function(module2, exports2, __webpack_require__2) {
                ;
                (function(root, factory, undef) {
                  if (true) {
                    module2.exports = exports2 = factory(__webpack_require__2(9021), __webpack_require__2(754), __webpack_require__2(4636), __webpack_require__2(9506), __webpack_require__2(7165));
                  } else {
                  }
                })(this, function(CryptoJS) {
                  (function() {
                    var C = CryptoJS;
                    var C_lib = C.lib;
                    var StreamCipher = C_lib.StreamCipher;
                    var C_algo = C.algo;
                    var RC4 = C_algo.RC4 = StreamCipher.extend({
                      _doReset: function() {
                        var key = this._key;
                        var keyWords = key.words;
                        var keySigBytes = key.sigBytes;
                        var S = this._S = [];
                        for (var i = 0; i < 256; i++) {
                          S[i] = i;
                        }
                        for (var i = 0, j = 0; i < 256; i++) {
                          var keyByteIndex = i % keySigBytes;
                          var keyByte = keyWords[keyByteIndex >>> 2] >>> 24 - keyByteIndex % 4 * 8 & 255;
                          j = (j + S[i] + keyByte) % 256;
                          var t = S[i];
                          S[i] = S[j];
                          S[j] = t;
                        }
                        this._i = this._j = 0;
                      },
                      _doProcessBlock: function(M, offset) {
                        M[offset] ^= generateKeystreamWord.call(this);
                      },
                      keySize: 256 / 32,
                      ivSize: 0
                    });
                    function generateKeystreamWord() {
                      var S = this._S;
                      var i = this._i;
                      var j = this._j;
                      var keystreamWord = 0;
                      for (var n = 0; n < 4; n++) {
                        i = (i + 1) % 256;
                        j = (j + S[i]) % 256;
                        var t = S[i];
                        S[i] = S[j];
                        S[j] = t;
                        keystreamWord |= S[(S[i] + S[j]) % 256] << 24 - n * 8;
                      }
                      this._i = i;
                      this._j = j;
                      return keystreamWord;
                    }
                    C.RC4 = StreamCipher._createHelper(RC4);
                    var RC4Drop = C_algo.RC4Drop = RC4.extend({
                      /**
                       * Configuration options.
                       *
                       * @property {number} drop The number of keystream words to drop. Default 192
                       */
                      cfg: RC4.cfg.extend({
                        drop: 192
                      }),
                      _doReset: function() {
                        RC4._doReset.call(this);
                        for (var i = this.cfg.drop; i > 0; i--) {
                          generateKeystreamWord.call(this);
                        }
                      }
                    });
                    C.RC4Drop = StreamCipher._createHelper(RC4Drop);
                  })();
                  return CryptoJS.RC4;
                });
              }
            ),
            /***/
            7363: (
              /***/
              (__unused_webpack_module, exports2, __webpack_require__2) => {
                var parser = __webpack_require__2(5020);
                var writer = __webpack_require__2(3804);
                var grammar = __webpack_require__2(5602);
                exports2.grammar = grammar;
                exports2.write = writer;
                exports2.parse = parser.parse;
                exports2.parseParams = parser.parseParams;
                exports2.parseFmtpConfig = parser.parseFmtpConfig;
                exports2.parsePayloads = parser.parsePayloads;
                exports2.parseRemoteCandidates = parser.parseRemoteCandidates;
                exports2.parseImageAttributes = parser.parseImageAttributes;
                exports2.parseSimulcastStreamList = parser.parseSimulcastStreamList;
              }
            ),
            /***/
            7504: (
              /***/
              (__unused_webpack_module, exports2, __webpack_require__2) => {
                "use strict";
                Object.defineProperty(exports2, "__esModule", { value: true });
                exports2.DataProducer = void 0;
                const Logger_1 = __webpack_require__2(2994);
                const enhancedEvents_1 = __webpack_require__2(3953);
                const errors_1 = __webpack_require__2(4893);
                const logger = new Logger_1.Logger("DataProducer");
                class DataProducer extends enhancedEvents_1.EnhancedEventEmitter {
                  constructor({ id, dataChannel, sctpStreamParameters, appData }) {
                    super();
                    // Id.
                    __publicField(this, "_id");
                    // The underlying RTCDataChannel instance.
                    __publicField(this, "_dataChannel");
                    // Closed flag.
                    __publicField(this, "_closed", false);
                    // SCTP stream parameters.
                    __publicField(this, "_sctpStreamParameters");
                    // App custom data.
                    __publicField(this, "_appData");
                    // Observer instance.
                    __publicField(this, "_observer", new enhancedEvents_1.EnhancedEventEmitter());
                    logger.debug("constructor()");
                    this._id = id;
                    this._dataChannel = dataChannel;
                    this._sctpStreamParameters = sctpStreamParameters;
                    this._appData = appData ?? {};
                    this.handleDataChannel();
                  }
                  /**
                   * DataProducer id.
                   */
                  get id() {
                    return this._id;
                  }
                  /**
                   * Whether the DataProducer is closed.
                   */
                  get closed() {
                    return this._closed;
                  }
                  /**
                   * SCTP stream parameters.
                   */
                  get sctpStreamParameters() {
                    return this._sctpStreamParameters;
                  }
                  /**
                   * DataChannel readyState.
                   */
                  get readyState() {
                    return this._dataChannel.readyState;
                  }
                  /**
                   * DataChannel label.
                   */
                  get label() {
                    return this._dataChannel.label;
                  }
                  /**
                   * DataChannel protocol.
                   */
                  get protocol() {
                    return this._dataChannel.protocol;
                  }
                  /**
                   * DataChannel bufferedAmount.
                   */
                  get bufferedAmount() {
                    return this._dataChannel.bufferedAmount;
                  }
                  /**
                   * DataChannel bufferedAmountLowThreshold.
                   */
                  get bufferedAmountLowThreshold() {
                    return this._dataChannel.bufferedAmountLowThreshold;
                  }
                  /**
                   * Set DataChannel bufferedAmountLowThreshold.
                   */
                  set bufferedAmountLowThreshold(bufferedAmountLowThreshold) {
                    this._dataChannel.bufferedAmountLowThreshold = bufferedAmountLowThreshold;
                  }
                  /**
                   * App custom data.
                   */
                  get appData() {
                    return this._appData;
                  }
                  /**
                   * App custom data setter.
                   */
                  set appData(appData) {
                    this._appData = appData;
                  }
                  get observer() {
                    return this._observer;
                  }
                  /**
                   * Closes the DataProducer.
                   */
                  close() {
                    if (this._closed) {
                      return;
                    }
                    logger.debug("close()");
                    this._closed = true;
                    this._dataChannel.close();
                    this.emit("@close");
                    this._observer.safeEmit("close");
                    super.close();
                    this._observer.close();
                  }
                  /**
                   * Transport was closed.
                   */
                  transportClosed() {
                    if (this._closed) {
                      return;
                    }
                    logger.debug("transportClosed()");
                    this._closed = true;
                    this._dataChannel.close();
                    this.safeEmit("transportclose");
                    this._observer.safeEmit("close");
                  }
                  /**
                   * Send a message.
                   *
                   * @param {String|Blob|ArrayBuffer|ArrayBufferView} data.
                   */
                  // eslint-disable-next-line @typescript-eslint/no-explicit-any
                  send(data) {
                    logger.debug("send()");
                    if (this._closed) {
                      throw new errors_1.InvalidStateError("closed");
                    }
                    this._dataChannel.send(data);
                  }
                  handleDataChannel() {
                    this._dataChannel.addEventListener("open", () => {
                      if (this._closed) {
                        return;
                      }
                      logger.debug('DataChannel "open" event');
                      this.safeEmit("open");
                    });
                    this._dataChannel.addEventListener("error", (event) => {
                      var _a, _b;
                      if (this._closed) {
                        return;
                      }
                      const error = event.error ?? new Error("unknown DataChannel error");
                      if (((_a = event.error) == null ? void 0 : _a.errorDetail) === "sctp-failure") {
                        logger.error("DataChannel SCTP error [sctpCauseCode:%s]: %s", (_b = event.error) == null ? void 0 : _b.sctpCauseCode, event.error.message);
                      } else {
                        logger.error('DataChannel "error" event: %o', error);
                      }
                      this.safeEmit("error", error);
                    });
                    this._dataChannel.addEventListener("close", () => {
                      if (this._closed) {
                        return;
                      }
                      logger.warn('DataChannel "close" event');
                      this._closed = true;
                      this.emit("@close");
                      this.safeEmit("close");
                      this._observer.safeEmit("close");
                    });
                    this._dataChannel.addEventListener("message", () => {
                      if (this._closed) {
                        return;
                      }
                      logger.warn('DataChannel "message" event in a DataProducer, message discarded');
                    });
                    this._dataChannel.addEventListener("bufferedamountlow", () => {
                      if (this._closed) {
                        return;
                      }
                      this.safeEmit("bufferedamountlow");
                    });
                  }
                }
                exports2.DataProducer = DataProducer;
              }
            ),
            /***/
            7628: (
              /***/
              function(module2, exports2, __webpack_require__2) {
                ;
                (function(root, factory, undef) {
                  if (true) {
                    module2.exports = exports2 = factory(__webpack_require__2(9021), __webpack_require__2(754), __webpack_require__2(4636), __webpack_require__2(9506), __webpack_require__2(7165));
                  } else {
                  }
                })(this, function(CryptoJS) {
                  (function() {
                    var C = CryptoJS;
                    var C_lib = C.lib;
                    var WordArray = C_lib.WordArray;
                    var BlockCipher = C_lib.BlockCipher;
                    var C_algo = C.algo;
                    var PC1 = [
                      57,
                      49,
                      41,
                      33,
                      25,
                      17,
                      9,
                      1,
                      58,
                      50,
                      42,
                      34,
                      26,
                      18,
                      10,
                      2,
                      59,
                      51,
                      43,
                      35,
                      27,
                      19,
                      11,
                      3,
                      60,
                      52,
                      44,
                      36,
                      63,
                      55,
                      47,
                      39,
                      31,
                      23,
                      15,
                      7,
                      62,
                      54,
                      46,
                      38,
                      30,
                      22,
                      14,
                      6,
                      61,
                      53,
                      45,
                      37,
                      29,
                      21,
                      13,
                      5,
                      28,
                      20,
                      12,
                      4
                    ];
                    var PC2 = [
                      14,
                      17,
                      11,
                      24,
                      1,
                      5,
                      3,
                      28,
                      15,
                      6,
                      21,
                      10,
                      23,
                      19,
                      12,
                      4,
                      26,
                      8,
                      16,
                      7,
                      27,
                      20,
                      13,
                      2,
                      41,
                      52,
                      31,
                      37,
                      47,
                      55,
                      30,
                      40,
                      51,
                      45,
                      33,
                      48,
                      44,
                      49,
                      39,
                      56,
                      34,
                      53,
                      46,
                      42,
                      50,
                      36,
                      29,
                      32
                    ];
                    var BIT_SHIFTS = [1, 2, 4, 6, 8, 10, 12, 14, 15, 17, 19, 21, 23, 25, 27, 28];
                    var SBOX_P = [
                      {
                        0: 8421888,
                        268435456: 32768,
                        536870912: 8421378,
                        805306368: 2,
                        1073741824: 512,
                        1342177280: 8421890,
                        1610612736: 8389122,
                        1879048192: 8388608,
                        2147483648: 514,
                        2415919104: 8389120,
                        2684354560: 33280,
                        2952790016: 8421376,
                        3221225472: 32770,
                        3489660928: 8388610,
                        3758096384: 0,
                        4026531840: 33282,
                        134217728: 0,
                        402653184: 8421890,
                        671088640: 33282,
                        939524096: 32768,
                        1207959552: 8421888,
                        1476395008: 512,
                        1744830464: 8421378,
                        2013265920: 2,
                        2281701376: 8389120,
                        2550136832: 33280,
                        2818572288: 8421376,
                        3087007744: 8389122,
                        3355443200: 8388610,
                        3623878656: 32770,
                        3892314112: 514,
                        4160749568: 8388608,
                        1: 32768,
                        268435457: 2,
                        536870913: 8421888,
                        805306369: 8388608,
                        1073741825: 8421378,
                        1342177281: 33280,
                        1610612737: 512,
                        1879048193: 8389122,
                        2147483649: 8421890,
                        2415919105: 8421376,
                        2684354561: 8388610,
                        2952790017: 33282,
                        3221225473: 514,
                        3489660929: 8389120,
                        3758096385: 32770,
                        4026531841: 0,
                        134217729: 8421890,
                        402653185: 8421376,
                        671088641: 8388608,
                        939524097: 512,
                        1207959553: 32768,
                        1476395009: 8388610,
                        1744830465: 2,
                        2013265921: 33282,
                        2281701377: 32770,
                        2550136833: 8389122,
                        2818572289: 514,
                        3087007745: 8421888,
                        3355443201: 8389120,
                        3623878657: 0,
                        3892314113: 33280,
                        4160749569: 8421378
                      },
                      {
                        0: 1074282512,
                        16777216: 16384,
                        33554432: 524288,
                        50331648: 1074266128,
                        67108864: 1073741840,
                        83886080: 1074282496,
                        100663296: 1073758208,
                        117440512: 16,
                        134217728: 540672,
                        150994944: 1073758224,
                        167772160: 1073741824,
                        184549376: 540688,
                        201326592: 524304,
                        218103808: 0,
                        234881024: 16400,
                        251658240: 1074266112,
                        8388608: 1073758208,
                        25165824: 540688,
                        41943040: 16,
                        58720256: 1073758224,
                        75497472: 1074282512,
                        92274688: 1073741824,
                        109051904: 524288,
                        125829120: 1074266128,
                        142606336: 524304,
                        159383552: 0,
                        176160768: 16384,
                        192937984: 1074266112,
                        209715200: 1073741840,
                        226492416: 540672,
                        243269632: 1074282496,
                        260046848: 16400,
                        268435456: 0,
                        285212672: 1074266128,
                        301989888: 1073758224,
                        318767104: 1074282496,
                        335544320: 1074266112,
                        352321536: 16,
                        369098752: 540688,
                        385875968: 16384,
                        402653184: 16400,
                        419430400: 524288,
                        436207616: 524304,
                        452984832: 1073741840,
                        469762048: 540672,
                        486539264: 1073758208,
                        503316480: 1073741824,
                        520093696: 1074282512,
                        276824064: 540688,
                        293601280: 524288,
                        310378496: 1074266112,
                        327155712: 16384,
                        343932928: 1073758208,
                        360710144: 1074282512,
                        377487360: 16,
                        394264576: 1073741824,
                        411041792: 1074282496,
                        427819008: 1073741840,
                        444596224: 1073758224,
                        461373440: 524304,
                        478150656: 0,
                        494927872: 16400,
                        511705088: 1074266128,
                        528482304: 540672
                      },
                      {
                        0: 260,
                        1048576: 0,
                        2097152: 67109120,
                        3145728: 65796,
                        4194304: 65540,
                        5242880: 67108868,
                        6291456: 67174660,
                        7340032: 67174400,
                        8388608: 67108864,
                        9437184: 67174656,
                        10485760: 65792,
                        11534336: 67174404,
                        12582912: 67109124,
                        13631488: 65536,
                        14680064: 4,
                        15728640: 256,
                        524288: 67174656,
                        1572864: 67174404,
                        2621440: 0,
                        3670016: 67109120,
                        4718592: 67108868,
                        5767168: 65536,
                        6815744: 65540,
                        7864320: 260,
                        8912896: 4,
                        9961472: 256,
                        11010048: 67174400,
                        12058624: 65796,
                        13107200: 65792,
                        14155776: 67109124,
                        15204352: 67174660,
                        16252928: 67108864,
                        16777216: 67174656,
                        17825792: 65540,
                        18874368: 65536,
                        19922944: 67109120,
                        20971520: 256,
                        22020096: 67174660,
                        23068672: 67108868,
                        24117248: 0,
                        25165824: 67109124,
                        26214400: 67108864,
                        27262976: 4,
                        28311552: 65792,
                        29360128: 67174400,
                        30408704: 260,
                        31457280: 65796,
                        32505856: 67174404,
                        17301504: 67108864,
                        18350080: 260,
                        19398656: 67174656,
                        20447232: 0,
                        21495808: 65540,
                        22544384: 67109120,
                        23592960: 256,
                        24641536: 67174404,
                        25690112: 65536,
                        26738688: 67174660,
                        27787264: 65796,
                        28835840: 67108868,
                        29884416: 67109124,
                        30932992: 67174400,
                        31981568: 4,
                        33030144: 65792
                      },
                      {
                        0: 2151682048,
                        65536: 2147487808,
                        131072: 4198464,
                        196608: 2151677952,
                        262144: 0,
                        327680: 4198400,
                        393216: 2147483712,
                        458752: 4194368,
                        524288: 2147483648,
                        589824: 4194304,
                        655360: 64,
                        720896: 2147487744,
                        786432: 2151678016,
                        851968: 4160,
                        917504: 4096,
                        983040: 2151682112,
                        32768: 2147487808,
                        98304: 64,
                        163840: 2151678016,
                        229376: 2147487744,
                        294912: 4198400,
                        360448: 2151682112,
                        425984: 0,
                        491520: 2151677952,
                        557056: 4096,
                        622592: 2151682048,
                        688128: 4194304,
                        753664: 4160,
                        819200: 2147483648,
                        884736: 4194368,
                        950272: 4198464,
                        1015808: 2147483712,
                        1048576: 4194368,
                        1114112: 4198400,
                        1179648: 2147483712,
                        1245184: 0,
                        1310720: 4160,
                        1376256: 2151678016,
                        1441792: 2151682048,
                        1507328: 2147487808,
                        1572864: 2151682112,
                        1638400: 2147483648,
                        1703936: 2151677952,
                        1769472: 4198464,
                        1835008: 2147487744,
                        1900544: 4194304,
                        1966080: 64,
                        2031616: 4096,
                        1081344: 2151677952,
                        1146880: 2151682112,
                        1212416: 0,
                        1277952: 4198400,
                        1343488: 4194368,
                        1409024: 2147483648,
                        1474560: 2147487808,
                        1540096: 64,
                        1605632: 2147483712,
                        1671168: 4096,
                        1736704: 2147487744,
                        1802240: 2151678016,
                        1867776: 4160,
                        1933312: 2151682048,
                        1998848: 4194304,
                        2064384: 4198464
                      },
                      {
                        0: 128,
                        4096: 17039360,
                        8192: 262144,
                        12288: 536870912,
                        16384: 537133184,
                        20480: 16777344,
                        24576: 553648256,
                        28672: 262272,
                        32768: 16777216,
                        36864: 537133056,
                        40960: 536871040,
                        45056: 553910400,
                        49152: 553910272,
                        53248: 0,
                        57344: 17039488,
                        61440: 553648128,
                        2048: 17039488,
                        6144: 553648256,
                        10240: 128,
                        14336: 17039360,
                        18432: 262144,
                        22528: 537133184,
                        26624: 553910272,
                        30720: 536870912,
                        34816: 537133056,
                        38912: 0,
                        43008: 553910400,
                        47104: 16777344,
                        51200: 536871040,
                        55296: 553648128,
                        59392: 16777216,
                        63488: 262272,
                        65536: 262144,
                        69632: 128,
                        73728: 536870912,
                        77824: 553648256,
                        81920: 16777344,
                        86016: 553910272,
                        90112: 537133184,
                        94208: 16777216,
                        98304: 553910400,
                        102400: 553648128,
                        106496: 17039360,
                        110592: 537133056,
                        114688: 262272,
                        118784: 536871040,
                        122880: 0,
                        126976: 17039488,
                        67584: 553648256,
                        71680: 16777216,
                        75776: 17039360,
                        79872: 537133184,
                        83968: 536870912,
                        88064: 17039488,
                        92160: 128,
                        96256: 553910272,
                        100352: 262272,
                        104448: 553910400,
                        108544: 0,
                        112640: 553648128,
                        116736: 16777344,
                        120832: 262144,
                        124928: 537133056,
                        129024: 536871040
                      },
                      {
                        0: 268435464,
                        256: 8192,
                        512: 270532608,
                        768: 270540808,
                        1024: 268443648,
                        1280: 2097152,
                        1536: 2097160,
                        1792: 268435456,
                        2048: 0,
                        2304: 268443656,
                        2560: 2105344,
                        2816: 8,
                        3072: 270532616,
                        3328: 2105352,
                        3584: 8200,
                        3840: 270540800,
                        128: 270532608,
                        384: 270540808,
                        640: 8,
                        896: 2097152,
                        1152: 2105352,
                        1408: 268435464,
                        1664: 268443648,
                        1920: 8200,
                        2176: 2097160,
                        2432: 8192,
                        2688: 268443656,
                        2944: 270532616,
                        3200: 0,
                        3456: 270540800,
                        3712: 2105344,
                        3968: 268435456,
                        4096: 268443648,
                        4352: 270532616,
                        4608: 270540808,
                        4864: 8200,
                        5120: 2097152,
                        5376: 268435456,
                        5632: 268435464,
                        5888: 2105344,
                        6144: 2105352,
                        6400: 0,
                        6656: 8,
                        6912: 270532608,
                        7168: 8192,
                        7424: 268443656,
                        7680: 270540800,
                        7936: 2097160,
                        4224: 8,
                        4480: 2105344,
                        4736: 2097152,
                        4992: 268435464,
                        5248: 268443648,
                        5504: 8200,
                        5760: 270540808,
                        6016: 270532608,
                        6272: 270540800,
                        6528: 270532616,
                        6784: 8192,
                        7040: 2105352,
                        7296: 2097160,
                        7552: 0,
                        7808: 268435456,
                        8064: 268443656
                      },
                      {
                        0: 1048576,
                        16: 33555457,
                        32: 1024,
                        48: 1049601,
                        64: 34604033,
                        80: 0,
                        96: 1,
                        112: 34603009,
                        128: 33555456,
                        144: 1048577,
                        160: 33554433,
                        176: 34604032,
                        192: 34603008,
                        208: 1025,
                        224: 1049600,
                        240: 33554432,
                        8: 34603009,
                        24: 0,
                        40: 33555457,
                        56: 34604032,
                        72: 1048576,
                        88: 33554433,
                        104: 33554432,
                        120: 1025,
                        136: 1049601,
                        152: 33555456,
                        168: 34603008,
                        184: 1048577,
                        200: 1024,
                        216: 34604033,
                        232: 1,
                        248: 1049600,
                        256: 33554432,
                        272: 1048576,
                        288: 33555457,
                        304: 34603009,
                        320: 1048577,
                        336: 33555456,
                        352: 34604032,
                        368: 1049601,
                        384: 1025,
                        400: 34604033,
                        416: 1049600,
                        432: 1,
                        448: 0,
                        464: 34603008,
                        480: 33554433,
                        496: 1024,
                        264: 1049600,
                        280: 33555457,
                        296: 34603009,
                        312: 1,
                        328: 33554432,
                        344: 1048576,
                        360: 1025,
                        376: 34604032,
                        392: 33554433,
                        408: 34603008,
                        424: 0,
                        440: 34604033,
                        456: 1049601,
                        472: 1024,
                        488: 33555456,
                        504: 1048577
                      },
                      {
                        0: 134219808,
                        1: 131072,
                        2: 134217728,
                        3: 32,
                        4: 131104,
                        5: 134350880,
                        6: 134350848,
                        7: 2048,
                        8: 134348800,
                        9: 134219776,
                        10: 133120,
                        11: 134348832,
                        12: 2080,
                        13: 0,
                        14: 134217760,
                        15: 133152,
                        2147483648: 2048,
                        2147483649: 134350880,
                        2147483650: 134219808,
                        2147483651: 134217728,
                        2147483652: 134348800,
                        2147483653: 133120,
                        2147483654: 133152,
                        2147483655: 32,
                        2147483656: 134217760,
                        2147483657: 2080,
                        2147483658: 131104,
                        2147483659: 134350848,
                        2147483660: 0,
                        2147483661: 134348832,
                        2147483662: 134219776,
                        2147483663: 131072,
                        16: 133152,
                        17: 134350848,
                        18: 32,
                        19: 2048,
                        20: 134219776,
                        21: 134217760,
                        22: 134348832,
                        23: 131072,
                        24: 0,
                        25: 131104,
                        26: 134348800,
                        27: 134219808,
                        28: 134350880,
                        29: 133120,
                        30: 2080,
                        31: 134217728,
                        2147483664: 131072,
                        2147483665: 2048,
                        2147483666: 134348832,
                        2147483667: 133152,
                        2147483668: 32,
                        2147483669: 134348800,
                        2147483670: 134217728,
                        2147483671: 134219808,
                        2147483672: 134350880,
                        2147483673: 134217760,
                        2147483674: 134219776,
                        2147483675: 0,
                        2147483676: 133120,
                        2147483677: 2080,
                        2147483678: 131104,
                        2147483679: 134350848
                      }
                    ];
                    var SBOX_MASK = [
                      4160749569,
                      528482304,
                      33030144,
                      2064384,
                      129024,
                      8064,
                      504,
                      2147483679
                    ];
                    var DES = C_algo.DES = BlockCipher.extend({
                      _doReset: function() {
                        var key = this._key;
                        var keyWords = key.words;
                        var keyBits = [];
                        for (var i = 0; i < 56; i++) {
                          var keyBitPos = PC1[i] - 1;
                          keyBits[i] = keyWords[keyBitPos >>> 5] >>> 31 - keyBitPos % 32 & 1;
                        }
                        var subKeys = this._subKeys = [];
                        for (var nSubKey = 0; nSubKey < 16; nSubKey++) {
                          var subKey = subKeys[nSubKey] = [];
                          var bitShift = BIT_SHIFTS[nSubKey];
                          for (var i = 0; i < 24; i++) {
                            subKey[i / 6 | 0] |= keyBits[(PC2[i] - 1 + bitShift) % 28] << 31 - i % 6;
                            subKey[4 + (i / 6 | 0)] |= keyBits[28 + (PC2[i + 24] - 1 + bitShift) % 28] << 31 - i % 6;
                          }
                          subKey[0] = subKey[0] << 1 | subKey[0] >>> 31;
                          for (var i = 1; i < 7; i++) {
                            subKey[i] = subKey[i] >>> (i - 1) * 4 + 3;
                          }
                          subKey[7] = subKey[7] << 5 | subKey[7] >>> 27;
                        }
                        var invSubKeys = this._invSubKeys = [];
                        for (var i = 0; i < 16; i++) {
                          invSubKeys[i] = subKeys[15 - i];
                        }
                      },
                      encryptBlock: function(M, offset) {
                        this._doCryptBlock(M, offset, this._subKeys);
                      },
                      decryptBlock: function(M, offset) {
                        this._doCryptBlock(M, offset, this._invSubKeys);
                      },
                      _doCryptBlock: function(M, offset, subKeys) {
                        this._lBlock = M[offset];
                        this._rBlock = M[offset + 1];
                        exchangeLR.call(this, 4, 252645135);
                        exchangeLR.call(this, 16, 65535);
                        exchangeRL.call(this, 2, 858993459);
                        exchangeRL.call(this, 8, 16711935);
                        exchangeLR.call(this, 1, 1431655765);
                        for (var round = 0; round < 16; round++) {
                          var subKey = subKeys[round];
                          var lBlock = this._lBlock;
                          var rBlock = this._rBlock;
                          var f = 0;
                          for (var i = 0; i < 8; i++) {
                            f |= SBOX_P[i][((rBlock ^ subKey[i]) & SBOX_MASK[i]) >>> 0];
                          }
                          this._lBlock = rBlock;
                          this._rBlock = lBlock ^ f;
                        }
                        var t = this._lBlock;
                        this._lBlock = this._rBlock;
                        this._rBlock = t;
                        exchangeLR.call(this, 1, 1431655765);
                        exchangeRL.call(this, 8, 16711935);
                        exchangeRL.call(this, 2, 858993459);
                        exchangeLR.call(this, 16, 65535);
                        exchangeLR.call(this, 4, 252645135);
                        M[offset] = this._lBlock;
                        M[offset + 1] = this._rBlock;
                      },
                      keySize: 64 / 32,
                      ivSize: 64 / 32,
                      blockSize: 64 / 32
                    });
                    function exchangeLR(offset, mask) {
                      var t = (this._lBlock >>> offset ^ this._rBlock) & mask;
                      this._rBlock ^= t;
                      this._lBlock ^= t << offset;
                    }
                    function exchangeRL(offset, mask) {
                      var t = (this._rBlock >>> offset ^ this._lBlock) & mask;
                      this._lBlock ^= t;
                      this._rBlock ^= t << offset;
                    }
                    C.DES = BlockCipher._createHelper(DES);
                    var TripleDES = C_algo.TripleDES = BlockCipher.extend({
                      _doReset: function() {
                        var key = this._key;
                        var keyWords = key.words;
                        if (keyWords.length !== 2 && keyWords.length !== 4 && keyWords.length < 6) {
                          throw new Error("Invalid key length - 3DES requires the key length to be 64, 128, 192 or >192.");
                        }
                        var key1 = keyWords.slice(0, 2);
                        var key2 = keyWords.length < 4 ? keyWords.slice(0, 2) : keyWords.slice(2, 4);
                        var key3 = keyWords.length < 6 ? keyWords.slice(0, 2) : keyWords.slice(4, 6);
                        this._des1 = DES.createEncryptor(WordArray.create(key1));
                        this._des2 = DES.createEncryptor(WordArray.create(key2));
                        this._des3 = DES.createEncryptor(WordArray.create(key3));
                      },
                      encryptBlock: function(M, offset) {
                        this._des1.encryptBlock(M, offset);
                        this._des2.decryptBlock(M, offset);
                        this._des3.encryptBlock(M, offset);
                      },
                      decryptBlock: function(M, offset) {
                        this._des3.decryptBlock(M, offset);
                        this._des2.encryptBlock(M, offset);
                        this._des1.decryptBlock(M, offset);
                      },
                      keySize: 192 / 32,
                      ivSize: 64 / 32,
                      blockSize: 64 / 32
                    });
                    C.TripleDES = BlockCipher._createHelper(TripleDES);
                  })();
                  return CryptoJS.TripleDES;
                });
              }
            ),
            /***/
            7654: (
              /***/
              (module2, __unused_webpack_exports, __webpack_require__2) => {
                var FUNC_ERROR_TEXT = "Expected a function";
                var HASH_UNDEFINED = "__lodash_hash_undefined__";
                var funcTag = "[object Function]", genTag = "[object GeneratorFunction]";
                var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
                var reIsHostCtor = /^\[object .+?Constructor\]$/;
                var freeGlobal = typeof __webpack_require__2.g == "object" && __webpack_require__2.g && __webpack_require__2.g.Object === Object && __webpack_require__2.g;
                var freeSelf = typeof self == "object" && self && self.Object === Object && self;
                var root = freeGlobal || freeSelf || Function("return this")();
                function getValue(object, key) {
                  return object == null ? void 0 : object[key];
                }
                function isHostObject(value) {
                  var result = false;
                  if (value != null && typeof value.toString != "function") {
                    try {
                      result = !!(value + "");
                    } catch (e) {
                    }
                  }
                  return result;
                }
                var arrayProto = Array.prototype, funcProto = Function.prototype, objectProto = Object.prototype;
                var coreJsData = root["__core-js_shared__"];
                var maskSrcKey = function() {
                  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
                  return uid ? "Symbol(src)_1." + uid : "";
                }();
                var funcToString = funcProto.toString;
                var hasOwnProperty = objectProto.hasOwnProperty;
                var objectToString = objectProto.toString;
                var reIsNative = RegExp(
                  "^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
                );
                var splice = arrayProto.splice;
                var Map2 = getNative(root, "Map"), nativeCreate = getNative(Object, "create");
                function Hash(entries) {
                  var index = -1, length = entries ? entries.length : 0;
                  this.clear();
                  while (++index < length) {
                    var entry = entries[index];
                    this.set(entry[0], entry[1]);
                  }
                }
                function hashClear() {
                  this.__data__ = nativeCreate ? nativeCreate(null) : {};
                }
                function hashDelete(key) {
                  return this.has(key) && delete this.__data__[key];
                }
                function hashGet(key) {
                  var data = this.__data__;
                  if (nativeCreate) {
                    var result = data[key];
                    return result === HASH_UNDEFINED ? void 0 : result;
                  }
                  return hasOwnProperty.call(data, key) ? data[key] : void 0;
                }
                function hashHas(key) {
                  var data = this.__data__;
                  return nativeCreate ? data[key] !== void 0 : hasOwnProperty.call(data, key);
                }
                function hashSet(key, value) {
                  var data = this.__data__;
                  data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
                  return this;
                }
                Hash.prototype.clear = hashClear;
                Hash.prototype["delete"] = hashDelete;
                Hash.prototype.get = hashGet;
                Hash.prototype.has = hashHas;
                Hash.prototype.set = hashSet;
                function ListCache(entries) {
                  var index = -1, length = entries ? entries.length : 0;
                  this.clear();
                  while (++index < length) {
                    var entry = entries[index];
                    this.set(entry[0], entry[1]);
                  }
                }
                function listCacheClear() {
                  this.__data__ = [];
                }
                function listCacheDelete(key) {
                  var data = this.__data__, index = assocIndexOf(data, key);
                  if (index < 0) {
                    return false;
                  }
                  var lastIndex = data.length - 1;
                  if (index == lastIndex) {
                    data.pop();
                  } else {
                    splice.call(data, index, 1);
                  }
                  return true;
                }
                function listCacheGet(key) {
                  var data = this.__data__, index = assocIndexOf(data, key);
                  return index < 0 ? void 0 : data[index][1];
                }
                function listCacheHas(key) {
                  return assocIndexOf(this.__data__, key) > -1;
                }
                function listCacheSet(key, value) {
                  var data = this.__data__, index = assocIndexOf(data, key);
                  if (index < 0) {
                    data.push([key, value]);
                  } else {
                    data[index][1] = value;
                  }
                  return this;
                }
                ListCache.prototype.clear = listCacheClear;
                ListCache.prototype["delete"] = listCacheDelete;
                ListCache.prototype.get = listCacheGet;
                ListCache.prototype.has = listCacheHas;
                ListCache.prototype.set = listCacheSet;
                function MapCache(entries) {
                  var index = -1, length = entries ? entries.length : 0;
                  this.clear();
                  while (++index < length) {
                    var entry = entries[index];
                    this.set(entry[0], entry[1]);
                  }
                }
                function mapCacheClear() {
                  this.__data__ = {
                    "hash": new Hash(),
                    "map": new (Map2 || ListCache)(),
                    "string": new Hash()
                  };
                }
                function mapCacheDelete(key) {
                  return getMapData(this, key)["delete"](key);
                }
                function mapCacheGet(key) {
                  return getMapData(this, key).get(key);
                }
                function mapCacheHas(key) {
                  return getMapData(this, key).has(key);
                }
                function mapCacheSet(key, value) {
                  getMapData(this, key).set(key, value);
                  return this;
                }
                MapCache.prototype.clear = mapCacheClear;
                MapCache.prototype["delete"] = mapCacheDelete;
                MapCache.prototype.get = mapCacheGet;
                MapCache.prototype.has = mapCacheHas;
                MapCache.prototype.set = mapCacheSet;
                function assocIndexOf(array, key) {
                  var length = array.length;
                  while (length--) {
                    if (eq(array[length][0], key)) {
                      return length;
                    }
                  }
                  return -1;
                }
                function baseIsNative(value) {
                  if (!isObject(value) || isMasked(value)) {
                    return false;
                  }
                  var pattern = isFunction(value) || isHostObject(value) ? reIsNative : reIsHostCtor;
                  return pattern.test(toSource(value));
                }
                function getMapData(map, key) {
                  var data = map.__data__;
                  return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
                }
                function getNative(object, key) {
                  var value = getValue(object, key);
                  return baseIsNative(value) ? value : void 0;
                }
                function isKeyable(value) {
                  var type = typeof value;
                  return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
                }
                function isMasked(func) {
                  return !!maskSrcKey && maskSrcKey in func;
                }
                function toSource(func) {
                  if (func != null) {
                    try {
                      return funcToString.call(func);
                    } catch (e) {
                    }
                    try {
                      return func + "";
                    } catch (e) {
                    }
                  }
                  return "";
                }
                function memoize(func, resolver) {
                  if (typeof func != "function" || resolver && typeof resolver != "function") {
                    throw new TypeError(FUNC_ERROR_TEXT);
                  }
                  var memoized = function() {
                    var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
                    if (cache.has(key)) {
                      return cache.get(key);
                    }
                    var result = func.apply(this, args);
                    memoized.cache = cache.set(key, result);
                    return result;
                  };
                  memoized.cache = new (memoize.Cache || MapCache)();
                  return memoized;
                }
                memoize.Cache = MapCache;
                function eq(value, other) {
                  return value === other || value !== value && other !== other;
                }
                function isFunction(value) {
                  var tag = isObject(value) ? objectToString.call(value) : "";
                  return tag == funcTag || tag == genTag;
                }
                function isObject(value) {
                  var type = typeof value;
                  return !!value && (type == "object" || type == "function");
                }
                module2.exports = memoize;
              }
            ),
            /***/
            7800: (
              /***/
              (__unused_webpack___webpack_module__, __webpack_exports__2, __webpack_require__2) => {
                "use strict";
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  A: () => (
                    /* binding */
                    _unsupportedIterableToArray2
                  )
                  /* harmony export */
                });
                var _arrayLikeToArray_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(3145);
                function _unsupportedIterableToArray2(r, a) {
                  if (r) {
                    if ("string" == typeof r) return (0, _arrayLikeToArray_js__WEBPACK_IMPORTED_MODULE_0__.A)(r, a);
                    var t = {}.toString.call(r).slice(8, -1);
                    return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? (0, _arrayLikeToArray_js__WEBPACK_IMPORTED_MODULE_0__.A)(r, a) : void 0;
                  }
                }
              }
            ),
            /***/
            7833: (
              /***/
              (module2, exports2, __webpack_require__2) => {
                exports2.formatArgs = formatArgs;
                exports2.save = save;
                exports2.load = load;
                exports2.useColors = useColors;
                exports2.storage = localstorage();
                exports2.destroy = /* @__PURE__ */ (() => {
                  let warned = false;
                  return () => {
                    if (!warned) {
                      warned = true;
                      console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
                    }
                  };
                })();
                exports2.colors = [
                  "#0000CC",
                  "#0000FF",
                  "#0033CC",
                  "#0033FF",
                  "#0066CC",
                  "#0066FF",
                  "#0099CC",
                  "#0099FF",
                  "#00CC00",
                  "#00CC33",
                  "#00CC66",
                  "#00CC99",
                  "#00CCCC",
                  "#00CCFF",
                  "#3300CC",
                  "#3300FF",
                  "#3333CC",
                  "#3333FF",
                  "#3366CC",
                  "#3366FF",
                  "#3399CC",
                  "#3399FF",
                  "#33CC00",
                  "#33CC33",
                  "#33CC66",
                  "#33CC99",
                  "#33CCCC",
                  "#33CCFF",
                  "#6600CC",
                  "#6600FF",
                  "#6633CC",
                  "#6633FF",
                  "#66CC00",
                  "#66CC33",
                  "#9900CC",
                  "#9900FF",
                  "#9933CC",
                  "#9933FF",
                  "#99CC00",
                  "#99CC33",
                  "#CC0000",
                  "#CC0033",
                  "#CC0066",
                  "#CC0099",
                  "#CC00CC",
                  "#CC00FF",
                  "#CC3300",
                  "#CC3333",
                  "#CC3366",
                  "#CC3399",
                  "#CC33CC",
                  "#CC33FF",
                  "#CC6600",
                  "#CC6633",
                  "#CC9900",
                  "#CC9933",
                  "#CCCC00",
                  "#CCCC33",
                  "#FF0000",
                  "#FF0033",
                  "#FF0066",
                  "#FF0099",
                  "#FF00CC",
                  "#FF00FF",
                  "#FF3300",
                  "#FF3333",
                  "#FF3366",
                  "#FF3399",
                  "#FF33CC",
                  "#FF33FF",
                  "#FF6600",
                  "#FF6633",
                  "#FF9900",
                  "#FF9933",
                  "#FFCC00",
                  "#FFCC33"
                ];
                function useColors() {
                  if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
                    return true;
                  }
                  if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
                    return false;
                  }
                  let m;
                  return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
                  typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
                  // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
                  typeof navigator !== "undefined" && navigator.userAgent && (m = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m[1], 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
                  typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
                }
                function formatArgs(args) {
                  args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module2.exports.humanize(this.diff);
                  if (!this.useColors) {
                    return;
                  }
                  const c = "color: " + this.color;
                  args.splice(1, 0, c, "color: inherit");
                  let index = 0;
                  let lastC = 0;
                  args[0].replace(/%[a-zA-Z%]/g, (match) => {
                    if (match === "%%") {
                      return;
                    }
                    index++;
                    if (match === "%c") {
                      lastC = index;
                    }
                  });
                  args.splice(lastC, 0, c);
                }
                exports2.log = console.debug || console.log || (() => {
                });
                function save(namespaces) {
                  try {
                    if (namespaces) {
                      exports2.storage.setItem("debug", namespaces);
                    } else {
                      exports2.storage.removeItem("debug");
                    }
                  } catch (error) {
                  }
                }
                function load() {
                  let r;
                  try {
                    r = exports2.storage.getItem("debug") || exports2.storage.getItem("DEBUG");
                  } catch (error) {
                  }
                  if (!r && typeof process !== "undefined" && "env" in process) {
                    r = process.env.DEBUG;
                  }
                  return r;
                }
                function localstorage() {
                  try {
                    return localStorage;
                  } catch (error) {
                  }
                }
                module2.exports = __webpack_require__2(736)(exports2);
                const { formatters } = module2.exports;
                formatters.j = function(v) {
                  try {
                    return JSON.stringify(v);
                  } catch (error) {
                    return "[UnexpectedJSONParseError]: " + error.message;
                  }
                };
              }
            ),
            /***/
            8046: (
              /***/
              (__unused_webpack_module, exports2, __webpack_require__2) => {
                "use strict";
                Object.defineProperty(exports2, "__esModule", { value: true });
                exports2.validateAndNormalizeRtpCapabilities = validateAndNormalizeRtpCapabilities;
                exports2.validateAndNormalizeRtpParameters = validateAndNormalizeRtpParameters;
                exports2.validateAndNormalizeSctpStreamParameters = validateAndNormalizeSctpStreamParameters;
                exports2.validateSctpCapabilities = validateSctpCapabilities;
                exports2.getExtendedRtpCapabilities = getExtendedRtpCapabilities;
                exports2.getRecvRtpCapabilities = getRecvRtpCapabilities;
                exports2.getSendingRtpParameters = getSendingRtpParameters;
                exports2.getSendingRemoteRtpParameters = getSendingRemoteRtpParameters;
                exports2.reduceCodecs = reduceCodecs;
                exports2.generateProbatorRtpParameters = generateProbatorRtpParameters;
                exports2.canSend = canSend;
                exports2.canReceive = canReceive;
                const h264 = __webpack_require__2(3200);
                const utils = __webpack_require__2(1765);
                const RTP_PROBATOR_MID = "probator";
                const RTP_PROBATOR_SSRC = 1234;
                const RTP_PROBATOR_CODEC_PAYLOAD_TYPE = 127;
                function validateAndNormalizeRtpCapabilities(caps) {
                  if (typeof caps !== "object") {
                    throw new TypeError("caps is not an object");
                  }
                  if (caps.codecs && !Array.isArray(caps.codecs)) {
                    throw new TypeError("caps.codecs is not an array");
                  } else if (!caps.codecs) {
                    caps.codecs = [];
                  }
                  for (const codec of caps.codecs) {
                    validateAndNormalizeRtpCodecCapability(codec);
                  }
                  if (caps.headerExtensions && !Array.isArray(caps.headerExtensions)) {
                    throw new TypeError("caps.headerExtensions is not an array");
                  } else if (!caps.headerExtensions) {
                    caps.headerExtensions = [];
                  }
                  for (const ext of caps.headerExtensions) {
                    validateAndNormalizeRtpHeaderExtension(ext);
                  }
                }
                function validateAndNormalizeRtpParameters(params) {
                  if (typeof params !== "object") {
                    throw new TypeError("params is not an object");
                  }
                  if (params.mid && typeof params.mid !== "string") {
                    throw new TypeError("params.mid is not a string");
                  }
                  if (!Array.isArray(params.codecs)) {
                    throw new TypeError("missing params.codecs");
                  }
                  for (const codec of params.codecs) {
                    validateAndNormalizeRtpCodecParameters(codec);
                  }
                  if (params.headerExtensions && !Array.isArray(params.headerExtensions)) {
                    throw new TypeError("params.headerExtensions is not an array");
                  } else if (!params.headerExtensions) {
                    params.headerExtensions = [];
                  }
                  for (const ext of params.headerExtensions) {
                    validateRtpHeaderExtensionParameters(ext);
                  }
                  if (params.encodings && !Array.isArray(params.encodings)) {
                    throw new TypeError("params.encodings is not an array");
                  } else if (!params.encodings) {
                    params.encodings = [];
                  }
                  for (const encoding of params.encodings) {
                    validateAndNormalizeRtpEncodingParameters(encoding);
                  }
                  if (params.rtcp && typeof params.rtcp !== "object") {
                    throw new TypeError("params.rtcp is not an object");
                  } else if (!params.rtcp) {
                    params.rtcp = {};
                  }
                  validateAndNormalizeRtcpParameters(params.rtcp);
                }
                function validateAndNormalizeSctpStreamParameters(params) {
                  if (typeof params !== "object") {
                    throw new TypeError("params is not an object");
                  }
                  if (typeof params.streamId !== "number") {
                    throw new TypeError("missing params.streamId");
                  }
                  let orderedGiven = false;
                  if (typeof params.ordered === "boolean") {
                    orderedGiven = true;
                  } else {
                    params.ordered = true;
                  }
                  if (params.maxPacketLifeTime && typeof params.maxPacketLifeTime !== "number") {
                    throw new TypeError("invalid params.maxPacketLifeTime");
                  }
                  if (params.maxRetransmits && typeof params.maxRetransmits !== "number") {
                    throw new TypeError("invalid params.maxRetransmits");
                  }
                  if (params.maxPacketLifeTime && params.maxRetransmits) {
                    throw new TypeError("cannot provide both maxPacketLifeTime and maxRetransmits");
                  }
                  if (orderedGiven && params.ordered && (params.maxPacketLifeTime || params.maxRetransmits)) {
                    throw new TypeError("cannot be ordered with maxPacketLifeTime or maxRetransmits");
                  } else if (!orderedGiven && (params.maxPacketLifeTime || params.maxRetransmits)) {
                    params.ordered = false;
                  }
                  if (params.label && typeof params.label !== "string") {
                    throw new TypeError("invalid params.label");
                  }
                  if (params.protocol && typeof params.protocol !== "string") {
                    throw new TypeError("invalid params.protocol");
                  }
                }
                function validateSctpCapabilities(caps) {
                  if (typeof caps !== "object") {
                    throw new TypeError("caps is not an object");
                  }
                  if (!caps.numStreams || typeof caps.numStreams !== "object") {
                    throw new TypeError("missing caps.numStreams");
                  }
                  validateNumSctpStreams(caps.numStreams);
                }
                function getExtendedRtpCapabilities(localCaps, remoteCaps, preferLocalCodecsOrder) {
                  const extendedRtpCapabilities = {
                    codecs: [],
                    headerExtensions: []
                  };
                  if (preferLocalCodecsOrder) {
                    for (const localCodec of localCaps.codecs ?? []) {
                      if (isRtxCodec(localCodec)) {
                        continue;
                      }
                      const matchingRemoteCodec = (remoteCaps.codecs ?? []).find((remoteCodec) => matchCodecs(remoteCodec, localCodec, { strict: true, modify: true }));
                      if (!matchingRemoteCodec) {
                        continue;
                      }
                      const extendedCodec = {
                        kind: localCodec.kind,
                        mimeType: localCodec.mimeType,
                        clockRate: localCodec.clockRate,
                        channels: localCodec.channels,
                        localPayloadType: localCodec.preferredPayloadType,
                        localRtxPayloadType: void 0,
                        remotePayloadType: matchingRemoteCodec.preferredPayloadType,
                        remoteRtxPayloadType: void 0,
                        localParameters: localCodec.parameters ?? {},
                        remoteParameters: matchingRemoteCodec.parameters ?? {},
                        rtcpFeedback: reduceRtcpFeedback(localCodec, matchingRemoteCodec)
                      };
                      extendedRtpCapabilities.codecs.push(extendedCodec);
                    }
                  } else {
                    for (const remoteCodec of remoteCaps.codecs ?? []) {
                      if (isRtxCodec(remoteCodec)) {
                        continue;
                      }
                      const matchingLocalCodec = (localCaps.codecs ?? []).find((localCodec) => matchCodecs(localCodec, remoteCodec, { strict: true, modify: true }));
                      if (!matchingLocalCodec) {
                        continue;
                      }
                      const extendedCodec = {
                        kind: matchingLocalCodec.kind,
                        mimeType: matchingLocalCodec.mimeType,
                        clockRate: matchingLocalCodec.clockRate,
                        channels: matchingLocalCodec.channels,
                        localPayloadType: matchingLocalCodec.preferredPayloadType,
                        localRtxPayloadType: void 0,
                        remotePayloadType: remoteCodec.preferredPayloadType,
                        remoteRtxPayloadType: void 0,
                        localParameters: matchingLocalCodec.parameters ?? {},
                        remoteParameters: remoteCodec.parameters ?? {},
                        rtcpFeedback: reduceRtcpFeedback(matchingLocalCodec, remoteCodec)
                      };
                      extendedRtpCapabilities.codecs.push(extendedCodec);
                    }
                  }
                  for (const extendedCodec of extendedRtpCapabilities.codecs) {
                    const matchingLocalRtxCodec = localCaps.codecs.find((localCodec) => {
                      var _a;
                      return isRtxCodec(localCodec) && ((_a = localCodec.parameters) == null ? void 0 : _a["apt"]) === extendedCodec.localPayloadType;
                    });
                    const matchingRemoteRtxCodec = remoteCaps.codecs.find((remoteCodec) => {
                      var _a;
                      return isRtxCodec(remoteCodec) && ((_a = remoteCodec.parameters) == null ? void 0 : _a["apt"]) === extendedCodec.remotePayloadType;
                    });
                    if (matchingLocalRtxCodec && matchingRemoteRtxCodec) {
                      extendedCodec.localRtxPayloadType = matchingLocalRtxCodec.preferredPayloadType;
                      extendedCodec.remoteRtxPayloadType = matchingRemoteRtxCodec.preferredPayloadType;
                    }
                  }
                  for (const remoteExt of remoteCaps.headerExtensions) {
                    const matchingLocalExt = localCaps.headerExtensions.find((localExt) => matchHeaderExtensions(localExt, remoteExt));
                    if (!matchingLocalExt) {
                      continue;
                    }
                    const extendedExt = {
                      kind: remoteExt.kind,
                      uri: remoteExt.uri,
                      sendId: matchingLocalExt.preferredId,
                      recvId: remoteExt.preferredId,
                      encrypt: matchingLocalExt.preferredEncrypt ?? false,
                      direction: "sendrecv"
                    };
                    switch (remoteExt.direction) {
                      case "sendrecv": {
                        extendedExt.direction = "sendrecv";
                        break;
                      }
                      case "recvonly": {
                        extendedExt.direction = "sendonly";
                        break;
                      }
                      case "sendonly": {
                        extendedExt.direction = "recvonly";
                        break;
                      }
                      case "inactive": {
                        extendedExt.direction = "inactive";
                        break;
                      }
                    }
                    extendedRtpCapabilities.headerExtensions.push(extendedExt);
                  }
                  return extendedRtpCapabilities;
                }
                function getRecvRtpCapabilities(extendedRtpCapabilities) {
                  const rtpCapabilities = {
                    codecs: [],
                    headerExtensions: []
                  };
                  for (const extendedCodec of extendedRtpCapabilities.codecs) {
                    const codec = {
                      kind: extendedCodec.kind,
                      mimeType: extendedCodec.mimeType,
                      preferredPayloadType: extendedCodec.remotePayloadType,
                      clockRate: extendedCodec.clockRate,
                      channels: extendedCodec.channels,
                      parameters: extendedCodec.localParameters,
                      rtcpFeedback: extendedCodec.rtcpFeedback
                    };
                    rtpCapabilities.codecs.push(codec);
                    if (!extendedCodec.remoteRtxPayloadType) {
                      continue;
                    }
                    const rtxCodec = {
                      kind: extendedCodec.kind,
                      mimeType: `${extendedCodec.kind}/rtx`,
                      preferredPayloadType: extendedCodec.remoteRtxPayloadType,
                      clockRate: extendedCodec.clockRate,
                      parameters: {
                        apt: extendedCodec.remotePayloadType
                      },
                      rtcpFeedback: []
                    };
                    rtpCapabilities.codecs.push(rtxCodec);
                  }
                  for (const extendedExtension of extendedRtpCapabilities.headerExtensions) {
                    if (extendedExtension.direction !== "sendrecv" && extendedExtension.direction !== "recvonly") {
                      continue;
                    }
                    const ext = {
                      kind: extendedExtension.kind,
                      uri: extendedExtension.uri,
                      preferredId: extendedExtension.recvId,
                      preferredEncrypt: extendedExtension.encrypt ?? false,
                      direction: extendedExtension.direction
                    };
                    rtpCapabilities.headerExtensions.push(ext);
                  }
                  return rtpCapabilities;
                }
                function getSendingRtpParameters(kind, extendedRtpCapabilities) {
                  const rtpParameters = {
                    mid: void 0,
                    codecs: [],
                    headerExtensions: [],
                    encodings: [],
                    rtcp: {}
                  };
                  for (const extendedCodec of extendedRtpCapabilities.codecs) {
                    if (extendedCodec.kind !== kind) {
                      continue;
                    }
                    const codec = {
                      mimeType: extendedCodec.mimeType,
                      payloadType: extendedCodec.localPayloadType,
                      clockRate: extendedCodec.clockRate,
                      channels: extendedCodec.channels,
                      parameters: extendedCodec.localParameters,
                      rtcpFeedback: extendedCodec.rtcpFeedback
                    };
                    rtpParameters.codecs.push(codec);
                    if (extendedCodec.localRtxPayloadType) {
                      const rtxCodec = {
                        mimeType: `${extendedCodec.kind}/rtx`,
                        payloadType: extendedCodec.localRtxPayloadType,
                        clockRate: extendedCodec.clockRate,
                        parameters: {
                          apt: extendedCodec.localPayloadType
                        },
                        rtcpFeedback: []
                      };
                      rtpParameters.codecs.push(rtxCodec);
                    }
                  }
                  for (const extendedExtension of extendedRtpCapabilities.headerExtensions) {
                    if (extendedExtension.kind && extendedExtension.kind !== kind || extendedExtension.direction !== "sendrecv" && extendedExtension.direction !== "sendonly") {
                      continue;
                    }
                    const ext = {
                      uri: extendedExtension.uri,
                      id: extendedExtension.sendId,
                      encrypt: extendedExtension.encrypt,
                      parameters: {}
                    };
                    rtpParameters.headerExtensions.push(ext);
                  }
                  return rtpParameters;
                }
                function getSendingRemoteRtpParameters(kind, extendedRtpCapabilities) {
                  const rtpParameters = {
                    mid: void 0,
                    codecs: [],
                    headerExtensions: [],
                    encodings: [],
                    rtcp: {}
                  };
                  for (const extendedCodec of extendedRtpCapabilities.codecs) {
                    if (extendedCodec.kind !== kind) {
                      continue;
                    }
                    const codec = {
                      mimeType: extendedCodec.mimeType,
                      payloadType: extendedCodec.localPayloadType,
                      clockRate: extendedCodec.clockRate,
                      channels: extendedCodec.channels,
                      parameters: extendedCodec.remoteParameters,
                      rtcpFeedback: extendedCodec.rtcpFeedback
                    };
                    rtpParameters.codecs.push(codec);
                    if (extendedCodec.localRtxPayloadType) {
                      const rtxCodec = {
                        mimeType: `${extendedCodec.kind}/rtx`,
                        payloadType: extendedCodec.localRtxPayloadType,
                        clockRate: extendedCodec.clockRate,
                        parameters: {
                          apt: extendedCodec.localPayloadType
                        },
                        rtcpFeedback: []
                      };
                      rtpParameters.codecs.push(rtxCodec);
                    }
                  }
                  for (const extendedExtension of extendedRtpCapabilities.headerExtensions) {
                    if (extendedExtension.kind && extendedExtension.kind !== kind || extendedExtension.direction !== "sendrecv" && extendedExtension.direction !== "sendonly") {
                      continue;
                    }
                    const ext = {
                      uri: extendedExtension.uri,
                      id: extendedExtension.sendId,
                      encrypt: extendedExtension.encrypt,
                      parameters: {}
                    };
                    rtpParameters.headerExtensions.push(ext);
                  }
                  if (rtpParameters.headerExtensions.some((ext) => ext.uri === "http://www.ietf.org/id/draft-holmer-rmcat-transport-wide-cc-extensions-01")) {
                    for (const codec of rtpParameters.codecs) {
                      codec.rtcpFeedback = (codec.rtcpFeedback ?? []).filter((fb) => fb.type !== "goog-remb");
                    }
                  } else if (rtpParameters.headerExtensions.some((ext) => ext.uri === "http://www.webrtc.org/experiments/rtp-hdrext/abs-send-time")) {
                    for (const codec of rtpParameters.codecs) {
                      codec.rtcpFeedback = (codec.rtcpFeedback ?? []).filter((fb) => fb.type !== "transport-cc");
                    }
                  } else {
                    for (const codec of rtpParameters.codecs) {
                      codec.rtcpFeedback = (codec.rtcpFeedback ?? []).filter((fb) => fb.type !== "transport-cc" && fb.type !== "goog-remb");
                    }
                  }
                  return rtpParameters;
                }
                function reduceCodecs(codecs, capCodec) {
                  const filteredCodecs = [];
                  if (!capCodec) {
                    filteredCodecs.push(codecs[0]);
                    if (isRtxCodec(codecs[1])) {
                      filteredCodecs.push(codecs[1]);
                    }
                  } else {
                    for (let idx = 0; idx < codecs.length; ++idx) {
                      if (matchCodecs(codecs[idx], capCodec, { strict: true })) {
                        filteredCodecs.push(codecs[idx]);
                        if (isRtxCodec(codecs[idx + 1])) {
                          filteredCodecs.push(codecs[idx + 1]);
                        }
                        break;
                      }
                    }
                    if (filteredCodecs.length === 0) {
                      throw new TypeError("no matching codec found");
                    }
                  }
                  return filteredCodecs;
                }
                function generateProbatorRtpParameters(videoRtpParameters) {
                  videoRtpParameters = utils.clone(videoRtpParameters);
                  validateAndNormalizeRtpParameters(videoRtpParameters);
                  const rtpParameters = {
                    mid: RTP_PROBATOR_MID,
                    codecs: [],
                    headerExtensions: [],
                    encodings: [{ ssrc: RTP_PROBATOR_SSRC }],
                    rtcp: { cname: "probator" }
                  };
                  rtpParameters.codecs.push(videoRtpParameters.codecs[0]);
                  rtpParameters.codecs[0].payloadType = RTP_PROBATOR_CODEC_PAYLOAD_TYPE;
                  rtpParameters.headerExtensions = videoRtpParameters.headerExtensions;
                  return rtpParameters;
                }
                function canSend(kind, rtpCapabilities) {
                  return (rtpCapabilities.codecs ?? []).some((codec) => codec.kind === kind);
                }
                function canReceive(rtpParameters, rtpCapabilities) {
                  validateAndNormalizeRtpParameters(rtpParameters);
                  if (rtpParameters.codecs.length === 0) {
                    return false;
                  }
                  const firstMediaCodec = rtpParameters.codecs[0];
                  return (rtpCapabilities.codecs ?? []).some((codec) => codec.preferredPayloadType === firstMediaCodec.payloadType);
                }
                function validateAndNormalizeRtpCodecCapability(codec) {
                  const MimeTypeRegex = new RegExp("^(audio|video)/(.+)", "i");
                  if (typeof codec !== "object") {
                    throw new TypeError("codec is not an object");
                  }
                  if (!codec.mimeType || typeof codec.mimeType !== "string") {
                    throw new TypeError("missing codec.mimeType");
                  }
                  const mimeTypeMatch = MimeTypeRegex.exec(codec.mimeType);
                  if (!mimeTypeMatch) {
                    throw new TypeError("invalid codec.mimeType");
                  }
                  codec.kind = mimeTypeMatch[1].toLowerCase();
                  if (typeof codec.preferredPayloadType !== "number") {
                    throw new TypeError("missing codec.preferredPayloadType");
                  }
                  if (typeof codec.clockRate !== "number") {
                    throw new TypeError("missing codec.clockRate");
                  }
                  if (codec.kind === "audio") {
                    if (typeof codec.channels !== "number") {
                      codec.channels = 1;
                    }
                  } else {
                    delete codec.channels;
                  }
                  if (!codec.parameters || typeof codec.parameters !== "object") {
                    codec.parameters = {};
                  }
                  for (const key of Object.keys(codec.parameters)) {
                    let value = codec.parameters[key];
                    if (value === void 0) {
                      codec.parameters[key] = "";
                      value = "";
                    }
                    if (typeof value !== "string" && typeof value !== "number") {
                      throw new TypeError(`invalid codec parameter [key:${key}s, value:${value}]`);
                    }
                    if (key === "apt") {
                      if (typeof value !== "number") {
                        throw new TypeError("invalid codec apt parameter");
                      }
                    }
                  }
                  if (!codec.rtcpFeedback || !Array.isArray(codec.rtcpFeedback)) {
                    codec.rtcpFeedback = [];
                  }
                  for (const fb of codec.rtcpFeedback) {
                    validateAndNormalizeRtcpFeedback(fb);
                  }
                }
                function validateAndNormalizeRtcpFeedback(fb) {
                  if (typeof fb !== "object") {
                    throw new TypeError("fb is not an object");
                  }
                  if (!fb.type || typeof fb.type !== "string") {
                    throw new TypeError("missing fb.type");
                  }
                  if (!fb.parameter || typeof fb.parameter !== "string") {
                    fb.parameter = "";
                  }
                }
                function validateAndNormalizeRtpHeaderExtension(ext) {
                  if (typeof ext !== "object") {
                    throw new TypeError("ext is not an object");
                  }
                  if (ext.kind !== "audio" && ext.kind !== "video") {
                    throw new TypeError("invalid ext.kind");
                  }
                  if (!ext.uri || typeof ext.uri !== "string") {
                    throw new TypeError("missing ext.uri");
                  }
                  if (typeof ext.preferredId !== "number") {
                    throw new TypeError("missing ext.preferredId");
                  }
                  if (ext.preferredEncrypt && typeof ext.preferredEncrypt !== "boolean") {
                    throw new TypeError("invalid ext.preferredEncrypt");
                  } else if (!ext.preferredEncrypt) {
                    ext.preferredEncrypt = false;
                  }
                  if (ext.direction && typeof ext.direction !== "string") {
                    throw new TypeError("invalid ext.direction");
                  } else if (!ext.direction) {
                    ext.direction = "sendrecv";
                  }
                }
                function validateAndNormalizeRtpCodecParameters(codec) {
                  const MimeTypeRegex = new RegExp("^(audio|video)/(.+)", "i");
                  if (typeof codec !== "object") {
                    throw new TypeError("codec is not an object");
                  }
                  if (!codec.mimeType || typeof codec.mimeType !== "string") {
                    throw new TypeError("missing codec.mimeType");
                  }
                  const mimeTypeMatch = MimeTypeRegex.exec(codec.mimeType);
                  if (!mimeTypeMatch) {
                    throw new TypeError("invalid codec.mimeType");
                  }
                  if (typeof codec.payloadType !== "number") {
                    throw new TypeError("missing codec.payloadType");
                  }
                  if (typeof codec.clockRate !== "number") {
                    throw new TypeError("missing codec.clockRate");
                  }
                  const kind = mimeTypeMatch[1].toLowerCase();
                  if (kind === "audio") {
                    if (typeof codec.channels !== "number") {
                      codec.channels = 1;
                    }
                  } else {
                    delete codec.channels;
                  }
                  if (!codec.parameters || typeof codec.parameters !== "object") {
                    codec.parameters = {};
                  }
                  for (const key of Object.keys(codec.parameters)) {
                    let value = codec.parameters[key];
                    if (value === void 0) {
                      codec.parameters[key] = "";
                      value = "";
                    }
                    if (typeof value !== "string" && typeof value !== "number") {
                      throw new TypeError(`invalid codec parameter [key:${key}s, value:${value}]`);
                    }
                    if (key === "apt") {
                      if (typeof value !== "number") {
                        throw new TypeError("invalid codec apt parameter");
                      }
                    }
                  }
                  if (!codec.rtcpFeedback || !Array.isArray(codec.rtcpFeedback)) {
                    codec.rtcpFeedback = [];
                  }
                  for (const fb of codec.rtcpFeedback) {
                    validateAndNormalizeRtcpFeedback(fb);
                  }
                }
                function validateRtpHeaderExtensionParameters(ext) {
                  if (typeof ext !== "object") {
                    throw new TypeError("ext is not an object");
                  }
                  if (!ext.uri || typeof ext.uri !== "string") {
                    throw new TypeError("missing ext.uri");
                  }
                  if (typeof ext.id !== "number") {
                    throw new TypeError("missing ext.id");
                  }
                  if (ext.encrypt && typeof ext.encrypt !== "boolean") {
                    throw new TypeError("invalid ext.encrypt");
                  } else if (!ext.encrypt) {
                    ext.encrypt = false;
                  }
                  if (!ext.parameters || typeof ext.parameters !== "object") {
                    ext.parameters = {};
                  }
                  for (const key of Object.keys(ext.parameters)) {
                    let value = ext.parameters[key];
                    if (value === void 0) {
                      ext.parameters[key] = "";
                      value = "";
                    }
                    if (typeof value !== "string" && typeof value !== "number") {
                      throw new TypeError("invalid header extension parameter");
                    }
                  }
                }
                function validateAndNormalizeRtpEncodingParameters(encoding) {
                  if (typeof encoding !== "object") {
                    throw new TypeError("encoding is not an object");
                  }
                  if (encoding.ssrc && typeof encoding.ssrc !== "number") {
                    throw new TypeError("invalid encoding.ssrc");
                  }
                  if (encoding.rid && typeof encoding.rid !== "string") {
                    throw new TypeError("invalid encoding.rid");
                  }
                  if (encoding.rtx && typeof encoding.rtx !== "object") {
                    throw new TypeError("invalid encoding.rtx");
                  } else if (encoding.rtx) {
                    if (typeof encoding.rtx.ssrc !== "number") {
                      throw new TypeError("missing encoding.rtx.ssrc");
                    }
                  }
                  if (!encoding.dtx || typeof encoding.dtx !== "boolean") {
                    encoding.dtx = false;
                  }
                  if (encoding.scalabilityMode && typeof encoding.scalabilityMode !== "string") {
                    throw new TypeError("invalid encoding.scalabilityMode");
                  }
                }
                function validateAndNormalizeRtcpParameters(rtcp) {
                  if (typeof rtcp !== "object") {
                    throw new TypeError("rtcp is not an object");
                  }
                  if (rtcp.cname && typeof rtcp.cname !== "string") {
                    throw new TypeError("invalid rtcp.cname");
                  }
                  if (!rtcp.reducedSize || typeof rtcp.reducedSize !== "boolean") {
                    rtcp.reducedSize = true;
                  }
                }
                function validateNumSctpStreams(numStreams) {
                  if (typeof numStreams !== "object") {
                    throw new TypeError("numStreams is not an object");
                  }
                  if (typeof numStreams.OS !== "number") {
                    throw new TypeError("missing numStreams.OS");
                  }
                  if (typeof numStreams.MIS !== "number") {
                    throw new TypeError("missing numStreams.MIS");
                  }
                }
                function isRtxCodec(codec) {
                  if (!codec) {
                    return false;
                  }
                  return /.+\/rtx$/i.test(codec.mimeType);
                }
                function matchCodecs(aCodec, bCodec, { strict = false, modify = false } = {}) {
                  const aMimeType = aCodec.mimeType.toLowerCase();
                  const bMimeType = bCodec.mimeType.toLowerCase();
                  if (aMimeType !== bMimeType) {
                    return false;
                  }
                  if (aCodec.clockRate !== bCodec.clockRate) {
                    return false;
                  }
                  if (aCodec.channels !== bCodec.channels) {
                    return false;
                  }
                  switch (aMimeType) {
                    case "video/h264": {
                      if (strict) {
                        const aPacketizationMode = aCodec.parameters["packetization-mode"] ?? 0;
                        const bPacketizationMode = bCodec.parameters["packetization-mode"] ?? 0;
                        if (aPacketizationMode !== bPacketizationMode) {
                          return false;
                        }
                        if (!h264.isSameProfile(aCodec.parameters, bCodec.parameters)) {
                          return false;
                        }
                        let selectedProfileLevelId;
                        try {
                          selectedProfileLevelId = h264.generateProfileLevelIdStringForAnswer(aCodec.parameters, bCodec.parameters);
                        } catch (error) {
                          return false;
                        }
                        if (modify) {
                          if (selectedProfileLevelId) {
                            aCodec.parameters["profile-level-id"] = selectedProfileLevelId;
                            bCodec.parameters["profile-level-id"] = selectedProfileLevelId;
                          } else {
                            delete aCodec.parameters["profile-level-id"];
                            delete bCodec.parameters["profile-level-id"];
                          }
                        }
                      }
                      break;
                    }
                    case "video/vp9": {
                      if (strict) {
                        const aProfileId = aCodec.parameters["profile-id"] ?? 0;
                        const bProfileId = bCodec.parameters["profile-id"] ?? 0;
                        if (aProfileId !== bProfileId) {
                          return false;
                        }
                      }
                      break;
                    }
                  }
                  return true;
                }
                function matchHeaderExtensions(aExt, bExt) {
                  if (aExt.kind && bExt.kind && aExt.kind !== bExt.kind) {
                    return false;
                  }
                  if (aExt.uri !== bExt.uri) {
                    return false;
                  }
                  return true;
                }
                function reduceRtcpFeedback(codecA, codecB) {
                  const reducedRtcpFeedback = [];
                  for (const aFb of codecA.rtcpFeedback ?? []) {
                    const matchingBFb = (codecB.rtcpFeedback ?? []).find((bFb) => bFb.type === aFb.type && (bFb.parameter === aFb.parameter || !bFb.parameter && !aFb.parameter));
                    if (matchingBFb) {
                      reducedRtcpFeedback.push(matchingBFb);
                    }
                  }
                  return reducedRtcpFeedback;
                }
              }
            ),
            /***/
            8056: (
              /***/
              function(module2, exports2, __webpack_require__2) {
                ;
                (function(root, factory) {
                  if (true) {
                    module2.exports = exports2 = factory(__webpack_require__2(9021));
                  } else {
                  }
                })(this, function(CryptoJS) {
                  (function(Math2) {
                    var C = CryptoJS;
                    var C_lib = C.lib;
                    var WordArray = C_lib.WordArray;
                    var Hasher = C_lib.Hasher;
                    var C_algo = C.algo;
                    var _zl = WordArray.create([
                      0,
                      1,
                      2,
                      3,
                      4,
                      5,
                      6,
                      7,
                      8,
                      9,
                      10,
                      11,
                      12,
                      13,
                      14,
                      15,
                      7,
                      4,
                      13,
                      1,
                      10,
                      6,
                      15,
                      3,
                      12,
                      0,
                      9,
                      5,
                      2,
                      14,
                      11,
                      8,
                      3,
                      10,
                      14,
                      4,
                      9,
                      15,
                      8,
                      1,
                      2,
                      7,
                      0,
                      6,
                      13,
                      11,
                      5,
                      12,
                      1,
                      9,
                      11,
                      10,
                      0,
                      8,
                      12,
                      4,
                      13,
                      3,
                      7,
                      15,
                      14,
                      5,
                      6,
                      2,
                      4,
                      0,
                      5,
                      9,
                      7,
                      12,
                      2,
                      10,
                      14,
                      1,
                      3,
                      8,
                      11,
                      6,
                      15,
                      13
                    ]);
                    var _zr = WordArray.create([
                      5,
                      14,
                      7,
                      0,
                      9,
                      2,
                      11,
                      4,
                      13,
                      6,
                      15,
                      8,
                      1,
                      10,
                      3,
                      12,
                      6,
                      11,
                      3,
                      7,
                      0,
                      13,
                      5,
                      10,
                      14,
                      15,
                      8,
                      12,
                      4,
                      9,
                      1,
                      2,
                      15,
                      5,
                      1,
                      3,
                      7,
                      14,
                      6,
                      9,
                      11,
                      8,
                      12,
                      2,
                      10,
                      0,
                      4,
                      13,
                      8,
                      6,
                      4,
                      1,
                      3,
                      11,
                      15,
                      0,
                      5,
                      12,
                      2,
                      13,
                      9,
                      7,
                      10,
                      14,
                      12,
                      15,
                      10,
                      4,
                      1,
                      5,
                      8,
                      7,
                      6,
                      2,
                      13,
                      14,
                      0,
                      3,
                      9,
                      11
                    ]);
                    var _sl = WordArray.create([
                      11,
                      14,
                      15,
                      12,
                      5,
                      8,
                      7,
                      9,
                      11,
                      13,
                      14,
                      15,
                      6,
                      7,
                      9,
                      8,
                      7,
                      6,
                      8,
                      13,
                      11,
                      9,
                      7,
                      15,
                      7,
                      12,
                      15,
                      9,
                      11,
                      7,
                      13,
                      12,
                      11,
                      13,
                      6,
                      7,
                      14,
                      9,
                      13,
                      15,
                      14,
                      8,
                      13,
                      6,
                      5,
                      12,
                      7,
                      5,
                      11,
                      12,
                      14,
                      15,
                      14,
                      15,
                      9,
                      8,
                      9,
                      14,
                      5,
                      6,
                      8,
                      6,
                      5,
                      12,
                      9,
                      15,
                      5,
                      11,
                      6,
                      8,
                      13,
                      12,
                      5,
                      12,
                      13,
                      14,
                      11,
                      8,
                      5,
                      6
                    ]);
                    var _sr = WordArray.create([
                      8,
                      9,
                      9,
                      11,
                      13,
                      15,
                      15,
                      5,
                      7,
                      7,
                      8,
                      11,
                      14,
                      14,
                      12,
                      6,
                      9,
                      13,
                      15,
                      7,
                      12,
                      8,
                      9,
                      11,
                      7,
                      7,
                      12,
                      7,
                      6,
                      15,
                      13,
                      11,
                      9,
                      7,
                      15,
                      11,
                      8,
                      6,
                      6,
                      14,
                      12,
                      13,
                      5,
                      14,
                      13,
                      13,
                      7,
                      5,
                      15,
                      5,
                      8,
                      11,
                      14,
                      14,
                      6,
                      14,
                      6,
                      9,
                      12,
                      9,
                      12,
                      5,
                      15,
                      8,
                      8,
                      5,
                      12,
                      9,
                      12,
                      5,
                      14,
                      6,
                      8,
                      13,
                      6,
                      5,
                      15,
                      13,
                      11,
                      11
                    ]);
                    var _hl = WordArray.create([0, 1518500249, 1859775393, 2400959708, 2840853838]);
                    var _hr = WordArray.create([1352829926, 1548603684, 1836072691, 2053994217, 0]);
                    var RIPEMD160 = C_algo.RIPEMD160 = Hasher.extend({
                      _doReset: function() {
                        this._hash = WordArray.create([1732584193, 4023233417, 2562383102, 271733878, 3285377520]);
                      },
                      _doProcessBlock: function(M, offset) {
                        for (var i = 0; i < 16; i++) {
                          var offset_i = offset + i;
                          var M_offset_i = M[offset_i];
                          M[offset_i] = (M_offset_i << 8 | M_offset_i >>> 24) & 16711935 | (M_offset_i << 24 | M_offset_i >>> 8) & 4278255360;
                        }
                        var H = this._hash.words;
                        var hl = _hl.words;
                        var hr = _hr.words;
                        var zl = _zl.words;
                        var zr = _zr.words;
                        var sl = _sl.words;
                        var sr = _sr.words;
                        var al, bl, cl, dl, el;
                        var ar, br, cr, dr, er;
                        ar = al = H[0];
                        br = bl = H[1];
                        cr = cl = H[2];
                        dr = dl = H[3];
                        er = el = H[4];
                        var t;
                        for (var i = 0; i < 80; i += 1) {
                          t = al + M[offset + zl[i]] | 0;
                          if (i < 16) {
                            t += f1(bl, cl, dl) + hl[0];
                          } else if (i < 32) {
                            t += f2(bl, cl, dl) + hl[1];
                          } else if (i < 48) {
                            t += f3(bl, cl, dl) + hl[2];
                          } else if (i < 64) {
                            t += f4(bl, cl, dl) + hl[3];
                          } else {
                            t += f5(bl, cl, dl) + hl[4];
                          }
                          t = t | 0;
                          t = rotl(t, sl[i]);
                          t = t + el | 0;
                          al = el;
                          el = dl;
                          dl = rotl(cl, 10);
                          cl = bl;
                          bl = t;
                          t = ar + M[offset + zr[i]] | 0;
                          if (i < 16) {
                            t += f5(br, cr, dr) + hr[0];
                          } else if (i < 32) {
                            t += f4(br, cr, dr) + hr[1];
                          } else if (i < 48) {
                            t += f3(br, cr, dr) + hr[2];
                          } else if (i < 64) {
                            t += f2(br, cr, dr) + hr[3];
                          } else {
                            t += f1(br, cr, dr) + hr[4];
                          }
                          t = t | 0;
                          t = rotl(t, sr[i]);
                          t = t + er | 0;
                          ar = er;
                          er = dr;
                          dr = rotl(cr, 10);
                          cr = br;
                          br = t;
                        }
                        t = H[1] + cl + dr | 0;
                        H[1] = H[2] + dl + er | 0;
                        H[2] = H[3] + el + ar | 0;
                        H[3] = H[4] + al + br | 0;
                        H[4] = H[0] + bl + cr | 0;
                        H[0] = t;
                      },
                      _doFinalize: function() {
                        var data = this._data;
                        var dataWords = data.words;
                        var nBitsTotal = this._nDataBytes * 8;
                        var nBitsLeft = data.sigBytes * 8;
                        dataWords[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;
                        dataWords[(nBitsLeft + 64 >>> 9 << 4) + 14] = (nBitsTotal << 8 | nBitsTotal >>> 24) & 16711935 | (nBitsTotal << 24 | nBitsTotal >>> 8) & 4278255360;
                        data.sigBytes = (dataWords.length + 1) * 4;
                        this._process();
                        var hash = this._hash;
                        var H = hash.words;
                        for (var i = 0; i < 5; i++) {
                          var H_i = H[i];
                          H[i] = (H_i << 8 | H_i >>> 24) & 16711935 | (H_i << 24 | H_i >>> 8) & 4278255360;
                        }
                        return hash;
                      },
                      clone: function() {
                        var clone = Hasher.clone.call(this);
                        clone._hash = this._hash.clone();
                        return clone;
                      }
                    });
                    function f1(x, y, z) {
                      return x ^ y ^ z;
                    }
                    function f2(x, y, z) {
                      return x & y | ~x & z;
                    }
                    function f3(x, y, z) {
                      return (x | ~y) ^ z;
                    }
                    function f4(x, y, z) {
                      return x & z | y & ~z;
                    }
                    function f5(x, y, z) {
                      return x ^ (y | ~z);
                    }
                    function rotl(x, n) {
                      return x << n | x >>> 32 - n;
                    }
                    C.RIPEMD160 = Hasher._createHelper(RIPEMD160);
                    C.HmacRIPEMD160 = Hasher._createHmacHelper(RIPEMD160);
                  })(Math);
                  return CryptoJS.RIPEMD160;
                });
              }
            ),
            /***/
            8057: (
              /***/
              (__unused_webpack_module, exports2) => {
                "use strict";
                var __webpack_unused_export__;
                __webpack_unused_export__ = { value: true };
              }
            ),
            /***/
            8124: (
              /***/
              function(module2, exports2, __webpack_require__2) {
                ;
                (function(root, factory, undef) {
                  if (true) {
                    module2.exports = exports2 = factory(__webpack_require__2(9021), __webpack_require__2(7165));
                  } else {
                  }
                })(this, function(CryptoJS) {
                  CryptoJS.pad.NoPadding = {
                    pad: function() {
                    },
                    unpad: function() {
                    }
                  };
                  return CryptoJS.pad.NoPadding;
                });
              }
            ),
            /***/
            8274: (
              /***/
              (__unused_webpack_module, exports2, __webpack_require__2) => {
                "use strict";
                Object.defineProperty(exports2, "__esModule", { value: true });
                exports2.Logger = void 0;
                const debug = __webpack_require__2(7833);
                const LIB_NAME = "awaitqueue";
                class Logger {
                  constructor(prefix) {
                    __publicField(this, "_debug");
                    __publicField(this, "_warn");
                    __publicField(this, "_error");
                    if (prefix) {
                      this._debug = debug(`${LIB_NAME}:${prefix}`);
                      this._warn = debug(`${LIB_NAME}:WARN:${prefix}`);
                      this._error = debug(`${LIB_NAME}:ERROR:${prefix}`);
                    } else {
                      this._debug = debug(LIB_NAME);
                      this._warn = debug(`${LIB_NAME}:WARN`);
                      this._error = debug(`${LIB_NAME}:ERROR`);
                    }
                    this._debug.log = console.info.bind(console);
                    this._warn.log = console.warn.bind(console);
                    this._error.log = console.error.bind(console);
                  }
                  get debug() {
                    return this._debug;
                  }
                  get warn() {
                    return this._warn;
                  }
                  get error() {
                    return this._error;
                  }
                }
                exports2.Logger = Logger;
              }
            ),
            /***/
            8278: (
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                "use strict";
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  Ag: () => (
                    /* binding */
                    isE2EESupported
                  ),
                  /* harmony export */
                  Wm: () => (
                    /* binding */
                    isScriptTransformSupported
                  ),
                  /* harmony export */
                  sn: () => (
                    /* binding */
                    createKeyMaterialFromString
                  ),
                  /* harmony export */
                  tr: () => (
                    /* binding */
                    createKeyMaterialFromBuffer
                  )
                  /* harmony export */
                });
                var _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(467);
                var _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(4756);
                var _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default = __webpack_require__2.n(_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1__);
                var _constants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__2(1806);
                function isE2EESupported() {
                  return isInsertableStreamSupported() || isScriptTransformSupported();
                }
                function isScriptTransformSupported() {
                  return typeof window.RTCRtpScriptTransform !== "undefined";
                }
                function isInsertableStreamSupported() {
                  return typeof window.RTCRtpSender !== "undefined" && // @ts-ignore
                  typeof window.RTCRtpSender.prototype.createEncodedStreams !== "undefined";
                }
                function isVideoFrame(frame) {
                  return "type" in frame;
                }
                function importKey(_x) {
                  return _importKey.apply(this, arguments);
                }
                function _importKey() {
                  _importKey = _asyncToGenerator(_regeneratorRuntime.mark(function _callee(keyBytes) {
                    var algorithm, usage, _args = arguments;
                    return _regeneratorRuntime.wrap(function(_context) {
                      while (1) switch (_context.prev = _context.next) {
                        case 0:
                          algorithm = _args.length > 1 && _args[1] !== void 0 ? _args[1] : {
                            name: ENCRYPTION_ALGORITHM
                          };
                          usage = _args.length > 2 && _args[2] !== void 0 ? _args[2] : "encrypt";
                          return _context.abrupt("return", crypto.subtle.importKey("raw", keyBytes, algorithm, false, usage === "derive" ? ["deriveBits", "deriveKey"] : ["encrypt", "decrypt"]));
                        case 1:
                        case "end":
                          return _context.stop();
                      }
                    }, _callee);
                  }));
                  return _importKey.apply(this, arguments);
                }
                function createKeyMaterialFromString(_x2) {
                  return _createKeyMaterialFromString.apply(this, arguments);
                }
                function _createKeyMaterialFromString() {
                  _createKeyMaterialFromString = (0, _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__.A)(_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().mark(function _callee2(password) {
                    var enc, keyMaterial;
                    return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().wrap(function(_context2) {
                      while (1) switch (_context2.prev = _context2.next) {
                        case 0:
                          enc = new TextEncoder();
                          _context2.next = 1;
                          return crypto.subtle.importKey("raw", enc.encode(password), {
                            name: "PBKDF2"
                          }, false, ["deriveBits", "deriveKey"]);
                        case 1:
                          keyMaterial = _context2.sent;
                          return _context2.abrupt("return", keyMaterial);
                        case 2:
                        case "end":
                          return _context2.stop();
                      }
                    }, _callee2);
                  }));
                  return _createKeyMaterialFromString.apply(this, arguments);
                }
                function createKeyMaterialFromBuffer(_x3) {
                  return _createKeyMaterialFromBuffer.apply(this, arguments);
                }
                function _createKeyMaterialFromBuffer() {
                  _createKeyMaterialFromBuffer = (0, _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__.A)(_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().mark(function _callee3(cryptoBuffer) {
                    var keyMaterial;
                    return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default().wrap(function(_context3) {
                      while (1) switch (_context3.prev = _context3.next) {
                        case 0:
                          _context3.next = 1;
                          return crypto.subtle.importKey("raw", cryptoBuffer, "HKDF", false, ["deriveBits", "deriveKey"]);
                        case 1:
                          keyMaterial = _context3.sent;
                          return _context3.abrupt("return", keyMaterial);
                        case 2:
                        case "end":
                          return _context3.stop();
                      }
                    }, _callee3);
                  }));
                  return _createKeyMaterialFromBuffer.apply(this, arguments);
                }
                function getAlgoOptions(algorithmName, salt) {
                  var textEncoder = new TextEncoder();
                  var encodedSalt = textEncoder.encode(salt);
                  switch (algorithmName) {
                    case "HKDF":
                      return {
                        name: "HKDF",
                        salt: encodedSalt,
                        hash: "SHA-256",
                        info: new ArrayBuffer(128)
                      };
                    case "PBKDF2": {
                      return {
                        name: "PBKDF2",
                        salt: encodedSalt,
                        hash: "SHA-256",
                        iterations: 1e5
                      };
                    }
                    default:
                      throw new Error("algorithm ".concat(algorithmName, " is currently unsupported"));
                  }
                }
                function deriveKeys(_x4, _x5) {
                  return _deriveKeys.apply(this, arguments);
                }
                function _deriveKeys() {
                  _deriveKeys = _asyncToGenerator(_regeneratorRuntime.mark(function _callee4(material, salt) {
                    var algorithmOptions, encryptionKey;
                    return _regeneratorRuntime.wrap(function(_context4) {
                      while (1) switch (_context4.prev = _context4.next) {
                        case 0:
                          algorithmOptions = getAlgoOptions(material.algorithm.name, salt);
                          _context4.next = 1;
                          return crypto.subtle.deriveKey(algorithmOptions, material, {
                            name: ENCRYPTION_ALGORITHM,
                            length: 128
                          }, false, ["encrypt", "decrypt"]);
                        case 1:
                          encryptionKey = _context4.sent;
                          return _context4.abrupt("return", {
                            material,
                            encryptionKey
                          });
                        case 2:
                        case "end":
                          return _context4.stop();
                      }
                    }, _callee4);
                  }));
                  return _deriveKeys.apply(this, arguments);
                }
                function createE2EEKey() {
                  return window.crypto.getRandomValues(new Uint8Array(32));
                }
                function ratchet(_x6, _x7) {
                  return _ratchet.apply(this, arguments);
                }
                function _ratchet() {
                  _ratchet = _asyncToGenerator(_regeneratorRuntime.mark(function _callee5(material, salt) {
                    var algorithmOptions;
                    return _regeneratorRuntime.wrap(function(_context5) {
                      while (1) switch (_context5.prev = _context5.next) {
                        case 0:
                          algorithmOptions = getAlgoOptions(material.algorithm.name, salt);
                          return _context5.abrupt("return", crypto.subtle.deriveBits(algorithmOptions, material, 256));
                        case 1:
                        case "end":
                          return _context5.stop();
                      }
                    }, _callee5);
                  }));
                  return _ratchet.apply(this, arguments);
                }
                function needsRbspUnescaping(frameData) {
                  for (var i = 0; i < frameData.length - 3; i++) {
                    if (frameData[i] == 0 && frameData[i + 1] == 0 && frameData[i + 2] == 3) return true;
                  }
                  return false;
                }
                function parseRbsp(stream) {
                  var dataOut = [];
                  var length = stream.length;
                  for (var i = 0; i < stream.length; ) {
                    if (length - i >= 3 && !stream[i] && !stream[i + 1] && stream[i + 2] == 3) {
                      dataOut.push(stream[i++]);
                      dataOut.push(stream[i++]);
                      i++;
                    } else {
                      dataOut.push(stream[i++]);
                    }
                  }
                  return new Uint8Array(dataOut);
                }
                var kZerosInStartSequence = 2;
                var kEmulationByte = 3;
                function writeRbsp(data_in) {
                  var dataOut = [];
                  var numConsecutiveZeros = 0;
                  for (var i = 0; i < data_in.length; ++i) {
                    var _byte = data_in[i];
                    if (_byte <= kEmulationByte && numConsecutiveZeros >= kZerosInStartSequence) {
                      dataOut.push(kEmulationByte);
                      numConsecutiveZeros = 0;
                    }
                    dataOut.push(_byte);
                    if (_byte == 0) {
                      ++numConsecutiveZeros;
                    } else {
                      numConsecutiveZeros = 0;
                    }
                  }
                  return new Uint8Array(dataOut);
                }
                function mimeTypeToVideoCodecString(mimeType) {
                  return mimeType.split("/")[1].toLowerCase();
                }
              }
            ),
            /***/
            8454: (
              /***/
              function(module2, exports2, __webpack_require__2) {
                ;
                (function(root, factory, undef) {
                  if (true) {
                    module2.exports = exports2 = factory(__webpack_require__2(9021), __webpack_require__2(7165));
                  } else {
                  }
                })(this, function(CryptoJS) {
                  CryptoJS.mode.ECB = function() {
                    var ECB = CryptoJS.lib.BlockCipherMode.extend();
                    ECB.Encryptor = ECB.extend({
                      processBlock: function(words, offset) {
                        this._cipher.encryptBlock(words, offset);
                      }
                    });
                    ECB.Decryptor = ECB.extend({
                      processBlock: function(words, offset) {
                        this._cipher.decryptBlock(words, offset);
                      }
                    });
                    return ECB;
                  }();
                  return CryptoJS.mode.ECB;
                });
              }
            ),
            /***/
            8624: (
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                "use strict";
                __webpack_require__2.r(__webpack_exports__2);
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  DOMException: () => (
                    /* binding */
                    DOMException2
                  ),
                  /* harmony export */
                  Headers: () => (
                    /* binding */
                    Headers2
                  ),
                  /* harmony export */
                  Request: () => (
                    /* binding */
                    Request
                  ),
                  /* harmony export */
                  Response: () => (
                    /* binding */
                    Response
                  ),
                  /* harmony export */
                  fetch: () => (
                    /* binding */
                    fetch2
                  )
                  /* harmony export */
                });
                var g = typeof globalThis !== "undefined" && globalThis || typeof self !== "undefined" && self || // eslint-disable-next-line no-undef
                typeof __webpack_require__2.g !== "undefined" && __webpack_require__2.g || {};
                var support = {
                  searchParams: "URLSearchParams" in g,
                  iterable: "Symbol" in g && "iterator" in Symbol,
                  blob: "FileReader" in g && "Blob" in g && function() {
                    try {
                      new Blob();
                      return true;
                    } catch (e) {
                      return false;
                    }
                  }(),
                  formData: "FormData" in g,
                  arrayBuffer: "ArrayBuffer" in g
                };
                function isDataView(obj) {
                  return obj && DataView.prototype.isPrototypeOf(obj);
                }
                if (support.arrayBuffer) {
                  var viewClasses = [
                    "[object Int8Array]",
                    "[object Uint8Array]",
                    "[object Uint8ClampedArray]",
                    "[object Int16Array]",
                    "[object Uint16Array]",
                    "[object Int32Array]",
                    "[object Uint32Array]",
                    "[object Float32Array]",
                    "[object Float64Array]"
                  ];
                  var isArrayBufferView = ArrayBuffer.isView || function(obj) {
                    return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1;
                  };
                }
                function normalizeName(name) {
                  if (typeof name !== "string") {
                    name = String(name);
                  }
                  if (/[^a-z0-9\-#$%&'*+.^_`|~!]/i.test(name) || name === "") {
                    throw new TypeError('Invalid character in header field name: "' + name + '"');
                  }
                  return name.toLowerCase();
                }
                function normalizeValue(value) {
                  if (typeof value !== "string") {
                    value = String(value);
                  }
                  return value;
                }
                function iteratorFor(items) {
                  var iterator = {
                    next: function() {
                      var value = items.shift();
                      return { done: value === void 0, value };
                    }
                  };
                  if (support.iterable) {
                    iterator[Symbol.iterator] = function() {
                      return iterator;
                    };
                  }
                  return iterator;
                }
                function Headers2(headers) {
                  this.map = {};
                  if (headers instanceof Headers2) {
                    headers.forEach(function(value, name) {
                      this.append(name, value);
                    }, this);
                  } else if (Array.isArray(headers)) {
                    headers.forEach(function(header) {
                      if (header.length != 2) {
                        throw new TypeError("Headers constructor: expected name/value pair to be length 2, found" + header.length);
                      }
                      this.append(header[0], header[1]);
                    }, this);
                  } else if (headers) {
                    Object.getOwnPropertyNames(headers).forEach(function(name) {
                      this.append(name, headers[name]);
                    }, this);
                  }
                }
                Headers2.prototype.append = function(name, value) {
                  name = normalizeName(name);
                  value = normalizeValue(value);
                  var oldValue = this.map[name];
                  this.map[name] = oldValue ? oldValue + ", " + value : value;
                };
                Headers2.prototype["delete"] = function(name) {
                  delete this.map[normalizeName(name)];
                };
                Headers2.prototype.get = function(name) {
                  name = normalizeName(name);
                  return this.has(name) ? this.map[name] : null;
                };
                Headers2.prototype.has = function(name) {
                  return this.map.hasOwnProperty(normalizeName(name));
                };
                Headers2.prototype.set = function(name, value) {
                  this.map[normalizeName(name)] = normalizeValue(value);
                };
                Headers2.prototype.forEach = function(callback, thisArg) {
                  for (var name in this.map) {
                    if (this.map.hasOwnProperty(name)) {
                      callback.call(thisArg, this.map[name], name, this);
                    }
                  }
                };
                Headers2.prototype.keys = function() {
                  var items = [];
                  this.forEach(function(value, name) {
                    items.push(name);
                  });
                  return iteratorFor(items);
                };
                Headers2.prototype.values = function() {
                  var items = [];
                  this.forEach(function(value) {
                    items.push(value);
                  });
                  return iteratorFor(items);
                };
                Headers2.prototype.entries = function() {
                  var items = [];
                  this.forEach(function(value, name) {
                    items.push([name, value]);
                  });
                  return iteratorFor(items);
                };
                if (support.iterable) {
                  Headers2.prototype[Symbol.iterator] = Headers2.prototype.entries;
                }
                function consumed(body) {
                  if (body._noBody) return;
                  if (body.bodyUsed) {
                    return Promise.reject(new TypeError("Already read"));
                  }
                  body.bodyUsed = true;
                }
                function fileReaderReady(reader) {
                  return new Promise(function(resolve, reject) {
                    reader.onload = function() {
                      resolve(reader.result);
                    };
                    reader.onerror = function() {
                      reject(reader.error);
                    };
                  });
                }
                function readBlobAsArrayBuffer(blob) {
                  var reader = new FileReader();
                  var promise = fileReaderReady(reader);
                  reader.readAsArrayBuffer(blob);
                  return promise;
                }
                function readBlobAsText(blob) {
                  var reader = new FileReader();
                  var promise = fileReaderReady(reader);
                  var match = /charset=([A-Za-z0-9_-]+)/.exec(blob.type);
                  var encoding = match ? match[1] : "utf-8";
                  reader.readAsText(blob, encoding);
                  return promise;
                }
                function readArrayBufferAsText(buf) {
                  var view = new Uint8Array(buf);
                  var chars = new Array(view.length);
                  for (var i = 0; i < view.length; i++) {
                    chars[i] = String.fromCharCode(view[i]);
                  }
                  return chars.join("");
                }
                function bufferClone(buf) {
                  if (buf.slice) {
                    return buf.slice(0);
                  } else {
                    var view = new Uint8Array(buf.byteLength);
                    view.set(new Uint8Array(buf));
                    return view.buffer;
                  }
                }
                function Body() {
                  this.bodyUsed = false;
                  this._initBody = function(body) {
                    this.bodyUsed = this.bodyUsed;
                    this._bodyInit = body;
                    if (!body) {
                      this._noBody = true;
                      this._bodyText = "";
                    } else if (typeof body === "string") {
                      this._bodyText = body;
                    } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
                      this._bodyBlob = body;
                    } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
                      this._bodyFormData = body;
                    } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
                      this._bodyText = body.toString();
                    } else if (support.arrayBuffer && support.blob && isDataView(body)) {
                      this._bodyArrayBuffer = bufferClone(body.buffer);
                      this._bodyInit = new Blob([this._bodyArrayBuffer]);
                    } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
                      this._bodyArrayBuffer = bufferClone(body);
                    } else {
                      this._bodyText = body = Object.prototype.toString.call(body);
                    }
                    if (!this.headers.get("content-type")) {
                      if (typeof body === "string") {
                        this.headers.set("content-type", "text/plain;charset=UTF-8");
                      } else if (this._bodyBlob && this._bodyBlob.type) {
                        this.headers.set("content-type", this._bodyBlob.type);
                      } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
                        this.headers.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8");
                      }
                    }
                  };
                  if (support.blob) {
                    this.blob = function() {
                      var rejected = consumed(this);
                      if (rejected) {
                        return rejected;
                      }
                      if (this._bodyBlob) {
                        return Promise.resolve(this._bodyBlob);
                      } else if (this._bodyArrayBuffer) {
                        return Promise.resolve(new Blob([this._bodyArrayBuffer]));
                      } else if (this._bodyFormData) {
                        throw new Error("could not read FormData body as blob");
                      } else {
                        return Promise.resolve(new Blob([this._bodyText]));
                      }
                    };
                  }
                  this.arrayBuffer = function() {
                    if (this._bodyArrayBuffer) {
                      var isConsumed = consumed(this);
                      if (isConsumed) {
                        return isConsumed;
                      } else if (ArrayBuffer.isView(this._bodyArrayBuffer)) {
                        return Promise.resolve(
                          this._bodyArrayBuffer.buffer.slice(
                            this._bodyArrayBuffer.byteOffset,
                            this._bodyArrayBuffer.byteOffset + this._bodyArrayBuffer.byteLength
                          )
                        );
                      } else {
                        return Promise.resolve(this._bodyArrayBuffer);
                      }
                    } else if (support.blob) {
                      return this.blob().then(readBlobAsArrayBuffer);
                    } else {
                      throw new Error("could not read as ArrayBuffer");
                    }
                  };
                  this.text = function() {
                    var rejected = consumed(this);
                    if (rejected) {
                      return rejected;
                    }
                    if (this._bodyBlob) {
                      return readBlobAsText(this._bodyBlob);
                    } else if (this._bodyArrayBuffer) {
                      return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer));
                    } else if (this._bodyFormData) {
                      throw new Error("could not read FormData body as text");
                    } else {
                      return Promise.resolve(this._bodyText);
                    }
                  };
                  if (support.formData) {
                    this.formData = function() {
                      return this.text().then(decode);
                    };
                  }
                  this.json = function() {
                    return this.text().then(JSON.parse);
                  };
                  return this;
                }
                var methods = ["CONNECT", "DELETE", "GET", "HEAD", "OPTIONS", "PATCH", "POST", "PUT", "TRACE"];
                function normalizeMethod(method) {
                  var upcased = method.toUpperCase();
                  return methods.indexOf(upcased) > -1 ? upcased : method;
                }
                function Request(input, options) {
                  if (!(this instanceof Request)) {
                    throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.');
                  }
                  options = options || {};
                  var body = options.body;
                  if (input instanceof Request) {
                    if (input.bodyUsed) {
                      throw new TypeError("Already read");
                    }
                    this.url = input.url;
                    this.credentials = input.credentials;
                    if (!options.headers) {
                      this.headers = new Headers2(input.headers);
                    }
                    this.method = input.method;
                    this.mode = input.mode;
                    this.signal = input.signal;
                    if (!body && input._bodyInit != null) {
                      body = input._bodyInit;
                      input.bodyUsed = true;
                    }
                  } else {
                    this.url = String(input);
                  }
                  this.credentials = options.credentials || this.credentials || "same-origin";
                  if (options.headers || !this.headers) {
                    this.headers = new Headers2(options.headers);
                  }
                  this.method = normalizeMethod(options.method || this.method || "GET");
                  this.mode = options.mode || this.mode || null;
                  this.signal = options.signal || this.signal || function() {
                    if ("AbortController" in g) {
                      var ctrl = new AbortController();
                      return ctrl.signal;
                    }
                  }();
                  this.referrer = null;
                  if ((this.method === "GET" || this.method === "HEAD") && body) {
                    throw new TypeError("Body not allowed for GET or HEAD requests");
                  }
                  this._initBody(body);
                  if (this.method === "GET" || this.method === "HEAD") {
                    if (options.cache === "no-store" || options.cache === "no-cache") {
                      var reParamSearch = /([?&])_=[^&]*/;
                      if (reParamSearch.test(this.url)) {
                        this.url = this.url.replace(reParamSearch, "$1_=" + (/* @__PURE__ */ new Date()).getTime());
                      } else {
                        var reQueryString = /\?/;
                        this.url += (reQueryString.test(this.url) ? "&" : "?") + "_=" + (/* @__PURE__ */ new Date()).getTime();
                      }
                    }
                  }
                }
                Request.prototype.clone = function() {
                  return new Request(this, { body: this._bodyInit });
                };
                function decode(body) {
                  var form = new FormData();
                  body.trim().split("&").forEach(function(bytes) {
                    if (bytes) {
                      var split = bytes.split("=");
                      var name = split.shift().replace(/\+/g, " ");
                      var value = split.join("=").replace(/\+/g, " ");
                      form.append(decodeURIComponent(name), decodeURIComponent(value));
                    }
                  });
                  return form;
                }
                function parseHeaders(rawHeaders) {
                  var headers = new Headers2();
                  var preProcessedHeaders = rawHeaders.replace(/\r?\n[\t ]+/g, " ");
                  preProcessedHeaders.split("\r").map(function(header) {
                    return header.indexOf("\n") === 0 ? header.substr(1, header.length) : header;
                  }).forEach(function(line) {
                    var parts = line.split(":");
                    var key = parts.shift().trim();
                    if (key) {
                      var value = parts.join(":").trim();
                      try {
                        headers.append(key, value);
                      } catch (error) {
                        console.warn("Response " + error.message);
                      }
                    }
                  });
                  return headers;
                }
                Body.call(Request.prototype);
                function Response(bodyInit, options) {
                  if (!(this instanceof Response)) {
                    throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.');
                  }
                  if (!options) {
                    options = {};
                  }
                  this.type = "default";
                  this.status = options.status === void 0 ? 200 : options.status;
                  if (this.status < 200 || this.status > 599) {
                    throw new RangeError("Failed to construct 'Response': The status provided (0) is outside the range [200, 599].");
                  }
                  this.ok = this.status >= 200 && this.status < 300;
                  this.statusText = options.statusText === void 0 ? "" : "" + options.statusText;
                  this.headers = new Headers2(options.headers);
                  this.url = options.url || "";
                  this._initBody(bodyInit);
                }
                Body.call(Response.prototype);
                Response.prototype.clone = function() {
                  return new Response(this._bodyInit, {
                    status: this.status,
                    statusText: this.statusText,
                    headers: new Headers2(this.headers),
                    url: this.url
                  });
                };
                Response.error = function() {
                  var response = new Response(null, { status: 200, statusText: "" });
                  response.ok = false;
                  response.status = 0;
                  response.type = "error";
                  return response;
                };
                var redirectStatuses = [301, 302, 303, 307, 308];
                Response.redirect = function(url, status) {
                  if (redirectStatuses.indexOf(status) === -1) {
                    throw new RangeError("Invalid status code");
                  }
                  return new Response(null, { status, headers: { location: url } });
                };
                var DOMException2 = g.DOMException;
                try {
                  new DOMException2();
                } catch (err) {
                  DOMException2 = function(message, name) {
                    this.message = message;
                    this.name = name;
                    var error = Error(message);
                    this.stack = error.stack;
                  };
                  DOMException2.prototype = Object.create(Error.prototype);
                  DOMException2.prototype.constructor = DOMException2;
                }
                function fetch2(input, init) {
                  return new Promise(function(resolve, reject) {
                    var request = new Request(input, init);
                    if (request.signal && request.signal.aborted) {
                      return reject(new DOMException2("Aborted", "AbortError"));
                    }
                    var xhr = new XMLHttpRequest();
                    function abortXhr() {
                      xhr.abort();
                    }
                    xhr.onload = function() {
                      var options = {
                        statusText: xhr.statusText,
                        headers: parseHeaders(xhr.getAllResponseHeaders() || "")
                      };
                      if (request.url.indexOf("file://") === 0 && (xhr.status < 200 || xhr.status > 599)) {
                        options.status = 200;
                      } else {
                        options.status = xhr.status;
                      }
                      options.url = "responseURL" in xhr ? xhr.responseURL : options.headers.get("X-Request-URL");
                      var body = "response" in xhr ? xhr.response : xhr.responseText;
                      setTimeout(function() {
                        resolve(new Response(body, options));
                      }, 0);
                    };
                    xhr.onerror = function() {
                      setTimeout(function() {
                        reject(new TypeError("Network request failed"));
                      }, 0);
                    };
                    xhr.ontimeout = function() {
                      setTimeout(function() {
                        reject(new TypeError("Network request timed out"));
                      }, 0);
                    };
                    xhr.onabort = function() {
                      setTimeout(function() {
                        reject(new DOMException2("Aborted", "AbortError"));
                      }, 0);
                    };
                    function fixUrl(url) {
                      try {
                        return url === "" && g.location.href ? g.location.href : url;
                      } catch (e) {
                        return url;
                      }
                    }
                    xhr.open(request.method, fixUrl(request.url), true);
                    if (request.credentials === "include") {
                      xhr.withCredentials = true;
                    } else if (request.credentials === "omit") {
                      xhr.withCredentials = false;
                    }
                    if ("responseType" in xhr) {
                      if (support.blob) {
                        xhr.responseType = "blob";
                      } else if (support.arrayBuffer) {
                        xhr.responseType = "arraybuffer";
                      }
                    }
                    if (init && typeof init.headers === "object" && !(init.headers instanceof Headers2 || g.Headers && init.headers instanceof g.Headers)) {
                      var names = [];
                      Object.getOwnPropertyNames(init.headers).forEach(function(name) {
                        names.push(normalizeName(name));
                        xhr.setRequestHeader(name, normalizeValue(init.headers[name]));
                      });
                      request.headers.forEach(function(value, name) {
                        if (names.indexOf(name) === -1) {
                          xhr.setRequestHeader(name, value);
                        }
                      });
                    } else {
                      request.headers.forEach(function(value, name) {
                        xhr.setRequestHeader(name, value);
                      });
                    }
                    if (request.signal) {
                      request.signal.addEventListener("abort", abortXhr);
                      xhr.onreadystatechange = function() {
                        if (xhr.readyState === 4) {
                          request.signal.removeEventListener("abort", abortXhr);
                        }
                      };
                    }
                    xhr.send(typeof request._bodyInit === "undefined" ? null : request._bodyInit);
                  });
                }
                fetch2.polyfill = true;
                if (!g.fetch) {
                  g.fetch = fetch2;
                  g.Headers = Headers2;
                  g.Request = Request;
                  g.Response = Response;
                }
              }
            ),
            /***/
            8876: (
              /***/
              (__unused_webpack_module, exports2, __webpack_require__2) => {
                "use strict";
                Object.defineProperty(exports2, "__esModule", { value: true });
                exports2.AwaitQueueRemovedTaskError = exports2.AwaitQueueStoppedError = exports2.AwaitQueue = void 0;
                var AwaitQueue_1 = __webpack_require__2(9275);
                Object.defineProperty(exports2, "AwaitQueue", { enumerable: true, get: function() {
                  return AwaitQueue_1.AwaitQueue;
                } });
                var errors_1 = __webpack_require__2(4253);
                Object.defineProperty(exports2, "AwaitQueueStoppedError", { enumerable: true, get: function() {
                  return errors_1.AwaitQueueStoppedError;
                } });
                Object.defineProperty(exports2, "AwaitQueueRemovedTaskError", { enumerable: true, get: function() {
                  return errors_1.AwaitQueueRemovedTaskError;
                } });
              }
            ),
            /***/
            9021: (
              /***/
              function(module2, exports2, __webpack_require__2) {
                ;
                (function(root, factory) {
                  if (true) {
                    module2.exports = exports2 = factory();
                  } else {
                  }
                })(this, function() {
                  var CryptoJS = CryptoJS || function(Math2, undefined2) {
                    var crypto2;
                    if (typeof window !== "undefined" && window.crypto) {
                      crypto2 = window.crypto;
                    }
                    if (typeof self !== "undefined" && self.crypto) {
                      crypto2 = self.crypto;
                    }
                    if (typeof globalThis !== "undefined" && globalThis.crypto) {
                      crypto2 = globalThis.crypto;
                    }
                    if (!crypto2 && typeof window !== "undefined" && window.msCrypto) {
                      crypto2 = window.msCrypto;
                    }
                    if (!crypto2 && typeof __webpack_require__2.g !== "undefined" && __webpack_require__2.g.crypto) {
                      crypto2 = __webpack_require__2.g.crypto;
                    }
                    if (!crypto2 && true) {
                      try {
                        crypto2 = __webpack_require__2(477);
                      } catch (err) {
                      }
                    }
                    var cryptoSecureRandomInt = function() {
                      if (crypto2) {
                        if (typeof crypto2.getRandomValues === "function") {
                          try {
                            return crypto2.getRandomValues(new Uint32Array(1))[0];
                          } catch (err) {
                          }
                        }
                        if (typeof crypto2.randomBytes === "function") {
                          try {
                            return crypto2.randomBytes(4).readInt32LE();
                          } catch (err) {
                          }
                        }
                      }
                      throw new Error("Native crypto module could not be used to get secure random number.");
                    };
                    var create = Object.create || /* @__PURE__ */ function() {
                      function F() {
                      }
                      return function(obj) {
                        var subtype;
                        F.prototype = obj;
                        subtype = new F();
                        F.prototype = null;
                        return subtype;
                      };
                    }();
                    var C = {};
                    var C_lib = C.lib = {};
                    var Base = C_lib.Base = /* @__PURE__ */ function() {
                      return {
                        /**
                         * Creates a new object that inherits from this object.
                         *
                         * @param {Object} overrides Properties to copy into the new object.
                         *
                         * @return {Object} The new object.
                         *
                         * @static
                         *
                         * @example
                         *
                         *     var MyType = CryptoJS.lib.Base.extend({
                         *         field: 'value',
                         *
                         *         method: function () {
                         *         }
                         *     });
                         */
                        extend: function(overrides) {
                          var subtype = create(this);
                          if (overrides) {
                            subtype.mixIn(overrides);
                          }
                          if (!subtype.hasOwnProperty("init") || this.init === subtype.init) {
                            subtype.init = function() {
                              subtype.$super.init.apply(this, arguments);
                            };
                          }
                          subtype.init.prototype = subtype;
                          subtype.$super = this;
                          return subtype;
                        },
                        /**
                         * Extends this object and runs the init method.
                         * Arguments to create() will be passed to init().
                         *
                         * @return {Object} The new object.
                         *
                         * @static
                         *
                         * @example
                         *
                         *     var instance = MyType.create();
                         */
                        create: function() {
                          var instance = this.extend();
                          instance.init.apply(instance, arguments);
                          return instance;
                        },
                        /**
                         * Initializes a newly created object.
                         * Override this method to add some logic when your objects are created.
                         *
                         * @example
                         *
                         *     var MyType = CryptoJS.lib.Base.extend({
                         *         init: function () {
                         *             // ...
                         *         }
                         *     });
                         */
                        init: function() {
                        },
                        /**
                         * Copies properties into this object.
                         *
                         * @param {Object} properties The properties to mix in.
                         *
                         * @example
                         *
                         *     MyType.mixIn({
                         *         field: 'value'
                         *     });
                         */
                        mixIn: function(properties) {
                          for (var propertyName in properties) {
                            if (properties.hasOwnProperty(propertyName)) {
                              this[propertyName] = properties[propertyName];
                            }
                          }
                          if (properties.hasOwnProperty("toString")) {
                            this.toString = properties.toString;
                          }
                        },
                        /**
                         * Creates a copy of this object.
                         *
                         * @return {Object} The clone.
                         *
                         * @example
                         *
                         *     var clone = instance.clone();
                         */
                        clone: function() {
                          return this.init.prototype.extend(this);
                        }
                      };
                    }();
                    var WordArray = C_lib.WordArray = Base.extend({
                      /**
                       * Initializes a newly created word array.
                       *
                       * @param {Array} words (Optional) An array of 32-bit words.
                       * @param {number} sigBytes (Optional) The number of significant bytes in the words.
                       *
                       * @example
                       *
                       *     var wordArray = CryptoJS.lib.WordArray.create();
                       *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607]);
                       *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607], 6);
                       */
                      init: function(words, sigBytes) {
                        words = this.words = words || [];
                        if (sigBytes != undefined2) {
                          this.sigBytes = sigBytes;
                        } else {
                          this.sigBytes = words.length * 4;
                        }
                      },
                      /**
                       * Converts this word array to a string.
                       *
                       * @param {Encoder} encoder (Optional) The encoding strategy to use. Default: CryptoJS.enc.Hex
                       *
                       * @return {string} The stringified word array.
                       *
                       * @example
                       *
                       *     var string = wordArray + '';
                       *     var string = wordArray.toString();
                       *     var string = wordArray.toString(CryptoJS.enc.Utf8);
                       */
                      toString: function(encoder) {
                        return (encoder || Hex).stringify(this);
                      },
                      /**
                       * Concatenates a word array to this word array.
                       *
                       * @param {WordArray} wordArray The word array to append.
                       *
                       * @return {WordArray} This word array.
                       *
                       * @example
                       *
                       *     wordArray1.concat(wordArray2);
                       */
                      concat: function(wordArray) {
                        var thisWords = this.words;
                        var thatWords = wordArray.words;
                        var thisSigBytes = this.sigBytes;
                        var thatSigBytes = wordArray.sigBytes;
                        this.clamp();
                        if (thisSigBytes % 4) {
                          for (var i = 0; i < thatSigBytes; i++) {
                            var thatByte = thatWords[i >>> 2] >>> 24 - i % 4 * 8 & 255;
                            thisWords[thisSigBytes + i >>> 2] |= thatByte << 24 - (thisSigBytes + i) % 4 * 8;
                          }
                        } else {
                          for (var j = 0; j < thatSigBytes; j += 4) {
                            thisWords[thisSigBytes + j >>> 2] = thatWords[j >>> 2];
                          }
                        }
                        this.sigBytes += thatSigBytes;
                        return this;
                      },
                      /**
                       * Removes insignificant bits.
                       *
                       * @example
                       *
                       *     wordArray.clamp();
                       */
                      clamp: function() {
                        var words = this.words;
                        var sigBytes = this.sigBytes;
                        words[sigBytes >>> 2] &= 4294967295 << 32 - sigBytes % 4 * 8;
                        words.length = Math2.ceil(sigBytes / 4);
                      },
                      /**
                       * Creates a copy of this word array.
                       *
                       * @return {WordArray} The clone.
                       *
                       * @example
                       *
                       *     var clone = wordArray.clone();
                       */
                      clone: function() {
                        var clone = Base.clone.call(this);
                        clone.words = this.words.slice(0);
                        return clone;
                      },
                      /**
                       * Creates a word array filled with random bytes.
                       *
                       * @param {number} nBytes The number of random bytes to generate.
                       *
                       * @return {WordArray} The random word array.
                       *
                       * @static
                       *
                       * @example
                       *
                       *     var wordArray = CryptoJS.lib.WordArray.random(16);
                       */
                      random: function(nBytes) {
                        var words = [];
                        for (var i = 0; i < nBytes; i += 4) {
                          words.push(cryptoSecureRandomInt());
                        }
                        return new WordArray.init(words, nBytes);
                      }
                    });
                    var C_enc = C.enc = {};
                    var Hex = C_enc.Hex = {
                      /**
                       * Converts a word array to a hex string.
                       *
                       * @param {WordArray} wordArray The word array.
                       *
                       * @return {string} The hex string.
                       *
                       * @static
                       *
                       * @example
                       *
                       *     var hexString = CryptoJS.enc.Hex.stringify(wordArray);
                       */
                      stringify: function(wordArray) {
                        var words = wordArray.words;
                        var sigBytes = wordArray.sigBytes;
                        var hexChars = [];
                        for (var i = 0; i < sigBytes; i++) {
                          var bite = words[i >>> 2] >>> 24 - i % 4 * 8 & 255;
                          hexChars.push((bite >>> 4).toString(16));
                          hexChars.push((bite & 15).toString(16));
                        }
                        return hexChars.join("");
                      },
                      /**
                       * Converts a hex string to a word array.
                       *
                       * @param {string} hexStr The hex string.
                       *
                       * @return {WordArray} The word array.
                       *
                       * @static
                       *
                       * @example
                       *
                       *     var wordArray = CryptoJS.enc.Hex.parse(hexString);
                       */
                      parse: function(hexStr) {
                        var hexStrLength = hexStr.length;
                        var words = [];
                        for (var i = 0; i < hexStrLength; i += 2) {
                          words[i >>> 3] |= parseInt(hexStr.substr(i, 2), 16) << 24 - i % 8 * 4;
                        }
                        return new WordArray.init(words, hexStrLength / 2);
                      }
                    };
                    var Latin1 = C_enc.Latin1 = {
                      /**
                       * Converts a word array to a Latin1 string.
                       *
                       * @param {WordArray} wordArray The word array.
                       *
                       * @return {string} The Latin1 string.
                       *
                       * @static
                       *
                       * @example
                       *
                       *     var latin1String = CryptoJS.enc.Latin1.stringify(wordArray);
                       */
                      stringify: function(wordArray) {
                        var words = wordArray.words;
                        var sigBytes = wordArray.sigBytes;
                        var latin1Chars = [];
                        for (var i = 0; i < sigBytes; i++) {
                          var bite = words[i >>> 2] >>> 24 - i % 4 * 8 & 255;
                          latin1Chars.push(String.fromCharCode(bite));
                        }
                        return latin1Chars.join("");
                      },
                      /**
                       * Converts a Latin1 string to a word array.
                       *
                       * @param {string} latin1Str The Latin1 string.
                       *
                       * @return {WordArray} The word array.
                       *
                       * @static
                       *
                       * @example
                       *
                       *     var wordArray = CryptoJS.enc.Latin1.parse(latin1String);
                       */
                      parse: function(latin1Str) {
                        var latin1StrLength = latin1Str.length;
                        var words = [];
                        for (var i = 0; i < latin1StrLength; i++) {
                          words[i >>> 2] |= (latin1Str.charCodeAt(i) & 255) << 24 - i % 4 * 8;
                        }
                        return new WordArray.init(words, latin1StrLength);
                      }
                    };
                    var Utf8 = C_enc.Utf8 = {
                      /**
                       * Converts a word array to a UTF-8 string.
                       *
                       * @param {WordArray} wordArray The word array.
                       *
                       * @return {string} The UTF-8 string.
                       *
                       * @static
                       *
                       * @example
                       *
                       *     var utf8String = CryptoJS.enc.Utf8.stringify(wordArray);
                       */
                      stringify: function(wordArray) {
                        try {
                          return decodeURIComponent(escape(Latin1.stringify(wordArray)));
                        } catch (e) {
                          throw new Error("Malformed UTF-8 data");
                        }
                      },
                      /**
                       * Converts a UTF-8 string to a word array.
                       *
                       * @param {string} utf8Str The UTF-8 string.
                       *
                       * @return {WordArray} The word array.
                       *
                       * @static
                       *
                       * @example
                       *
                       *     var wordArray = CryptoJS.enc.Utf8.parse(utf8String);
                       */
                      parse: function(utf8Str) {
                        return Latin1.parse(unescape(encodeURIComponent(utf8Str)));
                      }
                    };
                    var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm = Base.extend({
                      /**
                       * Resets this block algorithm's data buffer to its initial state.
                       *
                       * @example
                       *
                       *     bufferedBlockAlgorithm.reset();
                       */
                      reset: function() {
                        this._data = new WordArray.init();
                        this._nDataBytes = 0;
                      },
                      /**
                       * Adds new data to this block algorithm's buffer.
                       *
                       * @param {WordArray|string} data The data to append. Strings are converted to a WordArray using UTF-8.
                       *
                       * @example
                       *
                       *     bufferedBlockAlgorithm._append('data');
                       *     bufferedBlockAlgorithm._append(wordArray);
                       */
                      _append: function(data) {
                        if (typeof data == "string") {
                          data = Utf8.parse(data);
                        }
                        this._data.concat(data);
                        this._nDataBytes += data.sigBytes;
                      },
                      /**
                       * Processes available data blocks.
                       *
                       * This method invokes _doProcessBlock(offset), which must be implemented by a concrete subtype.
                       *
                       * @param {boolean} doFlush Whether all blocks and partial blocks should be processed.
                       *
                       * @return {WordArray} The processed data.
                       *
                       * @example
                       *
                       *     var processedData = bufferedBlockAlgorithm._process();
                       *     var processedData = bufferedBlockAlgorithm._process(!!'flush');
                       */
                      _process: function(doFlush) {
                        var processedWords;
                        var data = this._data;
                        var dataWords = data.words;
                        var dataSigBytes = data.sigBytes;
                        var blockSize = this.blockSize;
                        var blockSizeBytes = blockSize * 4;
                        var nBlocksReady = dataSigBytes / blockSizeBytes;
                        if (doFlush) {
                          nBlocksReady = Math2.ceil(nBlocksReady);
                        } else {
                          nBlocksReady = Math2.max((nBlocksReady | 0) - this._minBufferSize, 0);
                        }
                        var nWordsReady = nBlocksReady * blockSize;
                        var nBytesReady = Math2.min(nWordsReady * 4, dataSigBytes);
                        if (nWordsReady) {
                          for (var offset = 0; offset < nWordsReady; offset += blockSize) {
                            this._doProcessBlock(dataWords, offset);
                          }
                          processedWords = dataWords.splice(0, nWordsReady);
                          data.sigBytes -= nBytesReady;
                        }
                        return new WordArray.init(processedWords, nBytesReady);
                      },
                      /**
                       * Creates a copy of this object.
                       *
                       * @return {Object} The clone.
                       *
                       * @example
                       *
                       *     var clone = bufferedBlockAlgorithm.clone();
                       */
                      clone: function() {
                        var clone = Base.clone.call(this);
                        clone._data = this._data.clone();
                        return clone;
                      },
                      _minBufferSize: 0
                    });
                    var Hasher = C_lib.Hasher = BufferedBlockAlgorithm.extend({
                      /**
                       * Configuration options.
                       */
                      cfg: Base.extend(),
                      /**
                       * Initializes a newly created hasher.
                       *
                       * @param {Object} cfg (Optional) The configuration options to use for this hash computation.
                       *
                       * @example
                       *
                       *     var hasher = CryptoJS.algo.SHA256.create();
                       */
                      init: function(cfg) {
                        this.cfg = this.cfg.extend(cfg);
                        this.reset();
                      },
                      /**
                       * Resets this hasher to its initial state.
                       *
                       * @example
                       *
                       *     hasher.reset();
                       */
                      reset: function() {
                        BufferedBlockAlgorithm.reset.call(this);
                        this._doReset();
                      },
                      /**
                       * Updates this hasher with a message.
                       *
                       * @param {WordArray|string} messageUpdate The message to append.
                       *
                       * @return {Hasher} This hasher.
                       *
                       * @example
                       *
                       *     hasher.update('message');
                       *     hasher.update(wordArray);
                       */
                      update: function(messageUpdate) {
                        this._append(messageUpdate);
                        this._process();
                        return this;
                      },
                      /**
                       * Finalizes the hash computation.
                       * Note that the finalize operation is effectively a destructive, read-once operation.
                       *
                       * @param {WordArray|string} messageUpdate (Optional) A final message update.
                       *
                       * @return {WordArray} The hash.
                       *
                       * @example
                       *
                       *     var hash = hasher.finalize();
                       *     var hash = hasher.finalize('message');
                       *     var hash = hasher.finalize(wordArray);
                       */
                      finalize: function(messageUpdate) {
                        if (messageUpdate) {
                          this._append(messageUpdate);
                        }
                        var hash = this._doFinalize();
                        return hash;
                      },
                      blockSize: 512 / 32,
                      /**
                       * Creates a shortcut function to a hasher's object interface.
                       *
                       * @param {Hasher} hasher The hasher to create a helper for.
                       *
                       * @return {Function} The shortcut function.
                       *
                       * @static
                       *
                       * @example
                       *
                       *     var SHA256 = CryptoJS.lib.Hasher._createHelper(CryptoJS.algo.SHA256);
                       */
                      _createHelper: function(hasher) {
                        return function(message, cfg) {
                          return new hasher.init(cfg).finalize(message);
                        };
                      },
                      /**
                       * Creates a shortcut function to the HMAC's object interface.
                       *
                       * @param {Hasher} hasher The hasher to use in this HMAC helper.
                       *
                       * @return {Function} The shortcut function.
                       *
                       * @static
                       *
                       * @example
                       *
                       *     var HmacSHA256 = CryptoJS.lib.Hasher._createHmacHelper(CryptoJS.algo.SHA256);
                       */
                      _createHmacHelper: function(hasher) {
                        return function(message, key) {
                          return new C_algo.HMAC.init(hasher, key).finalize(message);
                        };
                      }
                    });
                    var C_algo = C.algo = {};
                    return C;
                  }(Math);
                  return CryptoJS;
                });
              }
            ),
            /***/
            9027: (
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                "use strict";
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  $: () => (
                    /* binding */
                    config2
                  )
                  /* harmony export */
                });
                var config2 = {
                  /**
                   * Network priorities
                   * DSCP bits set by browser according this priority values.
                   * ("high" means actually: EF for audio, and AF41 for Video in chrome)
                   * https://en.wikipedia.org/wiki/Differentiated_services
                   */
                  networkPriorities: {
                    audio: "high",
                    dominatingVideo: "high",
                    otherVideos: "medium",
                    screenShare: "medium"
                  },
                  // The aspect ratio of the videos as shown on the screen.
                  // This is changeable in client settings.
                  // This value must match one of the defined values in
                  // aspectRatios EXACTLY (e.g. 1.333)
                  aspectRatios: {
                    fourThree: {
                      label: "fourThree",
                      value: 1.333
                    },
                    oneSixNine: {
                      label: "oneSixNine",
                      value: 1.777
                    }
                  },
                  audioProfiles: {
                    speech_low_quality: {
                      sampleRate: 16e3,
                      bitRate: 24,
                      sampleSize: 16,
                      stereo: false,
                      dtx: true,
                      fec: true,
                      maxPlaybackRate: 16e3,
                      packetTime: 20,
                      autoGainControl: true,
                      echoCancellation: true,
                      noiseSuppression: true,
                      channelCount: 1
                    },
                    speech_standard: {
                      sampleRate: 32e3,
                      bitRate: 24,
                      sampleSize: 24,
                      stereo: false,
                      dtx: true,
                      fec: true,
                      maxPlaybackRate: 32e3,
                      packetTime: 30,
                      autoGainControl: true,
                      echoCancellation: true,
                      noiseSuppression: true,
                      channelCount: 1
                    },
                    music_standard: {
                      sampleRate: 48e3,
                      bitRate: 40,
                      sampleSize: 32,
                      stereo: false,
                      dtx: false,
                      fec: true,
                      maxPlaybackRate: 48e3,
                      packetTime: 40,
                      autoGainControl: false,
                      echoCancellation: false,
                      noiseSuppression: false,
                      channelCount: 1
                    },
                    standard_stereo: {
                      sampleRate: 48e3,
                      sampleSize: 32,
                      bitRate: 64,
                      stereo: true,
                      dtx: false,
                      fec: true,
                      maxPlaybackRate: 48e3,
                      packetTime: 40,
                      autoGainControl: false,
                      echoCancellation: false,
                      noiseSuppression: false,
                      channelCount: 2
                    },
                    high_quality: {
                      sampleRate: 48e3,
                      sampleSize: 32,
                      bitRate: 128,
                      stereo: false,
                      dtx: false,
                      fec: true,
                      maxPlaybackRate: 48e3,
                      packetTime: 60,
                      autoGainControl: false,
                      echoCancellation: false,
                      noiseSuppression: false,
                      channelCount: 1
                    },
                    high_quality_stereo: {
                      sampleRate: 48e3,
                      sampleSize: 32,
                      bitRate: 192,
                      stereo: true,
                      dtx: false,
                      fec: true,
                      maxPlaybackRate: 48e3,
                      packetTime: 60,
                      autoGainControl: false,
                      echoCancellation: false,
                      noiseSuppression: false,
                      channelCount: 2
                    }
                  },
                  videoProfiles: {
                    // TODO: portrait mode
                    h90p_w160p: {
                      width: 160,
                      height: 90,
                      bitRate: 60 * 1e3,
                      frameRate: 15,
                      aspectRatio: "oneSixNine"
                    },
                    h180p_w320p: {
                      width: 320,
                      height: 180,
                      bitRate: 120 * 1e3,
                      frameRate: 15,
                      aspectRatio: "oneSixNine"
                    },
                    h216p_w384p: {
                      width: 384,
                      height: 216,
                      bitRate: 180 * 1e3,
                      frameRate: 15,
                      aspectRatio: "oneSixNine"
                    },
                    h360p_w640p: {
                      width: 640,
                      height: 360,
                      bitRate: 300 * 1e3,
                      frameRate: 20,
                      aspectRatio: "oneSixNine"
                    },
                    h360p_w640p_150kbps: {
                      width: 640,
                      height: 360,
                      bitRate: 150 * 1e3,
                      frameRate: 15,
                      aspectRatio: "oneSixNine"
                    },
                    h540p_w960p: {
                      width: 960,
                      height: 540,
                      bitRate: 600 * 1e3,
                      frameRate: 25,
                      aspectRatio: "oneSixNine"
                    },
                    h540p_w960p_500kbps: {
                      width: 960,
                      height: 540,
                      bitRate: 500 * 1e3,
                      frameRate: 25,
                      aspectRatio: "oneSixNine"
                    },
                    h720p_w1280p: {
                      width: 1280,
                      height: 720,
                      bitRate: 2e3 * 1e3,
                      frameRate: 30,
                      aspectRatio: "oneSixNine"
                    },
                    h1080p_w1920p: {
                      width: 1920,
                      height: 1080,
                      bitRate: 3e3 * 1e3,
                      frameRate: 30,
                      aspectRatio: "oneSixNine"
                    },
                    h1440p_w2560p: {
                      width: 2560,
                      height: 1440,
                      bitRate: 5e3 * 1e3,
                      frameRate: 30,
                      aspectRatio: "oneSixNine"
                    },
                    h2160p_w3840p: {
                      width: 3840,
                      height: 2160,
                      bitRate: 8e3 * 1e3,
                      frameRate: 30,
                      aspectRatio: "oneSixNine"
                    },
                    h120p_w160p: {
                      width: 160,
                      height: 120,
                      bitRate: 80 * 1e3,
                      frameRate: 15,
                      aspectRatio: "fourThree"
                    },
                    h180p_w240p: {
                      width: 240,
                      height: 180,
                      bitRate: 100 * 1e3,
                      frameRate: 15,
                      aspectRatio: "fourThree"
                    },
                    h240p_w320p: {
                      width: 320,
                      height: 240,
                      bitRate: 150 * 1e3,
                      frameRate: 15,
                      aspectRatio: "fourThree"
                    },
                    h360p_w480p: {
                      width: 480,
                      height: 360,
                      bitRate: 225 * 1e3,
                      frameRate: 20,
                      aspectRatio: "fourThree"
                    },
                    h480p_w640p: {
                      width: 640,
                      height: 480,
                      bitRate: 300 * 1e3,
                      frameRate: 25,
                      aspectRatio: "fourThree"
                    },
                    h540p_w720p: {
                      width: 720,
                      height: 540,
                      bitRate: 450 * 1e3,
                      frameRate: 30,
                      aspectRatio: "fourThree"
                    },
                    h720p_w960p: {
                      width: 960,
                      height: 720,
                      bitRate: 1500 * 1e3,
                      frameRate: 30,
                      aspectRatio: "fourThree"
                    },
                    h1080p_w1440p: {
                      width: 1440,
                      height: 1080,
                      bitRate: 2500 * 1e3,
                      frameRate: 30,
                      aspectRatio: "fourThree"
                    },
                    h1440p_w1920p: {
                      width: 1920,
                      height: 1440,
                      bitRate: 3500 * 1e3,
                      frameRate: 30,
                      aspectRatio: "fourThree"
                    }
                  },
                  // OLD Profiles
                  // screenShareProfiles: {
                  //   h360p_30fps: {
                  //     width: 640,
                  //     height: 360,
                  //     bitRate: 200 * 1000,
                  //     frameRate: 30,
                  //   },
                  //   h720p_5fps: {
                  //     width: 1280,
                  //     height: 720,
                  //     bitRate: 400 * 1000,
                  //     frameRate: 5,
                  //   },
                  //   h720p_15fps: {
                  //     width: 1280,
                  //     height: 720,
                  //     bitRate: 1000 * 1000,
                  //     frameRate: 15,
                  //   },
                  //   h1080p_15fps: {
                  //     width: 1920,
                  //     height: 1080,
                  //     bitRate: 1500 * 1000,
                  //     frameRate: 15,
                  //   },
                  //   h1080p_30fps: {
                  //     width: 1920,
                  //     height: 1080,
                  //     bitRate: 1000 * 1000,
                  //     frameRate: 30,
                  //   },
                  // },
                  // Define different encodings for various resolutions of the video.
                  // New Profiles
                  screenShareProfiles: {
                    h360p_30fps: {
                      resolution: {
                        width: 640,
                        height: 360
                      },
                      frameRate: 30,
                      bitrates: {
                        high: 4e5,
                        // 400 kbps
                        medium: 2e5,
                        // 200 kbps
                        low: 1e5
                        // 100 kbps
                      }
                    },
                    h480p_15fps: {
                      resolution: {
                        width: 854,
                        height: 480
                      },
                      frameRate: 15,
                      bitrates: {
                        high: 3e5,
                        medium: 15e4,
                        low: 75e3
                      }
                    },
                    h480p_30fps: {
                      resolution: {
                        width: 854,
                        height: 480
                      },
                      frameRate: 30,
                      bitrates: {
                        high: 5e5,
                        medium: 25e4,
                        low: 125e3
                      }
                    },
                    h720p_5fps: {
                      resolution: {
                        width: 1280,
                        height: 720
                      },
                      frameRate: 5,
                      bitrates: {
                        high: 4e5,
                        medium: 2e5,
                        low: 1e5
                      }
                    },
                    h720p_15fps: {
                      resolution: {
                        width: 1280,
                        height: 720
                      },
                      frameRate: 15,
                      bitrates: {
                        high: 1e6,
                        medium: 5e5,
                        low: 25e4
                      }
                    },
                    h720p_30fps: {
                      resolution: {
                        width: 1280,
                        height: 720
                      },
                      frameRate: 30,
                      bitrates: {
                        high: 15e5,
                        medium: 75e4,
                        low: 375e3
                      }
                    },
                    h1080p_15fps: {
                      resolution: {
                        width: 1920,
                        height: 1080
                      },
                      frameRate: 15,
                      bitrates: {
                        high: 15e5,
                        medium: 75e4,
                        low: 3e5
                      }
                    },
                    h1080p_30fps: {
                      resolution: {
                        width: 1920,
                        height: 1080
                      },
                      frameRate: 30,
                      bitrates: {
                        high: 2e6,
                        // 2 Mbps
                        medium: 1e6,
                        // 1 Mbps
                        low: 5e5
                        // 500 kbps
                      }
                    }
                  },
                  simulcastProfiles: {
                    3840: [{
                      scaleResolutionDownBy: 12,
                      maxBitRate: 150 * 1e3
                    }, {
                      scaleResolutionDownBy: 6,
                      maxBitRate: 500 * 1e3
                    }, {
                      scaleResolutionDownBy: 1,
                      maxBitRate: 1e3 * 1e4
                    }],
                    1920: [{
                      scaleResolutionDownBy: 6,
                      maxBitRate: 150 * 1e3
                    }, {
                      scaleResolutionDownBy: 3,
                      maxBitRate: 500 * 1e3
                    }, {
                      scaleResolutionDownBy: 1,
                      maxBitRate: 350 * 1e4
                    }],
                    1280: [{
                      scaleResolutionDownBy: 4,
                      maxBitRate: 150 * 1e3
                    }, {
                      scaleResolutionDownBy: 2,
                      maxBitRate: 500 * 1e3
                    }, {
                      scaleResolutionDownBy: 1,
                      maxBitRate: 120 * 1e4
                    }],
                    640: [{
                      scaleResolutionDownBy: 2,
                      maxBitRate: 150 * 1e3
                    }, {
                      scaleResolutionDownBy: 1,
                      maxBitRate: 500 * 1e3
                    }],
                    320: [{
                      scaleResolutionDownBy: 1,
                      maxBitRate: 150 * 1e3
                    }]
                  },
                  // The Socket.io request timeout.
                  requestTimeout: 2e4,
                  // The Socket.io request maximum retries.
                  requestRetries: 3,
                  // The Mediasoup transport options.
                  transportOptions: {
                    tcp: true
                  },
                  // Used for VP9 webcam video.
                  videoKSVCEncodings: [{
                    scalabilityMode: "S3T3_KEY"
                  }],
                  // Used for VP9 desktop sharing.
                  videoSVCEncodings: [{
                    scalabilityMode: "S3T3",
                    dtx: true
                  }]
                };
              }
            ),
            /***/
            9166: (
              /***/
              (__unused_webpack_module, exports2, __webpack_require__2) => {
                "use strict";
                Object.defineProperty(exports2, "__esModule", { value: true });
                exports2.DataConsumer = void 0;
                const Logger_1 = __webpack_require__2(2994);
                const enhancedEvents_1 = __webpack_require__2(3953);
                const logger = new Logger_1.Logger("DataConsumer");
                class DataConsumer extends enhancedEvents_1.EnhancedEventEmitter {
                  constructor({ id, dataProducerId, dataChannel, sctpStreamParameters, appData }) {
                    super();
                    // Id.
                    __publicField(this, "_id");
                    // Associated DataProducer Id.
                    __publicField(this, "_dataProducerId");
                    // The underlying RTCDataChannel instance.
                    __publicField(this, "_dataChannel");
                    // Closed flag.
                    __publicField(this, "_closed", false);
                    // SCTP stream parameters.
                    __publicField(this, "_sctpStreamParameters");
                    // App custom data.
                    __publicField(this, "_appData");
                    // Observer instance.
                    __publicField(this, "_observer", new enhancedEvents_1.EnhancedEventEmitter());
                    logger.debug("constructor()");
                    this._id = id;
                    this._dataProducerId = dataProducerId;
                    this._dataChannel = dataChannel;
                    this._sctpStreamParameters = sctpStreamParameters;
                    this._appData = appData ?? {};
                    this.handleDataChannel();
                  }
                  /**
                   * DataConsumer id.
                   */
                  get id() {
                    return this._id;
                  }
                  /**
                   * Associated DataProducer id.
                   */
                  get dataProducerId() {
                    return this._dataProducerId;
                  }
                  /**
                   * Whether the DataConsumer is closed.
                   */
                  get closed() {
                    return this._closed;
                  }
                  /**
                   * SCTP stream parameters.
                   */
                  get sctpStreamParameters() {
                    return this._sctpStreamParameters;
                  }
                  /**
                   * DataChannel readyState.
                   */
                  get readyState() {
                    return this._dataChannel.readyState;
                  }
                  /**
                   * DataChannel label.
                   */
                  get label() {
                    return this._dataChannel.label;
                  }
                  /**
                   * DataChannel protocol.
                   */
                  get protocol() {
                    return this._dataChannel.protocol;
                  }
                  /**
                   * DataChannel binaryType.
                   */
                  get binaryType() {
                    return this._dataChannel.binaryType;
                  }
                  /**
                   * Set DataChannel binaryType.
                   */
                  set binaryType(binaryType) {
                    this._dataChannel.binaryType = binaryType;
                  }
                  /**
                   * App custom data.
                   */
                  get appData() {
                    return this._appData;
                  }
                  /**
                   * App custom data setter.
                   */
                  set appData(appData) {
                    this._appData = appData;
                  }
                  get observer() {
                    return this._observer;
                  }
                  /**
                   * Closes the DataConsumer.
                   */
                  close() {
                    if (this._closed) {
                      return;
                    }
                    logger.debug("close()");
                    this._closed = true;
                    this._dataChannel.close();
                    this.emit("@close");
                    this._observer.safeEmit("close");
                    super.close();
                    this._observer.close();
                  }
                  /**
                   * Transport was closed.
                   */
                  transportClosed() {
                    if (this._closed) {
                      return;
                    }
                    logger.debug("transportClosed()");
                    this._closed = true;
                    this._dataChannel.close();
                    this.safeEmit("transportclose");
                    this._observer.safeEmit("close");
                  }
                  handleDataChannel() {
                    this._dataChannel.addEventListener("open", () => {
                      if (this._closed) {
                        return;
                      }
                      logger.debug('DataChannel "open" event');
                      this.safeEmit("open");
                    });
                    this._dataChannel.addEventListener("error", (event) => {
                      var _a, _b;
                      if (this._closed) {
                        return;
                      }
                      const error = event.error ?? new Error("unknown DataChannel error");
                      if (((_a = event.error) == null ? void 0 : _a.errorDetail) === "sctp-failure") {
                        logger.error("DataChannel SCTP error [sctpCauseCode:%s]: %s", (_b = event.error) == null ? void 0 : _b.sctpCauseCode, event.error.message);
                      } else {
                        logger.error('DataChannel "error" event: %o', error);
                      }
                      this.safeEmit("error", error);
                    });
                    this._dataChannel.addEventListener("close", () => {
                      if (this._closed) {
                        return;
                      }
                      logger.warn('DataChannel "close" event');
                      this._closed = true;
                      this.emit("@close");
                      this.safeEmit("close");
                      this._observer.safeEmit("close");
                    });
                    this._dataChannel.addEventListener("message", (event) => {
                      if (this._closed) {
                        return;
                      }
                      this.safeEmit("message", event.data);
                    });
                  }
                }
                exports2.DataConsumer = DataConsumer;
              }
            ),
            /***/
            9275: (
              /***/
              (__unused_webpack_module, exports2, __webpack_require__2) => {
                "use strict";
                Object.defineProperty(exports2, "__esModule", { value: true });
                exports2.AwaitQueue = void 0;
                const Logger_1 = __webpack_require__2(8274);
                const errors_1 = __webpack_require__2(4253);
                const logger = new Logger_1.Logger("AwaitQueue");
                class AwaitQueue {
                  constructor() {
                    // Queue of pending tasks (map of PendingTasks indexed by id).
                    __publicField(this, "pendingTasks", /* @__PURE__ */ new Map());
                    // Incrementing PendingTask id.
                    __publicField(this, "nextTaskId", 0);
                    logger.debug("constructor()");
                  }
                  get size() {
                    return this.pendingTasks.size;
                  }
                  async push(task, name, options) {
                    name = name ?? task.name;
                    logger.debug(`push() [name:${name}, options:%o]`, options);
                    if (typeof task !== "function") {
                      throw new TypeError("given task is not a function");
                    }
                    if (name) {
                      try {
                        Object.defineProperty(task, "name", { value: name });
                      } catch (error) {
                      }
                    }
                    return new Promise((resolve, reject) => {
                      if (name && (options == null ? void 0 : options.removeOngoingTasksWithSameName)) {
                        for (const pendingTask2 of this.pendingTasks.values()) {
                          if (pendingTask2.name === name) {
                            pendingTask2.reject(new errors_1.AwaitQueueRemovedTaskError(), {
                              canExecuteNextTask: false
                            });
                          }
                        }
                      }
                      const pendingTask = {
                        id: this.nextTaskId++,
                        task,
                        name,
                        enqueuedAt: Date.now(),
                        executedAt: void 0,
                        completed: false,
                        resolve: (result) => {
                          if (pendingTask.completed) {
                            return;
                          }
                          pendingTask.completed = true;
                          this.pendingTasks.delete(pendingTask.id);
                          logger.debug(`resolving task [name:${pendingTask.name}]`);
                          resolve(result);
                          const [nextPendingTask] = this.pendingTasks.values();
                          if (nextPendingTask && !nextPendingTask.executedAt) {
                            void this.execute(nextPendingTask);
                          }
                        },
                        reject: (error, { canExecuteNextTask }) => {
                          if (pendingTask.completed) {
                            return;
                          }
                          pendingTask.completed = true;
                          this.pendingTasks.delete(pendingTask.id);
                          logger.debug(`rejecting task [name:${pendingTask.name}]: %s`, String(error));
                          reject(error);
                          if (canExecuteNextTask) {
                            const [nextPendingTask] = this.pendingTasks.values();
                            if (nextPendingTask && !nextPendingTask.executedAt) {
                              void this.execute(nextPendingTask);
                            }
                          }
                        }
                      };
                      this.pendingTasks.set(pendingTask.id, pendingTask);
                      if (this.pendingTasks.size === 1) {
                        void this.execute(pendingTask);
                      }
                    });
                  }
                  stop() {
                    logger.debug("stop()");
                    for (const pendingTask of this.pendingTasks.values()) {
                      logger.debug(`stop() | stopping task [name:${pendingTask.name}]`);
                      pendingTask.reject(new errors_1.AwaitQueueStoppedError(), {
                        canExecuteNextTask: false
                      });
                    }
                  }
                  remove(taskIdx) {
                    logger.debug(`remove() [taskIdx:${taskIdx}]`);
                    const pendingTask = Array.from(this.pendingTasks.values())[taskIdx];
                    if (!pendingTask) {
                      logger.debug(`stop() | no task with given idx [taskIdx:${taskIdx}]`);
                      return;
                    }
                    pendingTask.reject(new errors_1.AwaitQueueRemovedTaskError(), {
                      canExecuteNextTask: true
                    });
                  }
                  dump() {
                    const now = Date.now();
                    let idx = 0;
                    return Array.from(this.pendingTasks.values()).map((pendingTask) => ({
                      idx: idx++,
                      task: pendingTask.task,
                      name: pendingTask.name,
                      enqueuedTime: pendingTask.executedAt ? pendingTask.executedAt - pendingTask.enqueuedAt : now - pendingTask.enqueuedAt,
                      executionTime: pendingTask.executedAt ? now - pendingTask.executedAt : 0
                    }));
                  }
                  async execute(pendingTask) {
                    logger.debug(`execute() [name:${pendingTask.name}]`);
                    if (pendingTask.executedAt) {
                      throw new Error("task already being executed");
                    }
                    pendingTask.executedAt = Date.now();
                    try {
                      const result = await pendingTask.task();
                      pendingTask.resolve(result);
                    } catch (error) {
                      pendingTask.reject(error, { canExecuteNextTask: true });
                    }
                  }
                }
                exports2.AwaitQueue = AwaitQueue;
              }
            ),
            /***/
            9506: (
              /***/
              function(module2, exports2, __webpack_require__2) {
                ;
                (function(root, factory, undef) {
                  if (true) {
                    module2.exports = exports2 = factory(__webpack_require__2(9021), __webpack_require__2(5471), __webpack_require__2(1025));
                  } else {
                  }
                })(this, function(CryptoJS) {
                  (function() {
                    var C = CryptoJS;
                    var C_lib = C.lib;
                    var Base = C_lib.Base;
                    var WordArray = C_lib.WordArray;
                    var C_algo = C.algo;
                    var MD5 = C_algo.MD5;
                    var EvpKDF = C_algo.EvpKDF = Base.extend({
                      /**
                       * Configuration options.
                       *
                       * @property {number} keySize The key size in words to generate. Default: 4 (128 bits)
                       * @property {Hasher} hasher The hash algorithm to use. Default: MD5
                       * @property {number} iterations The number of iterations to perform. Default: 1
                       */
                      cfg: Base.extend({
                        keySize: 128 / 32,
                        hasher: MD5,
                        iterations: 1
                      }),
                      /**
                       * Initializes a newly created key derivation function.
                       *
                       * @param {Object} cfg (Optional) The configuration options to use for the derivation.
                       *
                       * @example
                       *
                       *     var kdf = CryptoJS.algo.EvpKDF.create();
                       *     var kdf = CryptoJS.algo.EvpKDF.create({ keySize: 8 });
                       *     var kdf = CryptoJS.algo.EvpKDF.create({ keySize: 8, iterations: 1000 });
                       */
                      init: function(cfg) {
                        this.cfg = this.cfg.extend(cfg);
                      },
                      /**
                       * Derives a key from a password.
                       *
                       * @param {WordArray|string} password The password.
                       * @param {WordArray|string} salt A salt.
                       *
                       * @return {WordArray} The derived key.
                       *
                       * @example
                       *
                       *     var key = kdf.compute(password, salt);
                       */
                      compute: function(password, salt) {
                        var block;
                        var cfg = this.cfg;
                        var hasher = cfg.hasher.create();
                        var derivedKey = WordArray.create();
                        var derivedKeyWords = derivedKey.words;
                        var keySize = cfg.keySize;
                        var iterations = cfg.iterations;
                        while (derivedKeyWords.length < keySize) {
                          if (block) {
                            hasher.update(block);
                          }
                          block = hasher.update(password).finalize(salt);
                          hasher.reset();
                          for (var i = 1; i < iterations; i++) {
                            block = hasher.finalize(block);
                            hasher.reset();
                          }
                          derivedKey.concat(block);
                        }
                        derivedKey.sigBytes = keySize * 4;
                        return derivedKey;
                      }
                    });
                    C.EvpKDF = function(password, salt, cfg) {
                      return EvpKDF.create(cfg).compute(password, salt);
                    };
                  })();
                  return CryptoJS.EvpKDF;
                });
              }
            ),
            /***/
            9557: (
              /***/
              function(module2, exports2, __webpack_require__2) {
                ;
                (function(root, factory, undef) {
                  if (true) {
                    module2.exports = exports2 = factory(__webpack_require__2(9021), __webpack_require__2(3240), __webpack_require__2(1380));
                  } else {
                  }
                })(this, function(CryptoJS) {
                  (function() {
                    var C = CryptoJS;
                    var C_x64 = C.x64;
                    var X64Word = C_x64.Word;
                    var X64WordArray = C_x64.WordArray;
                    var C_algo = C.algo;
                    var SHA512 = C_algo.SHA512;
                    var SHA384 = C_algo.SHA384 = SHA512.extend({
                      _doReset: function() {
                        this._hash = new X64WordArray.init([
                          new X64Word.init(3418070365, 3238371032),
                          new X64Word.init(1654270250, 914150663),
                          new X64Word.init(2438529370, 812702999),
                          new X64Word.init(355462360, 4144912697),
                          new X64Word.init(1731405415, 4290775857),
                          new X64Word.init(2394180231, 1750603025),
                          new X64Word.init(3675008525, 1694076839),
                          new X64Word.init(1203062813, 3204075428)
                        ]);
                      },
                      _doFinalize: function() {
                        var hash = SHA512._doFinalize.call(this);
                        hash.sigBytes -= 16;
                        return hash;
                      }
                    });
                    C.SHA384 = SHA512._createHelper(SHA384);
                    C.HmacSHA384 = SHA512._createHmacHelper(SHA384);
                  })();
                  return CryptoJS.SHA384;
                });
              }
            ),
            /***/
            9633: (
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                "use strict";
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  l: () => (
                    /* binding */
                    ExternalE2EEKeyProvider2
                  )
                  /* harmony export */
                });
                var _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(467);
                var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(3029);
                var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__2(2901);
                var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__2(388);
                var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__2(3954);
                var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__2(5501);
                var _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__2(4756);
                var _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_6___default = __webpack_require__2.n(_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_6__);
                var events__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__2(7007);
                var events__WEBPACK_IMPORTED_MODULE_7___default = __webpack_require__2.n(events__WEBPACK_IMPORTED_MODULE_7__);
                var _constants__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__2(1806);
                var _events__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__2(6746);
                var _utils__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__2(8278);
                function _callSuper(t, o, e) {
                  return o = (0, _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4__.A)(o), (0, _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_3__.A)(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], (0, _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4__.A)(t).constructor) : o.apply(t, e));
                }
                function _isNativeReflectConstruct() {
                  try {
                    var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
                    }));
                  } catch (t2) {
                  }
                  return (_isNativeReflectConstruct = function _isNativeReflectConstruct2() {
                    return !!t;
                  })();
                }
                var BaseKeyProvider = function(_EventEmitter) {
                  function BaseKeyProvider2() {
                    var _this;
                    var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
                    (0, _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1__.A)(this, BaseKeyProvider2);
                    _this = _callSuper(this, BaseKeyProvider2);
                    _this.onKeyRatcheted = function(material, keyIndex) {
                      console.debug("key ratcheted event received", {
                        material,
                        keyIndex
                      });
                    };
                    _this.keyInfoMap = /* @__PURE__ */ new Map();
                    _this.options = Object.assign(Object.assign({}, _constants__WEBPACK_IMPORTED_MODULE_8__.T4), options);
                    _this.on(_events__WEBPACK_IMPORTED_MODULE_9__.fo.KeyRatcheted, _this.onKeyRatcheted);
                    return _this;
                  }
                  (0, _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_5__.A)(BaseKeyProvider2, _EventEmitter);
                  return (0, _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2__.A)(BaseKeyProvider2, [{
                    key: "onSetEncryptionKey",
                    value: function onSetEncryptionKey(key, participantIdentity, keyIndex) {
                      var keyInfo = {
                        key,
                        participantIdentity,
                        keyIndex
                      };
                      if (!this.options.sharedKey && !participantIdentity) {
                        throw new Error("participant identity needs to be passed for encryption key if sharedKey option is false");
                      }
                      this.keyInfoMap.set("".concat(participantIdentity !== null && participantIdentity !== void 0 ? participantIdentity : "shared", "-").concat(keyIndex !== null && keyIndex !== void 0 ? keyIndex : 0), keyInfo);
                      this.emit(_events__WEBPACK_IMPORTED_MODULE_9__.fo.SetKey, keyInfo);
                    }
                  }, {
                    key: "getKeys",
                    value: function getKeys() {
                      return Array.from(this.keyInfoMap.values());
                    }
                  }, {
                    key: "getOptions",
                    value: function getOptions() {
                      return this.options;
                    }
                  }, {
                    key: "ratchetKey",
                    value: function ratchetKey(participantIdentity, keyIndex) {
                      this.emit(_events__WEBPACK_IMPORTED_MODULE_9__.fo.RatchetRequest, participantIdentity, keyIndex);
                    }
                  }]);
                }(events__WEBPACK_IMPORTED_MODULE_7__.EventEmitter);
                var ExternalE2EEKeyProvider2 = function(_BaseKeyProvider) {
                  function ExternalE2EEKeyProvider3() {
                    var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
                    (0, _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1__.A)(this, ExternalE2EEKeyProvider3);
                    var opts = Object.assign(Object.assign({}, options), {
                      sharedKey: true,
                      // for a shared key provider failing to decrypt for a specific participant
                      // should not mark the key as invalid, so we accept wrong keys forever
                      // and won't try to auto-ratchet
                      ratchetWindowSize: 0,
                      failureTolerance: -1
                    });
                    return _callSuper(this, ExternalE2EEKeyProvider3, [opts]);
                  }
                  (0, _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_5__.A)(ExternalE2EEKeyProvider3, _BaseKeyProvider);
                  return (0, _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2__.A)(ExternalE2EEKeyProvider3, [{
                    key: "setSharedKey",
                    value: function() {
                      var _setSharedKey = (0, _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__.A)(_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_6___default().mark(function _callee(key) {
                        var derivedKey, _t;
                        return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_6___default().wrap(function(_context) {
                          while (1) switch (_context.prev = _context.next) {
                            case 0:
                              if (!(typeof key === "string")) {
                                _context.next = 2;
                                break;
                              }
                              _context.next = 1;
                              return (0, _utils__WEBPACK_IMPORTED_MODULE_10__.sn)(key);
                            case 1:
                              _t = _context.sent;
                              _context.next = 4;
                              break;
                            case 2:
                              _context.next = 3;
                              return (0, _utils__WEBPACK_IMPORTED_MODULE_10__.tr)(key);
                            case 3:
                              _t = _context.sent;
                            case 4:
                              derivedKey = _t;
                              this.onSetEncryptionKey(derivedKey);
                            case 5:
                            case "end":
                              return _context.stop();
                          }
                        }, _callee, this);
                      }));
                      function setSharedKey(_x) {
                        return _setSharedKey.apply(this, arguments);
                      }
                      return setSharedKey;
                    }()
                  }]);
                }(BaseKeyProvider);
              }
            ),
            /***/
            9792: (
              /***/
              (__unused_webpack_module, exports2, __webpack_require__2) => {
                "use strict";
                Object.defineProperty(exports2, "__esModule", { value: true });
                exports2.Producer = void 0;
                const Logger_1 = __webpack_require__2(2994);
                const enhancedEvents_1 = __webpack_require__2(3953);
                const errors_1 = __webpack_require__2(4893);
                const logger = new Logger_1.Logger("Producer");
                class Producer extends enhancedEvents_1.EnhancedEventEmitter {
                  constructor({ id, localId, rtpSender, track, rtpParameters, stopTracks, disableTrackOnPause, zeroRtpOnPause, appData }) {
                    super();
                    // Id.
                    __publicField(this, "_id");
                    // Local id.
                    __publicField(this, "_localId");
                    // Closed flag.
                    __publicField(this, "_closed", false);
                    // Associated RTCRtpSender.
                    __publicField(this, "_rtpSender");
                    // Local track.
                    __publicField(this, "_track");
                    // Producer kind.
                    __publicField(this, "_kind");
                    // RTP parameters.
                    __publicField(this, "_rtpParameters");
                    // Paused flag.
                    __publicField(this, "_paused");
                    // Video max spatial layer.
                    __publicField(this, "_maxSpatialLayer");
                    // Whether the Producer should call stop() in given tracks.
                    __publicField(this, "_stopTracks");
                    // Whether the Producer should set track.enabled = false when paused.
                    __publicField(this, "_disableTrackOnPause");
                    // Whether we should replace the RTCRtpSender.track with null when paused.
                    __publicField(this, "_zeroRtpOnPause");
                    // App custom data.
                    __publicField(this, "_appData");
                    // Observer instance.
                    __publicField(this, "_observer", new enhancedEvents_1.EnhancedEventEmitter());
                    logger.debug("constructor()");
                    this._id = id;
                    this._localId = localId;
                    this._rtpSender = rtpSender;
                    this._track = track;
                    this._kind = track.kind;
                    this._rtpParameters = rtpParameters;
                    this._paused = disableTrackOnPause ? !track.enabled : false;
                    this._maxSpatialLayer = void 0;
                    this._stopTracks = stopTracks;
                    this._disableTrackOnPause = disableTrackOnPause;
                    this._zeroRtpOnPause = zeroRtpOnPause;
                    this._appData = appData ?? {};
                    this.onTrackEnded = this.onTrackEnded.bind(this);
                    this.handleTrack();
                  }
                  /**
                   * Producer id.
                   */
                  get id() {
                    return this._id;
                  }
                  /**
                   * Local id.
                   */
                  get localId() {
                    return this._localId;
                  }
                  /**
                   * Whether the Producer is closed.
                   */
                  get closed() {
                    return this._closed;
                  }
                  /**
                   * Media kind.
                   */
                  get kind() {
                    return this._kind;
                  }
                  /**
                   * Associated RTCRtpSender.
                   */
                  get rtpSender() {
                    return this._rtpSender;
                  }
                  /**
                   * The associated track.
                   */
                  get track() {
                    return this._track;
                  }
                  /**
                   * RTP parameters.
                   */
                  get rtpParameters() {
                    return this._rtpParameters;
                  }
                  /**
                   * Whether the Producer is paused.
                   */
                  get paused() {
                    return this._paused;
                  }
                  /**
                   * Max spatial layer.
                   *
                   * @type {Number | undefined}
                   */
                  get maxSpatialLayer() {
                    return this._maxSpatialLayer;
                  }
                  /**
                   * App custom data.
                   */
                  get appData() {
                    return this._appData;
                  }
                  /**
                   * App custom data setter.
                   */
                  set appData(appData) {
                    this._appData = appData;
                  }
                  get observer() {
                    return this._observer;
                  }
                  /**
                   * Closes the Producer.
                   */
                  close() {
                    if (this._closed) {
                      return;
                    }
                    logger.debug("close()");
                    this._closed = true;
                    this.destroyTrack();
                    this.emit("@close");
                    this._observer.safeEmit("close");
                    super.close();
                    this._observer.close();
                  }
                  /**
                   * Transport was closed.
                   */
                  transportClosed() {
                    if (this._closed) {
                      return;
                    }
                    logger.debug("transportClosed()");
                    this._closed = true;
                    this.destroyTrack();
                    this.safeEmit("transportclose");
                    this._observer.safeEmit("close");
                  }
                  /**
                   * Get associated RTCRtpSender stats.
                   */
                  async getStats() {
                    if (this._closed) {
                      throw new errors_1.InvalidStateError("closed");
                    }
                    return new Promise((resolve, reject) => {
                      this.safeEmit("@getstats", resolve, reject);
                    });
                  }
                  /**
                   * Pauses sending media.
                   */
                  pause() {
                    logger.debug("pause()");
                    if (this._closed) {
                      logger.error("pause() | Producer closed");
                      return;
                    }
                    this._paused = true;
                    if (this._track && this._disableTrackOnPause) {
                      this._track.enabled = false;
                    }
                    if (this._zeroRtpOnPause) {
                      new Promise((resolve, reject) => {
                        this.safeEmit("@pause", resolve, reject);
                      }).catch(() => {
                      });
                    }
                    this._observer.safeEmit("pause");
                  }
                  /**
                   * Resumes sending media.
                   */
                  resume() {
                    logger.debug("resume()");
                    if (this._closed) {
                      logger.error("resume() | Producer closed");
                      return;
                    }
                    this._paused = false;
                    if (this._track && this._disableTrackOnPause) {
                      this._track.enabled = true;
                    }
                    if (this._zeroRtpOnPause) {
                      new Promise((resolve, reject) => {
                        this.safeEmit("@resume", resolve, reject);
                      }).catch(() => {
                      });
                    }
                    this._observer.safeEmit("resume");
                  }
                  /**
                   * Replaces the current track with a new one or null.
                   */
                  async replaceTrack({ track }) {
                    logger.debug("replaceTrack() [track:%o]", track);
                    if (this._closed) {
                      if (track && this._stopTracks) {
                        try {
                          track.stop();
                        } catch (error) {
                        }
                      }
                      throw new errors_1.InvalidStateError("closed");
                    } else if (track && track.readyState === "ended") {
                      throw new errors_1.InvalidStateError("track ended");
                    }
                    if (track === this._track) {
                      logger.debug("replaceTrack() | same track, ignored");
                      return;
                    }
                    await new Promise((resolve, reject) => {
                      this.safeEmit("@replacetrack", track, resolve, reject);
                    });
                    this.destroyTrack();
                    this._track = track;
                    if (this._track && this._disableTrackOnPause) {
                      if (!this._paused) {
                        this._track.enabled = true;
                      } else if (this._paused) {
                        this._track.enabled = false;
                      }
                    }
                    this.handleTrack();
                  }
                  /**
                   * Sets the video max spatial layer to be sent.
                   */
                  async setMaxSpatialLayer(spatialLayer) {
                    if (this._closed) {
                      throw new errors_1.InvalidStateError("closed");
                    } else if (this._kind !== "video") {
                      throw new errors_1.UnsupportedError("not a video Producer");
                    } else if (typeof spatialLayer !== "number") {
                      throw new TypeError("invalid spatialLayer");
                    }
                    if (spatialLayer === this._maxSpatialLayer) {
                      return;
                    }
                    await new Promise((resolve, reject) => {
                      this.safeEmit("@setmaxspatiallayer", spatialLayer, resolve, reject);
                    }).catch(() => {
                    });
                    this._maxSpatialLayer = spatialLayer;
                  }
                  async setRtpEncodingParameters(params) {
                    if (this._closed) {
                      throw new errors_1.InvalidStateError("closed");
                    } else if (typeof params !== "object") {
                      throw new TypeError("invalid params");
                    }
                    await new Promise((resolve, reject) => {
                      this.safeEmit("@setrtpencodingparameters", params, resolve, reject);
                    });
                  }
                  onTrackEnded() {
                    logger.debug('track "ended" event');
                    this.safeEmit("trackended");
                    this._observer.safeEmit("trackended");
                  }
                  handleTrack() {
                    if (!this._track) {
                      return;
                    }
                    this._track.addEventListener("ended", this.onTrackEnded);
                  }
                  destroyTrack() {
                    if (!this._track) {
                      return;
                    }
                    try {
                      this._track.removeEventListener("ended", this.onTrackEnded);
                      if (this._stopTracks) {
                        this._track.stop();
                      }
                    } catch (error) {
                    }
                  }
                }
                exports2.Producer = Producer;
              }
            )
            /******/
          };
          var __webpack_module_cache__ = {};
          function __webpack_require__(moduleId) {
            var cachedModule = __webpack_module_cache__[moduleId];
            if (cachedModule !== void 0) {
              return cachedModule.exports;
            }
            var module2 = __webpack_module_cache__[moduleId] = {
              /******/
              // no module.id needed
              /******/
              // no module.loaded needed
              /******/
              exports: {}
              /******/
            };
            __webpack_modules__[moduleId].call(module2.exports, module2, module2.exports, __webpack_require__);
            return module2.exports;
          }
          (() => {
            __webpack_require__.amdO = {};
          })();
          (() => {
            __webpack_require__.n = (module2) => {
              var getter = module2 && module2.__esModule ? (
                /******/
                () => module2["default"]
              ) : (
                /******/
                () => module2
              );
              __webpack_require__.d(getter, { a: getter });
              return getter;
            };
          })();
          (() => {
            __webpack_require__.d = (exports2, definition) => {
              for (var key in definition) {
                if (__webpack_require__.o(definition, key) && !__webpack_require__.o(exports2, key)) {
                  Object.defineProperty(exports2, key, { enumerable: true, get: definition[key] });
                }
              }
            };
          })();
          (() => {
            __webpack_require__.g = function() {
              if (typeof globalThis === "object") return globalThis;
              try {
                return this || new Function("return this")();
              } catch (e) {
                if (typeof window === "object") return window;
              }
            }();
          })();
          (() => {
            __webpack_require__.o = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop);
          })();
          (() => {
            __webpack_require__.r = (exports2) => {
              if (typeof Symbol !== "undefined" && Symbol.toStringTag) {
                Object.defineProperty(exports2, Symbol.toStringTag, { value: "Module" });
              }
              Object.defineProperty(exports2, "__esModule", { value: true });
            };
          })();
          var __webpack_exports__ = __webpack_require__(3115);
          return __webpack_exports__;
        })()
      );
    });
  }
});

// node_modules/@videosdk.live/react-sdk/dist/index.modern.js
var import_react = __toESM(require_react());
var import_events = __toESM(require_events());
var import_js_sdk = __toESM(require_videosdk());
var import_js_sdk2 = __toESM(require_videosdk());
function _arrayLikeToArray(r, a) {
  (null == a || a > r.length) && (a = r.length);
  for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];
  return n;
}
function _createForOfIteratorHelperLoose(r, e) {
  var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
  if (t) return (t = t.call(r)).next.bind(t);
  if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) {
    t && (r = t);
    var o = 0;
    return function() {
      return o >= r.length ? {
        done: true
      } : {
        done: false,
        value: r[o++]
      };
    };
  }
  throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _extends() {
  return _extends = Object.assign ? Object.assign.bind() : function(n) {
    for (var e = 1; e < arguments.length; e++) {
      var t = arguments[e];
      for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);
    }
    return n;
  }, _extends.apply(null, arguments);
}
function _objectWithoutPropertiesLoose(r, e) {
  if (null == r) return {};
  var t = {};
  for (var n in r) if ({}.hasOwnProperty.call(r, n)) {
    if (-1 !== e.indexOf(n)) continue;
    t[n] = r[n];
  }
  return t;
}
function _unsupportedIterableToArray(r, a) {
  if (r) {
    if ("string" == typeof r) return _arrayLikeToArray(r, a);
    var t = {}.toString.call(r).slice(8, -1);
    return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0;
  }
}
var eventPrifix = "videosdk-live-react-sdk";
var events = {
  "participant-joined": eventPrifix + "-participant-joined",
  "participant-left": eventPrifix + "-participant-left",
  "speaker-changed": eventPrifix + "-speaker-changed",
  "presenter-changed": eventPrifix + "-presenter-changed",
  "main-participant-changed": eventPrifix + "-main-participant-changed",
  "entry-requested": eventPrifix + "-entry-requested",
  "entry-responded": eventPrifix + "-entry-responded",
  "recording-started": eventPrifix + "-recording-started",
  "recording-stopped": eventPrifix + "-recording-stopped",
  data: eventPrifix + "-data",
  "meeting-joined": eventPrifix + "-meeting-joined",
  "meeting-left": eventPrifix + "-meeting-left",
  "live-stream-started": eventPrifix + "-live-stream-started",
  "live-stream-stopped": eventPrifix + "-live-stream-stopped",
  "video-state-changed": eventPrifix + "-video-state-changed",
  "video-seeked": eventPrifix + "-video-seeked",
  "webcam-requested": eventPrifix + "-webcam-requested",
  "mic-requested": eventPrifix + "-mic-requested",
  "pin-state-changed": eventPrifix + "-pin-state-changed",
  "connection-open": eventPrifix + "-connection-open",
  "connection-close": eventPrifix + "-connection-close",
  "switch-meeting": eventPrifix + "-switch-meeting",
  error: eventPrifix + "-error",
  "hls-started": eventPrifix + "-hls-started",
  "hls-stopped": eventPrifix + "-hls-stopped",
  "hls-state-changed": eventPrifix + "-hls-state-changed",
  "hls-playable-state-changed": eventPrifix + "-hls-playable-state-changed",
  "recording-state-changed": eventPrifix + "-recording-state-changed",
  "livestream-state-changed": eventPrifix + "-livestream-state-changed",
  "meeting-state-changed": eventPrifix + "-meeting-state-changed",
  "participant-mode-changed": eventPrifix + "-participant-mode-changed",
  "transcription-state-changed": eventPrifix + "-transcription-state-changed",
  "transcription-text": eventPrifix + "-transcription-text",
  "translation-state-changed": eventPrifix + "-translation-state-changed",
  "translation-language-changed": eventPrifix + "-translation-language-changed",
  "translation-text": eventPrifix + "-translation-text",
  "character-joined": eventPrifix + "-character-joined",
  "character-left": eventPrifix + "-character-left",
  "whiteboard-started": eventPrifix + "-whiteboard-started",
  "whiteboard-stopped": eventPrifix + "-whiteboard-stopped",
  "paused-all-streams": eventPrifix + "-paused-all-streams",
  "resumed-all-streams": eventPrifix + "-resumed-all-streams",
  "media-relay-started": eventPrifix + "-media-relay-started",
  "media-relay-stopped": eventPrifix + "-media-relay-stopped",
  "media-relay-error": eventPrifix + "-media-relay-error",
  "media-relay-request-response": eventPrifix + "-media-relay-request-response",
  "media-relay-request-received": eventPrifix + "-media-relay-request-received",
  "quality-limitation": eventPrifix + "-quality-limitation"
};
var eventEmitter = new import_events.default();
eventEmitter.setMaxListeners(9999);
function debounce(func, delay) {
  var timeout;
  return function() {
    var _this = this;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    clearTimeout(timeout);
    timeout = setTimeout(function() {
      return func.apply(_this, args);
    }, delay);
  };
}
var MeetingProviderContex = (0, import_react.createContext)();
var useMeeting = function useMeeting2(_temp) {
  var _ref = _temp === void 0 ? {} : _temp, _ref$onParticipantJoi = _ref.onParticipantJoined, onParticipantJoined = _ref$onParticipantJoi === void 0 ? function() {
  } : _ref$onParticipantJoi, _ref$onParticipantLef = _ref.onParticipantLeft, onParticipantLeft = _ref$onParticipantLef === void 0 ? function() {
  } : _ref$onParticipantLef, _ref$onSpeakerChanged = _ref.onSpeakerChanged, onSpeakerChanged = _ref$onSpeakerChanged === void 0 ? function() {
  } : _ref$onSpeakerChanged, _ref$onPresenterChang = _ref.onPresenterChanged, onPresenterChanged = _ref$onPresenterChang === void 0 ? function() {
  } : _ref$onPresenterChang, _ref$onMainParticipan = _ref.onMainParticipantChanged, onMainParticipantChanged = _ref$onMainParticipan === void 0 ? function() {
  } : _ref$onMainParticipan, _ref$onEntryRequested = _ref.onEntryRequested, onEntryRequested = _ref$onEntryRequested === void 0 ? function() {
  } : _ref$onEntryRequested, _ref$onEntryResponded = _ref.onEntryResponded, onEntryResponded = _ref$onEntryResponded === void 0 ? function() {
  } : _ref$onEntryResponded, _ref$onPausedAllStrea = _ref.onPausedAllStreams, onPausedAllStreams = _ref$onPausedAllStrea === void 0 ? function() {
  } : _ref$onPausedAllStrea, _ref$onResumedAllStre = _ref.onResumedAllStreams, onResumedAllStreams = _ref$onResumedAllStre === void 0 ? function() {
  } : _ref$onResumedAllStre, _ref$onRecordingStart = _ref.onRecordingStarted, onRecordingStarted = _ref$onRecordingStart === void 0 ? function() {
  } : _ref$onRecordingStart, _ref$onRecordingStopp = _ref.onRecordingStopped, onRecordingStopped = _ref$onRecordingStopp === void 0 ? function() {
  } : _ref$onRecordingStopp, _ref$onData = _ref.onData, onData = _ref$onData === void 0 ? function() {
  } : _ref$onData, _ref$onMeetingJoined = _ref.onMeetingJoined, onMeetingJoined = _ref$onMeetingJoined === void 0 ? function() {
  } : _ref$onMeetingJoined, _ref$onMeetingLeft = _ref.onMeetingLeft, onMeetingLeft = _ref$onMeetingLeft === void 0 ? function() {
  } : _ref$onMeetingLeft, _ref$onLiveStreamStar = _ref.onLiveStreamStarted, onLiveStreamStarted = _ref$onLiveStreamStar === void 0 ? function() {
  } : _ref$onLiveStreamStar, _ref$onLiveStreamStop = _ref.onLiveStreamStopped, onLiveStreamStopped = _ref$onLiveStreamStop === void 0 ? function() {
  } : _ref$onLiveStreamStop, _ref$onVideoStateChan = _ref.onVideoStateChanged, onVideoStateChanged = _ref$onVideoStateChan === void 0 ? function() {
  } : _ref$onVideoStateChan, _ref$onVideoSeeked = _ref.onVideoSeeked, onVideoSeeked = _ref$onVideoSeeked === void 0 ? function() {
  } : _ref$onVideoSeeked, _ref$onWebcamRequeste = _ref.onWebcamRequested, onWebcamRequested = _ref$onWebcamRequeste === void 0 ? function() {
  } : _ref$onWebcamRequeste, _ref$onMicRequested = _ref.onMicRequested, onMicRequested = _ref$onMicRequested === void 0 ? function() {
  } : _ref$onMicRequested, _ref$onPinStateChange = _ref.onPinStateChanged, onPinStateChanged = _ref$onPinStateChange === void 0 ? function() {
  } : _ref$onPinStateChange, _ref$onConnectionOpen = _ref.onConnectionOpen, onConnectionOpen = _ref$onConnectionOpen === void 0 ? function() {
  } : _ref$onConnectionOpen, _ref$onConnetionClose = _ref.onConnetionClose, onConnetionClose = _ref$onConnetionClose === void 0 ? function() {
  } : _ref$onConnetionClose, _ref$onSwitchMeeting = _ref.onSwitchMeeting, onSwitchMeeting = _ref$onSwitchMeeting === void 0 ? function() {
  } : _ref$onSwitchMeeting, _ref$onError = _ref.onError, onError = _ref$onError === void 0 ? function() {
  } : _ref$onError, _ref$onHlsStarted = _ref.onHlsStarted, onHlsStarted = _ref$onHlsStarted === void 0 ? function() {
  } : _ref$onHlsStarted, _ref$onHlsStopped = _ref.onHlsStopped, onHlsStopped = _ref$onHlsStopped === void 0 ? function() {
  } : _ref$onHlsStopped, _ref$onHlsStateChange = _ref.onHlsStateChanged, onHlsStateChanged = _ref$onHlsStateChange === void 0 ? function() {
  } : _ref$onHlsStateChange, _ref$onRecordingState = _ref.onRecordingStateChanged, onRecordingStateChanged = _ref$onRecordingState === void 0 ? function() {
  } : _ref$onRecordingState, _ref$onLivestreamStat = _ref.onLivestreamStateChanged, onLivestreamStateChanged = _ref$onLivestreamStat === void 0 ? function() {
  } : _ref$onLivestreamStat, _ref$onMeetingStateCh = _ref.onMeetingStateChanged, onMeetingStateChanged = _ref$onMeetingStateCh === void 0 ? function() {
  } : _ref$onMeetingStateCh, _ref$onParticipantMod = _ref.onParticipantModeChanged, onParticipantModeChanged = _ref$onParticipantMod === void 0 ? function() {
  } : _ref$onParticipantMod, _ref$onCharacterJoine = _ref.onCharacterJoined, onCharacterJoined = _ref$onCharacterJoine === void 0 ? function() {
  } : _ref$onCharacterJoine, _ref$onCharacterLeft = _ref.onCharacterLeft, onCharacterLeft = _ref$onCharacterLeft === void 0 ? function() {
  } : _ref$onCharacterLeft, _ref$onMediaRelayStar = _ref.onMediaRelayStarted, onMediaRelayStarted = _ref$onMediaRelayStar === void 0 ? function() {
  } : _ref$onMediaRelayStar, _ref$onMediaRelayStop = _ref.onMediaRelayStopped, onMediaRelayStopped = _ref$onMediaRelayStop === void 0 ? function() {
  } : _ref$onMediaRelayStop, _ref$onMediaRelayErro = _ref.onMediaRelayError, onMediaRelayError = _ref$onMediaRelayErro === void 0 ? function() {
  } : _ref$onMediaRelayErro, _ref$onMediaRelayRequ = _ref.onMediaRelayRequestResponse, onMediaRelayRequestResponse = _ref$onMediaRelayRequ === void 0 ? function() {
  } : _ref$onMediaRelayRequ, _ref$onMediaRelayRequ2 = _ref.onMediaRelayRequestReceived, onMediaRelayRequestReceived = _ref$onMediaRelayRequ2 === void 0 ? function() {
  } : _ref$onMediaRelayRequ2, _ref$onQualityLimitat = _ref.onQualityLimitation, onQualityLimitation = _ref$onQualityLimitat === void 0 ? function() {
  } : _ref$onQualityLimitat;
  (0, import_react.useEffect)(function() {
    eventEmitter.on(events["participant-joined"], onParticipantJoined);
    eventEmitter.on(events["participant-left"], onParticipantLeft);
    eventEmitter.on(events["speaker-changed"], onSpeakerChanged);
    eventEmitter.on(events["presenter-changed"], onPresenterChanged);
    eventEmitter.on(events["main-participant-changed"], onMainParticipantChanged);
    eventEmitter.on(events["entry-requested"], onEntryRequested);
    eventEmitter.on(events["entry-responded"], onEntryResponded);
    eventEmitter.on(events["paused-all-streams"], onPausedAllStreams);
    eventEmitter.on(events["resumed-all-streams"], onResumedAllStreams);
    eventEmitter.on(events["recording-started"], onRecordingStarted);
    eventEmitter.on(events["recording-stopped"], onRecordingStopped);
    eventEmitter.on(events["data"], onData);
    eventEmitter.on(events["meeting-joined"], onMeetingJoined);
    eventEmitter.on(events["meeting-left"], onMeetingLeft);
    eventEmitter.on(events["live-stream-started"], onLiveStreamStarted);
    eventEmitter.on(events["live-stream-stopped"], onLiveStreamStopped);
    eventEmitter.on(events["video-state-changed"], onVideoStateChanged);
    eventEmitter.on(events["video-seeked"], onVideoSeeked);
    eventEmitter.on(events["webcam-requested"], onWebcamRequested);
    eventEmitter.on(events["mic-requested"], onMicRequested);
    eventEmitter.on(events["pin-state-changed"], onPinStateChanged);
    eventEmitter.on(events["connection-open"], onConnectionOpen);
    eventEmitter.on(events["connection-close"], onConnetionClose);
    eventEmitter.on(events["switch-meeting"], onSwitchMeeting);
    eventEmitter.on(events["error"], onError);
    eventEmitter.on(events["hls-started"], onHlsStarted);
    eventEmitter.on(events["hls-stopped"], onHlsStopped);
    eventEmitter.on(events["hls-state-changed"], onHlsStateChanged);
    eventEmitter.on(events["recording-state-changed"], onRecordingStateChanged);
    eventEmitter.on(events["livestream-state-changed"], onLivestreamStateChanged);
    eventEmitter.on(events["meeting-state-changed"], onMeetingStateChanged);
    eventEmitter.on(events["participant-mode-changed"], onParticipantModeChanged);
    eventEmitter.on(events["character-joined"], onCharacterJoined);
    eventEmitter.on(events["character-left"], onCharacterLeft);
    eventEmitter.on(events["media-relay-started"], onMediaRelayStarted);
    eventEmitter.on(events["media-relay-stopped"], onMediaRelayStopped);
    eventEmitter.on(events["media-relay-error"], onMediaRelayError);
    eventEmitter.on(events["media-relay-request-response"], onMediaRelayRequestResponse);
    eventEmitter.on(events["media-relay-request-received"], onMediaRelayRequestReceived);
    eventEmitter.on(events["quality-limitation"], onQualityLimitation);
    return function() {
      eventEmitter.off(events["meeting-state-changed"], onMeetingStateChanged);
      eventEmitter.off(events["participant-joined"], onParticipantJoined);
      eventEmitter.off(events["participant-left"], onParticipantLeft);
      eventEmitter.off(events["speaker-changed"], onSpeakerChanged);
      eventEmitter.off(events["presenter-changed"], onPresenterChanged);
      eventEmitter.off(events["main-participant-changed"], onMainParticipantChanged);
      eventEmitter.off(events["entry-requested"], onEntryRequested);
      eventEmitter.off(events["entry-responded"], onEntryResponded);
      eventEmitter.off(events["paused-all-streams"], onPausedAllStreams);
      eventEmitter.off(events["resumed-all-streams"], onResumedAllStreams);
      eventEmitter.off(events["recording-started"], onRecordingStarted);
      eventEmitter.off(events["recording-stopped"], onRecordingStopped);
      eventEmitter.off(events["data"], onData);
      eventEmitter.off(events["meeting-joined"], onMeetingJoined);
      eventEmitter.off(events["meeting-left"], onMeetingLeft);
      eventEmitter.off(events["live-stream-started"], onLiveStreamStarted);
      eventEmitter.off(events["live-stream-stopped"], onLiveStreamStopped);
      eventEmitter.off(events["video-state-changed"], onVideoStateChanged);
      eventEmitter.off(events["video-seeked"], onVideoSeeked);
      eventEmitter.off(events["webcam-requested"], onWebcamRequested);
      eventEmitter.off(events["mic-requested"], onMicRequested);
      eventEmitter.off(events["pin-state-changed"], onPinStateChanged);
      eventEmitter.off(events["connection-open"], onConnectionOpen);
      eventEmitter.off(events["connection-close"], onConnetionClose);
      eventEmitter.off(events["switch-meeting"], onSwitchMeeting);
      eventEmitter.off(events["error"], onError);
      eventEmitter.off(events["hls-started"], onHlsStarted);
      eventEmitter.off(events["hls-stopped"], onHlsStopped);
      eventEmitter.off(events["hls-state-changed"], onHlsStateChanged);
      eventEmitter.off(events["recording-state-changed"], onRecordingStateChanged);
      eventEmitter.off(events["livestream-state-changed"], onLivestreamStateChanged);
      eventEmitter.off(events["participant-mode-changed"], onParticipantModeChanged);
      eventEmitter.off(events["character-joined"], onCharacterJoined);
      eventEmitter.off(events["character-left"], onCharacterLeft);
      eventEmitter.off(events["media-relay-started"], onMediaRelayStarted);
      eventEmitter.off(events["media-relay-stopped"], onMediaRelayStopped);
      eventEmitter.off(events["media-relay-error"], onMediaRelayError);
      eventEmitter.off(events["media-relay-request-response"], onMediaRelayRequestResponse);
      eventEmitter.off(events["media-relay-request-received"], onMediaRelayRequestReceived);
      eventEmitter.off(events["quality-limitation"], onQualityLimitation);
    };
  }, []);
  return (0, import_react.useContext)(MeetingProviderContex);
};
var MeetingConsumer = function MeetingConsumer2(_ref2) {
  var children = _ref2.children, _ref2$onParticipantJo = _ref2.onParticipantJoined, onParticipantJoined = _ref2$onParticipantJo === void 0 ? function() {
  } : _ref2$onParticipantJo, _ref2$onParticipantLe = _ref2.onParticipantLeft, onParticipantLeft = _ref2$onParticipantLe === void 0 ? function() {
  } : _ref2$onParticipantLe, _ref2$onSpeakerChange = _ref2.onSpeakerChanged, onSpeakerChanged = _ref2$onSpeakerChange === void 0 ? function() {
  } : _ref2$onSpeakerChange, _ref2$onPresenterChan = _ref2.onPresenterChanged, onPresenterChanged = _ref2$onPresenterChan === void 0 ? function() {
  } : _ref2$onPresenterChan, _ref2$onMainParticipa = _ref2.onMainParticipantChanged, onMainParticipantChanged = _ref2$onMainParticipa === void 0 ? function() {
  } : _ref2$onMainParticipa, _ref2$onEntryRequeste = _ref2.onEntryRequested, onEntryRequested = _ref2$onEntryRequeste === void 0 ? function() {
  } : _ref2$onEntryRequeste, _ref2$onEntryResponde = _ref2.onEntryResponded, onEntryResponded = _ref2$onEntryResponde === void 0 ? function() {
  } : _ref2$onEntryResponde, _ref2$onPausedAllStre = _ref2.onPausedAllStreams, onPausedAllStreams = _ref2$onPausedAllStre === void 0 ? function() {
  } : _ref2$onPausedAllStre, _ref2$onResumedAllStr = _ref2.onResumedAllStreams, onResumedAllStreams = _ref2$onResumedAllStr === void 0 ? function() {
  } : _ref2$onResumedAllStr, _ref2$onRecordingStar = _ref2.onRecordingStarted, onRecordingStarted = _ref2$onRecordingStar === void 0 ? function() {
  } : _ref2$onRecordingStar, _ref2$onRecordingStop = _ref2.onRecordingStopped, onRecordingStopped = _ref2$onRecordingStop === void 0 ? function() {
  } : _ref2$onRecordingStop, _ref2$onData = _ref2.onData, onData = _ref2$onData === void 0 ? function() {
  } : _ref2$onData, _ref2$onMeetingJoined = _ref2.onMeetingJoined, onMeetingJoined = _ref2$onMeetingJoined === void 0 ? function() {
  } : _ref2$onMeetingJoined, _ref2$onMeetingLeft = _ref2.onMeetingLeft, onMeetingLeft = _ref2$onMeetingLeft === void 0 ? function() {
  } : _ref2$onMeetingLeft, _ref2$onLiveStreamSta = _ref2.onLiveStreamStarted, onLiveStreamStarted = _ref2$onLiveStreamSta === void 0 ? function() {
  } : _ref2$onLiveStreamSta, _ref2$onLiveStreamSto = _ref2.onLiveStreamStopped, onLiveStreamStopped = _ref2$onLiveStreamSto === void 0 ? function() {
  } : _ref2$onLiveStreamSto, _ref2$onVideoStateCha = _ref2.onVideoStateChanged, onVideoStateChanged = _ref2$onVideoStateCha === void 0 ? function() {
  } : _ref2$onVideoStateCha, _ref2$onVideoSeeked = _ref2.onVideoSeeked, onVideoSeeked = _ref2$onVideoSeeked === void 0 ? function() {
  } : _ref2$onVideoSeeked, _ref2$onWebcamRequest = _ref2.onWebcamRequested, onWebcamRequested = _ref2$onWebcamRequest === void 0 ? function() {
  } : _ref2$onWebcamRequest, _ref2$onMicRequested = _ref2.onMicRequested, onMicRequested = _ref2$onMicRequested === void 0 ? function() {
  } : _ref2$onMicRequested, _ref2$onPinStateChang = _ref2.onPinStateChanged, onPinStateChanged = _ref2$onPinStateChang === void 0 ? function() {
  } : _ref2$onPinStateChang, _ref2$onConnectionOpe = _ref2.onConnectionOpen, onConnectionOpen = _ref2$onConnectionOpe === void 0 ? function() {
  } : _ref2$onConnectionOpe, _ref2$onConnetionClos = _ref2.onConnetionClose, onConnetionClose = _ref2$onConnetionClos === void 0 ? function() {
  } : _ref2$onConnetionClos, _ref2$onSwitchMeeting = _ref2.onSwitchMeeting, onSwitchMeeting = _ref2$onSwitchMeeting === void 0 ? function() {
  } : _ref2$onSwitchMeeting, _ref2$onError = _ref2.onError, onError = _ref2$onError === void 0 ? function() {
  } : _ref2$onError, _ref2$onHlsStarted = _ref2.onHlsStarted, onHlsStarted = _ref2$onHlsStarted === void 0 ? function() {
  } : _ref2$onHlsStarted, _ref2$onHlsStopped = _ref2.onHlsStopped, onHlsStopped = _ref2$onHlsStopped === void 0 ? function() {
  } : _ref2$onHlsStopped, _ref2$onHlsStateChang = _ref2.onHlsStateChanged, onHlsStateChanged = _ref2$onHlsStateChang === void 0 ? function() {
  } : _ref2$onHlsStateChang, _ref2$onRecordingStat = _ref2.onRecordingStateChanged, onRecordingStateChanged = _ref2$onRecordingStat === void 0 ? function() {
  } : _ref2$onRecordingStat, _ref2$onLivestreamSta = _ref2.onLivestreamStateChanged, onLivestreamStateChanged = _ref2$onLivestreamSta === void 0 ? function() {
  } : _ref2$onLivestreamSta, _ref2$onMeetingStateC = _ref2.onMeetingStateChanged, onMeetingStateChanged = _ref2$onMeetingStateC === void 0 ? function() {
  } : _ref2$onMeetingStateC, _ref2$onParticipantMo = _ref2.onParticipantModeChanged, onParticipantModeChanged = _ref2$onParticipantMo === void 0 ? function() {
  } : _ref2$onParticipantMo, _ref2$onCharacterJoin = _ref2.onCharacterJoined, onCharacterJoined = _ref2$onCharacterJoin === void 0 ? function() {
  } : _ref2$onCharacterJoin, _ref2$onCharacterLeft = _ref2.onCharacterLeft, onCharacterLeft = _ref2$onCharacterLeft === void 0 ? function() {
  } : _ref2$onCharacterLeft, _ref2$onMediaRelaySta = _ref2.onMediaRelayStarted, onMediaRelayStarted = _ref2$onMediaRelaySta === void 0 ? function() {
  } : _ref2$onMediaRelaySta, _ref2$onMediaRelaySto = _ref2.onMediaRelayStopped, onMediaRelayStopped = _ref2$onMediaRelaySto === void 0 ? function() {
  } : _ref2$onMediaRelaySto, _ref2$onMediaRelayErr = _ref2.onMediaRelayError, onMediaRelayError = _ref2$onMediaRelayErr === void 0 ? function() {
  } : _ref2$onMediaRelayErr, _ref2$onMediaRelayReq = _ref2.onMediaRelayRequestResponse, onMediaRelayRequestResponse = _ref2$onMediaRelayReq === void 0 ? function() {
  } : _ref2$onMediaRelayReq, _ref2$onMediaRelayReq2 = _ref2.onMediaRelayRequestReceived, onMediaRelayRequestReceived = _ref2$onMediaRelayReq2 === void 0 ? function() {
  } : _ref2$onMediaRelayReq2, _ref2$onQualityLimita = _ref2.onQualityLimitation, onQualityLimitation = _ref2$onQualityLimita === void 0 ? function() {
  } : _ref2$onQualityLimita;
  (0, import_react.useEffect)(function() {
    eventEmitter.on(events["meeting-state-changed"], onMeetingStateChanged);
    eventEmitter.on(events["participant-joined"], onParticipantJoined);
    eventEmitter.on(events["participant-left"], onParticipantLeft);
    eventEmitter.on(events["speaker-changed"], onSpeakerChanged);
    eventEmitter.on(events["presenter-changed"], onPresenterChanged);
    eventEmitter.on(events["main-participant-changed"], onMainParticipantChanged);
    eventEmitter.on(events["entry-requested"], onEntryRequested);
    eventEmitter.on(events["entry-responded"], onEntryResponded);
    eventEmitter.on(events["paused-all-streams"], onPausedAllStreams);
    eventEmitter.on(events["resumed-all-streams"], onResumedAllStreams);
    eventEmitter.on(events["recording-started"], onRecordingStarted);
    eventEmitter.on(events["recording-stopped"], onRecordingStopped);
    eventEmitter.on(events["data"], onData);
    eventEmitter.on(events["meeting-joined"], onMeetingJoined);
    eventEmitter.on(events["meeting-left"], onMeetingLeft);
    eventEmitter.on(events["live-stream-enabled"], onLiveStreamStarted);
    eventEmitter.on(events["live-stream-disabled"], onLiveStreamStopped);
    eventEmitter.on(events["video-state-changed"], onVideoStateChanged);
    eventEmitter.on(events["video-seeked"], onVideoSeeked);
    eventEmitter.on(events["webcam-requested"], onWebcamRequested);
    eventEmitter.on(events["mic-requested"], onMicRequested);
    eventEmitter.on(events["pin-state-changed"], onPinStateChanged);
    eventEmitter.on(events["connection-open"], onConnectionOpen);
    eventEmitter.on(events["connection-close"], onConnetionClose);
    eventEmitter.on(events["switch-meeting"], onSwitchMeeting);
    eventEmitter.on(events["error"], onError);
    eventEmitter.on(events["hls-started"], onHlsStarted);
    eventEmitter.on(events["hls-stopped"], onHlsStopped);
    eventEmitter.on(events["hls-state-changed"], onHlsStateChanged);
    eventEmitter.on(events["recording-state-changed"], onRecordingStateChanged);
    eventEmitter.on(events["livestream-state-changed"], onLivestreamStateChanged);
    eventEmitter.on(events["participant-mode-changed"], onParticipantModeChanged);
    eventEmitter.on(events["character-joined"], onCharacterJoined);
    eventEmitter.on(events["character-left"], onCharacterLeft);
    eventEmitter.on(events["media-relay-started"], onMediaRelayStarted);
    eventEmitter.on(events["media-relay-stopped"], onMediaRelayStopped);
    eventEmitter.on(events["media-relay-error"], onMediaRelayError);
    eventEmitter.on(events["media-relay-request-response"], onMediaRelayRequestResponse);
    eventEmitter.on(events["media-relay-request-received"], onMediaRelayRequestReceived);
    eventEmitter.on(events["quality-limitation"], onQualityLimitation);
    return function() {
      eventEmitter.off(events["meeting-state-changed"], onMeetingStateChanged);
      eventEmitter.off(events["participant-joined"], onParticipantJoined);
      eventEmitter.off(events["participant-left"], onParticipantLeft);
      eventEmitter.off(events["speaker-changed"], onSpeakerChanged);
      eventEmitter.off(events["presenter-changed"], onPresenterChanged);
      eventEmitter.off(events["main-participant-changed"], onMainParticipantChanged);
      eventEmitter.off(events["entry-requested"], onEntryRequested);
      eventEmitter.off(events["entry-responded"], onEntryResponded);
      eventEmitter.off(events["paused-all-streams"], onPausedAllStreams);
      eventEmitter.off(events["resumed-all-streams"], onResumedAllStreams);
      eventEmitter.off(events["recording-started"], onRecordingStarted);
      eventEmitter.off(events["recording-stopped"], onRecordingStopped);
      eventEmitter.off(events["data"], onData);
      eventEmitter.off(events["meeting-joined"], onMeetingJoined);
      eventEmitter.off(events["meeting-left"], onMeetingLeft);
      eventEmitter.off(events["live-stream-enabled"], onLiveStreamStarted);
      eventEmitter.off(events["live-stream-disabled"], onLiveStreamStopped);
      eventEmitter.off(events["video-state-changed"], onVideoStateChanged);
      eventEmitter.off(events["video-seeked"], onVideoSeeked);
      eventEmitter.off(events["webcam-requested"], onWebcamRequested);
      eventEmitter.off(events["mic-requested"], onMicRequested);
      eventEmitter.off(events["pin-state-changed"], onPinStateChanged);
      eventEmitter.off(events["connection-open"], onConnectionOpen);
      eventEmitter.off(events["connection-close"], onConnetionClose);
      eventEmitter.off(events["switch-meeting"], onSwitchMeeting);
      eventEmitter.off(events["error"], onError);
      eventEmitter.off(events["hls-started"], onHlsStarted);
      eventEmitter.off(events["hls-stopped"], onHlsStopped);
      eventEmitter.off(events["hls-state-changed"], onHlsStateChanged);
      eventEmitter.off(events["recording-state-changed"], onRecordingStateChanged);
      eventEmitter.off(events["livestream-state-changed"], onLivestreamStateChanged);
      eventEmitter.off(events["participant-mode-changed"], onParticipantModeChanged);
      eventEmitter.off(events["character-joined"], onCharacterJoined);
      eventEmitter.off(events["character-left"], onCharacterLeft);
      eventEmitter.off(events["media-relay-started"], onMediaRelayStarted);
      eventEmitter.off(events["media-relay-stopped"], onMediaRelayStopped);
      eventEmitter.off(events["media-relay-error"], onMediaRelayError);
      eventEmitter.off(events["media-relay-request-response"], onMediaRelayRequestResponse);
      eventEmitter.off(events["media-relay-request-received"], onMediaRelayRequestReceived);
      eventEmitter.off(events["quality-limitation"], onQualityLimitation);
    };
  }, []);
  return import_react.default.createElement(import_react.default.Fragment, null, import_react.default.createElement(MeetingProviderContex.Consumer, null, children));
};
var version = "0.4.12";
var MeetingProvider = function MeetingProvider2(_ref) {
  var children = _ref.children, config2 = _ref.config, token = _ref.token, joinWithoutUserInteraction = _ref.joinWithoutUserInteraction, _reinitialiseMeetingOnConfigChange = _ref.reinitialiseMeetingOnConfigChange, deviceInfo = _ref.deviceInfo, keyProvider = _ref.keyProvider;
  var _useState = (0, import_react.useState)(null), meeting = _useState[0], setMeeting = _useState[1];
  var _useState2 = (0, import_react.useState)(null), localParticipant = _useState2[0], setLocalParticipant = _useState2[1];
  var _useState3 = (0, import_react.useState)(null), mainParticipant = _useState3[0], setMainParticipant = _useState3[1];
  var _useState4 = (0, import_react.useState)(null), activeSpeakerId = _useState4[0], setActiveSpeakerId = _useState4[1];
  var _useState5 = (0, import_react.useState)(null), presenterId = _useState5[0], setPresenterId = _useState5[1];
  var _useState6 = (0, import_react.useState)(false), localMicOn = _useState6[0], setLocalMicOn = _useState6[1];
  var _useState7 = (0, import_react.useState)(false), localWebcamOn = _useState7[0], setLocalWebcamOn = _useState7[1];
  var _useState8 = (0, import_react.useState)(false), localScreenShareOn = _useState8[0], setLocalScreenShareOn = _useState8[1];
  var _useState9 = (0, import_react.useState)(false), isRecording = _useState9[0], setIsRecording = _useState9[1];
  var _useState0 = (0, import_react.useState)([]), messages = _useState0[0], setMessages = _useState0[1];
  var _useState1 = (0, import_react.useState)(/* @__PURE__ */ new Map()), participants = _useState1[0], setParticipants = _useState1[1];
  var _useState10 = (0, import_react.useState)(/* @__PURE__ */ new Map()), characters = _useState10[0], setCharacters = _useState10[1];
  var _useState11 = (0, import_react.useState)(/* @__PURE__ */ new Map()), pinnedParticipants = _useState11[0], setPinnedParticipants = _useState11[1];
  var _useState12 = (0, import_react.useState)(false), isLiveStreaming = _useState12[0], setIsLiveStreaming = _useState12[1];
  var _useState13 = (0, import_react.useState)(/* @__PURE__ */ new Map()), connections = _useState13[0], setConnections = _useState13[1];
  var _useState14 = (0, import_react.useState)(false), isMeetingJoined = _useState14[0], setIsMeetingJoined = _useState14[1];
  var _useState15 = (0, import_react.useState)(false), isHls = _useState15[0], setIsHls = _useState15[1];
  var _useState16 = (0, import_react.useState)("RECORDING_STOPPED"), recordingState = _useState16[0], setRecordingState = _useState16[1];
  var _useState17 = (0, import_react.useState)("LIVESTREAM_STOPPED"), livestreamState = _useState17[0], setLivestreamState = _useState17[1];
  var _useState18 = (0, import_react.useState)("HLS_STOPPED"), hlsState = _useState18[0], setHlsState = _useState18[1];
  var _useState19 = (0, import_react.useState)({
    downstreamUrl: null,
    playbackHlsUrl: null,
    livestreamUrl: null
  }), hlsUrls = _useState19[0], setHlsUrls = _useState19[1];
  var _useState20 = (0, import_react.useState)("TRANSCRIPTION_STOPPED"), transcriptionState = _useState20[0], setTranscriptionState = _useState20[1];
  var _useState21 = (0, import_react.useState)("TRANSLATION_STOPPED"), translationState = _useState21[0], setTranslationState = _useState21[1];
  var meetingRef = (0, import_react.useRef)();
  var localMicOnRef = (0, import_react.useRef)();
  var localWebcamOnRef = (0, import_react.useRef)();
  var localScreenShareOnRef = (0, import_react.useRef)();
  var isRecordingRef = (0, import_react.useRef)();
  var keyProviderRef = (0, import_react.useRef)(keyProvider);
  var configRef = (0, import_react.useRef)(config2);
  var tokenRef = (0, import_react.useRef)(token);
  var joinedOnFirstRender = (0, import_react.useRef)(false);
  var isHlsRef = (0, import_react.useRef)();
  var reinitialiseMeetingOnConfigChange = (0, import_react.useMemo)(function() {
    return _reinitialiseMeetingOnConfigChange;
  }, []);
  (0, import_react.useEffect)(function() {
    meetingRef.current = meeting;
  }, [meeting]);
  (0, import_react.useEffect)(function() {
    localMicOnRef.current = localMicOn;
  }, [localMicOn]);
  (0, import_react.useEffect)(function() {
    localWebcamOnRef.current = localWebcamOn;
  }, [localWebcamOn]);
  (0, import_react.useEffect)(function() {
    localScreenShareOnRef.current = localScreenShareOn;
  }, [localScreenShareOn]);
  (0, import_react.useEffect)(function() {
    isRecordingRef.current = isRecording;
  }, [isRecording]);
  (0, import_react.useEffect)(function() {
    configRef.current = config2;
  }, [config2]);
  (0, import_react.useEffect)(function() {
    tokenRef.current = token;
  }, [token]);
  (0, import_react.useEffect)(function() {
    isHlsRef.current = isHls;
  }, [isHls]);
  var resetStates = function resetStates2() {
    setMeeting(null);
    setLocalParticipant(null);
    setMainParticipant(null);
    setActiveSpeakerId(null);
    setPresenterId(null);
    setLocalMicOn(false);
    setLocalWebcamOn(false);
    setLocalScreenShareOn(false);
    setIsRecording(false);
    setMessages([]);
    setIsLiveStreaming(false);
    setParticipants(/* @__PURE__ */ new Map());
    setCharacters(/* @__PURE__ */ new Map());
    setPinnedParticipants(/* @__PURE__ */ new Map());
    setConnections(/* @__PURE__ */ new Map());
    setIsMeetingJoined(false);
    setIsHls(false);
    setRecordingState("RECORDING_STOPPED");
    setLivestreamState("LIVESTREAM_STOPPED");
    setHlsState("HLS_STOPPED");
    setTranscriptionState("TRANSCRIPTION_STOPPED");
    setTranslationState("TRANSLATION_STOPPED");
    setHlsUrls({
      downstreamUrl: null,
      playbackHlsUrl: null,
      livestreamUrl: null
    });
  };
  var _handle_participant_joined = function _handle_participant_joined2(participant) {
    setParticipants(function(participants2) {
      participants2.set(participant.id, participant);
      var participantsToSet = new Map(participants2);
      return participantsToSet;
    });
    eventEmitter.emit(events["participant-joined"], participant);
  };
  var _handle_participant_left = function _handle_participant_left2(participant, reason) {
    setParticipants(function(participants2) {
      participants2["delete"](participant.id);
      var newParticipants = new Map(participants2);
      return newParticipants;
    });
    eventEmitter.emit(events["participant-left"], participant, reason);
  };
  var _handle_presenter_changed = function _handle_presenter_changed2(presenterId2) {
    var _meetingRef$current, _meetingRef$current$l;
    setPresenterId(presenterId2);
    setLocalScreenShareOn(presenterId2 === (meetingRef === null || meetingRef === void 0 ? void 0 : (_meetingRef$current = meetingRef.current) === null || _meetingRef$current === void 0 ? void 0 : (_meetingRef$current$l = _meetingRef$current.localParticipant) === null || _meetingRef$current$l === void 0 ? void 0 : _meetingRef$current$l.id));
    eventEmitter.emit(events["presenter-changed"], presenterId2);
  };
  var _handle_main_participant_changed = function _handle_main_participant_changed2(participant) {
    setMainParticipant(participant);
    eventEmitter.emit(events["main-participant-changed"], participant);
  };
  var _handle_speaker_changed = function _handle_speaker_changed2(activeSpeakerId2) {
    setActiveSpeakerId(activeSpeakerId2);
    eventEmitter.emit(events["speaker-changed"], activeSpeakerId2);
  };
  var _handle_chat_message = function _handle_chat_message2(data) {
    setMessages(function(s) {
      return [].concat(s, [data]);
    });
    eventEmitter.emit(events["data"], data);
  };
  var _handle_entry_requested = function _handle_entry_requested2(data) {
    eventEmitter.emit(events["entry-requested"], data);
  };
  var _handle_entry_responded = function _handle_entry_responded2(participantId, decision) {
    eventEmitter.emit(events["entry-responded"], participantId, decision);
  };
  var _handle_recording_started = function _handle_recording_started2() {
    setIsRecording(true);
    eventEmitter.emit(events["recording-started"]);
  };
  var _handle_recording_stopped = function _handle_recording_stopped2() {
    setIsRecording(false);
    eventEmitter.emit(events["recording-stopped"]);
  };
  var _handle_localParticipant_stream_enabled = function _handle_localParticipant_stream_enabled2(stream) {
    if (stream.track.readyState === "live") {
      if (stream.kind === "video") {
        setLocalWebcamOn(true);
      } else if (stream.kind === "audio") {
        setLocalMicOn(true);
      }
    }
  };
  var _handle_localParticipant_stream_disabled = function _handle_localParticipant_stream_disabled2(stream) {
    if (stream.kind === "video") {
      setLocalWebcamOn(false);
    } else if (stream.kind === "audio") {
      setLocalMicOn(false);
    }
  };
  var _handle_live_stream_started = function _handle_live_stream_started2(data) {
    setIsLiveStreaming(true);
    eventEmitter.emit(events["live-stream-started"], data);
  };
  var _handle_live_stream_stopped = function _handle_live_stream_stopped2() {
    setIsLiveStreaming(false);
    eventEmitter.emit(events["live-stream-stopped"]);
  };
  var _handle_hls_started = function _handle_hls_started2(data) {
    setIsHls(true);
    eventEmitter.emit(events["hls-started"], data);
  };
  var _handle_hls_stopped = function _handle_hls_stopped2() {
    setIsHls(false);
    eventEmitter.emit(events["hls-stopped"]);
  };
  var _handle_video_state_changed = function _handle_video_state_changed2(data) {
    eventEmitter.emit(events["video-state-changed"], data);
  };
  var _handle_video_seeked = function _handle_video_seeked2(data) {
    eventEmitter.emit(events["video-seeked"], data);
  };
  var _handle_webcam_requested = function _handle_webcam_requested2(data) {
    eventEmitter.emit(events["webcam-requested"], data);
  };
  var _handle_mic_requested = function _handle_mic_requested2(data) {
    eventEmitter.emit(events["mic-requested"], data);
  };
  var _handle_meeting_joined = function _handle_meeting_joined2(data) {
    if (data.switchRoomId) {
      setMessages(function(s) {
        return [].concat(s, data.messages);
      });
      eventEmitter.emit(events["meeting-joined"], data);
    } else {
      joinedOnFirstRender.current = true;
      setMessages(function(s) {
        return [].concat(s, data.messages);
      });
      eventEmitter.emit(events["meeting-joined"], data);
      setIsMeetingJoined(true);
    }
  };
  var _handle_meeting_left2 = function _handle_meeting_left(data) {
    eventEmitter.emit(events["meeting-left"], data);
    var meeting2 = meetingRef.current;
    if (meeting2) {
      var _meeting$localPartici;
      if (typeof (meeting2 === null || meeting2 === void 0 ? void 0 : meeting2.off) === "function") {
        meeting2.off("meeting-state-changed", _handle_meeting_state_changed);
        meeting2.off("participant-joined", _handle_participant_joined);
        meeting2.off("participant-left", _handle_participant_left);
        meeting2.off("presenter-changed", _handle_presenter_changed);
        meeting2.off("main-participant-changed", _handle_main_participant_changed);
        meeting2.off("speaker-changed", _handle_speaker_changed);
        meeting2.off("entry-requested", _handle_entry_requested);
        meeting2.off("entry-responded", _handle_entry_responded);
        meeting2.off("data", _handle_chat_message);
        meeting2.off("recording-started", _handle_recording_started);
        meeting2.off("recording-stopped", _handle_recording_stopped);
        meeting2.off("meeting-joined", _handle_meeting_joined);
        meeting2.off("meeting-left", _handle_meeting_left2);
        meeting2.off("livestream-started", _handle_live_stream_started);
        meeting2.off("livestream-stopped", _handle_live_stream_stopped);
        meeting2.off("video-state-changed", _handle_video_state_changed);
        meeting2.off("video-seeked", _handle_video_seeked);
        meeting2.off("webcam-requested", _handle_webcam_requested);
        meeting2.off("mic-requested", _handle_mic_requested);
        meeting2.off("pin-state-changed", _handle_pin_state_changed);
        meeting2.off("paused-all-streams", _handle_streams_paused);
        meeting2.off("resumed-all-streams", _handle_streams_resumed);
        meeting2.off("connection-open", _handle_connection_open);
        meeting2.off("connection-close", _handle_connection_close);
        meeting2.off("switch-meeting", _handle_switch_meeting);
        meeting2.off("error", _handle_error);
        meeting2.off("hls-started", _handle_hls_started);
        meeting2.off("hls-stopped", _handle_hls_stopped);
        meeting2.off("recording-state-changed", _handle_recording_state_changed);
        meeting2.off("livestream-state-changed", _handle_livestream_state_changed);
        meeting2.off("hls-state-changed", _handle_hls_state_changed);
        meeting2.off("participant-mode-changed", _handel_participant_mode_changed);
        meeting2.off("whiteboard-stopped", _handle_whiteboard_stopped);
        meeting2.off("whiteboard-started", _handle_whiteboard_started);
        meeting2.off("transcription-state-changed", _handle_transcription_state_changed);
        meeting2.off("transcription-text", _handle_transcription_text);
        meeting2.off("translation-state-changed", _handle_translation_state_changed);
        meeting2.off("translation-text", _handle_translation_text);
        meeting2.off("translation-language-changed", _handle_translation_language_changed);
        meeting2.off("character-joined", _handle_character_joined);
        meeting2.off("character-left", _handle_character_left);
        meeting2.off("media-relay-started", _handle_media_relay_started);
        meeting2.off("media-relay-stopped", _handle_media_relay_stopped);
        meeting2.off("media-relay-error", _handle_media_relay_error);
        meeting2.off("media-relay-request-response", _handle_media_relay_request_response);
        meeting2.off("media-relay-request-received", _handle_media_relay_request_received);
        meeting2.off("quality-limitation", _handle_quality_limitation_received);
      }
      if (typeof (meeting2 === null || meeting2 === void 0 ? void 0 : (_meeting$localPartici = meeting2.localParticipant) === null || _meeting$localPartici === void 0 ? void 0 : _meeting$localPartici.off) === "function") {
        meeting2.localParticipant.off("stream-enabled", _handle_localParticipant_stream_enabled);
        meeting2.localParticipant.off("stream-disabled", _handle_localParticipant_stream_disabled);
      }
      resetStates();
    }
  };
  var _handle_pin_state_changed = function _handle_pin_state_changed2(_ref2) {
    var participantId = _ref2.participantId, state = _ref2.state, pinnedBy = _ref2.pinnedBy;
    setPinnedParticipants(function(pinnedParticipants2) {
      if (!state.cam && !state.share) {
        pinnedParticipants2["delete"](participantId);
      } else {
        pinnedParticipants2.set(participantId, state);
      }
      var pinnedParticipantsToSet = new Map(pinnedParticipants2);
      return pinnedParticipantsToSet;
    });
    eventEmitter.emit(events["pin-state-changed"], {
      participantId,
      state,
      pinnedBy
    });
  };
  var _handle_streams_paused = function _handle_streams_paused2(_ref3) {
    var kind = _ref3.kind;
    eventEmitter.emit(events["paused-all-streams"], {
      kind
    });
  };
  var _handle_streams_resumed = function _handle_streams_resumed2(_ref4) {
    var kind = _ref4.kind;
    eventEmitter.emit(events["resumed-all-streams"], {
      kind
    });
  };
  var _handle_connection_open = function _handle_connection_open2(connection) {
    setConnections(function(s) {
      s.set(connection.id, connection);
      var connectionsToSet = new Map(s);
      return connectionsToSet;
    });
    eventEmitter.emit(events["connection-open"], connection);
  };
  var _handle_connection_close = function _handle_connection_close2(connectionId) {
    setConnections(function(s) {
      s["delete"](connectionId);
      var newConnections = new Map(s);
      return newConnections;
    });
    eventEmitter.emit(events["connection-close"], connectionId);
  };
  var _handle_switch_meeting = function _handle_switch_meeting2(d) {
    eventEmitter.emit(events["switch-meeting"], d);
  };
  var _handle_error = function _handle_error2(data) {
    eventEmitter.emit(events["error"], data);
  };
  var _handle_recording_state_changed = function _handle_recording_state_changed2(data) {
    setRecordingState(data === null || data === void 0 ? void 0 : data.status);
    eventEmitter.emit(events["recording-state-changed"], data);
  };
  var _handle_livestream_state_changed = function _handle_livestream_state_changed2(data) {
    setLivestreamState(data === null || data === void 0 ? void 0 : data.status);
    eventEmitter.emit(events["livestream-state-changed"], data);
  };
  var _handle_hls_state_changed = function _handle_hls_state_changed2(data) {
    setHlsState(data === null || data === void 0 ? void 0 : data.status);
    if ((data === null || data === void 0 ? void 0 : data.status) == "HLS_PLAYABLE") {
      setHlsUrls({
        downstreamUrl: data === null || data === void 0 ? void 0 : data.downstreamUrl,
        playbackHlsUrl: data === null || data === void 0 ? void 0 : data.playbackHlsUrl,
        livestreamUrl: data === null || data === void 0 ? void 0 : data.livestreamUrl
      });
    } else if ((data === null || data === void 0 ? void 0 : data.status) == "HLS_STOPPED") {
      setHlsUrls({
        downstreamUrl: null,
        playbackHlsUrl: null,
        livestreamUrl: null
      });
    }
    eventEmitter.emit(events["hls-state-changed"], data);
  };
  var _handle_meeting_state_changed = function _handle_meeting_state_changed2(data) {
    eventEmitter.emit(events["meeting-state-changed"], data);
  };
  var _handle_transcription_state_changed = function _handle_transcription_state_changed2(data) {
    setTranscriptionState(data === null || data === void 0 ? void 0 : data.status);
    eventEmitter.emit(events["transcription-state-changed"], data);
  };
  var _handle_transcription_text = function _handle_transcription_text2(data) {
    eventEmitter.emit(events["transcription-text"], data);
  };
  var _handle_translation_state_changed = function _handle_translation_state_changed2(data) {
    setTranslationState(data === null || data === void 0 ? void 0 : data.status);
    eventEmitter.emit(events["translation-state-changed"], data);
  };
  var _handle_translation_text = function _handle_translation_text2(data) {
    eventEmitter.emit(events["translation-text"], data);
  };
  var _handle_translation_language_changed = function _handle_translation_language_changed2(data) {
    eventEmitter.emit(events["translation-language-changed"], data);
  };
  var _handle_whiteboard_started = function _handle_whiteboard_started2(data) {
    eventEmitter.emit(events["whiteboard-started"], data);
  };
  var _handle_whiteboard_stopped = function _handle_whiteboard_stopped2(data) {
    eventEmitter.emit(events["whiteboard-stopped"], data);
  };
  var _handle_character_joined = function _handle_character_joined2(character) {
    setCharacters(function(characters2) {
      characters2.set(character.id, character);
      var charactersToSet = new Map(characters2);
      return charactersToSet;
    });
    eventEmitter.emit(events["character-joined"], character);
  };
  var _handle_character_left = function _handle_character_left2(character) {
    setCharacters(function(characters2) {
      characters2["delete"](character.id);
      var newCharacters = new Map(characters2);
      return newCharacters;
    });
    eventEmitter.emit(events["character-left"], character);
  };
  var _handel_participant_mode_changed = function _handel_participant_mode_changed2(data) {
    var _meetingRef$current2, _meetingRef$current2$;
    setParticipants(function(participants2) {
      var part = participants2.get(data.participantId);
      part.mode = data.mode;
      participants2.set(part.id, part);
      var participantsToSet = new Map(participants2);
      return participantsToSet;
    });
    if (data.participantId === (meetingRef === null || meetingRef === void 0 ? void 0 : (_meetingRef$current2 = meetingRef.current) === null || _meetingRef$current2 === void 0 ? void 0 : (_meetingRef$current2$ = _meetingRef$current2.localParticipant) === null || _meetingRef$current2$ === void 0 ? void 0 : _meetingRef$current2$.id)) {
      setLocalParticipant(function(participant) {
        participant.mode = data.mode;
        return participant;
      });
    }
    eventEmitter.emit(events["participant-mode-changed"], data);
  };
  var _handle_media_relay_started = function _handle_media_relay_started2(data) {
    eventEmitter.emit(events["media-relay-started"], data);
  };
  var _handle_media_relay_stopped = function _handle_media_relay_stopped2(data) {
    eventEmitter.emit(events["media-relay-stopped"], data);
  };
  var _handle_media_relay_error = function _handle_media_relay_error2(data) {
    eventEmitter.emit(events["media-relay-error"], data);
  };
  var _handle_media_relay_request_response = function _handle_media_relay_request_response2(data) {
    eventEmitter.emit(events["media-relay-request-response"], data);
  };
  var _handle_media_relay_request_received = function _handle_media_relay_request_received2(data) {
    eventEmitter.emit(events["media-relay-request-received"], data);
  };
  var _handle_quality_limitation_received = function _handle_quality_limitation_received2(data) {
    eventEmitter.emit(events["quality-limitation"], data);
  };
  var join = function join2() {
    var meeting2 = import_js_sdk.VideoSDK && import_js_sdk.VideoSDK.initMeeting(configRef.current);
    setMeeting(meeting2);
    var localParticipant2 = meeting2.localParticipant, participants2 = meeting2.participants, characters2 = meeting2.characters;
    participants2.set(localParticipant2.id, localParticipant2);
    setParticipants(participants2);
    setCharacters(characters2);
    setLocalParticipant(localParticipant2);
    meeting2.on("meeting-state-changed", _handle_meeting_state_changed);
    meeting2.on("participant-joined", _handle_participant_joined);
    meeting2.on("participant-left", _handle_participant_left);
    meeting2.on("presenter-changed", _handle_presenter_changed);
    meeting2.on("main-participant-changed", _handle_main_participant_changed);
    meeting2.on("speaker-changed", _handle_speaker_changed);
    meeting2.on("entry-requested", _handle_entry_requested);
    meeting2.on("entry-responded", _handle_entry_responded);
    meeting2.on("data", _handle_chat_message);
    meeting2.on("recording-started", _handle_recording_started);
    meeting2.on("recording-stopped", _handle_recording_stopped);
    meeting2.on("meeting-joined", _handle_meeting_joined);
    meeting2.on("meeting-left", _handle_meeting_left2);
    meeting2.on("livestream-started", _handle_live_stream_started);
    meeting2.on("livestream-stopped", _handle_live_stream_stopped);
    meeting2.on("video-state-changed", _handle_video_state_changed);
    meeting2.on("video-seeked", _handle_video_seeked);
    meeting2.on("webcam-requested", _handle_webcam_requested);
    meeting2.on("mic-requested", _handle_mic_requested);
    meeting2.on("pin-state-changed", _handle_pin_state_changed);
    meeting2.on("paused-all-streams", _handle_streams_paused);
    meeting2.on("resumed-all-streams", _handle_streams_resumed);
    meeting2.on("connection-open", _handle_connection_open);
    meeting2.on("connection-close", _handle_connection_close);
    meeting2.on("switch-meeting", _handle_switch_meeting);
    meeting2.on("error", _handle_error);
    meeting2.on("hls-started", _handle_hls_started);
    meeting2.on("hls-stopped", _handle_hls_stopped);
    meeting2.on("recording-state-changed", _handle_recording_state_changed);
    meeting2.on("livestream-state-changed", _handle_livestream_state_changed);
    meeting2.on("hls-state-changed", _handle_hls_state_changed);
    meeting2.on("participant-mode-changed", _handel_participant_mode_changed);
    meeting2.on("transcription-state-changed", _handle_transcription_state_changed);
    meeting2.on("transcription-text", _handle_transcription_text);
    meeting2.on("translation-state-changed", _handle_translation_state_changed);
    meeting2.on("translation-text", _handle_translation_text);
    meeting2.on("translation-language-changed", _handle_translation_language_changed);
    meeting2.on("whiteboard-started", _handle_whiteboard_started);
    meeting2.on("whiteboard-stopped", _handle_whiteboard_stopped);
    meeting2.on("character-joined", _handle_character_joined);
    meeting2.on("character-left", _handle_character_left);
    meeting2.on("media-relay-started", _handle_media_relay_started);
    meeting2.on("media-relay-stopped", _handle_media_relay_stopped);
    meeting2.on("media-relay-error", _handle_media_relay_error);
    meeting2.on("media-relay-request-response", _handle_media_relay_request_response);
    meeting2.on("media-relay-request-received", _handle_media_relay_request_received);
    meeting2.on("quality-limitation", _handle_quality_limitation_received);
    meeting2.localParticipant.on("stream-enabled", _handle_localParticipant_stream_enabled);
    meeting2.localParticipant.on("stream-disabled", _handle_localParticipant_stream_disabled);
    meeting2.join();
  };
  var leave = function leave2() {
    var meeting2 = meetingRef.current;
    if (meeting2) {
      meeting2.leave();
    }
  };
  var end = function end2() {
    var meeting2 = meetingRef.current;
    if (meeting2) {
      meeting2.end();
    }
  };
  var pauseAllStreams = function pauseAllStreams2(kind) {
    var meeting2 = meetingRef.current;
    if (meeting2) {
      meeting2.pauseAllStreams(kind);
    }
  };
  var resumeAllStreams = function resumeAllStreams2(kind) {
    var meeting2 = meetingRef.current;
    if (meeting2) {
      meeting2.resumeAllStreams(kind);
    }
  };
  var startRecording = function startRecording2(webhookUrl, awsDirPath, config3, transcription) {
    var meeting2 = meetingRef.current;
    if (meeting2) {
      meeting2.startRecording(webhookUrl, awsDirPath, config3, transcription);
    }
  };
  var stopRecording = function stopRecording2() {
    var meeting2 = meetingRef.current;
    if (meeting2) {
      var _isRecording = isRecordingRef.current;
      if (_isRecording) {
        meeting2.stopRecording();
      }
    }
  };
  var unmuteMic = function unmuteMic2(customAudioTrack) {
    if (customAudioTrack === void 0) {
      customAudioTrack = void 0;
    }
    var meeting2 = meetingRef.current;
    if (meeting2) {
      meeting2.unmuteMic(customAudioTrack);
    }
  };
  var muteMic = function muteMic2() {
    var meeting2 = meetingRef.current;
    if (meeting2) {
      meeting2.muteMic();
    }
  };
  var toggleMic = function toggleMic2(customAudioTrack) {
    if (customAudioTrack === void 0) {
      customAudioTrack = void 0;
    }
    var localMicOn2 = localMicOnRef.current;
    if (localMicOn2) {
      muteMic();
    } else {
      unmuteMic(customAudioTrack);
    }
  };
  var disableWebcam = function disableWebcam2() {
    var meeting2 = meetingRef.current;
    if (meeting2) {
      meeting2.disableWebcam();
    }
  };
  var enableWebcam = function enableWebcam2(customVideoTrack) {
    if (customVideoTrack === void 0) {
      customVideoTrack = void 0;
    }
    var meeting2 = meetingRef.current;
    if (meeting2) {
      meeting2.enableWebcam(customVideoTrack);
    }
  };
  var toggleWebcam = function toggleWebcam2(customVideoTrack) {
    if (customVideoTrack === void 0) {
      customVideoTrack = void 0;
    }
    var localWebcamOn2 = localWebcamOnRef.current;
    if (localWebcamOn2) {
      disableWebcam();
    } else {
      enableWebcam(customVideoTrack);
    }
  };
  var switchTo = function switchTo2(_ref5) {
    var meetingId = _ref5.meetingId, token2 = _ref5.token;
    var meeting2 = meetingRef.current;
    if (meeting2) {
      meeting2.switchTo({
        meetingId,
        token: token2
      });
    }
  };
  var disableScreenShare = function disableScreenShare2() {
    var meeting2 = meetingRef.current;
    if (meeting2) {
      meeting2.disableScreenShare();
    }
  };
  var enableScreenShare = function enableScreenShare2(customScreenShareTrack) {
    if (customScreenShareTrack === void 0) {
      customScreenShareTrack = void 0;
    }
    var meeting2 = meetingRef.current;
    if (meeting2) {
      meeting2.enableScreenShare(customScreenShareTrack);
    }
  };
  var toggleScreenShare = function toggleScreenShare2(customScreenShareTrack) {
    if (customScreenShareTrack === void 0) {
      customScreenShareTrack = void 0;
    }
    var localScreenShareOn2 = localScreenShareOnRef.current;
    if (localScreenShareOn2) {
      disableScreenShare();
    } else {
      enableScreenShare(customScreenShareTrack);
    }
  };
  var changeMode = function changeMode2(mode) {
    var meeting2 = meetingRef.current;
    if (meeting2) {
      meeting2.changeMode(mode);
    }
  };
  var send = function send2(payload, options) {
    if (options === void 0) {
      options = {
        reliability: "RELIABLE"
      };
    }
    try {
      var _meeting = meetingRef.current;
      return Promise.resolve(function() {
        if (_meeting) {
          return Promise.resolve(_meeting.send(payload, options));
        }
      }());
    } catch (e) {
      return Promise.reject(e);
    }
  };
  var respondEntry = function respondEntry2(participantId, decision) {
    var meeting2 = meetingRef.current;
    if (meeting2) {
      meeting2.respondEntry(participantId, decision);
    }
  };
  var getMics = function getMics2() {
    try {
      var _meeting2 = meetingRef.current;
      return Promise.resolve(function() {
        if (_meeting2) {
          return Promise.resolve(_meeting2.getMics());
        }
      }());
    } catch (e) {
      return Promise.reject(e);
    }
  };
  var getWebcams = function getWebcams2() {
    try {
      var _meeting3 = meetingRef.current;
      return Promise.resolve(function() {
        if (_meeting3) {
          return Promise.resolve(_meeting3.getWebcams());
        }
      }());
    } catch (e) {
      return Promise.reject(e);
    }
  };
  var changeWebcam = function changeWebcam2(obj) {
    var meeting2 = meetingRef.current;
    if (meeting2) {
      meeting2.changeWebcam(obj);
    }
  };
  var replaceWebcamStream = function replaceWebcamStream2(stream) {
    var meeting2 = meetingRef.current;
    if (meeting2) {
      meeting2.replaceWebcamStream(stream);
    }
  };
  var changeMic = function changeMic2(obj) {
    var meeting2 = meetingRef.current;
    if (meeting2) {
      meeting2.changeMic(obj);
    }
  };
  var startVideo = function startVideo2(_ref6) {
    var link = _ref6.link;
    var meeting2 = meetingRef.current;
    if (meeting2) {
      meeting2.startVideo({
        link
      });
    }
  };
  var stopVideo = function stopVideo2() {
    var meeting2 = meetingRef.current;
    if (meeting2) {
      meeting2.stopVideo();
    }
  };
  var resumeVideo = function resumeVideo2() {
    var meeting2 = meetingRef.current;
    if (meeting2) {
      meeting2.resumeVideo();
    }
  };
  var pauseVideo = function pauseVideo2(_ref7) {
    var currentTime = _ref7.currentTime;
    var meeting2 = meetingRef.current;
    if (meeting2) {
      meeting2.pauseVideo({
        currentTime
      });
    }
  };
  var enableAdaptiveSubscription = function enableAdaptiveSubscription2() {
    var meeting2 = meetingRef.current;
    if (meeting2) {
      meeting2.enableAdaptiveSubscription();
    }
  };
  var disableAdaptiveSubscription = function disableAdaptiveSubscription2() {
    var meeting2 = meetingRef.current;
    if (meeting2) {
      meeting2.disableAdaptiveSubscription();
    }
  };
  var requestMediaRelay = function requestMediaRelay2(_ref8) {
    var destinationMeetingId = _ref8.destinationMeetingId, token2 = _ref8.token, kinds = _ref8.kinds;
    var meeting2 = meetingRef.current;
    if (meeting2) {
      meeting2.requestMediaRelay({
        destinationMeetingId,
        token: token2,
        kinds
      });
    }
  };
  var stopMediaRelay = function stopMediaRelay2(destinationMeetingId) {
    var meeting2 = meetingRef.current;
    if (meeting2) {
      meeting2.stopMediaRelay(destinationMeetingId);
    }
  };
  var seekVideo = function seekVideo2(_ref9) {
    var currentTime = _ref9.currentTime;
    var meeting2 = meetingRef.current;
    if (meeting2) {
      meeting2.seekVideo({
        currentTime
      });
    }
  };
  var startLivestream = function startLivestream2(streamInfo, config3) {
    var meeting2 = meetingRef.current;
    if (meeting2) {
      meeting2.startLivestream(streamInfo, config3);
    }
  };
  var stopLivestream = function stopLivestream2() {
    var meeting2 = meetingRef.current;
    if (meeting2) {
      meeting2.stopLivestream();
    }
  };
  var connectTo = function connectTo2(_ref0) {
    var meetingId = _ref0.meetingId, payload = _ref0.payload;
    try {
      var _meeting4 = meetingRef.current;
      var _temp = function() {
        if (_meeting4) {
          return Promise.resolve(_meeting4.connectTo({
            meetingId,
            payload
          })).then(function() {
          });
        }
      }();
      return Promise.resolve(_temp && _temp.then ? _temp.then(function() {
      }) : void 0);
    } catch (e) {
      return Promise.reject(e);
    }
  };
  var startHls = function startHls2(config3, transcription) {
    var meeting2 = meetingRef.current;
    if (meeting2) {
      meeting2.startHls(config3, transcription);
    }
  };
  var stopHls = function stopHls2() {
    var meeting2 = meetingRef.current;
    if (meeting2) {
      meeting2.stopHls();
    }
  };
  var initSDK = function initSDK2() {
    import_js_sdk.VideoSDK.config(tokenRef.current);
    keyProviderRef.current && import_js_sdk.VideoSDK.setKeyProvider(keyProviderRef.current);
    if (deviceInfo) {
      import_js_sdk.VideoSDK.analytics(deviceInfo);
    } else {
      import_js_sdk.VideoSDK.analytics({
        sdkType: "react-web",
        sdkVersion: version
      });
    }
    if (joinWithoutUserInteraction) {
      join();
    }
  };
  (0, import_react.useEffect)(function() {
    initSDK();
  }, []);
  (0, import_react.useEffect)(function() {
    if (reinitialiseMeetingOnConfigChange && joinedOnFirstRender.current) {
      leave();
      initSDK();
      !joinWithoutUserInteraction && join();
    }
  }, [config2.meetingId, token, reinitialiseMeetingOnConfigChange]);
  return import_react.default.createElement(MeetingProviderContex.Provider, {
    value: {
      meetingId: meeting === null || meeting === void 0 ? void 0 : meeting.id,
      meeting,
      baseUrl: meeting === null || meeting === void 0 ? void 0 : meeting.baseUrl,
      localParticipant,
      mainParticipant,
      activeSpeakerId,
      participants,
      characters,
      presenterId,
      localMicOn,
      localWebcamOn,
      localScreenShareOn,
      messages,
      isRecording,
      isLiveStreaming,
      pinnedParticipants,
      connections,
      isHls,
      recordingState,
      livestreamState,
      hlsState,
      hlsUrls,
      transcriptionState,
      translationState,
      isMeetingJoined,
      selectedCameraDevice: meeting === null || meeting === void 0 ? void 0 : meeting.selectedCameraDevice,
      selectedMicrophoneDevice: meeting === null || meeting === void 0 ? void 0 : meeting.selectedMicrophoneDevice,
      join,
      leave,
      end,
      pauseAllStreams,
      resumeAllStreams,
      startRecording,
      stopRecording,
      send,
      respondEntry,
      muteMic,
      unmuteMic,
      toggleMic,
      disableWebcam,
      enableWebcam,
      toggleWebcam,
      disableScreenShare,
      enableScreenShare,
      toggleScreenShare,
      switchTo,
      getMics,
      getWebcams,
      changeWebcam,
      replaceWebcamStream,
      changeMic,
      changeMode,
      startVideo,
      stopVideo,
      resumeVideo,
      pauseVideo,
      seekVideo,
      startLivestream,
      stopLivestream,
      connectTo,
      startHls,
      stopHls,
      enableAdaptiveSubscription,
      disableAdaptiveSubscription,
      requestMediaRelay,
      stopMediaRelay
    }
  }, children);
};
var useParticipant = function useParticipant2(participantId, _temp) {
  var _ref = _temp === void 0 ? {} : _temp, _ref$onStreamEnabled = _ref.onStreamEnabled, onStreamEnabled = _ref$onStreamEnabled === void 0 ? function() {
  } : _ref$onStreamEnabled, _ref$onStreamDisabled = _ref.onStreamDisabled, onStreamDisabled = _ref$onStreamDisabled === void 0 ? function() {
  } : _ref$onStreamDisabled, _ref$onMediaStatusCha = _ref.onMediaStatusChanged, onMediaStatusChanged = _ref$onMediaStatusCha === void 0 ? function() {
  } : _ref$onMediaStatusCha, _ref$onVideoQualityCh = _ref.onVideoQualityChanged, onVideoQualityChanged = _ref$onVideoQualityCh === void 0 ? function() {
  } : _ref$onVideoQualityCh, _ref$onStreamPaused = _ref.onStreamPaused, onStreamPaused = _ref$onStreamPaused === void 0 ? function() {
  } : _ref$onStreamPaused, _ref$onStreamResumed = _ref.onStreamResumed, onStreamResumed = _ref$onStreamResumed === void 0 ? function() {
  } : _ref$onStreamResumed, _ref$onProducerAdded = _ref.onProducerAdded, onProducerAdded = _ref$onProducerAdded === void 0 ? function() {
  } : _ref$onProducerAdded, _ref$onProducerRemove = _ref.onProducerRemoved, onProducerRemoved = _ref$onProducerRemove === void 0 ? function() {
  } : _ref$onProducerRemove, _ref$onConsumerAdded = _ref.onConsumerAdded, onConsumerAdded = _ref$onConsumerAdded === void 0 ? function() {
  } : _ref$onConsumerAdded, _ref$onConsumerRemove = _ref.onConsumerRemoved, onConsumerRemoved = _ref$onConsumerRemove === void 0 ? function() {
  } : _ref$onConsumerRemove;
  var _useState = (0, import_react.useState)(null), webcamStream = _useState[0], setwebcamStream = _useState[1];
  var _useState2 = (0, import_react.useState)(null), micStream = _useState2[0], setMicStream = _useState2[1];
  var _useState3 = (0, import_react.useState)(null), screenShareStream = _useState3[0], setScreenShareStream = _useState3[1];
  var _useState4 = (0, import_react.useState)(null), screenShareAudioStream = _useState4[0], setScreenShareAudioStream = _useState4[1];
  var meeting = useMeeting();
  var _useMemo = (0, import_react.useMemo)(function() {
    var _meeting$pinnedPartic;
    var participants2 = meeting === null || meeting === void 0 ? void 0 : meeting.participants;
    var localParticipant2 = meeting === null || meeting === void 0 ? void 0 : meeting.localParticipant;
    var activeSpeakerId2 = meeting === null || meeting === void 0 ? void 0 : meeting.activeSpeakerId;
    var mainParticipant2 = meeting === null || meeting === void 0 ? void 0 : meeting.mainParticipant;
    var pinState2 = (meeting === null || meeting === void 0 ? void 0 : (_meeting$pinnedPartic = meeting.pinnedParticipants) === null || _meeting$pinnedPartic === void 0 ? void 0 : _meeting$pinnedPartic.get(participantId)) || {
      cam: false,
      share: false
    };
    return {
      participants: participants2,
      localParticipant: localParticipant2,
      activeSpeakerId: activeSpeakerId2,
      mainParticipant: mainParticipant2,
      pinState: pinState2
    };
  }, [meeting]), participants = _useMemo.participants, localParticipant = _useMemo.localParticipant, activeSpeakerId = _useMemo.activeSpeakerId, mainParticipant = _useMemo.mainParticipant, pinState = _useMemo.pinState;
  var participant = participants === null || participants === void 0 ? void 0 : participants.get(participantId);
  var _useState5 = (0, import_react.useState)(participant === null || participant === void 0 ? void 0 : participant.webcamOn), webcamOn = _useState5[0], setWebcamOn = _useState5[1];
  var _useState6 = (0, import_react.useState)(participant === null || participant === void 0 ? void 0 : participant.micOn), micOn = _useState6[0], setMicOn = _useState6[1];
  var _useState7 = (0, import_react.useState)(participant === null || participant === void 0 ? void 0 : participant.mode), mode = _useState7[0], setMode = _useState7[1];
  var setTrack = function setTrack2(stream) {
    if (stream.track.readyState === "live") {
      switch (stream.kind) {
        case "video":
          if (webcamStream != null) {
            setwebcamStream(null);
          }
          setwebcamStream(stream);
          break;
        case "audio":
          if (micStream != null) {
            setMicStream(null);
          }
          setMicStream(stream);
          break;
        case "share":
          if (screenShareStream != null) {
            setScreenShareStream(null);
          }
          setScreenShareStream(stream);
          break;
        case "shareAudio":
          if (screenShareAudioStream != null) {
            setScreenShareAudioStream(null);
          }
          setScreenShareAudioStream(stream);
          break;
      }
    }
  };
  var unSetTrack = function unSetTrack2(stream) {
    switch (stream.kind) {
      case "video":
        setwebcamStream(null);
        break;
      case "audio":
        setMicStream(null);
        break;
      case "share":
        setScreenShareStream(null);
        break;
      case "shareAudio":
        setScreenShareAudioStream(null);
        break;
    }
  };
  var _handleStreamEnabled = function _handleStreamEnabled2(stream) {
    setTrack(stream);
    onStreamEnabled(stream);
  };
  var _handleStreamPaused = function _handleStreamPaused2(data) {
    onStreamPaused(data);
  };
  var _handleStreamResumed = function _handleStreamResumed2(data) {
    onStreamResumed(data);
  };
  var _handleParticipantModeChanged = function _handleParticipantModeChanged2(data) {
    if (participantId === data.participantId) {
      setMode(data.mode);
    }
  };
  var _handleStreamDisabled = function _handleStreamDisabled2(stream) {
    unSetTrack(stream);
    onStreamDisabled(stream);
  };
  var _handleVideoQualityChanged = function _handleVideoQualityChanged2(data) {
    var peerId = data.peerId, prevQuality = data.prevQuality, currentQuality = data.currentQuality;
    onVideoQualityChanged({
      peerId,
      prevQuality,
      currentQuality
    });
  };
  var _handleMediaStatusChanged = function _handleMediaStatusChanged2(data) {
    var kind = data.kind, peerId = data.peerId, newStatus = data.newStatus;
    if (kind == "audio") {
      setMicOn(newStatus);
    } else if (kind == "video") {
      setWebcamOn(newStatus);
    }
    onMediaStatusChanged({
      kind,
      peerId,
      newStatus
    });
  };
  var _handleProducerAdded = function _handleProducerAdded2(data) {
    onProducerAdded(data);
  };
  var _handleProducerRemoved = function _handleProducerRemoved2(data) {
    onProducerRemoved(data);
  };
  var _handleConsumerAdded = function _handleConsumerAdded2(data) {
    onConsumerAdded(data);
  };
  var _handleConsumerRemoved = function _handleConsumerRemoved2(data) {
    onConsumerRemoved(data);
  };
  var setQuality = function setQuality2(quality) {
    participant === null || participant === void 0 ? void 0 : participant.setQuality(quality);
  };
  var setViewPort = function setViewPort2(width, height) {
    participant === null || participant === void 0 ? void 0 : participant.setViewPort(width, height);
  };
  var setScreenShareQuality = function setScreenShareQuality2(quality) {
    participant === null || participant === void 0 ? void 0 : participant.setScreenShareQuality(quality);
  };
  var enableMic = function enableMic2() {
    participant === null || participant === void 0 ? void 0 : participant.enableMic();
  };
  var disableMic = function disableMic2() {
    participant === null || participant === void 0 ? void 0 : participant.disableMic();
  };
  var enableWebcam = function enableWebcam2() {
    participant === null || participant === void 0 ? void 0 : participant.enableWebcam();
  };
  var disableWebcam = function disableWebcam2() {
    participant === null || participant === void 0 ? void 0 : participant.disableWebcam();
  };
  var pin = function pin2(data) {
    participant === null || participant === void 0 ? void 0 : participant.pin(data);
  };
  var unpin = function unpin2(data) {
    participant === null || participant === void 0 ? void 0 : participant.unpin(data);
  };
  var remove = function remove2() {
    participant === null || participant === void 0 ? void 0 : participant.remove();
  };
  var captureImage = function captureImage2(_temp2) {
    var _ref2 = _temp2 === void 0 ? {} : _temp2, height = _ref2.height, width = _ref2.width;
    return Promise.resolve(participant === null || participant === void 0 ? void 0 : participant.captureImage({
      height,
      width
    }));
  };
  var getAudioStats = function getAudioStats2() {
    return Promise.resolve(participant === null || participant === void 0 ? void 0 : participant.getAudioStats());
  };
  var getVideoStats = function getVideoStats2() {
    return Promise.resolve(participant === null || participant === void 0 ? void 0 : participant.getVideoStats());
  };
  var getShareStats = function getShareStats2() {
    return Promise.resolve(participant === null || participant === void 0 ? void 0 : participant.getShareStats());
  };
  var getShareAudioStats = function getShareAudioStats2() {
    return Promise.resolve(participant === null || participant === void 0 ? void 0 : participant.getShareAudioStats());
  };
  var consumeWebcamStreams = function consumeWebcamStreams2() {
    participant === null || participant === void 0 ? void 0 : participant.consumeWebcamStreams();
  };
  var consumeMicStreams = function consumeMicStreams2() {
    participant === null || participant === void 0 ? void 0 : participant.consumeMicStreams();
  };
  var stopConsumingWebcamStreams = function stopConsumingWebcamStreams2() {
    participant === null || participant === void 0 ? void 0 : participant.stopConsumingWebcamStreams();
  };
  var stopConsumingMicStreams = function stopConsumingMicStreams2() {
    participant === null || participant === void 0 ? void 0 : participant.stopConsumingMicStreams();
  };
  (0, import_react.useEffect)(function() {
    var streams = participant === null || participant === void 0 ? void 0 : participant.streams;
    if (streams) {
      streams.forEach(function(stream) {
        setTrack(stream);
      });
    }
    if (participant !== null && participant !== void 0 && participant.micOn) {
      setMicOn(micOn);
    }
    if (participant !== null && participant !== void 0 && participant.webcamOn) {
      setWebcamOn(webcamOn);
    }
    participant === null || participant === void 0 ? void 0 : participant.on("stream-enabled", _handleStreamEnabled);
    participant === null || participant === void 0 ? void 0 : participant.on("stream-disabled", _handleStreamDisabled);
    participant === null || participant === void 0 ? void 0 : participant.on("stream-paused", _handleStreamPaused);
    participant === null || participant === void 0 ? void 0 : participant.on("stream-resumed", _handleStreamResumed);
    participant === null || participant === void 0 ? void 0 : participant.on("media-status-changed", _handleMediaStatusChanged);
    participant === null || participant === void 0 ? void 0 : participant.on("video-quality-changed", _handleVideoQualityChanged);
    participant === null || participant === void 0 ? void 0 : participant.on("producer-added", _handleProducerAdded);
    participant === null || participant === void 0 ? void 0 : participant.on("producer-removed", _handleProducerRemoved);
    participant === null || participant === void 0 ? void 0 : participant.on("consumer-added", _handleConsumerAdded);
    participant === null || participant === void 0 ? void 0 : participant.on("consumer-removed", _handleConsumerRemoved);
    eventEmitter.on(events["participant-mode-changed"], _handleParticipantModeChanged);
    return function() {
      participant === null || participant === void 0 ? void 0 : participant.off("stream-enabled", _handleStreamEnabled);
      participant === null || participant === void 0 ? void 0 : participant.off("stream-disabled", _handleStreamDisabled);
      participant === null || participant === void 0 ? void 0 : participant.off("stream-paused", _handleStreamPaused);
      participant === null || participant === void 0 ? void 0 : participant.off("stream-resumed", _handleStreamResumed);
      participant === null || participant === void 0 ? void 0 : participant.off("media-status-changed", _handleMediaStatusChanged);
      participant === null || participant === void 0 ? void 0 : participant.off("video-quality-changed", _handleVideoQualityChanged);
      participant === null || participant === void 0 ? void 0 : participant.off("producer-added", _handleProducerAdded);
      participant === null || participant === void 0 ? void 0 : participant.off("producer-removed", _handleProducerRemoved);
      participant === null || participant === void 0 ? void 0 : participant.off("consumer-added", _handleConsumerAdded);
      participant === null || participant === void 0 ? void 0 : participant.off("consumer-removed", _handleConsumerRemoved);
      eventEmitter.off(events["participant-mode-changed"], _handleParticipantModeChanged);
    };
  }, [participant]);
  return {
    displayName: participant === null || participant === void 0 ? void 0 : participant.displayName,
    participant,
    webcamStream,
    micStream,
    screenShareStream,
    screenShareAudioStream,
    webcamOn: webcamOn || !!webcamStream,
    micOn: micOn || !!micStream,
    mode,
    metaData: participant === null || participant === void 0 ? void 0 : participant.metaData,
    screenShareOn: !!screenShareStream,
    isLocal: (localParticipant === null || localParticipant === void 0 ? void 0 : localParticipant.id) === participantId,
    isActiveSpeaker: activeSpeakerId === participantId,
    isMainParticipant: (mainParticipant === null || mainParticipant === void 0 ? void 0 : mainParticipant.id) === participantId,
    pinState,
    consumeMicStreams,
    consumeWebcamStreams,
    stopConsumingMicStreams,
    stopConsumingWebcamStreams,
    setQuality,
    setScreenShareQuality,
    setViewPort,
    enableMic,
    disableMic,
    enableWebcam,
    disableWebcam,
    captureImage,
    pin,
    unpin,
    remove,
    getAudioStats,
    getVideoStats,
    getShareStats,
    getShareAudioStats
  };
};
var useStream = function useStream2(streamId, _temp) {
  var _ref = _temp === void 0 ? {} : _temp, _ref$onStreamStateCha = _ref.onStreamStateChanged, onStreamStateChanged = _ref$onStreamStateCha === void 0 ? function() {
  } : _ref$onStreamStateCha;
  var _useState = (0, import_react.useState)(null), stream = _useState[0], setStream = _useState[1];
  var meeting = useMeeting();
  var _useMemo = (0, import_react.useMemo)(function() {
    var participants2 = meeting === null || meeting === void 0 ? void 0 : meeting.participants;
    return {
      participants: participants2
    };
  }, [meeting]), participants = _useMemo.participants;
  var _handleStreamStateChanged = function _handleStreamStateChanged2(data) {
    onStreamStateChanged(data);
  };
  (0, import_react.useEffect)(function() {
    if (!meeting) return;
    if (!streamId) return;
    var findStream = function findStream2() {
      for (var _iterator = _createForOfIteratorHelperLoose(participants.values()), _step; !(_step = _iterator()).done; ) {
        var participant = _step.value;
        var _stream = participant.streams.get(streamId);
        if (_stream != null) {
          return _stream;
        }
      }
      return null;
    };
    var s = findStream();
    if (!s) return;
    setStream(s);
    s === null || s === void 0 ? void 0 : s.on("state", _handleStreamStateChanged);
    return function() {
      s === null || s === void 0 ? void 0 : s.off("state", _handleStreamStateChanged);
    };
  }, [streamId]);
  var pause = function pause2() {
    if (stream) {
      stream.pause();
    }
  };
  var resume = function resume2() {
    if (stream) {
      stream.resume();
    }
  };
  return {
    kind: stream === null || stream === void 0 ? void 0 : stream.kind,
    codec: stream === null || stream === void 0 ? void 0 : stream.codec,
    track: stream === null || stream === void 0 ? void 0 : stream.track,
    paused: stream === null || stream === void 0 ? void 0 : stream.paused,
    stream,
    pause,
    resume
  };
};
var useConnection = function useConnection2(connectionId, _temp) {
  var _ref = _temp === void 0 ? {
    onMeeting: {
      onParticipantJoined: function onParticipantJoined2() {
      },
      onParticipantLeft: function onParticipantLeft2() {
      },
      onData: function onData2() {
      }
    }
  } : _temp, onMeeting = _ref.onMeeting;
  var onParticipantJoined = onMeeting === null || onMeeting === void 0 ? void 0 : onMeeting.onParticipantJoined;
  var onParticipantLeft = onMeeting === null || onMeeting === void 0 ? void 0 : onMeeting.onParticipantLeft;
  var onData = onMeeting === null || onMeeting === void 0 ? void 0 : onMeeting.onData;
  var meeting = useMeeting();
  var _useMemo = (0, import_react.useMemo)(function() {
    var connection2 = meeting === null || meeting === void 0 ? void 0 : meeting.connections.get(connectionId);
    if (!connection2) {
      throw new Error("connectionId not found");
    }
    var connectionParticipants2 = new Map(connection2.meeting.participants);
    return {
      connection: connection2,
      connectionParticipants: connectionParticipants2
    };
  }, [meeting]), connection = _useMemo.connection, connectionParticipants = _useMemo.connectionParticipants;
  var _useState = (0, import_react.useState)(new Map(connectionParticipants)), _connectionParticipants = _useState[0], setConnectionParticipants = _useState[1];
  var _handleParticipantJoined = function _handleParticipantJoined2(participant) {
    setConnectionParticipants(function(s) {
      s.set(participant.id, participant);
      var participantsToSet = new Map(s);
      return participantsToSet;
    });
    onParticipantJoined(participant);
  };
  var _handleParticipantLeft = function _handleParticipantLeft2(participantId) {
    setConnectionParticipants(function(s) {
      s["delete"](participantId);
      var newParticipants = new Map(s);
      return newParticipants;
    });
    onParticipantLeft(participantId);
  };
  var _handleChatMessage = function _handleChatMessage2(data) {
    onData(data);
  };
  (0, import_react.useEffect)(function() {
    connection === null || connection === void 0 ? void 0 : connection.meeting.on("participant-joined", _handleParticipantJoined);
    connection === null || connection === void 0 ? void 0 : connection.meeting.on("participant-left", _handleParticipantLeft);
    connection === null || connection === void 0 ? void 0 : connection.meeting.on("data", _handleChatMessage);
    return function() {
      connection === null || connection === void 0 ? void 0 : connection.meeting.off("participant-joined", _handleParticipantJoined);
      connection === null || connection === void 0 ? void 0 : connection.meeting.off("participant-left", _handleParticipantLeft);
      connection === null || connection === void 0 ? void 0 : connection.meeting.off("data", _handleChatMessage);
    };
  }, [connection]);
  return {
    connection: {
      id: connection.id,
      close: connection.close,
      payload: connection.payload,
      meeting: {
        id: connection.meeting.id,
        sendChatMessage: connection.meeting.sendChatMessage,
        end: connection.meeting.end,
        participants: _connectionParticipants
      }
    }
  };
};
var usePubSub = function usePubSub2(topic, _temp) {
  var _ref = _temp === void 0 ? {} : _temp, _ref$onMessageReceive = _ref.onMessageReceived, onMessageReceived = _ref$onMessageReceive === void 0 ? function() {
  } : _ref$onMessageReceive, _ref$onOldMessagesRec = _ref.onOldMessagesReceived, onOldMessagesReceived = _ref$onOldMessagesRec === void 0 ? function() {
  } : _ref$onOldMessagesRec;
  var _useMeeting = useMeeting(), meeting = _useMeeting.meeting, isMeetingJoined = _useMeeting.isMeetingJoined;
  var _useState = (0, import_react.useState)([]), messages = _useState[0], setMessages = _useState[1];
  var isSubscribed = (0, import_react.useRef)(false);
  var publish = function publish2(message, options, payload) {
    if (meeting) {
      return meeting.pubSub.publish(topic, message, options, payload);
    }
  };
  var _handlePubSub = function _handlePubSub2(data) {
    setMessages(function(s) {
      return [].concat(s, [data]);
    });
    onMessageReceived(data);
  };
  var subscribeToPubsub = function subscribeToPubsub2(meeting2) {
    try {
      var _meeting$pubSub;
      return Promise.resolve(meeting2 === null || meeting2 === void 0 ? void 0 : (_meeting$pubSub = meeting2.pubSub) === null || _meeting$pubSub === void 0 ? void 0 : _meeting$pubSub.subscribe(topic, _handlePubSub)).then(function(data) {
        if (data) {
          onOldMessagesReceived(data.messages);
          setMessages(data.messages);
        }
      });
    } catch (e) {
      return Promise.reject(e);
    }
  };
  (0, import_react.useEffect)(function() {
    if (meeting && !isSubscribed.current && isMeetingJoined) {
      isSubscribed.current = true;
      subscribeToPubsub(meeting);
      return function() {
        var _meeting$pubSub2;
        meeting === null || meeting === void 0 ? void 0 : (_meeting$pubSub2 = meeting.pubSub) === null || _meeting$pubSub2 === void 0 ? void 0 : _meeting$pubSub2.unsubscribe(topic, _handlePubSub);
      };
    }
  }, [meeting, isMeetingJoined]);
  return {
    publish,
    messages
  };
};
var useRealtimeStore = function useRealtimeStore2(key, _temp) {
  var _ref = _temp === void 0 ? {} : _temp, _ref$onValueChanged = _ref.onValueChanged, onValueChanged = _ref$onValueChanged === void 0 ? function() {
  } : _ref$onValueChanged;
  var observerIdRef = (0, import_react.useRef)(null);
  var _useMeeting = useMeeting(), meeting = _useMeeting.meeting, isMeetingJoined = _useMeeting.isMeetingJoined;
  var isObserving = (0, import_react.useRef)(false);
  var setValue = function setValue2(value) {
    try {
      return Promise.resolve(function() {
        if (meeting) {
          return Promise.resolve(meeting.realtimeStore.setValue(key, value));
        }
      }());
    } catch (e) {
      return Promise.reject(e);
    }
  };
  var getValue = function getValue2() {
    try {
      return Promise.resolve(function() {
        if (meeting) {
          return Promise.resolve(meeting.realtimeStore.getValue(key));
        }
      }());
    } catch (e) {
      return Promise.reject(e);
    }
  };
  var _handleRealtimeStore = function _handleRealtimeStore2(data) {
    onValueChanged(data);
  };
  var subscribeToKey = function subscribeToKey2(meeting2) {
    try {
      var _meeting$realtimeStor3;
      return Promise.resolve(meeting2 === null || meeting2 === void 0 ? void 0 : (_meeting$realtimeStor3 = meeting2.realtimeStore) === null || _meeting$realtimeStor3 === void 0 ? void 0 : _meeting$realtimeStor3.observe(key, _handleRealtimeStore)).then(function(observer) {
        if (observer) {
          observerIdRef.current = observer;
        }
      });
    } catch (e) {
      return Promise.reject(e);
    }
  };
  (0, import_react.useEffect)(function() {
    if (meeting && !isObserving.current && isMeetingJoined && onValueChanged) {
      isObserving.current = true;
      subscribeToKey(meeting);
      return function() {
        if (observerIdRef.current) {
          var _meeting$realtimeStor4;
          meeting === null || meeting === void 0 ? void 0 : (_meeting$realtimeStor4 = meeting.realtimeStore) === null || _meeting$realtimeStor4 === void 0 ? void 0 : _meeting$realtimeStor4.stopObserving(observerIdRef.current);
          observerIdRef.current = null;
        }
        isObserving.current = false;
      };
    }
  }, [meeting, isMeetingJoined]);
  return {
    setValue,
    getValue
  };
};
var useFile = function useFile2() {
  var mMeeting = useMeeting();
  var uploadBase64File = function uploadBase64File2(_ref) {
    var base64Data = _ref.base64Data, token = _ref.token, fileName = _ref.fileName;
    try {
      return Promise.resolve(mMeeting.meeting.uploadBase64File({
        base64Data,
        token,
        fileName
      }));
    } catch (e) {
      return Promise.reject(e);
    }
  };
  var fetchBase64File = function fetchBase64File2(_ref2) {
    var url = _ref2.url, token = _ref2.token;
    try {
      return Promise.resolve(mMeeting.meeting.fetchBase64File({
        url,
        token
      }));
    } catch (e) {
      return Promise.reject(e);
    }
  };
  return {
    uploadBase64File,
    fetchBase64File
  };
};
var useMediaDevice = function useMediaDevice2(_temp) {
  var _ref = _temp === void 0 ? {} : _temp, _ref$onDeviceChanged = _ref.onDeviceChanged, onDeviceChanged = _ref$onDeviceChanged === void 0 ? function() {
  } : _ref$onDeviceChanged;
  var getDevices = function getDevices2() {
    try {
      return Promise.resolve(import_js_sdk.VideoSDK.getDevices());
    } catch (e) {
      return Promise.reject(e);
    }
  };
  var getCameras = function getCameras2() {
    try {
      return Promise.resolve(import_js_sdk.VideoSDK.getCameras());
    } catch (e) {
      return Promise.reject(e);
    }
  };
  var getMicrophones = function getMicrophones2() {
    try {
      return Promise.resolve(import_js_sdk.VideoSDK.getMicrophones());
    } catch (e) {
      return Promise.reject(e);
    }
  };
  var getPlaybackDevices = function getPlaybackDevices2() {
    try {
      return Promise.resolve(import_js_sdk.VideoSDK.getPlaybackDevices());
    } catch (e) {
      return Promise.reject(e);
    }
  };
  var checkPermissions = function checkPermissions2(permissions) {
    if (permissions === void 0) {
      permissions = void 0;
    }
    try {
      return Promise.resolve(import_js_sdk.VideoSDK.checkPermissions(permissions));
    } catch (e) {
      return Promise.reject(e);
    }
  };
  var requestPermission = function requestPermission2(permissions) {
    if (permissions === void 0) {
      permissions = void 0;
    }
    try {
      return Promise.resolve(import_js_sdk.VideoSDK.requestPermission(permissions));
    } catch (e) {
      return Promise.reject(e);
    }
  };
  (0, import_react.useEffect)(function() {
    import_js_sdk.VideoSDK.on("device-changed", onDeviceChanged);
    return function() {
      import_js_sdk.VideoSDK.off("device-changed", onDeviceChanged);
    };
  }, []);
  return {
    getDevices,
    getCameras,
    getMicrophones,
    getPlaybackDevices,
    requestPermission,
    checkPermissions
  };
};
var useTranscription = function useTranscription2(_temp) {
  var _ref = _temp === void 0 ? {} : _temp, _ref$onTranscriptionS = _ref.onTranscriptionStateChanged, onTranscriptionStateChanged = _ref$onTranscriptionS === void 0 ? function() {
  } : _ref$onTranscriptionS, _ref$onTranscriptionT = _ref.onTranscriptionText, onTranscriptionText = _ref$onTranscriptionT === void 0 ? function() {
  } : _ref$onTranscriptionT;
  var mMeeting = useMeeting();
  (0, import_react.useEffect)(function() {
    eventEmitter.on(events["transcription-state-changed"], onTranscriptionStateChanged);
    eventEmitter.on(events["transcription-text"], onTranscriptionText);
    return function() {
      eventEmitter.off(events["transcription-state-changed"], onTranscriptionStateChanged);
      eventEmitter.off(events["transcription-text"], onTranscriptionText);
    };
  }, []);
  var startTranscription = function startTranscription2(config2) {
    try {
      return Promise.resolve(mMeeting.meeting.startTranscription(config2));
    } catch (e) {
      return Promise.reject(e);
    }
  };
  var stopTranscription = function stopTranscription2() {
    try {
      return Promise.resolve(mMeeting.meeting.stopTranscription());
    } catch (e) {
      return Promise.reject(e);
    }
  };
  return {
    startTranscription,
    stopTranscription
  };
};
var useTranslation = function useTranslation2(_temp) {
  var _ref = _temp === void 0 ? {} : _temp, _ref$onTranslationSta = _ref.onTranslationStateChanged, onTranslationStateChanged = _ref$onTranslationSta === void 0 ? function() {
    return Promise.resolve();
  } : _ref$onTranslationSta, _ref$onTranslationLan = _ref.onTranslationLanguageChanged, onTranslationLanguageChanged = _ref$onTranslationLan === void 0 ? function() {
    return Promise.resolve();
  } : _ref$onTranslationLan, _ref$onTranslationTex = _ref.onTranslationText, onTranslationText = _ref$onTranslationTex === void 0 ? function() {
    return Promise.resolve();
  } : _ref$onTranslationTex;
  var mMeeting = useMeeting();
  (0, import_react.useEffect)(function() {
    eventEmitter.on(events["translation-state-changed"], onTranslationStateChanged);
    eventEmitter.on(events["translation-language-changed"], onTranslationLanguageChanged);
    eventEmitter.on(events["translation-text"], onTranslationText);
    return function() {
      eventEmitter.off(events["translation-state-changed"], onTranslationStateChanged);
      eventEmitter.off(events["translation-language-changed"], onTranslationLanguageChanged);
      eventEmitter.off(events["translation-text"], onTranslationText);
    };
  }, []);
  var startTranslation = function startTranslation2(config2) {
    try {
      return Promise.resolve(mMeeting.meeting.startTranslation(config2));
    } catch (e) {
      return Promise.reject(e);
    }
  };
  var changeTranslationLanguage = function changeTranslationLanguage2(language) {
    try {
      return Promise.resolve(mMeeting.meeting.changeTranslationLanguage(language));
    } catch (e) {
      return Promise.reject(e);
    }
  };
  var stopTranslation = function stopTranslation2() {
    try {
      return Promise.resolve(mMeeting.meeting.stopTranslation());
    } catch (e) {
      return Promise.reject(e);
    }
  };
  return {
    startTranslation,
    changeTranslationLanguage,
    stopTranslation
  };
};
var useCharacter = function useCharacter2(_ref, _temp) {
  var interactionId = _ref.interactionId, id = _ref.id, characterMode = _ref.characterMode, displayName = _ref.displayName, characterRole = _ref.characterRole, knowledgeBases = _ref.knowledgeBases, language = _ref.language, metaData = _ref.metaData;
  var _ref2 = _temp === void 0 ? {} : _temp, _ref2$onCharacterStat = _ref2.onCharacterStateChanged, onCharacterStateChanged = _ref2$onCharacterStat === void 0 ? function() {
  } : _ref2$onCharacterStat, _ref2$onCharacterMess = _ref2.onCharacterMessage, onCharacterMessage = _ref2$onCharacterMess === void 0 ? function() {
  } : _ref2$onCharacterMess, _ref2$onUserMessage = _ref2.onUserMessage, onUserMessage = _ref2$onUserMessage === void 0 ? function() {
  } : _ref2$onUserMessage, _ref2$onData = _ref2.onData, onData = _ref2$onData === void 0 ? function() {
  } : _ref2$onData, _ref2$onError = _ref2.onError, onError = _ref2$onError === void 0 ? function() {
  } : _ref2$onError, _ref2$onCharacterJoin = _ref2.onCharacterJoined, onCharacterJoined = _ref2$onCharacterJoin === void 0 ? function() {
  } : _ref2$onCharacterJoin, _ref2$onCharacterLeft = _ref2.onCharacterLeft, onCharacterLeft = _ref2$onCharacterLeft === void 0 ? function() {
  } : _ref2$onCharacterLeft, _ref2$onStreamEnabled = _ref2.onStreamEnabled, onStreamEnabled = _ref2$onStreamEnabled === void 0 ? function() {
  } : _ref2$onStreamEnabled, _ref2$onStreamDisable = _ref2.onStreamDisabled, onStreamDisabled = _ref2$onStreamDisable === void 0 ? function() {
  } : _ref2$onStreamDisable, _ref2$onMediaStatusCh = _ref2.onMediaStatusChanged, onMediaStatusChanged = _ref2$onMediaStatusCh === void 0 ? function() {
  } : _ref2$onMediaStatusCh, _ref2$onVideoQualityC = _ref2.onVideoQualityChanged, onVideoQualityChanged = _ref2$onVideoQualityC === void 0 ? function() {
  } : _ref2$onVideoQualityC;
  var _useState = (0, import_react.useState)(null), webcamStream = _useState[0], setwebcamStream = _useState[1];
  var _useState2 = (0, import_react.useState)(null), micStream = _useState2[0], setMicStream = _useState2[1];
  var mMeeting = useMeeting();
  var _useMemo = (0, import_react.useMemo)(function() {
    var chars = Array.from(mMeeting.characters.values());
    var activeSpeakerId2 = mMeeting === null || mMeeting === void 0 ? void 0 : mMeeting.activeSpeakerId;
    return {
      character: chars.find(function(chars2) {
        return chars2.interactionId == interactionId;
      }) || mMeeting.characters.get(id) || mMeeting.meeting.createCharacter({
        interactionId,
        displayName,
        id,
        characterRole,
        characterMode,
        knowledgeBases,
        language,
        metaData
      }),
      activeSpeakerId: activeSpeakerId2
    };
  }, [mMeeting.characters, interactionId, id, characterMode, displayName, characterRole, knowledgeBases, language, metaData]), character = _useMemo.character, activeSpeakerId = _useMemo.activeSpeakerId;
  var _useState3 = (0, import_react.useState)(character === null || character === void 0 ? void 0 : character.webcamOn), webcamOn = _useState3[0], setWebcamOn = _useState3[1];
  var _useState4 = (0, import_react.useState)(character === null || character === void 0 ? void 0 : character.micOn), micOn = _useState4[0], setMicOn = _useState4[1];
  var _useState5 = (0, import_react.useState)(null), characterState = _useState5[0], setCharacterState = _useState5[1];
  var setTrack = function setTrack2(stream) {
    if (stream.track.readyState === "live") {
      switch (stream.kind) {
        case "video":
          if (webcamStream != null) {
            setwebcamStream(null);
          }
          setwebcamStream(stream);
          break;
        case "audio":
          if (micStream != null) {
            setMicStream(null);
          }
          setMicStream(stream);
          break;
      }
    }
  };
  var unSetTrack = function unSetTrack2(stream) {
    switch (stream.kind) {
      case "video":
        setwebcamStream(null);
        break;
      case "audio":
        setMicStream(null);
        break;
    }
  };
  var _handleCharacterStateChanged = function _handleCharacterStateChanged2(d) {
    var status = d.status;
    setCharacterState(status);
    onCharacterStateChanged(d);
  };
  var _handleCharacterMessage = function _handleCharacterMessage2(d) {
    onCharacterMessage(d);
  };
  var _handleUserMessage = function _handleUserMessage2(d) {
    onUserMessage(d);
  };
  var _handleOnData = function _handleOnData2(topic, d) {
    onData(topic, d);
  };
  var _handleOnError = function _handleOnError2(d) {
    onError(d);
  };
  var _handleCharacterJoined = function _handleCharacterJoined2() {
    onCharacterJoined();
  };
  var _handleCharacterLeft = function _handleCharacterLeft2() {
    onCharacterLeft();
  };
  var _handleStreamEnabled = function _handleStreamEnabled2(stream) {
    setTrack(stream);
    onStreamEnabled(stream);
  };
  var _handleStreamDisabled = function _handleStreamDisabled2(stream) {
    unSetTrack(stream);
    onStreamDisabled(stream);
  };
  var _handleVideoQualityChanged = function _handleVideoQualityChanged2(data) {
    var peerId = data.peerId, prevQuality = data.prevQuality, currentQuality = data.currentQuality;
    onVideoQualityChanged({
      peerId,
      prevQuality,
      currentQuality
    });
  };
  var _handleMediaStatusChanged = function _handleMediaStatusChanged2(data) {
    var kind = data.kind, peerId = data.peerId, newStatus = data.newStatus;
    if (kind == "audio") {
      setMicOn(newStatus);
    } else if (kind == "video") {
      setWebcamOn(newStatus);
    }
    onMediaStatusChanged({
      kind,
      peerId,
      newStatus
    });
  };
  var enableMic = function enableMic2() {
    character === null || character === void 0 ? void 0 : character.enableMic();
  };
  var disableMic = function disableMic2() {
    character === null || character === void 0 ? void 0 : character.disableMic();
  };
  var enableWebcam = function enableWebcam2() {
    character === null || character === void 0 ? void 0 : character.enableWebcam();
  };
  var disableWebcam = function disableWebcam2() {
    character === null || character === void 0 ? void 0 : character.disableWebcam();
  };
  var join = function join2() {
    return Promise.resolve(character === null || character === void 0 ? void 0 : character.join()).then(function() {
    });
  };
  var sendMessage = function sendMessage2(d) {
    return Promise.resolve(character === null || character === void 0 ? void 0 : character.sendMessage(d)).then(function() {
    });
  };
  var interrupt = function interrupt2() {
    return Promise.resolve(character === null || character === void 0 ? void 0 : character.interrupt()).then(function() {
    });
  };
  var leave = function leave2() {
    return Promise.resolve(character === null || character === void 0 ? void 0 : character.leave()).then(function() {
    });
  };
  (0, import_react.useEffect)(function() {
    var streams = character === null || character === void 0 ? void 0 : character.streams;
    if (streams) {
      streams.forEach(function(stream) {
        setTrack(stream);
      });
    }
    if (character !== null && character !== void 0 && character.micOn) {
      setMicOn(micOn);
    }
    if (character !== null && character !== void 0 && character.webcamOn) {
      setWebcamOn(webcamOn);
    }
    character === null || character === void 0 ? void 0 : character.on("character-state-changed", _handleCharacterStateChanged);
    character === null || character === void 0 ? void 0 : character.on("character-message", _handleCharacterMessage);
    character === null || character === void 0 ? void 0 : character.on("user-message", _handleUserMessage);
    character === null || character === void 0 ? void 0 : character.on("data", _handleOnData);
    character === null || character === void 0 ? void 0 : character.on("error", _handleOnError);
    character === null || character === void 0 ? void 0 : character.on("stream-enabled", _handleStreamEnabled);
    character === null || character === void 0 ? void 0 : character.on("stream-disabled", _handleStreamDisabled);
    character === null || character === void 0 ? void 0 : character.on("media-status-changed", _handleMediaStatusChanged);
    character === null || character === void 0 ? void 0 : character.on("video-quality-changed", _handleVideoQualityChanged);
    character === null || character === void 0 ? void 0 : character.on("character-joined", _handleCharacterJoined);
    character === null || character === void 0 ? void 0 : character.on("character-left", _handleCharacterLeft);
    return function() {
      character === null || character === void 0 ? void 0 : character.off("character-state-changed", _handleCharacterStateChanged);
      character === null || character === void 0 ? void 0 : character.off("character-message", _handleCharacterMessage);
      character === null || character === void 0 ? void 0 : character.off("user-message", _handleUserMessage);
      character === null || character === void 0 ? void 0 : character.off("data", _handleOnData);
      character === null || character === void 0 ? void 0 : character.off("error", _handleOnError);
      character === null || character === void 0 ? void 0 : character.off("stream-enabled", _handleStreamEnabled);
      character === null || character === void 0 ? void 0 : character.off("stream-disabled", _handleStreamDisabled);
      character === null || character === void 0 ? void 0 : character.off("media-status-changed", _handleMediaStatusChanged);
      character === null || character === void 0 ? void 0 : character.off("video-quality-changed", _handleVideoQualityChanged);
      character === null || character === void 0 ? void 0 : character.off("character-joined", _handleCharacterJoined);
      character === null || character === void 0 ? void 0 : character.off("character-left", _handleCharacterLeft);
    };
  }, [character]);
  return {
    displayName: character === null || character === void 0 ? void 0 : character.displayName,
    webcamStream,
    micStream,
    webcamOn: webcamOn || !!webcamStream,
    micOn: micOn || !!micStream,
    isActiveSpeaker: activeSpeakerId === id,
    interactionId: character === null || character === void 0 ? void 0 : character.interactionId,
    id: character === null || character === void 0 ? void 0 : character.id,
    characterMode: character === null || character === void 0 ? void 0 : character.characterMode,
    characterState: characterState || (character === null || character === void 0 ? void 0 : character.characterState),
    knowledgeBases: character === null || character === void 0 ? void 0 : character.knowledgeBases,
    language: character === null || character === void 0 ? void 0 : character.language,
    enableMic,
    disableMic,
    enableWebcam,
    disableWebcam,
    join,
    leave,
    sendMessage,
    interrupt
  };
};
var _iteratorSymbol = typeof Symbol !== "undefined" ? Symbol.iterator || (Symbol.iterator = Symbol("Symbol.iterator")) : "@@iterator";
var _asyncIteratorSymbol = typeof Symbol !== "undefined" ? Symbol.asyncIterator || (Symbol.asyncIterator = Symbol("Symbol.asyncIterator")) : "@@asyncIterator";
function _catch(body, recover) {
  try {
    var result = body();
  } catch (e) {
    return recover(e);
  }
  if (result && result.then) {
    return result.then(void 0, recover);
  }
  return result;
}
var useWhiteboard = function useWhiteboard2() {
  var _useMeeting = useMeeting(), meeting = _useMeeting.meeting, isMeetingJoined = _useMeeting.isMeetingJoined;
  var _useState = (0, import_react.useState)(null), whiteboardUrl = _useState[0], setWhiteboardUrl = _useState[1];
  (0, import_react.useEffect)(function() {
    if (!isMeetingJoined || !meeting) return;
    var handleWhiteboardStarted = function handleWhiteboardStarted2(data) {
      if (data !== null && data !== void 0 && data.url) {
        setWhiteboardUrl(data.url);
      }
    };
    var handleWhiteboardStopped = function handleWhiteboardStopped2() {
      return setWhiteboardUrl(null);
    };
    eventEmitter.on(events["whiteboard-started"], handleWhiteboardStarted);
    eventEmitter.on(events["whiteboard-stopped"], handleWhiteboardStopped);
    return function() {
      eventEmitter.off(events["whiteboard-started"], handleWhiteboardStarted);
      eventEmitter.off(events["whiteboard-stopped"], handleWhiteboardStopped);
    };
  }, [meeting, isMeetingJoined]);
  var startWhiteboard = function startWhiteboard2() {
    try {
      if (!isMeetingJoined || !meeting) {
        return Promise.resolve();
      }
      var _temp = _catch(function() {
        return Promise.resolve(meeting.startWhiteboard()).then(function() {
        });
      }, function(error) {
        console.error("Error starting whiteboard:", error);
      });
      return Promise.resolve(_temp && _temp.then ? _temp.then(function() {
      }) : void 0);
    } catch (e) {
      return Promise.reject(e);
    }
  };
  var stopWhiteboard = function stopWhiteboard2() {
    try {
      if (!isMeetingJoined || !meeting) {
        return Promise.resolve();
      }
      var _temp2 = _catch(function() {
        return Promise.resolve(meeting.stopWhiteboard()).then(function() {
        });
      }, function(error) {
        console.error("Error stopping whiteboard:", error);
      });
      return Promise.resolve(_temp2 && _temp2.then ? _temp2.then(function() {
      }) : void 0);
    } catch (e) {
      return Promise.reject(e);
    }
  };
  return {
    whiteboardUrl,
    startWhiteboard,
    stopWhiteboard
  };
};
var _excluded = ["participantId", "type"];
var Constants = import_js_sdk.VideoSDK.Constants;
var createCameraVideoTrack = function createCameraVideoTrack2(_ref) {
  var _ref$cameraId = _ref.cameraId, cameraId = _ref$cameraId === void 0 ? void 0 : _ref$cameraId, _ref$encoderConfig = _ref.encoderConfig, encoderConfig = _ref$encoderConfig === void 0 ? void 0 : _ref$encoderConfig, _ref$facingMode = _ref.facingMode, facingMode = _ref$facingMode === void 0 ? void 0 : _ref$facingMode, _ref$optimizationMode = _ref.optimizationMode, optimizationMode = _ref$optimizationMode === void 0 ? void 0 : _ref$optimizationMode, _ref$multiStream = _ref.multiStream, multiStream = _ref$multiStream === void 0 ? true : _ref$multiStream;
  try {
    return Promise.resolve(import_js_sdk.VideoSDK.createCameraVideoTrack({
      cameraId,
      encoderConfig,
      facingMode,
      optimizationMode,
      multiStream
    }));
  } catch (e) {
    return Promise.reject(e);
  }
};
var createScreenShareVideoTrack = function createScreenShareVideoTrack2(_ref2) {
  var _ref2$encoderConfig = _ref2.encoderConfig, encoderConfig = _ref2$encoderConfig === void 0 ? void 0 : _ref2$encoderConfig, _ref2$optimizationMod = _ref2.optimizationMode, optimizationMode = _ref2$optimizationMod === void 0 ? void 0 : _ref2$optimizationMod, _ref2$withAudio = _ref2.withAudio, withAudio = _ref2$withAudio === void 0 ? "enable" : _ref2$withAudio, _ref2$multiStream = _ref2.multiStream, multiStream = _ref2$multiStream === void 0 ? false : _ref2$multiStream;
  try {
    return Promise.resolve(import_js_sdk.VideoSDK.createScreenShareVideoTrack({
      encoderConfig,
      optimizationMode,
      withAudio,
      multiStream
    }));
  } catch (e) {
    return Promise.reject(e);
  }
};
var createMicrophoneAudioTrack = function createMicrophoneAudioTrack2(_ref3) {
  var _ref3$noiseConfig = _ref3.noiseConfig, noiseConfig = _ref3$noiseConfig === void 0 ? void 0 : _ref3$noiseConfig, _ref3$encoderConfig = _ref3.encoderConfig, encoderConfig = _ref3$encoderConfig === void 0 ? void 0 : _ref3$encoderConfig, _ref3$microphoneId = _ref3.microphoneId, microphoneId = _ref3$microphoneId === void 0 ? void 0 : _ref3$microphoneId;
  try {
    return Promise.resolve(import_js_sdk.VideoSDK.createMicrophoneAudioTrack({
      noiseConfig,
      encoderConfig,
      microphoneId
    }));
  } catch (e) {
    return Promise.reject(e);
  }
};
var getNetworkStats = function getNetworkStats2(_temp) {
  var _ref4 = _temp === void 0 ? {} : _temp, timeoutDuration = _ref4.timeoutDuration, baseUrl = _ref4.baseUrl;
  try {
    return Promise.resolve(import_js_sdk.VideoSDK.getNetworkStats({
      timeoutDuration,
      baseUrl
    }));
  } catch (e) {
    return Promise.reject(e);
  }
};
var withAdaptiveObservers = function withAdaptiveObservers2(VideoPlayerComponent) {
  var intersectionObserverOptions = {
    root: null,
    rootMargin: "0px",
    threshold: 0
  };
  var debounceDelay = 400;
  return function(props) {
    var participantId = props.participantId, type = props.type;
    var ref = (0, import_react.useRef)(null);
    var observerRef = (0, import_react.useRef)(null);
    var resizeObserverRef = (0, import_react.useRef)(null);
    var _useParticipant = useParticipant(participantId), participant = _useParticipant.participant;
    var _useMeeting = useMeeting(), localParticipant = _useMeeting.localParticipant;
    (0, import_react.useEffect)(function() {
      if (type === "share" || !ref.current || !participant || participantId === localParticipant.id) return;
      var element = ref.current;
      if (!element || !participant) return;
      if (observerRef.current) observerRef.current.disconnect();
      var handleIntersectionChange = debounce(function(entries) {
        if (!Array.isArray(entries) || entries.length === 0) return;
        var entry = entries[entries.length - 1];
        if (entry.intersectionRatio > 0) {
          for (var _iterator = _createForOfIteratorHelperLoose(participant.streams.values()), _step; !(_step = _iterator()).done; ) {
            var stream = _step.value;
            if (stream.kind === "video" && stream.pausedBy !== "SUB_MANAGER") {
              stream.resume();
            }
          }
        } else {
          for (var _iterator2 = _createForOfIteratorHelperLoose(participant.streams.values()), _step2; !(_step2 = _iterator2()).done; ) {
            var _stream = _step2.value;
            if (_stream.kind === "video") {
              _stream.pause();
            }
          }
        }
      }, debounceDelay);
      observerRef.current = new IntersectionObserver(handleIntersectionChange, intersectionObserverOptions);
      var processResize = function processResize2(width, height) {
        if (width > 0 && height > 0) {
          participant.setViewPort(width, height);
        }
      };
      var handleResize = debounce(function(entries) {
        var _entries$0$contentRec = entries[0].contentRect, width = _entries$0$contentRec.width, height = _entries$0$contentRec.height;
        processResize(width, height);
      }, debounceDelay);
      resizeObserverRef.current = new ResizeObserver(handleResize);
      resizeObserverRef.current.observe(element);
      observerRef.current.observe(element);
      return function() {
        if (observerRef.current) {
          observerRef.current.disconnect();
        }
        if (resizeObserverRef.current) {
          resizeObserverRef.current.disconnect();
        }
      };
    }, []);
    return import_react.default.createElement(VideoPlayerComponent, _extends({
      ref
    }, props));
  };
};
var VideoSDKPlayer = (0, import_react.forwardRef)(function(_ref5, ref) {
  var participantId = _ref5.participantId, _ref5$type = _ref5.type, type = _ref5$type === void 0 ? "video" : _ref5$type, _ref5$containerStyle = _ref5.containerStyle, containerStyle = _ref5$containerStyle === void 0 ? {} : _ref5$containerStyle, _ref5$className = _ref5.className, className = _ref5$className === void 0 ? "" : _ref5$className, _ref5$classNameVideo = _ref5.classNameVideo, classNameVideo = _ref5$classNameVideo === void 0 ? "" : _ref5$classNameVideo, _ref5$videoStyle = _ref5.videoStyle, videoStyle = _ref5$videoStyle === void 0 ? {} : _ref5$videoStyle, videoRef = _ref5.videoRef;
  var _useParticipant2 = useParticipant(participantId), webcamOn = _useParticipant2.webcamOn, webcamStream = _useParticipant2.webcamStream, isLocal = _useParticipant2.isLocal, screenShareStream = _useParticipant2.screenShareStream, screenShareOn = _useParticipant2.screenShareOn;
  var internalRef = (0, import_react.useRef)(null);
  var finalVideoRef = videoRef || internalRef;
  (0, import_react.useEffect)(function() {
    var stream = type === "share" ? screenShareStream : webcamStream;
    var isOn = type === "share" ? screenShareOn : webcamOn;
    if (finalVideoRef.current) {
      if (isOn && stream) {
        var mediaStream = new MediaStream();
        mediaStream.addTrack(stream.track);
        finalVideoRef.current.setAttribute("muted", "");
        finalVideoRef.current.srcObject = mediaStream;
        finalVideoRef.current.setAttribute("playsinline", "");
        finalVideoRef.current.setAttribute("x5-playsinline", "");
        finalVideoRef.current.setAttribute("webkit-playsinline", "");
        finalVideoRef.current.play()["catch"](function(error) {
          return console.error("finalVideoRef.current.play() failed", error);
        });
      } else {
        finalVideoRef.current.srcObject = null;
      }
    }
  }, [type].concat(type === "share" ? [screenShareOn, screenShareStream] : type === "video" ? [webcamOn, webcamStream] : []));
  return import_react.default.createElement("div", {
    ref,
    className: "video-container participant-video-" + participantId + " " + (className || ""),
    style: _extends({
      objectFit: type === "share" ? "contain" : "none",
      height: "100%"
    }, containerStyle)
  }, import_react.default.createElement("video", {
    width: "100%",
    height: "100%",
    ref: finalVideoRef,
    autoPlay: true,
    className: classNameVideo,
    muted: true,
    style: isLocal && type !== "share" ? _extends({
      transform: "scaleX(-1)",
      WebkitTransform: "scaleX(-1)"
    }, videoStyle) : videoStyle
  }));
});
var VideoPlayer = function VideoPlayer2(_ref6) {
  var participantId = _ref6.participantId, type = _ref6.type, props = _objectWithoutPropertiesLoose(_ref6, _excluded);
  var VideoPlayerComponent = (0, import_react.useMemo)(function() {
    return type === "share" ? VideoSDKPlayer : withAdaptiveObservers(VideoSDKPlayer);
  }, [type, participantId]);
  return import_react.default.createElement(VideoPlayerComponent, _extends({
    participantId,
    type
  }, props));
};
var AudioPlayer = function AudioPlayer2(_ref7) {
  var participantId = _ref7.participantId, type = _ref7.type;
  var _useParticipant3 = useParticipant(participantId), micStream = _useParticipant3.micStream, isLocal = _useParticipant3.isLocal, screenShareAudioStream = _useParticipant3.screenShareAudioStream;
  var micRef = (0, import_react.useRef)(null);
  (0, import_react.useEffect)(function() {
    if (micRef.current) {
      var audioStream = type === "shareAudio" ? screenShareAudioStream : micStream;
      if (audioStream) {
        var mediaStream = new MediaStream();
        mediaStream.addTrack(audioStream.track);
        micRef.current.srcObject = mediaStream;
        micRef.current.play()["catch"](function(error) {
          return console.error("micRef.current.play() failed", error);
        });
      } else {
        micRef.current.srcObject = null;
      }
    }
  }, [micStream, screenShareAudioStream, type]);
  return import_react.default.createElement("audio", {
    ref: micRef,
    autoPlay: true,
    playsInline: true,
    muted: isLocal
  });
};
var export_CameraDeviceInfo = import_js_sdk2.CameraDeviceInfo;
var export_DeviceInfo = import_js_sdk2.DeviceInfo;
var export_ExternalE2EEKeyProvider = import_js_sdk2.ExternalE2EEKeyProvider;
var export_MicrophoneDeviceInfo = import_js_sdk2.MicrophoneDeviceInfo;
export {
  AudioPlayer,
  export_CameraDeviceInfo as CameraDeviceInfo,
  Constants,
  export_DeviceInfo as DeviceInfo,
  export_ExternalE2EEKeyProvider as ExternalE2EEKeyProvider,
  MeetingConsumer,
  MeetingProvider,
  export_MicrophoneDeviceInfo as MicrophoneDeviceInfo,
  VideoPlayer,
  createCameraVideoTrack,
  createMicrophoneAudioTrack,
  createScreenShareVideoTrack,
  getNetworkStats,
  useCharacter,
  useConnection,
  useFile,
  useMediaDevice,
  useMeeting,
  useParticipant,
  usePubSub,
  useRealtimeStore,
  useStream,
  useTranscription,
  useTranslation,
  useWhiteboard,
  withAdaptiveObservers
};
/*! Bundled license information:

@videosdk.live/js-sdk/videosdk.js:
  (*!
  * JavaScript Cookie v2.2.1
  * https://github.com/js-cookie/js-cookie
  *
  * Copyright 2006, 2015 Klaus Hartl & Fagner Brack
  * Released under the MIT license
  *)
  (** @preserve
   * Counter block mode compatible with  Dr Brian Gladman fileenc.c
   * derived from CryptoJS.mode.CTR
   * Jan Hruby jhruby.web@gmail.com
   *)
  (*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/babel/babel/blob/main/packages/babel-helpers/LICENSE *)
  (** @preserve
  	(c) 2012 by Cdric Mesnil. All rights reserved.
  
  	Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
  
  	    - Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
  	    - Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
  
  	THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  	*)
*/
//# sourceMappingURL=@videosdk__live_react-sdk.js.map
